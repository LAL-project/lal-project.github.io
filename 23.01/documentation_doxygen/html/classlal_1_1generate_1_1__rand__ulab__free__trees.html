<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LAL: Linear Arrangement Library: lal::generate::_rand_ulab_free_trees Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">LAL: Linear Arrangement Library<span id="projectnumber">&#160;23.01.00</span>
   </div>
   <div id="projectbrief">A library focused on algorithms on linear arrangements of graphs.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacelal.html">lal</a></li><li class="navelem"><a class="el" href="namespacelal_1_1generate.html">generate</a></li><li class="navelem"><a class="el" href="classlal_1_1generate_1_1__rand__ulab__free__trees.html">_rand_ulab_free_trees</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classlal_1_1generate_1_1__rand__ulab__free__trees-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">lal::generate::_rand_ulab_free_trees Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Uniformly random generation of unlabelled free trees.  
 <a href="classlal_1_1generate_1_1__rand__ulab__free__trees.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="rand__ulab__free__trees_8hpp_source.html">rand_ulab_free_trees.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for lal::generate::_rand_ulab_free_trees:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classlal_1_1generate_1_1__rand__ulab__free__trees.png" usemap="#lal::generate::_5Frand_5Fulab_5Ffree_5Ftrees_map" alt=""/>
  <map id="lal::generate::_5Frand_5Fulab_5Ffree_5Ftrees_map" name="lal::generate::_5Frand_5Fulab_5Ffree_5Ftrees_map">
<area href="classlal_1_1generate_1_1__rand__ulab__rooted__trees.html" title="Uniformly random generation of unlabelled rooted trees." alt="lal::generate::_rand_ulab_rooted_trees" shape="rect" coords="0,0,229,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7696d3eda61b59152e472a7a413a0b2f"><td class="memItemLeft" align="right" valign="top"><a id="a7696d3eda61b59152e472a7a413a0b2f" name="a7696d3eda61b59152e472a7a413a0b2f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>_rand_ulab_free_trees</b> () noexcept</td></tr>
<tr class="memdesc:a7696d3eda61b59152e472a7a413a0b2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty constructor. <br /></td></tr>
<tr class="separator:a7696d3eda61b59152e472a7a413a0b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ac1c7ea6e981529b783f8643bb1f131"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1generate_1_1__rand__ulab__free__trees.html#a5ac1c7ea6e981529b783f8643bb1f131">_rand_ulab_free_trees</a> (uint64_t n, uint64_t seed=0) noexcept</td></tr>
<tr class="memdesc:a5ac1c7ea6e981529b783f8643bb1f131"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor with size of tree and seed for the random number generator.  <a href="classlal_1_1generate_1_1__rand__ulab__free__trees.html#a5ac1c7ea6e981529b783f8643bb1f131">More...</a><br /></td></tr>
<tr class="separator:a5ac1c7ea6e981529b783f8643bb1f131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90edd6d5abbe657843f8e73e1733b139"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1generate_1_1__rand__ulab__free__trees.html#a90edd6d5abbe657843f8e73e1733b139">_rand_ulab_free_trees</a> (const <a class="el" href="classlal_1_1generate_1_1__rand__ulab__free__trees.html">_rand_ulab_free_trees</a> &amp;Gen)=default</td></tr>
<tr class="memdesc:a90edd6d5abbe657843f8e73e1733b139"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="classlal_1_1generate_1_1__rand__ulab__free__trees.html#a90edd6d5abbe657843f8e73e1733b139">More...</a><br /></td></tr>
<tr class="separator:a90edd6d5abbe657843f8e73e1733b139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e1998ce65702824305ddc71c97949c7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1generate_1_1__rand__ulab__free__trees.html#a3e1998ce65702824305ddc71c97949c7">_rand_ulab_free_trees</a> (<a class="el" href="classlal_1_1generate_1_1__rand__ulab__free__trees.html">_rand_ulab_free_trees</a> &amp;&amp;Gen)=default</td></tr>
<tr class="memdesc:a3e1998ce65702824305ddc71c97949c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <a href="classlal_1_1generate_1_1__rand__ulab__free__trees.html#a3e1998ce65702824305ddc71c97949c7">More...</a><br /></td></tr>
<tr class="separator:a3e1998ce65702824305ddc71c97949c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a264af1c1310e32f104d56049f3ddefde"><td class="memItemLeft" align="right" valign="top"><a id="a264af1c1310e32f104d56049f3ddefde" name="a264af1c1310e32f104d56049f3ddefde"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~_rand_ulab_free_trees</b> ()=default</td></tr>
<tr class="memdesc:a264af1c1310e32f104d56049f3ddefde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default destructor. <br /></td></tr>
<tr class="separator:a264af1c1310e32f104d56049f3ddefde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a004285a5f3d18433356c6ad7f4791a8c"><td class="memItemLeft" align="right" valign="top"><a id="a004285a5f3d18433356c6ad7f4791a8c" name="a004285a5f3d18433356c6ad7f4791a8c"></a>
<a class="el" href="classlal_1_1generate_1_1__rand__ulab__free__trees.html">_rand_ulab_free_trees</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classlal_1_1generate_1_1__rand__ulab__free__trees.html">_rand_ulab_free_trees</a> &amp;g) noexcept=default</td></tr>
<tr class="memdesc:a004285a5f3d18433356c6ad7f4791a8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. <br /></td></tr>
<tr class="separator:a004285a5f3d18433356c6ad7f4791a8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34e40d4b3ac3ef91dbd0734754f9da92"><td class="memItemLeft" align="right" valign="top"><a id="a34e40d4b3ac3ef91dbd0734754f9da92" name="a34e40d4b3ac3ef91dbd0734754f9da92"></a>
<a class="el" href="classlal_1_1generate_1_1__rand__ulab__free__trees.html">_rand_ulab_free_trees</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classlal_1_1generate_1_1__rand__ulab__free__trees.html">_rand_ulab_free_trees</a> &amp;&amp;g) noexcept=default</td></tr>
<tr class="memdesc:a34e40d4b3ac3ef91dbd0734754f9da92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator. <br /></td></tr>
<tr class="separator:a34e40d4b3ac3ef91dbd0734754f9da92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a322afa16a11270dcf3c77a094a3e114e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1generate_1_1__rand__ulab__free__trees.html#a322afa16a11270dcf3c77a094a3e114e">init</a> (uint64_t n, uint64_t seed=0) noexcept</td></tr>
<tr class="memdesc:a322afa16a11270dcf3c77a094a3e114e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the size of the unlabelled trees to generate.  <a href="classlal_1_1generate_1_1__rand__ulab__free__trees.html#a322afa16a11270dcf3c77a094a3e114e">More...</a><br /></td></tr>
<tr class="separator:a322afa16a11270dcf3c77a094a3e114e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4536a9e3bbe95f84258270e67493bd1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1generate_1_1__rand__ulab__free__trees.html#ae4536a9e3bbe95f84258270e67493bd1">clear</a> () noexcept</td></tr>
<tr class="memdesc:ae4536a9e3bbe95f84258270e67493bd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the memory used.  <a href="classlal_1_1generate_1_1__rand__ulab__free__trees.html#ae4536a9e3bbe95f84258270e67493bd1">More...</a><br /></td></tr>
<tr class="separator:ae4536a9e3bbe95f84258270e67493bd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ef1c922352e91f7a9828aa0db997b94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1generate_1_1__rand__ulab__free__trees.html#a2ef1c922352e91f7a9828aa0db997b94">get_tree</a> () noexcept</td></tr>
<tr class="memdesc:a2ef1c922352e91f7a9828aa0db997b94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates uniformly at random a free unlabelled tree.  <a href="classlal_1_1generate_1_1__rand__ulab__free__trees.html#a2ef1c922352e91f7a9828aa0db997b94">More...</a><br /></td></tr>
<tr class="separator:a2ef1c922352e91f7a9828aa0db997b94"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a35d4e7cc61358fcf9c93c02c9fc25078"><td class="memItemLeft" align="right" valign="top">std::pair&lt; uint64_t, uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1generate_1_1__rand__ulab__rooted__trees.html#a35d4e7cc61358fcf9c93c02c9fc25078">ranrut</a> (uint64_t n, uint64_t lr, uint64_t nt) noexcept</td></tr>
<tr class="memdesc:a35d4e7cc61358fcf9c93c02c9fc25078"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates uniformly at random a rooted unlabelled tree of <em>n</em> nodes.  <a href="classlal_1_1generate_1_1__rand__ulab__rooted__trees.html#a35d4e7cc61358fcf9c93c02c9fc25078">More...</a><br /></td></tr>
<tr class="separator:a35d4e7cc61358fcf9c93c02c9fc25078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2007dc29e73daab2e97bedf810383cd4"><td class="memItemLeft" align="right" valign="top"><a id="a2007dc29e73daab2e97bedf810383cd4" name="a2007dc29e73daab2e97bedf810383cd4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>init_rn</b> () noexcept</td></tr>
<tr class="memdesc:a2007dc29e73daab2e97bedf810383cd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialiases <a class="el" href="classlal_1_1generate_1_1__rand__ulab__rooted__trees.html#a68343329e059142bc9b549f3ea797b00">m_rn</a> with values from the OEIS (see <a class="el" href="citelist.html#CITEREF_OEIS_A000081">[36]</a>). <br /></td></tr>
<tr class="separator:a2007dc29e73daab2e97bedf810383cd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1ceab4788761252f7a332ef678d24bf"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlal_1_1numeric_1_1integer.html">numeric::integer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1generate_1_1__rand__ulab__rooted__trees.html#aa1ceab4788761252f7a332ef678d24bf">get_rn</a> (uint64_t n) noexcept</td></tr>
<tr class="memdesc:aa1ceab4788761252f7a332ef678d24bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes all the values \(t_i\) for \(i \in [1,n]\).  <a href="classlal_1_1generate_1_1__rand__ulab__rooted__trees.html#aa1ceab4788761252f7a332ef678d24bf">More...</a><br /></td></tr>
<tr class="separator:aa1ceab4788761252f7a332ef678d24bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa90c4f21076cd497d896cbf714a07ff7"><td class="memItemLeft" align="right" valign="top">std::pair&lt; uint64_t, uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1generate_1_1__rand__ulab__rooted__trees.html#aa90c4f21076cd497d896cbf714a07ff7">choose_jd_from_T</a> (uint64_t n) noexcept</td></tr>
<tr class="memdesc:aa90c4f21076cd497d896cbf714a07ff7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chooses uniformly at random a pair \((j,d)\), according to some probability.  <a href="classlal_1_1generate_1_1__rand__ulab__rooted__trees.html#aa90c4f21076cd497d896cbf714a07ff7">More...</a><br /></td></tr>
<tr class="separator:aa90c4f21076cd497d896cbf714a07ff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ae0a784e9e3becd8ec29c36799ff1a6f8"><td class="memItemLeft" align="right" valign="top"><a id="ae0a784e9e3becd8ec29c36799ff1a6f8" name="ae0a784e9e3becd8ec29c36799ff1a6f8"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>m_n</b></td></tr>
<tr class="memdesc:ae0a784e9e3becd8ec29c36799ff1a6f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of nodes of the tree. <br /></td></tr>
<tr class="separator:ae0a784e9e3becd8ec29c36799ff1a6f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4cdaee91bc4848fd4e6e96ed6b32c59"><td class="memItemLeft" align="right" valign="top"><a id="ad4cdaee91bc4848fd4e6e96ed6b32c59" name="ad4cdaee91bc4848fd4e6e96ed6b32c59"></a>
std::mt19937&#160;</td><td class="memItemRight" valign="bottom"><b>m_gen</b></td></tr>
<tr class="memdesc:ad4cdaee91bc4848fd4e6e96ed6b32c59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random number generator. <br /></td></tr>
<tr class="separator:ad4cdaee91bc4848fd4e6e96ed6b32c59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad836fa66bf3cf1f393f39a1e37083098"><td class="memItemLeft" align="right" valign="top"><a id="ad836fa66bf3cf1f393f39a1e37083098" name="ad836fa66bf3cf1f393f39a1e37083098"></a>
std::uniform_real_distribution&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_unif</b></td></tr>
<tr class="memdesc:ad836fa66bf3cf1f393f39a1e37083098"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distribution of the numbers. <br /></td></tr>
<tr class="separator:ad836fa66bf3cf1f393f39a1e37083098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68343329e059142bc9b549f3ea797b00"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classlal_1_1numeric_1_1integer.html">numeric::integer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1generate_1_1__rand__ulab__rooted__trees.html#a68343329e059142bc9b549f3ea797b00">m_rn</a></td></tr>
<tr class="memdesc:a68343329e059142bc9b549f3ea797b00"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of unlabelled rooted trees.  <a href="classlal_1_1generate_1_1__rand__ulab__rooted__trees.html#a68343329e059142bc9b549f3ea797b00">More...</a><br /></td></tr>
<tr class="separator:a68343329e059142bc9b549f3ea797b00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae717e2b719a045ae866ece01b97d346f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlal_1_1detail_1_1data__array.html">detail::data_array</a>&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1generate_1_1__rand__ulab__rooted__trees.html#ae717e2b719a045ae866ece01b97d346f">m_head_vector</a></td></tr>
<tr class="memdesc:ae717e2b719a045ae866ece01b97d346f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The head vector of the tree under construction.  <a href="classlal_1_1generate_1_1__rand__ulab__rooted__trees.html#ae717e2b719a045ae866ece01b97d346f">More...</a><br /></td></tr>
<tr class="separator:ae717e2b719a045ae866ece01b97d346f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a79249587b8ecde295117e433d5e733ff"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1generate_1_1__rand__ulab__free__trees.html#a79249587b8ecde295117e433d5e733ff">forest</a> (uint64_t m, uint64_t q, uint64_t nt) noexcept</td></tr>
<tr class="memdesc:a79249587b8ecde295117e433d5e733ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates uniformly at random a forest of <em>m</em> nodes.  <a href="classlal_1_1generate_1_1__rand__ulab__free__trees.html#a79249587b8ecde295117e433d5e733ff">More...</a><br /></td></tr>
<tr class="separator:a79249587b8ecde295117e433d5e733ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fc46540f6e680cb0fb624182ce1c23d"><td class="memItemLeft" align="right" valign="top"><a id="a8fc46540f6e680cb0fb624182ce1c23d" name="a8fc46540f6e680cb0fb624182ce1c23d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>bicenter</b> (uint64_t n) noexcept</td></tr>
<tr class="memdesc:a8fc46540f6e680cb0fb624182ce1c23d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a tree of <em>n</em> nodes with two centroids. <br /></td></tr>
<tr class="separator:a8fc46540f6e680cb0fb624182ce1c23d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ecbcbc7efcd0c5e5302be89fb5a458f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlal_1_1numeric_1_1integer.html">numeric::integer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1generate_1_1__rand__ulab__free__trees.html#a1ecbcbc7efcd0c5e5302be89fb5a458f">get_alpha_mq</a> (const uint64_t m, const uint64_t q) noexcept</td></tr>
<tr class="memdesc:a1ecbcbc7efcd0c5e5302be89fb5a458f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes and return the value \(\alpha(m,q)\).  <a href="classlal_1_1generate_1_1__rand__ulab__free__trees.html#a1ecbcbc7efcd0c5e5302be89fb5a458f">More...</a><br /></td></tr>
<tr class="separator:a1ecbcbc7efcd0c5e5302be89fb5a458f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1999abdfe9491dbe633f63d45a5c9371"><td class="memItemLeft" align="right" valign="top"><a id="a1999abdfe9491dbe633f63d45a5c9371" name="a1999abdfe9491dbe633f63d45a5c9371"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>init_fn</b> () noexcept</td></tr>
<tr class="memdesc:a1999abdfe9491dbe633f63d45a5c9371"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialiases <a class="el" href="classlal_1_1generate_1_1__rand__ulab__free__trees.html#a2a05a2fb7de267e3a9d3ddcdb640a6d6">m_fn</a> with values from the OEIS (see <a class="el" href="citelist.html#CITEREF_OEIS_A000055">[35]</a>). <br /></td></tr>
<tr class="separator:a1999abdfe9491dbe633f63d45a5c9371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e667f0cf44a68af815953c8a13f7b2c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlal_1_1numeric_1_1integer.html">numeric::integer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1generate_1_1__rand__ulab__free__trees.html#a0e667f0cf44a68af815953c8a13f7b2c">get_fn</a> (const uint64_t n) noexcept</td></tr>
<tr class="memdesc:a0e667f0cf44a68af815953c8a13f7b2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes and returns the value \(f_n\).  <a href="classlal_1_1generate_1_1__rand__ulab__free__trees.html#a0e667f0cf44a68af815953c8a13f7b2c">More...</a><br /></td></tr>
<tr class="separator:a0e667f0cf44a68af815953c8a13f7b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a892d5b8036bd2bad731a7a1a209de5a0"><td class="memItemLeft" align="right" valign="top">std::pair&lt; uint64_t, uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1generate_1_1__rand__ulab__free__trees.html#a892d5b8036bd2bad731a7a1a209de5a0">choose_jd_from_alpha</a> (const uint64_t m, const uint64_t q) noexcept</td></tr>
<tr class="memdesc:a892d5b8036bd2bad731a7a1a209de5a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chooses uniformly at random a pair \((j,d)\), according to some probability.  <a href="classlal_1_1generate_1_1__rand__ulab__free__trees.html#a892d5b8036bd2bad731a7a1a209de5a0">More...</a><br /></td></tr>
<tr class="separator:a892d5b8036bd2bad731a7a1a209de5a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:abda2fdec407144ec6b6801293a879376"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::pair&lt; uint64_t, uint64_t &gt;, <a class="el" href="classlal_1_1numeric_1_1integer.html">numeric::integer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1generate_1_1__rand__ulab__free__trees.html#abda2fdec407144ec6b6801293a879376">m_alpha</a></td></tr>
<tr class="memdesc:abda2fdec407144ec6b6801293a879376"><td class="mdescLeft">&#160;</td><td class="mdescRight">Values \(\alpha_{m,q}\).  <a href="classlal_1_1generate_1_1__rand__ulab__free__trees.html#abda2fdec407144ec6b6801293a879376">More...</a><br /></td></tr>
<tr class="separator:abda2fdec407144ec6b6801293a879376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a05a2fb7de267e3a9d3ddcdb640a6d6"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classlal_1_1numeric_1_1integer.html">numeric::integer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1generate_1_1__rand__ulab__free__trees.html#a2a05a2fb7de267e3a9d3ddcdb640a6d6">m_fn</a></td></tr>
<tr class="memdesc:a2a05a2fb7de267e3a9d3ddcdb640a6d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of free unlabelled trees.  <a href="classlal_1_1generate_1_1__rand__ulab__free__trees.html#a2a05a2fb7de267e3a9d3ddcdb640a6d6">More...</a><br /></td></tr>
<tr class="separator:a2a05a2fb7de267e3a9d3ddcdb640a6d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Uniformly random generation of unlabelled free trees. </p>
<p ><b>Users should refrain from using this class.</b> The generation of random labelled trees should be done using the wrapper class <a class="el" href="classlal_1_1generate_1_1rand__ulab__free__trees.html">rand_ulab_free_trees</a>. This class, however, contains the actual code to generate labelled rooted trees uniformly at random.</p>
<p >Every call to <a class="el" href="classlal_1_1generate_1_1__rand__ulab__free__trees.html#a2ef1c922352e91f7a9828aa0db997b94">get_tree</a> generates uniformly at random an unlabelled free tree using the algorithm described in <a class="el" href="citelist.html#CITEREF_Wilf1981a">[39]</a>. This algorithm relies on the <a class="el" href="classlal_1_1generate_1_1__rand__ulab__rooted__trees.html#a35d4e7cc61358fcf9c93c02c9fc25078">ranrut</a> procedure (see <a class="el" href="citelist.html#CITEREF_Nijenhuis1978a">[30]</a>, chapter 29) and runs in about the same time. The implementation of Wilf's paper (see <a class="el" href="citelist.html#CITEREF_Wilf1981a">[39]</a>) in functions <a class="el" href="classlal_1_1generate_1_1__rand__ulab__free__trees.html#a2ef1c922352e91f7a9828aa0db997b94">get_tree</a>, <a class="el" href="classlal_1_1generate_1_1__rand__ulab__free__trees.html#a79249587b8ecde295117e433d5e733ff">forest</a>, and <a class="el" href="classlal_1_1generate_1_1__rand__ulab__free__trees.html#a8fc46540f6e680cb0fb624182ce1c23d">bicenter</a> includes the correction pointed out in <a class="el" href="citelist.html#CITEREF_GiacXcas_Manual">[28]</a> (page 38). </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a5ac1c7ea6e981529b783f8643bb1f131" name="a5ac1c7ea6e981529b783f8643bb1f131"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ac1c7ea6e981529b783f8643bb1f131">&#9670;&#160;</a></span>_rand_ulab_free_trees() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">lal::generate::_rand_ulab_free_trees::_rand_ulab_free_trees </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>seed</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor with size of tree and seed for the random number generator. </p>
<p >In case the seed given is '0', a random seed will be generated. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of nodes. </td></tr>
    <tr><td class="paramname">seed</td><td>The seed used for the random number generator. If the seed is 0 then a random seed is generated and used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a90edd6d5abbe657843f8e73e1733b139" name="a90edd6d5abbe657843f8e73e1733b139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90edd6d5abbe657843f8e73e1733b139">&#9670;&#160;</a></span>_rand_ulab_free_trees() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">lal::generate::_rand_ulab_free_trees::_rand_ulab_free_trees </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1generate_1_1__rand__ulab__free__trees.html">_rand_ulab_free_trees</a> &amp;&#160;</td>
          <td class="paramname"><em>Gen</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Gen</td><td>Random unlabelled free tree generator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3e1998ce65702824305ddc71c97949c7" name="a3e1998ce65702824305ddc71c97949c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e1998ce65702824305ddc71c97949c7">&#9670;&#160;</a></span>_rand_ulab_free_trees() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">lal::generate::_rand_ulab_free_trees::_rand_ulab_free_trees </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlal_1_1generate_1_1__rand__ulab__free__trees.html">_rand_ulab_free_trees</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>Gen</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Gen</td><td>Random unlabelled free tree generator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a892d5b8036bd2bad731a7a1a209de5a0" name="a892d5b8036bd2bad731a7a1a209de5a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a892d5b8036bd2bad731a7a1a209de5a0">&#9670;&#160;</a></span>choose_jd_from_alpha()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; uint64_t, uint64_t &gt; lal::generate::_rand_ulab_free_trees::choose_jd_from_alpha </td>
          <td>(</td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Chooses uniformly at random a pair \((j,d)\), according to some probability. </p>
<p >Probability of choosing \((j,d)\) is: \(\frac{d \cdot \alpha_{m - jd, q} \cdot t_d}{m\alpha_{m, q}}\). Here, <em>q</em> is fixed to \((n - 1)/2\) where <em>n</em> is <a class="el" href="classlal_1_1generate_1_1__rand__ulab__rooted__trees.html#ae0a784e9e3becd8ec29c36799ff1a6f8">m_n</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Amount of nodes. </td></tr>
    <tr><td class="paramname">q</td><td>Maximum amount of nodes per connected component. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair of integers \((j,d)\) such that \(j \ge 1\), \(jd \le n\) and \(j \ge 1\), \(jd \le n\). </dd></dl>

</div>
</div>
<a id="aa90c4f21076cd497d896cbf714a07ff7" name="aa90c4f21076cd497d896cbf714a07ff7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa90c4f21076cd497d896cbf714a07ff7">&#9670;&#160;</a></span>choose_jd_from_T()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; uint64_t, uint64_t &gt; lal::generate::_rand_ulab_rooted_trees::choose_jd_from_T </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Chooses uniformly at random a pair \((j,d)\), according to some probability. </p>
<p >Probability of choosing \((j,d)\) is: \(\frac{d \cdot t_{k - jd} \cdot t_d}{(k - 1)t_k}\). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of nodes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair of integers \((j,d)\) such that \(j \ge 1\), \(jd \le n\) and \(j \ge 1\), \(jd \le n\). </dd></dl>

</div>
</div>
<a id="ae4536a9e3bbe95f84258270e67493bd1" name="ae4536a9e3bbe95f84258270e67493bd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4536a9e3bbe95f84258270e67493bd1">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::generate::_rand_ulab_free_trees::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the memory used. </p>
<p >In order to save computation time, this class has been designed to reuse memory when generating trees. For example, since it needs the values of well-known integer sequences (see attributes <a class="el" href="classlal_1_1generate_1_1__rand__ulab__rooted__trees.html#a68343329e059142bc9b549f3ea797b00">m_rn</a> and <a class="el" href="classlal_1_1generate_1_1__rand__ulab__free__trees.html#abda2fdec407144ec6b6801293a879376">m_alpha</a>) that are costly to compute every time they are needed, they are stored in memory and reused over time.</p>
<p >So, if the user wants to generate trees of 1000 nodes there will be too much memory occupied (and unused) if then this class is used to generate trees of 10 nodes. In cases like this it is recommended to clear the memory occupied.</p>
<dl class="section post"><dt>Postcondition</dt><dd>After calling this method, the contents of the attributes <a class="el" href="classlal_1_1generate_1_1__rand__ulab__rooted__trees.html#a68343329e059142bc9b549f3ea797b00">m_rn</a>, <a class="el" href="classlal_1_1generate_1_1__rand__ulab__free__trees.html#a2a05a2fb7de267e3a9d3ddcdb640a6d6">m_fn</a> and <a class="el" href="classlal_1_1generate_1_1__rand__ulab__free__trees.html#abda2fdec407144ec6b6801293a879376">m_alpha</a> are cleared. Attributes <a class="el" href="classlal_1_1generate_1_1__rand__ulab__rooted__trees.html#a68343329e059142bc9b549f3ea797b00">m_rn</a> and <a class="el" href="classlal_1_1generate_1_1__rand__ulab__free__trees.html#a2a05a2fb7de267e3a9d3ddcdb640a6d6">m_fn</a> are then assigned the same values that they are assigned when creating an object of this class. </dd>
<dd>
Method <a class="el" href="classlal_1_1generate_1_1__rand__ulab__free__trees.html#a322afa16a11270dcf3c77a094a3e114e">init</a> must be called after every call to <a class="el" href="classlal_1_1generate_1_1__rand__ulab__free__trees.html#ae4536a9e3bbe95f84258270e67493bd1">clear</a>. </dd></dl>

</div>
</div>
<a id="a79249587b8ecde295117e433d5e733ff" name="a79249587b8ecde295117e433d5e733ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79249587b8ecde295117e433d5e733ff">&#9670;&#160;</a></span>forest()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lal::generate::_rand_ulab_free_trees::forest </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>nt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates uniformly at random a forest of <em>m</em> nodes. </p>
<p >Makes a random forest of <em>m</em> nodes and stores it in <a class="el" href="classlal_1_1generate_1_1__rand__ulab__rooted__trees.html#ae717e2b719a045ae866ece01b97d346f">m_head_vector</a>. Each tree in the forest has at most <em>q</em> nodes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Integer \(m \ge 0\). </td></tr>
    <tr><td class="paramname">q</td><td>Integer \(0 \le q \le m\). </td></tr>
    <tr><td class="paramname">nt</td><td>Index to <a class="el" href="classlal_1_1generate_1_1__rand__ulab__rooted__trees.html#ae717e2b719a045ae866ece01b97d346f">m_head_vector</a> indicating where to store the next tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The position where to store the following trees/forests in <a class="el" href="classlal_1_1generate_1_1__rand__ulab__rooted__trees.html#ae717e2b719a045ae866ece01b97d346f">m_head_vector</a>. </dd></dl>

</div>
</div>
<a id="a1ecbcbc7efcd0c5e5302be89fb5a458f" name="a1ecbcbc7efcd0c5e5302be89fb5a458f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ecbcbc7efcd0c5e5302be89fb5a458f">&#9670;&#160;</a></span>get_alpha_mq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classlal_1_1numeric_1_1integer.html">numeric::integer</a> &amp; lal::generate::_rand_ulab_free_trees::get_alpha_mq </td>
          <td>(</td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes and return the value \(\alpha(m,q)\). </p>
<p >Stores the calculated value in <a class="el" href="classlal_1_1generate_1_1__rand__ulab__free__trees.html#abda2fdec407144ec6b6801293a879376">m_alpha</a>. In case the value has already been calculated, this method does nothing. See <a class="el" href="citelist.html#CITEREF_Wilf1981a">[39]</a> for details on \(\alpha(m,q)\). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Number of nodes of the forest. </td></tr>
    <tr><td class="paramname">q</td><td>Maximum number of nodes of each connected component of the forest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>\(\alpha(m,q)\) </dd></dl>

</div>
</div>
<a id="a0e667f0cf44a68af815953c8a13f7b2c" name="a0e667f0cf44a68af815953c8a13f7b2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e667f0cf44a68af815953c8a13f7b2c">&#9670;&#160;</a></span>get_fn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classlal_1_1numeric_1_1integer.html">numeric::integer</a> &amp; lal::generate::_rand_ulab_free_trees::get_fn </td>
          <td>(</td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes and returns the value \(f_n\). </p>
<p >The value \(f_n\) is the number of unlabelled free trees on \(n\) nodes. The method implements Otter's formula (see <a class="el" href="citelist.html#CITEREF_Otter1948a">[31]</a>). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of nodes of the tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>\(f_n\). </dd></dl>

</div>
</div>
<a id="aa1ceab4788761252f7a332ef678d24bf" name="aa1ceab4788761252f7a332ef678d24bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1ceab4788761252f7a332ef678d24bf">&#9670;&#160;</a></span>get_rn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classlal_1_1numeric_1_1integer.html">numeric::integer</a> &amp; lal::generate::_rand_ulab_rooted_trees::get_rn </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes all the values \(t_i\) for \(i \in [1,n]\). </p>
<p >Here \(n\) is <a class="el" href="classlal_1_1generate_1_1__rand__ulab__rooted__trees.html#ae0a784e9e3becd8ec29c36799ff1a6f8">m_n</a>. In case these values have already been calculated, this method does nothing. </p>

</div>
</div>
<a id="a2ef1c922352e91f7a9828aa0db997b94" name="a2ef1c922352e91f7a9828aa0db997b94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ef1c922352e91f7a9828aa0db997b94">&#9670;&#160;</a></span>get_tree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> lal::generate::_rand_ulab_free_trees::get_tree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates uniformly at random a free unlabelled tree. </p>
<p >Includes the correction in Wilf's paper (see <a class="el" href="citelist.html#CITEREF_Wilf1981a">[39]</a>), as pointed out in <a class="el" href="citelist.html#CITEREF_GiacXcas_Manual">[28]</a>. </p><dl class="section return"><dt>Returns</dt><dd>An unlabelled free tree. </dd></dl>

</div>
</div>
<a id="a322afa16a11270dcf3c77a094a3e114e" name="a322afa16a11270dcf3c77a094a3e114e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a322afa16a11270dcf3c77a094a3e114e">&#9670;&#160;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::generate::_rand_ulab_free_trees::init </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>seed</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the size of the unlabelled trees to generate. </p>
<p >Initialises <a class="el" href="classlal_1_1generate_1_1__rand__ulab__rooted__trees.html#a68343329e059142bc9b549f3ea797b00">m_rn</a> with values extracted from <a class="el" href="citelist.html#CITEREF_OEIS_A000081">[36]</a>. It also initialises <a class="el" href="classlal_1_1generate_1_1__rand__ulab__free__trees.html#a2a05a2fb7de267e3a9d3ddcdb640a6d6">m_fn</a> with values extracted from <a class="el" href="citelist.html#CITEREF_OEIS_A000055">[35]</a>.</p>
<p >Initialises the random number generator with <em>seed</em>. When <em>seed</em> is 0, a random seed is used. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of nodes. </td></tr>
    <tr><td class="paramname">seed</td><td>The seed used for the random number generator. If the seed is 0 then a random seed is generated and used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a35d4e7cc61358fcf9c93c02c9fc25078" name="a35d4e7cc61358fcf9c93c02c9fc25078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35d4e7cc61358fcf9c93c02c9fc25078">&#9670;&#160;</a></span>ranrut()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; uint64_t, uint64_t &gt; lal::generate::_rand_ulab_rooted_trees::ranrut </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>nt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates uniformly at random a rooted unlabelled tree of <em>n</em> nodes. </p>
<p >The first call to this method should have <em>lr</em> = <a class="el" href="classlal_1_1generate_1_1__rand__ulab__rooted__trees.html#ae0a784e9e3becd8ec29c36799ff1a6f8">m_n</a> + 1. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of nodes of the rooted tree to generate. </td></tr>
    <tr><td class="paramname">lr</td><td>Pointer to the root of the last tree added. <a class="el" href="classlal_1_1generate_1_1__rand__ulab__rooted__trees.html#ae717e2b719a045ae866ece01b97d346f">m_head_vector</a>[<em>lr</em>] is the node that the root points to. </td></tr>
    <tr><td class="paramname">nt</td><td>Index to <a class="el" href="classlal_1_1generate_1_1__rand__ulab__rooted__trees.html#ae717e2b719a045ae866ece01b97d346f">m_head_vector</a> where we have to place the new tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Two indices: the index of the root of the last tree generated and where to store the next tree in <a class="el" href="classlal_1_1generate_1_1__rand__ulab__rooted__trees.html#ae717e2b719a045ae866ece01b97d346f">m_head_vector</a>. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="abda2fdec407144ec6b6801293a879376" name="abda2fdec407144ec6b6801293a879376"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abda2fdec407144ec6b6801293a879376">&#9670;&#160;</a></span>m_alpha</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::pair&lt;uint64_t, uint64_t&gt;, <a class="el" href="classlal_1_1numeric_1_1integer.html">numeric::integer</a>&gt; lal::generate::_rand_ulab_free_trees::m_alpha</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Values \(\alpha_{m,q}\). </p>
<p >\(\alpha_{m,q}\) is he number of rooted forests of \(m\) nodes whose trees have at most \(q\) nodes each. See <a class="el" href="citelist.html#CITEREF_Wilf1981a">[39]</a>.</p>
<p >Since \(m\) and \(q\) are usually calculated as \(m=n-1\) and \(q=(n - 1)/2\) there is only one value of \(q\) for each \(n\), so we do not need a matrix. </p>

</div>
</div>
<a id="a2a05a2fb7de267e3a9d3ddcdb640a6d6" name="a2a05a2fb7de267e3a9d3ddcdb640a6d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a05a2fb7de267e3a9d3ddcdb640a6d6">&#9670;&#160;</a></span>m_fn</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classlal_1_1numeric_1_1integer.html">numeric::integer</a>&gt; lal::generate::_rand_ulab_free_trees::m_fn</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of free unlabelled trees. </p>
<p >Contains \(f_n\) for \(n\ge 0\). </p>

</div>
</div>
<a id="ae717e2b719a045ae866ece01b97d346f" name="ae717e2b719a045ae866ece01b97d346f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae717e2b719a045ae866ece01b97d346f">&#9670;&#160;</a></span>m_head_vector</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlal_1_1detail_1_1data__array.html">detail::data_array</a>&lt;uint64_t&gt; lal::generate::_rand_ulab_rooted_trees::m_head_vector</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The head vector of the tree under construction. </p>
<p >This list has <em>n</em> values for <a class="el" href="classlal_1_1generate_1_1__rand__ulab__rooted__trees.html#ae0a784e9e3becd8ec29c36799ff1a6f8">m_n</a> nodes. The first position contains the root vertex.</p>
<p >Do not use its actual type (<a class="el" href="namespacelal.html#a2eb5b7f5b50ff908a7a67889a9ea744d">lal::head_vector</a>) in an attempt to make memory usage a bit more efficient. </p>

</div>
</div>
<a id="a68343329e059142bc9b549f3ea797b00" name="a68343329e059142bc9b549f3ea797b00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68343329e059142bc9b549f3ea797b00">&#9670;&#160;</a></span>m_rn</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classlal_1_1numeric_1_1integer.html">numeric::integer</a>&gt; lal::generate::_rand_ulab_rooted_trees::m_rn</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of unlabelled rooted trees. </p>
<p >Contains \(r_n\) for \(n\ge 0\). </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>lal/generate/<a class="el" href="rand__ulab__free__trees_8hpp_source.html">rand_ulab_free_trees.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
