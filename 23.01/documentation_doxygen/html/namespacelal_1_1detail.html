<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LAL: Linear Arrangement Library: lal::detail Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">LAL: Linear Arrangement Library<span id="projectnumber">&#160;23.01.00</span>
   </div>
   <div id="projectbrief">A library focused on algorithms on linear arrangements of graphs.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacelal.html">lal</a></li><li class="navelem"><a class="el" href="namespacelal_1_1detail.html">detail</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">lal::detail Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Detail namespace.  
<a href="namespacelal_1_1detail.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacelal_1_1detail_1_1crossings"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail_1_1crossings.html">crossings</a></td></tr>
<tr class="memdesc:namespacelal_1_1detail_1_1crossings"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace for the algorithms that compute the number of crossings. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacelal_1_1detail_1_1DMax"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail_1_1DMax.html">DMax</a></td></tr>
<tr class="memdesc:namespacelal_1_1detail_1_1DMax"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace for algorithms to calculate the maximum sum of edge lengths. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacelal_1_1detail_1_1DMax__utils"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail_1_1DMax__utils.html">DMax_utils</a></td></tr>
<tr class="memdesc:namespacelal_1_1detail_1_1DMax__utils"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utilities for the various maximum linear arrangement algorithms. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacelal_1_1detail_1_1Dmin"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail_1_1Dmin.html">Dmin</a></td></tr>
<tr class="memdesc:namespacelal_1_1detail_1_1Dmin"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace for algorithms to calculate the minimum sum of edge lengths. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacelal_1_1detail_1_1Dmin__utils"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail_1_1Dmin__utils.html">Dmin_utils</a></td></tr>
<tr class="memdesc:namespacelal_1_1detail_1_1Dmin__utils"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utilities for the various minimum linear arrangement algorithms. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacelal_1_1detail_1_1Dopt__utils"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail_1_1Dopt__utils.html">Dopt_utils</a></td></tr>
<tr class="memdesc:namespacelal_1_1detail_1_1Dopt__utils"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utilities for the various optimal linear arrangement algorithms. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacelal_1_1detail_1_1maximum__subtrees"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail_1_1maximum__subtrees.html">maximum_subtrees</a></td></tr>
<tr class="memdesc:namespacelal_1_1detail_1_1maximum__subtrees"><td class="mdescLeft">&#160;</td><td class="mdescRight">Algorithms to find maximum subtrees. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacelal_1_1detail_1_1sorting"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail_1_1sorting.html">sorting</a></td></tr>
<tr class="memdesc:namespacelal_1_1detail_1_1sorting"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorting algorithms. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1detail_1_1AVL.html">AVL</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple class that implements an <a class="el" href="classlal_1_1detail_1_1AVL.html" title="Simple class that implements an AVL tree.">AVL</a> tree.  <a href="classlal_1_1detail_1_1AVL.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1detail_1_1BFS.html">BFS</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract graph Breadth-First Search traversal.  <a href="classlal_1_1detail_1_1BFS.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlal_1_1detail_1_1bool__sequence.html">bool_sequence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sequence of Boolean values.  <a href="structlal_1_1detail_1_1bool__sequence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlal_1_1detail_1_1conditional__list.html">conditional_list</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generalization of std::conditional_list.  <a href="structlal_1_1detail_1_1conditional__list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlal_1_1detail_1_1data__array.html">data_array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper of a C array for autmatic deallocation of memory.  <a href="structlal_1_1detail_1_1data__array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlal_1_1detail_1_1edge__size.html">edge_size</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct used in many algorithms to sort edges according to some integer value.  <a href="structlal_1_1detail_1_1edge__size.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlal_1_1detail_1_1first__true.html">first_true</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">From a list of Boolean values, find the first that is set to true.  <a href="structlal_1_1detail_1_1first__true.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlal_1_1detail_1_1is__pointer__iterator.html">is_pointer_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decide if a type is a pointer or iterator to another.  <a href="structlal_1_1detail_1_1is__pointer__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlal_1_1detail_1_1ith__type.html">ith_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selection of the ith type of a list of types.  <a href="structlal_1_1detail_1_1ith__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlal_1_1detail_1_1ith__type_3_01ith__idx_00_01type__sequence_3_01Ts_8_8_8_01_4_01_4.html">ith_type&lt; ith_idx, type_sequence&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial template specialization of <a class="el" href="structlal_1_1detail_1_1ith__type.html">ith_type</a> for <a class="el" href="structlal_1_1detail_1_1type__sequence.html">type_sequence</a>.  <a href="structlal_1_1detail_1_1ith__type_3_01ith__idx_00_01type__sequence_3_01Ts_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlal_1_1detail_1_1linarr__wrapper.html">linarr_wrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper to easily use identity arrangements.  <a href="structlal_1_1detail_1_1linarr__wrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1detail_1_1linear__queue.html">linear_queue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple array-like fixed-size queue.  <a href="classlal_1_1detail_1_1linear__queue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlal_1_1detail_1_1node__size.html">node_size</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct used in many algorithms to sort vertices according to some integer value.  <a href="structlal_1_1detail_1_1node__size.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlal_1_1detail_1_1type__sequence.html">type_sequence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sequence of types.  <a href="structlal_1_1detail_1_1type__sequence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aefed716de4c6c3a2384f4403613d1d1b"><td class="memTemplParams" colspan="2"><a id="aefed716de4c6c3a2384f4403613d1d1b" name="aefed716de4c6c3a2384f4403613d1d1b"></a>
template&lt;typename bool_seq , typename type_seq &gt; </td></tr>
<tr class="memitem:aefed716de4c6c3a2384f4403613d1d1b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>conditional_list_t</b> = typename <a class="el" href="structlal_1_1detail_1_1conditional__list.html">conditional_list</a>&lt; bool_seq, type_seq &gt;::type</td></tr>
<tr class="memdesc:aefed716de4c6c3a2384f4403613d1d1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shorthand for <a class="el" href="structlal_1_1detail_1_1conditional__list.html">conditional_list</a>. <br /></td></tr>
<tr class="separator:aefed716de4c6c3a2384f4403613d1d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cdd4cee3f0b9bca6e63ff1922324b2f"><td class="memTemplParams" colspan="2"><a id="a3cdd4cee3f0b9bca6e63ff1922324b2f" name="a3cdd4cee3f0b9bca6e63ff1922324b2f"></a>
template&lt;std::size_t ith_idx, typename... Ts&gt; </td></tr>
<tr class="memitem:a3cdd4cee3f0b9bca6e63ff1922324b2f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ith_type_t</b> = typename <a class="el" href="structlal_1_1detail_1_1ith__type.html">ith_type</a>&lt; ith_idx, Ts... &gt;::type</td></tr>
<tr class="memdesc:a3cdd4cee3f0b9bca6e63ff1922324b2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shorthand for <a class="el" href="structlal_1_1detail_1_1ith__type.html#a86c0b29a28136adb235759f019209f35">ith_type::type</a>. <br /></td></tr>
<tr class="separator:a3cdd4cee3f0b9bca6e63ff1922324b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ae7e27c62d46601d7b2c7b75cbfdeda85"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#ae7e27c62d46601d7b2c7b75cbfdeda85">linarr_type</a> { <a class="el" href="namespacelal_1_1detail.html#ae7e27c62d46601d7b2c7b75cbfdeda85aff483d1ff591898a9942916050d2ca3f">identity</a>
, <a class="el" href="namespacelal_1_1detail.html#ae7e27c62d46601d7b2c7b75cbfdeda85a78463cb21909f69c5bb59611db0b7575">nonident</a>
 }</td></tr>
<tr class="memdesc:ae7e27c62d46601d7b2c7b75cbfdeda85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of arrangement.  <a href="namespacelal_1_1detail.html#ae7e27c62d46601d7b2c7b75cbfdeda85">More...</a><br /></td></tr>
<tr class="separator:ae7e27c62d46601d7b2c7b75cbfdeda85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47195c004957380992b21cdbb2b43cc9"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#a47195c004957380992b21cdbb2b43cc9">centroid_results</a> { <a class="el" href="namespacelal_1_1detail.html#a47195c004957380992b21cdbb2b43cc9ab99249477c8f37e1ad46c4983716d39c">only_one_centroidal</a>
, <a class="el" href="namespacelal_1_1detail.html#a47195c004957380992b21cdbb2b43cc9a9ef639b9182eadfee611fc58dd23f9d3">full_centroid</a>
, <a class="el" href="namespacelal_1_1detail.html#a47195c004957380992b21cdbb2b43cc9ae6e2f4d15b78cfcbb5a70f39f0d9dda8">full_centroid_plus_subtree_sizes</a>
, <a class="el" href="namespacelal_1_1detail.html#a47195c004957380992b21cdbb2b43cc9a454774b2983a333885b75c8845707e38">full_centroid_plus_edge_sizes</a>
 }</td></tr>
<tr class="memdesc:a47195c004957380992b21cdbb2b43cc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The different types of results.  <a href="namespacelal_1_1detail.html#a47195c004957380992b21cdbb2b43cc9">More...</a><br /></td></tr>
<tr class="separator:a47195c004957380992b21cdbb2b43cc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8767f98f8f22c1efe6183422848e76aa"><td class="memTemplParams" colspan="2">template&lt;class container &gt; </td></tr>
<tr class="memitem:a8767f98f8f22c1efe6183422848e76aa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#a8767f98f8f22c1efe6183422848e76aa">make_arrangement_permutations</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;T, <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> r, const container &amp;data, <a class="el" href="namespacelal.html#a5c3f34575ec933a44ed7b6d81e8c75f6">position</a> &amp;pos, <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;arr) noexcept</td></tr>
<tr class="memdesc:a8767f98f8f22c1efe6183422848e76aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make an arrangement using permutations.  <a href="namespacelal_1_1detail.html#a8767f98f8f22c1efe6183422848e76aa">More...</a><br /></td></tr>
<tr class="separator:a8767f98f8f22c1efe6183422848e76aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a50073a5ef6744e0e15a8ccd85b73fd"><td class="memTemplParams" colspan="2">template&lt;class container &gt; </td></tr>
<tr class="memitem:a1a50073a5ef6744e0e15a8ccd85b73fd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#a1a50073a5ef6744e0e15a8ccd85b73fd">make_arrangement_permutations</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;T, const container &amp;data) noexcept</td></tr>
<tr class="memdesc:a1a50073a5ef6744e0e15a8ccd85b73fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make an arrangement using permutations.  <a href="namespacelal_1_1detail.html#a1a50073a5ef6744e0e15a8ccd85b73fd">More...</a><br /></td></tr>
<tr class="separator:a1a50073a5ef6744e0e15a8ccd85b73fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41b38d88fe84f185d9fd54d431438724"><td class="memTemplParams" colspan="2">template&lt;class container &gt; </td></tr>
<tr class="memitem:a41b38d88fe84f185d9fd54d431438724"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#a41b38d88fe84f185d9fd54d431438724">make_arrangement_permutations</a> (const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;T, <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> parent, <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u, const container &amp;data, <a class="el" href="namespacelal.html#a5c3f34575ec933a44ed7b6d81e8c75f6">position</a> &amp;pos, <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;arr) noexcept</td></tr>
<tr class="memdesc:a41b38d88fe84f185d9fd54d431438724"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make an arrangement using permutations.  <a href="namespacelal_1_1detail.html#a41b38d88fe84f185d9fd54d431438724">More...</a><br /></td></tr>
<tr class="separator:a41b38d88fe84f185d9fd54d431438724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e642d379033a5a82b9a26aed5e1ebcf"><td class="memTemplParams" colspan="2">template&lt;class container &gt; </td></tr>
<tr class="memitem:a1e642d379033a5a82b9a26aed5e1ebcf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#a1e642d379033a5a82b9a26aed5e1ebcf">make_arrangement_permutations</a> (const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;T, <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> root, const container &amp;data) noexcept</td></tr>
<tr class="memdesc:a1e642d379033a5a82b9a26aed5e1ebcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make an arrangement using permutations.  <a href="namespacelal_1_1detail.html#a1e642d379033a5a82b9a26aed5e1ebcf">More...</a><br /></td></tr>
<tr class="separator:a1e642d379033a5a82b9a26aed5e1ebcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa0095a6495c62a6dcdec7319e82b5ea"><td class="memTemplParams" colspan="2">template&lt;class graph_t &gt; </td></tr>
<tr class="memitem:aaa0095a6495c62a6dcdec7319e82b5ea"><td class="memTemplItemLeft" align="right" valign="top">graph_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#aaa0095a6495c62a6dcdec7319e82b5ea">from_edge_list_to_graph</a> (const std::vector&lt; <a class="el" href="namespacelal.html#a5969ec7ecc85697ebb9ec0ace78fbcab">edge</a> &gt; &amp;edge_list, bool normalise=true, bool check=true) noexcept</td></tr>
<tr class="memdesc:aaa0095a6495c62a6dcdec7319e82b5ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an edge list into a graph.  <a href="namespacelal_1_1detail.html#aaa0095a6495c62a6dcdec7319e82b5ea">More...</a><br /></td></tr>
<tr class="separator:aaa0095a6495c62a6dcdec7319e82b5ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb17951c3b57fdde267388a5f3e1a91c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacelal_1_1detail.html#ae7e27c62d46601d7b2c7b75cbfdeda85">detail::linarr_type</a> arr_type&gt; </td></tr>
<tr class="memitem:abb17951c3b57fdde267388a5f3e1a91c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacelal.html#a2eb5b7f5b50ff908a7a67889a9ea744d">head_vector</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#abb17951c3b57fdde267388a5f3e1a91c">from_tree_to_head_vector</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;t, const <a class="el" href="structlal_1_1detail_1_1linarr__wrapper.html">detail::linarr_wrapper</a>&lt; arr_type &gt; &amp;arr) noexcept</td></tr>
<tr class="memdesc:abb17951c3b57fdde267388a5f3e1a91c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the head vector representation of a tree.  <a href="namespacelal_1_1detail.html#abb17951c3b57fdde267388a5f3e1a91c">More...</a><br /></td></tr>
<tr class="separator:abb17951c3b57fdde267388a5f3e1a91c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab530db874bc4a1c9e65a8984742350a8"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacelal_1_1detail.html#ae7e27c62d46601d7b2c7b75cbfdeda85">detail::linarr_type</a> arr_type&gt; </td></tr>
<tr class="memitem:ab530db874bc4a1c9e65a8984742350a8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacelal.html#a2eb5b7f5b50ff908a7a67889a9ea744d">head_vector</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#ab530db874bc4a1c9e65a8984742350a8">from_tree_to_head_vector</a> (const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;t, const <a class="el" href="structlal_1_1detail_1_1linarr__wrapper.html">detail::linarr_wrapper</a>&lt; arr_type &gt; &amp;arr, <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> r) noexcept</td></tr>
<tr class="memdesc:ab530db874bc4a1c9e65a8984742350a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the head vector representation of a tree.  <a href="namespacelal_1_1detail.html#ab530db874bc4a1c9e65a8984742350a8">More...</a><br /></td></tr>
<tr class="separator:ab530db874bc4a1c9e65a8984742350a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4600371144fff09b6ad77aa1feb6d13a"><td class="memTemplParams" colspan="2">template&lt;class tree_t , bool is_rooted = std::is_base_of_v&lt;graphs::rooted_tree, tree_t&gt;&gt; </td></tr>
<tr class="memitem:a4600371144fff09b6ad77aa1feb6d13a"><td class="memTemplItemLeft" align="right" valign="top">std::conditional_t&lt; is_rooted, <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a>, std::pair&lt; <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a>, <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#a4600371144fff09b6ad77aa1feb6d13a">from_head_vector_to_tree</a> (const <a class="el" href="namespacelal.html#a2eb5b7f5b50ff908a7a67889a9ea744d">head_vector</a> &amp;hv, bool normalise, bool check) noexcept</td></tr>
<tr class="memdesc:a4600371144fff09b6ad77aa1feb6d13a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a head vector into a tree.  <a href="namespacelal_1_1detail.html#a4600371144fff09b6ad77aa1feb6d13a">More...</a><br /></td></tr>
<tr class="separator:a4600371144fff09b6ad77aa1feb6d13a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd3c29c1187ac3421bc676fcd3eef7ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#abd3c29c1187ac3421bc676fcd3eef7ba">level_sequence_to_ftree</a> (const uint64_t *const L, uint64_t n, bool normalise=true, bool check=true) noexcept</td></tr>
<tr class="memdesc:abd3c29c1187ac3421bc676fcd3eef7ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the level sequence of a tree into a graph structure.  <a href="namespacelal_1_1detail.html#abd3c29c1187ac3421bc676fcd3eef7ba">More...</a><br /></td></tr>
<tr class="separator:abd3c29c1187ac3421bc676fcd3eef7ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5600ed70f6b12c07d428870c0734e64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#ad5600ed70f6b12c07d428870c0734e64">level_sequence_to_ftree</a> (const std::vector&lt; uint64_t &gt; &amp;L, uint64_t n, bool normalise=true, bool check=true) noexcept</td></tr>
<tr class="memdesc:ad5600ed70f6b12c07d428870c0734e64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the level sequence of a tree into a graph structure.  <a href="namespacelal_1_1detail.html#ad5600ed70f6b12c07d428870c0734e64">More...</a><br /></td></tr>
<tr class="separator:ad5600ed70f6b12c07d428870c0734e64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fa4324d332b6ab02db4492055333fe7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#a9fa4324d332b6ab02db4492055333fe7">Prufer_sequence_to_ftree</a> (const uint64_t *const seq, uint64_t n, bool normalise=true, bool check=true) noexcept</td></tr>
<tr class="memdesc:a9fa4324d332b6ab02db4492055333fe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the Prüfer sequence of a labelled tree into a tree structure.  <a href="namespacelal_1_1detail.html#a9fa4324d332b6ab02db4492055333fe7">More...</a><br /></td></tr>
<tr class="separator:a9fa4324d332b6ab02db4492055333fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83729c5ce96b983fa2fc7f86f07cffcd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#a83729c5ce96b983fa2fc7f86f07cffcd">Prufer_sequence_to_ftree</a> (const std::vector&lt; uint64_t &gt; &amp;seq, uint64_t n, bool normalise=true, bool check=true) noexcept</td></tr>
<tr class="memdesc:a83729c5ce96b983fa2fc7f86f07cffcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the Prüfer sequence of a labelled tree into a tree structure.  <a href="namespacelal_1_1detail.html#a83729c5ce96b983fa2fc7f86f07cffcd">More...</a><br /></td></tr>
<tr class="separator:a83729c5ce96b983fa2fc7f86f07cffcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa996c0eb5455d4f727cc3b5cada84ffa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#aa996c0eb5455d4f727cc3b5cada84ffa">find_cycle</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;g, <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u, char *const __restrict__ visited, char *const __restrict__ in_stack) noexcept</td></tr>
<tr class="memdesc:aa996c0eb5455d4f727cc3b5cada84ffa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if, and only if, the graph has cycles.  <a href="namespacelal_1_1detail.html#aa996c0eb5455d4f727cc3b5cada84ffa">More...</a><br /></td></tr>
<tr class="separator:aa996c0eb5455d4f727cc3b5cada84ffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa89ef322801fbacd0782763afb9c5f3a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#aa89ef322801fbacd0782763afb9c5f3a">has_directed_cycles</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;g, char *const __restrict__ vis, char *const __restrict__ in_stack) noexcept</td></tr>
<tr class="memdesc:aa89ef322801fbacd0782763afb9c5f3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if, and only if, the graph has <em>DIRECTED</em> cycles.  <a href="namespacelal_1_1detail.html#aa89ef322801fbacd0782763afb9c5f3a">More...</a><br /></td></tr>
<tr class="separator:aa89ef322801fbacd0782763afb9c5f3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad493ddcc9165c55d4b14b228da5cdc4d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#ad493ddcc9165c55d4b14b228da5cdc4d">has_directed_cycles</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;g) noexcept</td></tr>
<tr class="memdesc:ad493ddcc9165c55d4b14b228da5cdc4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if, and only if, the graph has DIRECTED cycles.  <a href="namespacelal_1_1detail.html#ad493ddcc9165c55d4b14b228da5cdc4d">More...</a><br /></td></tr>
<tr class="separator:ad493ddcc9165c55d4b14b228da5cdc4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac1d5fb0c4578d6be926acf180d657c4"><td class="memTemplParams" colspan="2">template&lt;class graph_t &gt; </td></tr>
<tr class="memitem:aac1d5fb0c4578d6be926acf180d657c4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#aac1d5fb0c4578d6be926acf180d657c4">has_undirected_cycles</a> (const graph_t &amp;g, <a class="el" href="classlal_1_1detail_1_1BFS.html">BFS</a>&lt; graph_t &gt; &amp;bfs) noexcept</td></tr>
<tr class="memdesc:aac1d5fb0c4578d6be926acf180d657c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if, and only if, the graph has UNDIRECTED cycles.  <a href="namespacelal_1_1detail.html#aac1d5fb0c4578d6be926acf180d657c4">More...</a><br /></td></tr>
<tr class="separator:aac1d5fb0c4578d6be926acf180d657c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af38edbbd2619cd3b319c1a54ce0638ed"><td class="memTemplParams" colspan="2">template&lt;class graph_t &gt; </td></tr>
<tr class="memitem:af38edbbd2619cd3b319c1a54ce0638ed"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#af38edbbd2619cd3b319c1a54ce0638ed">has_undirected_cycles</a> (const graph_t &amp;g) noexcept</td></tr>
<tr class="memdesc:af38edbbd2619cd3b319c1a54ce0638ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if, and only if, the graph has UNDIRECTED cycles.  <a href="namespacelal_1_1detail.html#af38edbbd2619cd3b319c1a54ce0638ed">More...</a><br /></td></tr>
<tr class="separator:af38edbbd2619cd3b319c1a54ce0638ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bb2c6db85eddc1623aa2e3e4b0cbb29"><td class="memTemplParams" colspan="2">template&lt;class graph_t &gt; </td></tr>
<tr class="memitem:a5bb2c6db85eddc1623aa2e3e4b0cbb29"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacelal.html#a5969ec7ecc85697ebb9ec0ace78fbcab">edge</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#a5bb2c6db85eddc1623aa2e3e4b0cbb29">set_edges</a> (const graph_t &amp;g) noexcept</td></tr>
<tr class="memdesc:a5bb2c6db85eddc1623aa2e3e4b0cbb29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerate the set of edges of the input graph <em>g</em>.  <a href="namespacelal_1_1detail.html#a5bb2c6db85eddc1623aa2e3e4b0cbb29">More...</a><br /></td></tr>
<tr class="separator:a5bb2c6db85eddc1623aa2e3e4b0cbb29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfa1dbbb9ce95e8374be50fe57e34922"><td class="memTemplParams" colspan="2">template&lt;class graph_t &gt; </td></tr>
<tr class="memitem:adfa1dbbb9ce95e8374be50fe57e34922"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacelal.html#a235d5351556fbc73aa51767ab7765f5c">edge_pair</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#adfa1dbbb9ce95e8374be50fe57e34922">set_pairs_independent_edges</a> (const graph_t &amp;g, uint64_t qs) noexcept</td></tr>
<tr class="memdesc:adfa1dbbb9ce95e8374be50fe57e34922"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerate the set of pairs of independent edges of the input graph <em>g</em>.  <a href="namespacelal_1_1detail.html#adfa1dbbb9ce95e8374be50fe57e34922">More...</a><br /></td></tr>
<tr class="separator:adfa1dbbb9ce95e8374be50fe57e34922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58af58031ebc33bbfb5dfcd8f798ebf4"><td class="memTemplParams" colspan="2">template&lt;class graph_t &gt; </td></tr>
<tr class="memitem:a58af58031ebc33bbfb5dfcd8f798ebf4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#a58af58031ebc33bbfb5dfcd8f798ebf4">is_graph_a_tree</a> (const graph_t &amp;g) noexcept</td></tr>
<tr class="memdesc:a58af58031ebc33bbfb5dfcd8f798ebf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the input graph a tree?  <a href="namespacelal_1_1detail.html#a58af58031ebc33bbfb5dfcd8f798ebf4">More...</a><br /></td></tr>
<tr class="separator:a58af58031ebc33bbfb5dfcd8f798ebf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81e5bdc0c496cec1dc8764ff73d9eff3"><td class="memTemplParams" colspan="2">template&lt;class graph_t &gt; </td></tr>
<tr class="memitem:a81e5bdc0c496cec1dc8764ff73d9eff3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#a81e5bdc0c496cec1dc8764ff73d9eff3">is_node_reachable_from</a> (const graph_t &amp;g, const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> source, const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> target) noexcept</td></tr>
<tr class="memdesc:a81e5bdc0c496cec1dc8764ff73d9eff3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is a node reachable from another?  <a href="namespacelal_1_1detail.html#a81e5bdc0c496cec1dc8764ff73d9eff3">More...</a><br /></td></tr>
<tr class="separator:a81e5bdc0c496cec1dc8764ff73d9eff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30ff5eb84d0bde7f88cf0762dcd4effe"><td class="memTemplParams" colspan="2">template&lt;bool get_subsizes&gt; </td></tr>
<tr class="memitem:a30ff5eb84d0bde7f88cf0762dcd4effe"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; <a class="el" href="namespacelal.html#a5969ec7ecc85697ebb9ec0ace78fbcab">edge</a> &gt;, uint64_t * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#a30ff5eb84d0bde7f88cf0762dcd4effe">get_edges_subtree</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;T, <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u, bool relabel) noexcept</td></tr>
<tr class="memdesc:a30ff5eb84d0bde7f88cf0762dcd4effe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the edges of a subtree.  <a href="namespacelal_1_1detail.html#a30ff5eb84d0bde7f88cf0762dcd4effe">More...</a><br /></td></tr>
<tr class="separator:a30ff5eb84d0bde7f88cf0762dcd4effe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07c5f3a005c23b6fb759e7bef0dc8053"><td class="memTemplParams" colspan="2">template&lt;class tree_t , std::enable_if_t&lt; std::is_base_of_v&lt; <a class="el" href="classlal_1_1graphs_1_1tree.html">graphs::tree</a>, tree_t &gt;, bool &gt;  = true&gt; </td></tr>
<tr class="memitem:a07c5f3a005c23b6fb759e7bef0dc8053"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#a07c5f3a005c23b6fb759e7bef0dc8053">get_size_subtrees</a> (const tree_t &amp;t, const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u, const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> v, uint64_t *const sizes) noexcept</td></tr>
<tr class="memdesc:a07c5f3a005c23b6fb759e7bef0dc8053"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the size of every subtree of the tree <em>t</em>.  <a href="namespacelal_1_1detail.html#a07c5f3a005c23b6fb759e7bef0dc8053">More...</a><br /></td></tr>
<tr class="separator:a07c5f3a005c23b6fb759e7bef0dc8053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7228078ded7f5e5aaab16cbc64a86284"><td class="memTemplParams" colspan="2">template&lt;class tree_t , std::enable_if_t&lt; std::is_base_of_v&lt; <a class="el" href="classlal_1_1graphs_1_1tree.html">graphs::tree</a>, tree_t &gt;, bool &gt;  = true&gt; </td></tr>
<tr class="memitem:a7228078ded7f5e5aaab16cbc64a86284"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#a7228078ded7f5e5aaab16cbc64a86284">get_size_subtrees</a> (const tree_t &amp;t, <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> r, uint64_t *const sizes) noexcept</td></tr>
<tr class="memdesc:a7228078ded7f5e5aaab16cbc64a86284"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the size of every subtree of tree <em>t</em>.  <a href="namespacelal_1_1detail.html#a7228078ded7f5e5aaab16cbc64a86284">More...</a><br /></td></tr>
<tr class="separator:a7228078ded7f5e5aaab16cbc64a86284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b8f436879c464b089f1f2a67e507ffb"><td class="memTemplParams" colspan="2">template&lt;class tree_t , typename iterator_t , std::enable_if_t&lt; std::is_base_of_v&lt; <a class="el" href="classlal_1_1graphs_1_1tree.html">graphs::tree</a>, tree_t &gt; and <a class="el" href="namespacelal_1_1detail.html#a1acf6acf0c665841481303603b6ddb02">is_pointer_iterator_v</a>&lt; <a class="el" href="structlal_1_1detail_1_1edge__size.html">edge_size</a>, iterator_t &gt;, bool &gt;  = true&gt; </td></tr>
<tr class="memitem:a3b8f436879c464b089f1f2a67e507ffb"><td class="memTemplItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#a3b8f436879c464b089f1f2a67e507ffb">calculate_bidirectional_sizes</a> (const tree_t &amp;t, const uint64_t n, const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u, const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> v, iterator_t &amp;it) noexcept</td></tr>
<tr class="memdesc:a3b8f436879c464b089f1f2a67e507ffb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the values \(s(u,v)\) for the edges \((s,t)\) reachable from \(v\) in the subtree \(T^u_v\).  <a href="namespacelal_1_1detail.html#a3b8f436879c464b089f1f2a67e507ffb">More...</a><br /></td></tr>
<tr class="separator:a3b8f436879c464b089f1f2a67e507ffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a332f440b66ce4e8dc243706901575023"><td class="memTemplParams" colspan="2">template&lt;class tree_t , typename iterator_t , std::enable_if_t&lt; std::is_base_of_v&lt; <a class="el" href="classlal_1_1graphs_1_1tree.html">graphs::tree</a>, tree_t &gt; and <a class="el" href="namespacelal_1_1detail.html#a1acf6acf0c665841481303603b6ddb02">is_pointer_iterator_v</a>&lt; <a class="el" href="structlal_1_1detail_1_1edge__size.html">edge_size</a>, iterator_t &gt;, bool &gt;  = true&gt; </td></tr>
<tr class="memitem:a332f440b66ce4e8dc243706901575023"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#a332f440b66ce4e8dc243706901575023">calculate_bidirectional_sizes</a> (const tree_t &amp;t, const uint64_t n, const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> x, iterator_t it) noexcept</td></tr>
<tr class="memdesc:a332f440b66ce4e8dc243706901575023"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the values \(s_u(v)\) for the edges \((u,v)\) reachable from vertex <em>x</em>.  <a href="namespacelal_1_1detail.html#a332f440b66ce4e8dc243706901575023">More...</a><br /></td></tr>
<tr class="separator:a332f440b66ce4e8dc243706901575023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab361b7ab281d4d1e27ac91526f4ce28f"><td class="memTemplParams" colspan="2">template&lt;class tree_t , std::enable_if_t&lt; std::is_base_of_v&lt; <a class="el" href="classlal_1_1graphs_1_1tree.html">graphs::tree</a>, tree_t &gt;, bool &gt;  = true&gt; </td></tr>
<tr class="memitem:ab361b7ab281d4d1e27ac91526f4ce28f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#ab361b7ab281d4d1e27ac91526f4ce28f">classify_tree</a> (const tree_t &amp;t, std::array&lt; bool, <a class="el" href="namespacelal_1_1graphs.html#a1895a9ed855ad1d85cd9510de714a732">graphs::__tree_type_size</a> &gt; &amp;array) noexcept</td></tr>
<tr class="memdesc:ab361b7ab281d4d1e27ac91526f4ce28f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Classify a tree into one of the types <a class="el" href="namespacelal_1_1graphs.html#a18d52542088507e2be6241759722835b">lal::graphs::tree_type</a>.  <a href="namespacelal_1_1detail.html#ab361b7ab281d4d1e27ac91526f4ce28f">More...</a><br /></td></tr>
<tr class="separator:ab361b7ab281d4d1e27ac91526f4ce28f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15fc99b90e9aef2b53fc9e3e186cdfb8"><td class="memItemLeft" align="right" valign="top"><a id="a15fc99b90e9aef2b53fc9e3e186cdfb8" name="a15fc99b90e9aef2b53fc9e3e186cdfb8"></a>
constexpr std::string_view&#160;</td><td class="memItemRight" valign="bottom"><b>tree_type_string</b> (const <a class="el" href="namespacelal_1_1graphs.html#a18d52542088507e2be6241759722835b">graphs::tree_type</a> &amp;tt) noexcept</td></tr>
<tr class="memdesc:a15fc99b90e9aef2b53fc9e3e186cdfb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts to a string a value of the enumeration <a class="el" href="namespacelal_1_1graphs.html#a18d52542088507e2be6241759722835b">lal::graphs::tree_type</a>. <br /></td></tr>
<tr class="separator:a15fc99b90e9aef2b53fc9e3e186cdfb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af50760eaee3200e963cc77c4c95470d6"><td class="memTemplParams" colspan="2">template&lt;class tree_t &gt; </td></tr>
<tr class="memitem:af50760eaee3200e963cc77c4c95470d6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#af50760eaee3200e963cc77c4c95470d6">update_unionfind_after_add_edge</a> (const tree_t &amp;t, const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u, const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> v, <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> *const root_of, uint64_t *const root_size) noexcept</td></tr>
<tr class="memdesc:af50760eaee3200e963cc77c4c95470d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the Union-Find data structure after an edge addition to a tree.  <a href="namespacelal_1_1detail.html#af50760eaee3200e963cc77c4c95470d6">More...</a><br /></td></tr>
<tr class="separator:af50760eaee3200e963cc77c4c95470d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a773e3f33dbdcf3c44007f621eea0e4de"><td class="memTemplParams" colspan="2">template&lt;class tree_t &gt; </td></tr>
<tr class="memitem:a773e3f33dbdcf3c44007f621eea0e4de"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#a773e3f33dbdcf3c44007f621eea0e4de">update_unionfind_after_remove_edge</a> (const tree_t &amp;t, const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u, const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> v, <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> *const root_of, uint64_t *const root_size) noexcept</td></tr>
<tr class="memdesc:a773e3f33dbdcf3c44007f621eea0e4de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates Union-Find after an edge removal.  <a href="namespacelal_1_1detail.html#a773e3f33dbdcf3c44007f621eea0e4de">More...</a><br /></td></tr>
<tr class="separator:a773e3f33dbdcf3c44007f621eea0e4de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a877790b322b3fcb13601ffd1ddd5a3a9"><td class="memTemplParams" colspan="2">template&lt;class tree_t &gt; </td></tr>
<tr class="memitem:a877790b322b3fcb13601ffd1ddd5a3a9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#a877790b322b3fcb13601ffd1ddd5a3a9">update_unionfind_before_remove_edges_incident_to</a> (<a class="el" href="classlal_1_1detail_1_1BFS.html">BFS</a>&lt; tree_t &gt; &amp;bfs, <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> v, <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> *const root_of, uint64_t *const root_size) noexcept</td></tr>
<tr class="memdesc:a877790b322b3fcb13601ffd1ddd5a3a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update Union-Find after a vertex removal.  <a href="namespacelal_1_1detail.html#a877790b322b3fcb13601ffd1ddd5a3a9">More...</a><br /></td></tr>
<tr class="separator:a877790b322b3fcb13601ffd1ddd5a3a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae70b74a1214f7f18bb95fb1b940fc66a"><td class="memTemplParams" colspan="2">template&lt;typename tree_t &gt; </td></tr>
<tr class="memitem:ae70b74a1214f7f18bb95fb1b940fc66a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#ae70b74a1214f7f18bb95fb1b940fc66a">update_unionfind_before_remove_edges_incident_to</a> (const tree_t &amp;t, <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u, <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> *const root_of, uint64_t *const root_size) noexcept</td></tr>
<tr class="memdesc:ae70b74a1214f7f18bb95fb1b940fc66a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update Union-Find after a vertex removal.  <a href="namespacelal_1_1detail.html#ae70b74a1214f7f18bb95fb1b940fc66a">More...</a><br /></td></tr>
<tr class="separator:ae70b74a1214f7f18bb95fb1b940fc66a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6380645d003f5db7d59f3547401002a7"><td class="memTemplParams" colspan="2">template&lt;class graph_t , typename char_type , std::enable_if_t&lt; std::is_base_of_v&lt; <a class="el" href="classlal_1_1graphs_1_1graph.html">graphs::graph</a>, graph_t &gt; &amp;&amp;std::is_integral_v&lt; char_type &gt;, bool &gt;  = true&gt; </td></tr>
<tr class="memitem:a6380645d003f5db7d59f3547401002a7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#a6380645d003f5db7d59f3547401002a7">get_bool_neighbours</a> (const graph_t &amp;g, <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u, char_type *const neighs) noexcept</td></tr>
<tr class="memdesc:a6380645d003f5db7d59f3547401002a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the neighbours of a node in an undirected graph as a list of 0-1 values.  <a href="namespacelal_1_1detail.html#a6380645d003f5db7d59f3547401002a7">More...</a><br /></td></tr>
<tr class="separator:a6380645d003f5db7d59f3547401002a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99e564e21a58d5a88f53503f71317136"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#a99e564e21a58d5a88f53503f71317136">append_adjacency_lists</a> (std::vector&lt; <a class="el" href="namespacelal.html#aef91d923414879a998619e9c65181d1f">neighbourhood</a> &gt; &amp;target, const std::vector&lt; <a class="el" href="namespacelal.html#aef91d923414879a998619e9c65181d1f">neighbourhood</a> &gt; &amp;source) noexcept</td></tr>
<tr class="memdesc:a99e564e21a58d5a88f53503f71317136"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append adjacency list 'source' to list 'target'.  <a href="namespacelal_1_1detail.html#a99e564e21a58d5a88f53503f71317136">More...</a><br /></td></tr>
<tr class="separator:a99e564e21a58d5a88f53503f71317136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30ad302d4880d287fa38e22cb63e4c4d"><td class="memItemLeft" align="right" valign="top"><a id="a30ad302d4880d287fa38e22cb63e4c4d" name="a30ad302d4880d287fa38e22cb63e4c4d"></a>
<a class="el" href="structlal_1_1detail_1_1linarr__wrapper.html">linarr_wrapper</a>&lt; <a class="el" href="namespacelal_1_1detail.html#ae7e27c62d46601d7b2c7b75cbfdeda85aff483d1ff591898a9942916050d2ca3f">linarr_type::identity</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>identity_arr</b> (const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;arr) noexcept</td></tr>
<tr class="memdesc:a30ad302d4880d287fa38e22cb63e4c4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shorthand for an identity arrangement. <br /></td></tr>
<tr class="separator:a30ad302d4880d287fa38e22cb63e4c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6ad3beffcda72a05bf08badaedc4bcb"><td class="memItemLeft" align="right" valign="top"><a id="ae6ad3beffcda72a05bf08badaedc4bcb" name="ae6ad3beffcda72a05bf08badaedc4bcb"></a>
<a class="el" href="structlal_1_1detail_1_1linarr__wrapper.html">linarr_wrapper</a>&lt; <a class="el" href="namespacelal_1_1detail.html#ae7e27c62d46601d7b2c7b75cbfdeda85a78463cb21909f69c5bb59611db0b7575">linarr_type::nonident</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>nonident_arr</b> (const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;arr) noexcept</td></tr>
<tr class="memdesc:ae6ad3beffcda72a05bf08badaedc4bcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shorthand for a nonidentity arrangement. <br /></td></tr>
<tr class="separator:ae6ad3beffcda72a05bf08badaedc4bcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac03b599e3f3bf8b9342abd77dd457dcf"><td class="memItemLeft" align="right" valign="top"><a id="ac03b599e3f3bf8b9342abd77dd457dcf" name="ac03b599e3f3bf8b9342abd77dd457dcf"></a>
<a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a>&#160;</td><td class="memItemRight" valign="bottom"><b>head_vector_to_directed_graph</b> (const <a class="el" href="namespacelal.html#a2eb5b7f5b50ff908a7a67889a9ea744d">head_vector</a> &amp;hv) noexcept</td></tr>
<tr class="memdesc:ac03b599e3f3bf8b9342abd77dd457dcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms a head vector in a directed graph. <br /></td></tr>
<tr class="separator:ac03b599e3f3bf8b9342abd77dd457dcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f57039e53dcd5976c7397a439b3f7ee"><td class="memTemplParams" colspan="2">template&lt;bool decide&gt; </td></tr>
<tr class="memitem:a6f57039e53dcd5976c7397a439b3f7ee"><td class="memTemplItemLeft" align="right" valign="top">std::conditional_t&lt; decide, bool, std::vector&lt; <a class="el" href="classlal_1_1io_1_1report__treebank__file.html">io::report_treebank_file</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#a6f57039e53dcd5976c7397a439b3f7ee">find_errors</a> (const <a class="el" href="namespacelal.html#a2eb5b7f5b50ff908a7a67889a9ea744d">head_vector</a> &amp;hv, const std::size_t line) noexcept</td></tr>
<tr class="memdesc:a6f57039e53dcd5976c7397a439b3f7ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find errors in a head vector.  <a href="namespacelal_1_1detail.html#a6f57039e53dcd5976c7397a439b3f7ee">More...</a><br /></td></tr>
<tr class="separator:a6f57039e53dcd5976c7397a439b3f7ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab50dcafac1d535062aab1c8f46e27b35"><td class="memTemplParams" colspan="2">template&lt;bool decide&gt; </td></tr>
<tr class="memitem:ab50dcafac1d535062aab1c8f46e27b35"><td class="memTemplItemLeft" align="right" valign="top">std::conditional_t&lt; decide, bool, std::vector&lt; <a class="el" href="classlal_1_1io_1_1report__treebank__file.html">io::report_treebank_file</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#ab50dcafac1d535062aab1c8f46e27b35">find_errors</a> (const std::string &amp;current_line, const std::size_t line) noexcept</td></tr>
<tr class="memdesc:ab50dcafac1d535062aab1c8f46e27b35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find errors in a line of a treebank.  <a href="namespacelal_1_1detail.html#ab50dcafac1d535062aab1c8f46e27b35">More...</a><br /></td></tr>
<tr class="separator:ab50dcafac1d535062aab1c8f46e27b35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb3b1129ae180b2186dd38f82b8091a8"><td class="memTemplParams" colspan="2">template&lt;bool decide&gt; </td></tr>
<tr class="memitem:acb3b1129ae180b2186dd38f82b8091a8"><td class="memTemplItemLeft" align="right" valign="top">std::conditional_t&lt; decide, bool, std::vector&lt; <a class="el" href="classlal_1_1io_1_1report__treebank__file.html">io::report_treebank_file</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#acb3b1129ae180b2186dd38f82b8091a8">check_correctness_treebank</a> (const std::string &amp;treebank_filename) noexcept</td></tr>
<tr class="memdesc:acb3b1129ae180b2186dd38f82b8091a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find errors in a treebank file.  <a href="namespacelal_1_1detail.html#acb3b1129ae180b2186dd38f82b8091a8">More...</a><br /></td></tr>
<tr class="separator:acb3b1129ae180b2186dd38f82b8091a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9fc8ab44169e4da6445f31598703572"><td class="memTemplParams" colspan="2">template&lt;bool decide&gt; </td></tr>
<tr class="memitem:ab9fc8ab44169e4da6445f31598703572"><td class="memTemplItemLeft" align="right" valign="top">std::conditional_t&lt; decide, bool, std::vector&lt; <a class="el" href="classlal_1_1io_1_1report__treebank__collection.html">io::report_treebank_collection</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#ab9fc8ab44169e4da6445f31598703572">check_correctness_treebank_collection</a> (const std::string &amp;main_file_name, std::size_t n_threads) noexcept</td></tr>
<tr class="memdesc:ab9fc8ab44169e4da6445f31598703572"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find errors in a treebank collection.  <a href="namespacelal_1_1detail.html#ab9fc8ab44169e4da6445f31598703572">More...</a><br /></td></tr>
<tr class="separator:ab9fc8ab44169e4da6445f31598703572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dfcbe004ac9a216754bf3eae410c32b"><td class="memTemplParams" colspan="2">template&lt;class graph_t &gt; </td></tr>
<tr class="memitem:a8dfcbe004ac9a216754bf3eae410c32b"><td class="memTemplItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#a8dfcbe004ac9a216754bf3eae410c32b">n_C_brute_force</a> (const graph_t &amp;g, const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;arr) noexcept</td></tr>
<tr class="memdesc:a8dfcbe004ac9a216754bf3eae410c32b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the number of crossings in the linear arrangement less than a constant?  <a href="namespacelal_1_1detail.html#a8dfcbe004ac9a216754bf3eae410c32b">More...</a><br /></td></tr>
<tr class="separator:a8dfcbe004ac9a216754bf3eae410c32b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aaadea543154a22dd77ce1179b9ab42"><td class="memTemplParams" colspan="2">template&lt;class graph_t &gt; </td></tr>
<tr class="memitem:a9aaadea543154a22dd77ce1179b9ab42"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; uint64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#a9aaadea543154a22dd77ce1179b9ab42">n_C_brute_force</a> (const graph_t &amp;g, const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;arrs) noexcept</td></tr>
<tr class="memdesc:a9aaadea543154a22dd77ce1179b9ab42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the number of crossings in the linear arrangement less than a constant?  <a href="namespacelal_1_1detail.html#a9aaadea543154a22dd77ce1179b9ab42">More...</a><br /></td></tr>
<tr class="separator:a9aaadea543154a22dd77ce1179b9ab42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ed32b72077e3f6f6119b321084d7ed6"><td class="memTemplParams" colspan="2">template&lt;class graph_t &gt; </td></tr>
<tr class="memitem:a2ed32b72077e3f6f6119b321084d7ed6"><td class="memTemplItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#a2ed32b72077e3f6f6119b321084d7ed6">is_n_C_brute_force_lesseq_than</a> (const graph_t &amp;g, const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;arr, uint64_t upper_bound) noexcept</td></tr>
<tr class="memdesc:a2ed32b72077e3f6f6119b321084d7ed6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the number of crossings is less than a given constant.  <a href="namespacelal_1_1detail.html#a2ed32b72077e3f6f6119b321084d7ed6">More...</a><br /></td></tr>
<tr class="separator:a2ed32b72077e3f6f6119b321084d7ed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7699f35ac7f97fd77fefa96bfb546635"><td class="memTemplParams" colspan="2">template&lt;class graph_t &gt; </td></tr>
<tr class="memitem:a7699f35ac7f97fd77fefa96bfb546635"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; uint64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#a7699f35ac7f97fd77fefa96bfb546635">is_n_C_brute_force_lesseq_than</a> (const graph_t &amp;g, const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;arrs, uint64_t upper_bound) noexcept</td></tr>
<tr class="memdesc:a7699f35ac7f97fd77fefa96bfb546635"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the number of crossings is less than a given constant.  <a href="namespacelal_1_1detail.html#a7699f35ac7f97fd77fefa96bfb546635">More...</a><br /></td></tr>
<tr class="separator:a7699f35ac7f97fd77fefa96bfb546635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52af8ab2c0352a408cce9e05de472e88"><td class="memTemplParams" colspan="2">template&lt;class graph_t &gt; </td></tr>
<tr class="memitem:a52af8ab2c0352a408cce9e05de472e88"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; uint64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#a52af8ab2c0352a408cce9e05de472e88">is_n_C_brute_force_lesseq_than</a> (const graph_t &amp;g, const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;arrs, const std::vector&lt; uint64_t &gt; &amp;upper_bounds) noexcept</td></tr>
<tr class="memdesc:a52af8ab2c0352a408cce9e05de472e88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the number of crossings is less than a given constant.  <a href="namespacelal_1_1detail.html#a52af8ab2c0352a408cce9e05de472e88">More...</a><br /></td></tr>
<tr class="separator:a52af8ab2c0352a408cce9e05de472e88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace62b8ae72aa81e2f7220ed5ab94d62b"><td class="memTemplParams" colspan="2">template&lt;class graph_t &gt; </td></tr>
<tr class="memitem:ace62b8ae72aa81e2f7220ed5ab94d62b"><td class="memTemplItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#ace62b8ae72aa81e2f7220ed5ab94d62b">n_C_dynamic_programming</a> (const graph_t &amp;g, const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;arr) noexcept</td></tr>
<tr class="memdesc:ace62b8ae72aa81e2f7220ed5ab94d62b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the number of crossings in the linear arrangement less than a constant?  <a href="namespacelal_1_1detail.html#ace62b8ae72aa81e2f7220ed5ab94d62b">More...</a><br /></td></tr>
<tr class="separator:ace62b8ae72aa81e2f7220ed5ab94d62b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6fb4a73feef834d6f6083017c77ffad"><td class="memTemplParams" colspan="2">template&lt;class graph_t &gt; </td></tr>
<tr class="memitem:ab6fb4a73feef834d6f6083017c77ffad"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; uint64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#ab6fb4a73feef834d6f6083017c77ffad">n_C_dynamic_programming</a> (const graph_t &amp;g, const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;arrs) noexcept</td></tr>
<tr class="memdesc:ab6fb4a73feef834d6f6083017c77ffad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the number of crossings in the linear arrangement less than a constant?  <a href="namespacelal_1_1detail.html#ab6fb4a73feef834d6f6083017c77ffad">More...</a><br /></td></tr>
<tr class="separator:ab6fb4a73feef834d6f6083017c77ffad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b6239adc7d16f0d1a8d4ea8e7979a5d"><td class="memTemplParams" colspan="2">template&lt;class graph_t &gt; </td></tr>
<tr class="memitem:a0b6239adc7d16f0d1a8d4ea8e7979a5d"><td class="memTemplItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#a0b6239adc7d16f0d1a8d4ea8e7979a5d">is_n_C_dynamic_programming_lesseq_than</a> (const graph_t &amp;g, const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;arr, uint64_t upper_bound) noexcept</td></tr>
<tr class="memdesc:a0b6239adc7d16f0d1a8d4ea8e7979a5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast calculation of \(C\) if it is less than or equal to an upper bound.  <a href="namespacelal_1_1detail.html#a0b6239adc7d16f0d1a8d4ea8e7979a5d">More...</a><br /></td></tr>
<tr class="separator:a0b6239adc7d16f0d1a8d4ea8e7979a5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa40e0c850c9d2b700f0d850547ae9ba5"><td class="memTemplParams" colspan="2">template&lt;class graph_t &gt; </td></tr>
<tr class="memitem:aa40e0c850c9d2b700f0d850547ae9ba5"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; uint64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#aa40e0c850c9d2b700f0d850547ae9ba5">is_n_C_dynamic_programming_lesseq_than</a> (const graph_t &amp;g, const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;arrs, uint64_t upper_bound) noexcept</td></tr>
<tr class="memdesc:aa40e0c850c9d2b700f0d850547ae9ba5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast calculation of \(C\) if it is less than or equal to an upper bound.  <a href="namespacelal_1_1detail.html#aa40e0c850c9d2b700f0d850547ae9ba5">More...</a><br /></td></tr>
<tr class="separator:aa40e0c850c9d2b700f0d850547ae9ba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa37dcfd68ac36acf6031b605ab75abc"><td class="memTemplParams" colspan="2">template&lt;class graph_t &gt; </td></tr>
<tr class="memitem:aaa37dcfd68ac36acf6031b605ab75abc"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; uint64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#aaa37dcfd68ac36acf6031b605ab75abc">is_n_C_dynamic_programming_lesseq_than</a> (const graph_t &amp;g, const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;arrs, const std::vector&lt; uint64_t &gt; &amp;upper_bounds) noexcept</td></tr>
<tr class="memdesc:aaa37dcfd68ac36acf6031b605ab75abc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast calculation of \(C\) if it is less than or equal to an upper bound.  <a href="namespacelal_1_1detail.html#aaa37dcfd68ac36acf6031b605ab75abc">More...</a><br /></td></tr>
<tr class="separator:aaa37dcfd68ac36acf6031b605ab75abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ff3d3faa9937f42252a89c79809d20f"><td class="memTemplParams" colspan="2">template&lt;class graph_t &gt; </td></tr>
<tr class="memitem:a0ff3d3faa9937f42252a89c79809d20f"><td class="memTemplItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#a0ff3d3faa9937f42252a89c79809d20f">n_C_ladder</a> (const graph_t &amp;g, const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;arr) noexcept</td></tr>
<tr class="memdesc:a0ff3d3faa9937f42252a89c79809d20f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the number of crossings in the linear arrangement less than a constant?  <a href="namespacelal_1_1detail.html#a0ff3d3faa9937f42252a89c79809d20f">More...</a><br /></td></tr>
<tr class="separator:a0ff3d3faa9937f42252a89c79809d20f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5860c3c8273d95209e36bdd689943629"><td class="memTemplParams" colspan="2">template&lt;class graph_t &gt; </td></tr>
<tr class="memitem:a5860c3c8273d95209e36bdd689943629"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; uint64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#a5860c3c8273d95209e36bdd689943629">n_C_ladder</a> (const graph_t &amp;g, const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;arrs) noexcept</td></tr>
<tr class="memdesc:a5860c3c8273d95209e36bdd689943629"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the number of crossings in the linear arrangement less than a constant?  <a href="namespacelal_1_1detail.html#a5860c3c8273d95209e36bdd689943629">More...</a><br /></td></tr>
<tr class="separator:a5860c3c8273d95209e36bdd689943629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12b35b7ee96b1b71634a019129cf74ea"><td class="memTemplParams" colspan="2">template&lt;class graph_t &gt; </td></tr>
<tr class="memitem:a12b35b7ee96b1b71634a019129cf74ea"><td class="memTemplItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#a12b35b7ee96b1b71634a019129cf74ea">is_n_C_ladder_lesseq_than</a> (const graph_t &amp;g, const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;arr, uint64_t upper_bound) noexcept</td></tr>
<tr class="memdesc:a12b35b7ee96b1b71634a019129cf74ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast calculation of \(C\) if it is less than or equal to an upper bound.  <a href="namespacelal_1_1detail.html#a12b35b7ee96b1b71634a019129cf74ea">More...</a><br /></td></tr>
<tr class="separator:a12b35b7ee96b1b71634a019129cf74ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac485b276e1592aa9b4fbf88393497206"><td class="memTemplParams" colspan="2">template&lt;class graph_t &gt; </td></tr>
<tr class="memitem:ac485b276e1592aa9b4fbf88393497206"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; uint64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#ac485b276e1592aa9b4fbf88393497206">is_n_C_ladder_lesseq_than</a> (const graph_t &amp;g, const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;arrs, uint64_t upper_bound) noexcept</td></tr>
<tr class="memdesc:ac485b276e1592aa9b4fbf88393497206"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast calculation of \(C\) if it is less than or equal to an upper bound.  <a href="namespacelal_1_1detail.html#ac485b276e1592aa9b4fbf88393497206">More...</a><br /></td></tr>
<tr class="separator:ac485b276e1592aa9b4fbf88393497206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a313d37b28c1b5efec442077b09c4ab"><td class="memTemplParams" colspan="2">template&lt;class graph_t &gt; </td></tr>
<tr class="memitem:a4a313d37b28c1b5efec442077b09c4ab"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; uint64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#a4a313d37b28c1b5efec442077b09c4ab">is_n_C_ladder_lesseq_than</a> (const graph_t &amp;g, const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;arrs, const std::vector&lt; uint64_t &gt; &amp;upper_bounds) noexcept</td></tr>
<tr class="memdesc:a4a313d37b28c1b5efec442077b09c4ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast calculation of \(C\) if it is less than or equal to an upper bound.  <a href="namespacelal_1_1detail.html#a4a313d37b28c1b5efec442077b09c4ab">More...</a><br /></td></tr>
<tr class="separator:a4a313d37b28c1b5efec442077b09c4ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d67b4d927bc4ada1816b903f278bcff"><td class="memTemplParams" colspan="2">template&lt;class graph_t &gt; </td></tr>
<tr class="memitem:a1d67b4d927bc4ada1816b903f278bcff"><td class="memTemplItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#a1d67b4d927bc4ada1816b903f278bcff">n_C_stack_based</a> (const graph_t &amp;g, const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;arr) noexcept</td></tr>
<tr class="memdesc:a1d67b4d927bc4ada1816b903f278bcff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the number of crossings in the linear arrangement less than a constant?  <a href="namespacelal_1_1detail.html#a1d67b4d927bc4ada1816b903f278bcff">More...</a><br /></td></tr>
<tr class="separator:a1d67b4d927bc4ada1816b903f278bcff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dcc673a543201a113c8c6f1d0f3e1ad"><td class="memTemplParams" colspan="2">template&lt;class graph_t &gt; </td></tr>
<tr class="memitem:a2dcc673a543201a113c8c6f1d0f3e1ad"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; uint64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#a2dcc673a543201a113c8c6f1d0f3e1ad">n_C_stack_based</a> (const graph_t &amp;g, const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;arrs) noexcept</td></tr>
<tr class="memdesc:a2dcc673a543201a113c8c6f1d0f3e1ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the number of crossings in the linear arrangement less than a constant?  <a href="namespacelal_1_1detail.html#a2dcc673a543201a113c8c6f1d0f3e1ad">More...</a><br /></td></tr>
<tr class="separator:a2dcc673a543201a113c8c6f1d0f3e1ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66ef8619b0afb6b4f1fe6bf2b055c182"><td class="memTemplParams" colspan="2">template&lt;class graph_t &gt; </td></tr>
<tr class="memitem:a66ef8619b0afb6b4f1fe6bf2b055c182"><td class="memTemplItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#a66ef8619b0afb6b4f1fe6bf2b055c182">is_n_C_stack_based_lesseq_than</a> (const graph_t &amp;g, const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;arr, uint64_t upper_bound) noexcept</td></tr>
<tr class="memdesc:a66ef8619b0afb6b4f1fe6bf2b055c182"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast calculation of \(C\) if it is less than or equal to an upper bound.  <a href="namespacelal_1_1detail.html#a66ef8619b0afb6b4f1fe6bf2b055c182">More...</a><br /></td></tr>
<tr class="separator:a66ef8619b0afb6b4f1fe6bf2b055c182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac578078f7000be585dce35b5dead731a"><td class="memTemplParams" colspan="2">template&lt;class graph_t &gt; </td></tr>
<tr class="memitem:ac578078f7000be585dce35b5dead731a"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; uint64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#ac578078f7000be585dce35b5dead731a">is_n_C_stack_based_lesseq_than</a> (const graph_t &amp;g, const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;arrs, uint64_t upper_bound) noexcept</td></tr>
<tr class="memdesc:ac578078f7000be585dce35b5dead731a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast calculation of \(C\) if it is less than or equal to an upper bound.  <a href="namespacelal_1_1detail.html#ac578078f7000be585dce35b5dead731a">More...</a><br /></td></tr>
<tr class="separator:ac578078f7000be585dce35b5dead731a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac9327821de6e918b01ac58c5e5f8ec2"><td class="memTemplParams" colspan="2">template&lt;class graph_t &gt; </td></tr>
<tr class="memitem:aac9327821de6e918b01ac58c5e5f8ec2"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; uint64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#aac9327821de6e918b01ac58c5e5f8ec2">is_n_C_stack_based_lesseq_than</a> (const graph_t &amp;g, const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;arrs, const std::vector&lt; uint64_t &gt; &amp;upper_bounds) noexcept</td></tr>
<tr class="memdesc:aac9327821de6e918b01ac58c5e5f8ec2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast calculation of \(C\) if it is less than or equal to an upper bound.  <a href="namespacelal_1_1detail.html#aac9327821de6e918b01ac58c5e5f8ec2">More...</a><br /></td></tr>
<tr class="separator:aac9327821de6e918b01ac58c5e5f8ec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa20b450ba80542fb87c883a99c5d63b2"><td class="memTemplParams" colspan="2">template&lt;class depflux , class arrangement_t &gt; </td></tr>
<tr class="memitem:aa20b450ba80542fb87c883a99c5d63b2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#aa20b450ba80542fb87c883a99c5d63b2">calculate_dependencies_and_span</a> (const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;t, const arrangement_t &amp;arr, const std::vector&lt; std::pair&lt; <a class="el" href="namespacelal.html#af8e55c3f8923a4ba55e8117a20a75b4a">edge_t</a>, uint64_t &gt; &gt; &amp;edge_with_max_pos_at, <a class="el" href="namespacelal.html#a5c3f34575ec933a44ed7b6d81e8c75f6">position</a> cur_pos, std::vector&lt; depflux &gt; &amp;flux, std::vector&lt; <a class="el" href="namespacelal.html#a5969ec7ecc85697ebb9ec0ace78fbcab">edge</a> &gt; &amp;cur_deps) noexcept</td></tr>
<tr class="memdesc:aa20b450ba80542fb87c883a99c5d63b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the dependencies and their span.  <a href="namespacelal_1_1detail.html#aa20b450ba80542fb87c883a99c5d63b2">More...</a><br /></td></tr>
<tr class="separator:aa20b450ba80542fb87c883a99c5d63b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38e173ec404e2222f2d4b5a20dcdfe8b"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#a38e173ec404e2222f2d4b5a20dcdfe8b">calculate_weight</a> (const std::vector&lt; <a class="el" href="namespacelal.html#a5969ec7ecc85697ebb9ec0ace78fbcab">edge</a> &gt; &amp;dependencies, <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;ug) noexcept</td></tr>
<tr class="memdesc:a38e173ec404e2222f2d4b5a20dcdfe8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the weight of a set of dependencies in a flux.  <a href="namespacelal_1_1detail.html#a38e173ec404e2222f2d4b5a20dcdfe8b">More...</a><br /></td></tr>
<tr class="separator:a38e173ec404e2222f2d4b5a20dcdfe8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae10cd880698b3b3e49fd2232fe51bd40"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacelal_1_1detail.html#ae7e27c62d46601d7b2c7b75cbfdeda85">detail::linarr_type</a> arr_type&gt; </td></tr>
<tr class="memitem:ae10cd880698b3b3e49fd2232fe51bd40"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#ae10cd880698b3b3e49fd2232fe51bd40">is_root_covered</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;rt, const <a class="el" href="structlal_1_1detail_1_1linarr__wrapper.html">detail::linarr_wrapper</a>&lt; arr_type &gt; &amp;arr) noexcept</td></tr>
<tr class="memdesc:ae10cd880698b3b3e49fd2232fe51bd40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the root of a rooted tree covered in a given arrangement?  <a href="namespacelal_1_1detail.html#ae10cd880698b3b3e49fd2232fe51bd40">More...</a><br /></td></tr>
<tr class="separator:ae10cd880698b3b3e49fd2232fe51bd40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a770859f44e2ce4b5b18f393c4bb0978d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacelal_1_1detail.html#ae7e27c62d46601d7b2c7b75cbfdeda85">detail::linarr_type</a> arr_type&gt; </td></tr>
<tr class="memitem:a770859f44e2ce4b5b18f393c4bb0978d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#a770859f44e2ce4b5b18f393c4bb0978d">is_projective</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;rt, const <a class="el" href="structlal_1_1detail_1_1linarr__wrapper.html">detail::linarr_wrapper</a>&lt; arr_type &gt; &amp;arr) noexcept</td></tr>
<tr class="memdesc:a770859f44e2ce4b5b18f393c4bb0978d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is a given arrangement projective?  <a href="namespacelal_1_1detail.html#a770859f44e2ce4b5b18f393c4bb0978d">More...</a><br /></td></tr>
<tr class="separator:a770859f44e2ce4b5b18f393c4bb0978d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5730f2fef2524437fafcbeb1383d9d96"><td class="memTemplParams" colspan="2">template&lt;class arrangement_t &gt; </td></tr>
<tr class="memitem:a5730f2fef2524437fafcbeb1383d9d96"><td class="memTemplItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#a5730f2fef2524437fafcbeb1383d9d96">right_branching_edges</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;g, const arrangement_t &amp;arr) noexcept</td></tr>
<tr class="memdesc:a5730f2fef2524437fafcbeb1383d9d96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of right branching edges in a directed graph.  <a href="namespacelal_1_1detail.html#a5730f2fef2524437fafcbeb1383d9d96">More...</a><br /></td></tr>
<tr class="separator:a5730f2fef2524437fafcbeb1383d9d96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace97a861f8ce972d844103dd12a2af62"><td class="memTemplParams" colspan="2">template&lt;typename result_t , class arrangement_t &gt; </td></tr>
<tr class="memitem:ace97a861f8ce972d844103dd12a2af62"><td class="memTemplItemLeft" align="right" valign="top">result_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#ace97a861f8ce972d844103dd12a2af62">head_initial</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;g, const arrangement_t &amp;arr) noexcept</td></tr>
<tr class="memdesc:ace97a861f8ce972d844103dd12a2af62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proposition of right branching edges in a directed graph.  <a href="namespacelal_1_1detail.html#ace97a861f8ce972d844103dd12a2af62">More...</a><br /></td></tr>
<tr class="separator:ace97a861f8ce972d844103dd12a2af62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c3f637b02ebf8c6b82b6098cfbc40ca"><td class="memItemLeft" align="right" valign="top">constexpr uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#a0c3f637b02ebf8c6b82b6098cfbc40ca">alpha</a> (const int64_t n, const int64_t d1, const int64_t d2) noexcept</td></tr>
<tr class="memdesc:a0c3f637b02ebf8c6b82b6098cfbc40ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Amount of crossings pairs of edges of given lengths.  <a href="namespacelal_1_1detail.html#a0c3f637b02ebf8c6b82b6098cfbc40ca">More...</a><br /></td></tr>
<tr class="separator:a0c3f637b02ebf8c6b82b6098cfbc40ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad403e3fe175466a9544301b3d679eb9e"><td class="memItemLeft" align="right" valign="top">constexpr uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#ad403e3fe175466a9544301b3d679eb9e">beta</a> (const int64_t n, const int64_t d1, const int64_t d2) noexcept</td></tr>
<tr class="memdesc:ad403e3fe175466a9544301b3d679eb9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Amount of pairs of edges of given lengths.  <a href="namespacelal_1_1detail.html#ad403e3fe175466a9544301b3d679eb9e">More...</a><br /></td></tr>
<tr class="separator:ad403e3fe175466a9544301b3d679eb9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8965e5ea6dab322a1bfdd7ee94c7050f"><td class="memTemplParams" colspan="2">template&lt;typename result_t , class graph_t , class arrangement_t &gt; </td></tr>
<tr class="memitem:a8965e5ea6dab322a1bfdd7ee94c7050f"><td class="memTemplItemLeft" align="right" valign="top">result_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#a8965e5ea6dab322a1bfdd7ee94c7050f">predict_C_using_edge_lengths</a> (const graph_t &amp;g, const arrangement_t &amp;arr) noexcept</td></tr>
<tr class="memdesc:a8965e5ea6dab322a1bfdd7ee94c7050f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicted number of crossings based on the sum of edge lengths.  <a href="namespacelal_1_1detail.html#a8965e5ea6dab322a1bfdd7ee94c7050f">More...</a><br /></td></tr>
<tr class="separator:a8965e5ea6dab322a1bfdd7ee94c7050f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8452716fdc28399856f71906ef872b6c"><td class="memTemplParams" colspan="2">template&lt;class graph_t , class arrangement_t &gt; </td></tr>
<tr class="memitem:a8452716fdc28399856f71906ef872b6c"><td class="memTemplItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#a8452716fdc28399856f71906ef872b6c">sum_edge_lengths</a> (const graph_t &amp;g, const arrangement_t &amp;arr) noexcept</td></tr>
<tr class="memdesc:a8452716fdc28399856f71906ef872b6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum of edge lengths in a graph.  <a href="namespacelal_1_1detail.html#a8452716fdc28399856f71906ef872b6c">More...</a><br /></td></tr>
<tr class="separator:a8452716fdc28399856f71906ef872b6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f454be47191d83eb42085332877424e"><td class="memTemplParams" colspan="2">template&lt;typename result_t , class graph_t , class arrangement_t &gt; </td></tr>
<tr class="memitem:a4f454be47191d83eb42085332877424e"><td class="memTemplItemLeft" align="right" valign="top">result_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#a4f454be47191d83eb42085332877424e">mean_sum_edge_lengths</a> (const graph_t &amp;g, const arrangement_t &amp;arr) noexcept</td></tr>
<tr class="memdesc:a4f454be47191d83eb42085332877424e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Average sum of edge lengths in a graph.  <a href="namespacelal_1_1detail.html#a4f454be47191d83eb42085332877424e">More...</a><br /></td></tr>
<tr class="separator:a4f454be47191d83eb42085332877424e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a187fa2c26689d24012a0b50b80b676a2"><td class="memItemLeft" align="right" valign="top">constexpr std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#a187fa2c26689d24012a0b50b80b676a2">syntactic_dependency_structure_to_string</a> (const <a class="el" href="namespacelal_1_1linarr.html#a3e8b744d4c81d3bb4463ec203f9199d6">linarr::syntactic_dependency_structure</a> &amp;tt) noexcept</td></tr>
<tr class="separator:a187fa2c26689d24012a0b50b80b676a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67e72dd22d7c68404254ea092b3e8fa1"><td class="memTemplParams" colspan="2"><a id="a67e72dd22d7c68404254ea092b3e8fa1" name="a67e72dd22d7c68404254ea092b3e8fa1"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a67e72dd22d7c68404254ea092b3e8fa1"><td class="memTemplItemLeft" align="right" valign="top">constexpr int64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>to_int64</b> (const T &amp;t) noexcept</td></tr>
<tr class="memdesc:a67e72dd22d7c68404254ea092b3e8fa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion to int64_t. <br /></td></tr>
<tr class="separator:a67e72dd22d7c68404254ea092b3e8fa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9607b34bcc80c09c694fc694bd6a96a"><td class="memTemplParams" colspan="2"><a id="ab9607b34bcc80c09c694fc694bd6a96a" name="ab9607b34bcc80c09c694fc694bd6a96a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab9607b34bcc80c09c694fc694bd6a96a"><td class="memTemplItemLeft" align="right" valign="top">constexpr uint64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>to_uint64</b> (const T &amp;t) noexcept</td></tr>
<tr class="memdesc:ab9607b34bcc80c09c694fc694bd6a96a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion to uint64_t. <br /></td></tr>
<tr class="separator:ab9607b34bcc80c09c694fc694bd6a96a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d2da0aa7652f2dbbf6b7d6dc1e47fcd"><td class="memTemplParams" colspan="2"><a id="a4d2da0aa7652f2dbbf6b7d6dc1e47fcd" name="a4d2da0aa7652f2dbbf6b7d6dc1e47fcd"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4d2da0aa7652f2dbbf6b7d6dc1e47fcd"><td class="memTemplItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memTemplItemRight" valign="bottom"><b>to_double</b> (const T &amp;t) noexcept</td></tr>
<tr class="memdesc:a4d2da0aa7652f2dbbf6b7d6dc1e47fcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion to double. <br /></td></tr>
<tr class="separator:a4d2da0aa7652f2dbbf6b7d6dc1e47fcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd572e3130f477ef3c5098f1b21b5064"><td class="memTemplParams" colspan="2"><a id="abd572e3130f477ef3c5098f1b21b5064" name="abd572e3130f477ef3c5098f1b21b5064"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:abd572e3130f477ef3c5098f1b21b5064"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>abs_diff</b> (const T &amp;t1, const T &amp;t2) noexcept</td></tr>
<tr class="memdesc:abd572e3130f477ef3c5098f1b21b5064"><td class="mdescLeft">&#160;</td><td class="mdescRight">Absolute difference of two values. <br /></td></tr>
<tr class="separator:abd572e3130f477ef3c5098f1b21b5064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1c13d4871396a062ae9ce2533867b15"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t size, T v, std::size_t... I&gt; </td></tr>
<tr class="memitem:ab1c13d4871396a062ae9ce2533867b15"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::array&lt; T, size &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#ab1c13d4871396a062ae9ce2533867b15">make_array_with_value_impl</a> (std::index_sequence&lt; I... &gt;) noexcept</td></tr>
<tr class="memdesc:ab1c13d4871396a062ae9ce2533867b15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of <a class="el" href="namespacelal_1_1detail.html#adfd794b7d5d1d3b62c7faa1572342dfe">lal::detail::make_array_with_value</a>.  <a href="namespacelal_1_1detail.html#ab1c13d4871396a062ae9ce2533867b15">More...</a><br /></td></tr>
<tr class="separator:ab1c13d4871396a062ae9ce2533867b15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfd794b7d5d1d3b62c7faa1572342dfe"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t array_size, T value_to_fill_with&gt; </td></tr>
<tr class="memitem:adfd794b7d5d1d3b62c7faa1572342dfe"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::array&lt; T, array_size &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#adfd794b7d5d1d3b62c7faa1572342dfe">make_array_with_value</a> () noexcept</td></tr>
<tr class="memdesc:adfd794b7d5d1d3b62c7faa1572342dfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an array initialised at a given value.  <a href="namespacelal_1_1detail.html#adfd794b7d5d1d3b62c7faa1572342dfe">More...</a><br /></td></tr>
<tr class="separator:adfd794b7d5d1d3b62c7faa1572342dfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba881f87432bdfa65bc26d67244de6aa"><td class="memTemplParams" colspan="2">template&lt;typename T , T... ARGS&gt; </td></tr>
<tr class="memitem:aba881f87432bdfa65bc26d67244de6aa"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::array&lt; T, sizeof...(ARGS)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#aba881f87432bdfa65bc26d67244de6aa">make_array</a> () noexcept</td></tr>
<tr class="memdesc:aba881f87432bdfa65bc26d67244de6aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make an array with the values given as parameters of the template.  <a href="namespacelal_1_1detail.html#aba881f87432bdfa65bc26d67244de6aa">More...</a><br /></td></tr>
<tr class="separator:aba881f87432bdfa65bc26d67244de6aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadddf96b5de80a3d63d05ec36f9cb672"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#aadddf96b5de80a3d63d05ec36f9cb672">mpz_pow_mpz</a> (mpz_t &amp;r, const mpz_t &amp;b, const mpz_t &amp;e) noexcept</td></tr>
<tr class="memdesc:aadddf96b5de80a3d63d05ec36f9cb672"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the exponentiation of a big integer to another big integer.  <a href="namespacelal_1_1detail.html#aadddf96b5de80a3d63d05ec36f9cb672">More...</a><br /></td></tr>
<tr class="separator:aadddf96b5de80a3d63d05ec36f9cb672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52b8428c64f43950e2e231a38e2a730b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#a52b8428c64f43950e2e231a38e2a730b">mpz_divide_mpq</a> (mpq_t &amp;r, const mpz_t &amp;k) noexcept</td></tr>
<tr class="memdesc:a52b8428c64f43950e2e231a38e2a730b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rational-Integer division.  <a href="namespacelal_1_1detail.html#a52b8428c64f43950e2e231a38e2a730b">More...</a><br /></td></tr>
<tr class="separator:a52b8428c64f43950e2e231a38e2a730b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a811da8587db802ee4de53fe9c4d26b7c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#a811da8587db802ee4de53fe9c4d26b7c">mpq_divide_mpq</a> (mpq_t &amp;num, const mpq_t &amp;den) noexcept</td></tr>
<tr class="memdesc:a811da8587db802ee4de53fe9c4d26b7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rational-Rational division.  <a href="namespacelal_1_1detail.html#a811da8587db802ee4de53fe9c4d26b7c">More...</a><br /></td></tr>
<tr class="separator:a811da8587db802ee4de53fe9c4d26b7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82682656557db49caf9f7f0c0db9137f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#a82682656557db49caf9f7f0c0db9137f">operate_power</a> (mpq_t &amp;r, uint64_t p) noexcept</td></tr>
<tr class="memdesc:a82682656557db49caf9f7f0c0db9137f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Power operation.  <a href="namespacelal_1_1detail.html#a82682656557db49caf9f7f0c0db9137f">More...</a><br /></td></tr>
<tr class="separator:a82682656557db49caf9f7f0c0db9137f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac06bbc1aa13b66438da3a404b295ef3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#ac06bbc1aa13b66438da3a404b295ef3f">operate_power</a> (mpq_t &amp;r, const mpz_t &amp;p) noexcept</td></tr>
<tr class="memdesc:ac06bbc1aa13b66438da3a404b295ef3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Power operation.  <a href="namespacelal_1_1detail.html#ac06bbc1aa13b66438da3a404b295ef3f">More...</a><br /></td></tr>
<tr class="separator:ac06bbc1aa13b66438da3a404b295ef3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74a37d4a4d50e88991a229f5bfd0307a"><td class="memItemLeft" align="right" valign="top"><a id="a74a37d4a4d50e88991a229f5bfd0307a" name="a74a37d4a4d50e88991a229f5bfd0307a"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>mpz_bytes</b> (const mpz_t &amp;v) noexcept</td></tr>
<tr class="memdesc:a74a37d4a4d50e88991a229f5bfd0307a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the amount of bytes of a gmp's integer value. <br /></td></tr>
<tr class="separator:a74a37d4a4d50e88991a229f5bfd0307a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a968ddb05fafc9ff668ed947d506d29a1"><td class="memTemplParams" colspan="2">template&lt;class tree_t , std::enable_if_t&lt; std::is_base_of_v&lt; <a class="el" href="classlal_1_1graphs_1_1tree.html">graphs::tree</a>, tree_t &gt;, bool &gt;  = true&gt; </td></tr>
<tr class="memitem:a968ddb05fafc9ff668ed947d506d29a1"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a>, <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#a968ddb05fafc9ff668ed947d506d29a1">retrieve_centre</a> (const tree_t &amp;t, <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> X) noexcept</td></tr>
<tr class="memdesc:a968ddb05fafc9ff668ed947d506d29a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the centre of the connected component that has node <em>x</em>.  <a href="namespacelal_1_1detail.html#a968ddb05fafc9ff668ed947d506d29a1">More...</a><br /></td></tr>
<tr class="separator:a968ddb05fafc9ff668ed947d506d29a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53d74be21f492cfc19a875e6409dda6d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacelal_1_1detail.html#a47195c004957380992b21cdbb2b43cc9">centroid_results</a> mode, class tree_t , std::enable_if_t&lt; std::is_base_of_v&lt; <a class="el" href="classlal_1_1graphs_1_1tree.html">graphs::tree</a>, tree_t &gt;, bool &gt;  = true&gt; </td></tr>
<tr class="memitem:a53d74be21f492cfc19a875e6409dda6d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacelal_1_1detail.html#aefed716de4c6c3a2384f4403613d1d1b">conditional_list_t</a>&lt; <a class="el" href="structlal_1_1detail_1_1bool__sequence.html">bool_sequence</a>&lt; m1(mode), m2(mode), m3(mode), m4(mode) &gt;, <a class="el" href="structlal_1_1detail_1_1type__sequence.html">type_sequence</a>&lt; <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a>, std::pair&lt; <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">lal::node</a>, <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">lal::node</a> &gt;, std::pair&lt; std::pair&lt; <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">lal::node</a>, <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">lal::node</a> &gt;, <a class="el" href="structlal_1_1detail_1_1data__array.html">data_array</a>&lt; uint64_t &gt; &gt;, std::pair&lt; std::pair&lt; <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">lal::node</a>, <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">lal::node</a> &gt;, <a class="el" href="structlal_1_1detail_1_1data__array.html">data_array</a>&lt; <a class="el" href="structlal_1_1detail_1_1edge__size.html">edge_size</a> &gt; &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#a53d74be21f492cfc19a875e6409dda6d">find_centroidal_vertex</a> (const tree_t &amp;t, <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> x) noexcept</td></tr>
<tr class="memdesc:a53d74be21f492cfc19a875e6409dda6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the centroid of a tree.  <a href="namespacelal_1_1detail.html#a53d74be21f492cfc19a875e6409dda6d">More...</a><br /></td></tr>
<tr class="separator:a53d74be21f492cfc19a875e6409dda6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fd5e9f2690515fe4c713e0127e3e0bf"><td class="memTemplParams" colspan="2">template&lt;class tree_t , std::enable_if_t&lt; std::is_base_of_v&lt; <a class="el" href="classlal_1_1graphs_1_1tree.html">graphs::tree</a>, tree_t &gt;, bool &gt;  = true&gt; </td></tr>
<tr class="memitem:a6fd5e9f2690515fe4c713e0127e3e0bf"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a>, <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#a6fd5e9f2690515fe4c713e0127e3e0bf">centroidal_vertex_plus_adjacency_list</a> (const tree_t &amp;t, <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> x, std::vector&lt; std::vector&lt; <a class="el" href="structlal_1_1detail_1_1node__size.html">node_size</a> &gt; &gt; &amp;L) noexcept</td></tr>
<tr class="memdesc:a6fd5e9f2690515fe4c713e0127e3e0bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the centroid and the corresponding rooted adjacency list.  <a href="namespacelal_1_1detail.html#a6fd5e9f2690515fe4c713e0127e3e0bf">More...</a><br /></td></tr>
<tr class="separator:a6fd5e9f2690515fe4c713e0127e3e0bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25d097aefd29d279d75bae3b29c00a9c"><td class="memTemplParams" colspan="2">template&lt;class tree_t , std::enable_if_t&lt; std::is_base_of_v&lt; <a class="el" href="classlal_1_1graphs_1_1tree.html">graphs::tree</a>, tree_t &gt;, bool &gt;  = true&gt; </td></tr>
<tr class="memitem:a25d097aefd29d279d75bae3b29c00a9c"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a>, <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#a25d097aefd29d279d75bae3b29c00a9c">retrieve_centroid</a> (const tree_t &amp;t, const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> x) noexcept</td></tr>
<tr class="memdesc:a25d097aefd29d279d75bae3b29c00a9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the centroid of the connected component that has node <em>x</em>.  <a href="namespacelal_1_1detail.html#a25d097aefd29d279d75bae3b29c00a9c">More...</a><br /></td></tr>
<tr class="separator:a25d097aefd29d279d75bae3b29c00a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adae348ce62d716de5e5796448b4e97c6"><td class="memTemplParams" colspan="2">template&lt;class tree_t , std::enable_if_t&lt; std::is_base_of_v&lt; <a class="el" href="classlal_1_1graphs_1_1tree.html">graphs::tree</a>, tree_t &gt;, bool &gt;  = true&gt; </td></tr>
<tr class="memitem:adae348ce62d716de5e5796448b4e97c6"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a>, <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#adae348ce62d716de5e5796448b4e97c6">retrieve_centroid</a> (const tree_t &amp;t) noexcept</td></tr>
<tr class="memdesc:adae348ce62d716de5e5796448b4e97c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the centroid of the tree <em>t</em>.  <a href="namespacelal_1_1detail.html#adae348ce62d716de5e5796448b4e97c6">More...</a><br /></td></tr>
<tr class="separator:adae348ce62d716de5e5796448b4e97c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34526c181f7e86c1e94205fb12e899cb"><td class="memTemplParams" colspan="2">template&lt;class tree_t , std::enable_if_t&lt; std::is_base_of_v&lt; <a class="el" href="classlal_1_1graphs_1_1tree.html">graphs::tree</a>, tree_t &gt;, bool &gt;  = true&gt; </td></tr>
<tr class="memitem:a34526c181f7e86c1e94205fb12e899cb"><td class="memTemplItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#a34526c181f7e86c1e94205fb12e899cb">tree_diameter</a> (const tree_t &amp;t, <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> x) noexcept</td></tr>
<tr class="memdesc:a34526c181f7e86c1e94205fb12e899cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the diameter of a tree.  <a href="namespacelal_1_1detail.html#a34526c181f7e86c1e94205fb12e899cb">More...</a><br /></td></tr>
<tr class="separator:a34526c181f7e86c1e94205fb12e899cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2547121a9b242032eb4a4be0d318a7d5"><td class="memTemplParams" colspan="2">template&lt;class tree_t , std::enable_if_t&lt; std::is_base_of_v&lt; <a class="el" href="classlal_1_1graphs_1_1tree.html">graphs::tree</a>, tree_t &gt;, bool &gt;  = true&gt; </td></tr>
<tr class="memitem:a2547121a9b242032eb4a4be0d318a7d5"><td class="memTemplItemLeft" align="right" valign="top">char&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#a2547121a9b242032eb4a4be0d318a7d5">fast_non_iso</a> (const tree_t &amp;t1, const tree_t &amp;t2) noexcept</td></tr>
<tr class="memdesc:a2547121a9b242032eb4a4be0d318a7d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast tree non-isomorphism test.  <a href="namespacelal_1_1detail.html#a2547121a9b242032eb4a4be0d318a7d5">More...</a><br /></td></tr>
<tr class="separator:a2547121a9b242032eb4a4be0d318a7d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae099c00bbf83490409b4dfacdb4efde6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#ae099c00bbf83490409b4dfacdb4efde6">assign_name_and_keep</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;t, <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u, std::size_t idx, std::string *const aux_memory_for_names, std::string *const keep_name_of) noexcept</td></tr>
<tr class="memdesc:ae099c00bbf83490409b4dfacdb4efde6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns a name to node 'u', root of the current subtree.  <a href="namespacelal_1_1detail.html#ae099c00bbf83490409b4dfacdb4efde6">More...</a><br /></td></tr>
<tr class="separator:ae099c00bbf83490409b4dfacdb4efde6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9823742c3280224c7954665a51d2ada8"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail.html#a9823742c3280224c7954665a51d2ada8">assign_name</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;t, <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u, std::string *const names, std::size_t idx) noexcept</td></tr>
<tr class="memdesc:a9823742c3280224c7954665a51d2ada8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns a name to node 'u', root of the current subtree.  <a href="namespacelal_1_1detail.html#a9823742c3280224c7954665a51d2ada8">More...</a><br /></td></tr>
<tr class="separator:a9823742c3280224c7954665a51d2ada8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4724451a756fb81a06c1dedb88f395a0"><td class="memItemLeft" align="right" valign="top"><a id="a4724451a756fb81a06c1dedb88f395a0" name="a4724451a756fb81a06c1dedb88f395a0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>are_full_trees_isomorphic</b> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;t1, const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;t2) noexcept</td></tr>
<tr class="memdesc:a4724451a756fb81a06c1dedb88f395a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether two rooted trees are isomorphic or not. <br /></td></tr>
<tr class="separator:a4724451a756fb81a06c1dedb88f395a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aed9806774914e302211489b1e5e38769"><td class="memItemLeft" align="right" valign="top"><a id="aed9806774914e302211489b1e5e38769" name="aed9806774914e302211489b1e5e38769"></a>
constexpr std::array&lt; <a class="el" href="namespacelal_1_1graphs.html#a18d52542088507e2be6241759722835b">graphs::tree_type</a>, <a class="el" href="namespacelal_1_1graphs.html#a1895a9ed855ad1d85cd9510de714a732">graphs::__tree_type_size</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>array_of_tree_types</b></td></tr>
<tr class="memdesc:aed9806774914e302211489b1e5e38769"><td class="mdescLeft">&#160;</td><td class="mdescRight">The array of all types of trees. <br /></td></tr>
<tr class="separator:aed9806774914e302211489b1e5e38769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a868a82d80ccd62e025b131cacb598ee5"><td class="memItemLeft" align="right" valign="top"><a id="a868a82d80ccd62e025b131cacb598ee5" name="a868a82d80ccd62e025b131cacb598ee5"></a>
constexpr std::array&lt; <a class="el" href="namespacelal_1_1linarr.html#a3e8b744d4c81d3bb4463ec203f9199d6">linarr::syntactic_dependency_structure</a>, <a class="el" href="namespacelal_1_1linarr.html#a71f12918a0e2775e9a97181fddd1f7bc">linarr::__syntactic_dependency_structure_size</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>array_of_syntactic_dependency_structures</b></td></tr>
<tr class="memdesc:a868a82d80ccd62e025b131cacb598ee5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The array of all types of syntact dependency structures. <br /></td></tr>
<tr class="separator:a868a82d80ccd62e025b131cacb598ee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a061ab47fda03ab411321f87a56dd31cc"><td class="memTemplParams" colspan="2"><a id="a061ab47fda03ab411321f87a56dd31cc" name="a061ab47fda03ab411321f87a56dd31cc"></a>
template&lt;bool... conds&gt; </td></tr>
<tr class="memitem:a061ab47fda03ab411321f87a56dd31cc"><td class="memTemplItemLeft" align="right" valign="top">static constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>first_true_v</b> = <a class="el" href="structlal_1_1detail_1_1first__true.html">first_true</a>&lt;conds...&gt;::value</td></tr>
<tr class="memdesc:a061ab47fda03ab411321f87a56dd31cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shorthand for <a class="el" href="structlal_1_1detail_1_1first__true.html">first_true</a>. <br /></td></tr>
<tr class="separator:a061ab47fda03ab411321f87a56dd31cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1acf6acf0c665841481303603b6ddb02"><td class="memTemplParams" colspan="2"><a id="a1acf6acf0c665841481303603b6ddb02" name="a1acf6acf0c665841481303603b6ddb02"></a>
template&lt;typename Iterated_Type , typename Iterator &gt; </td></tr>
<tr class="memitem:a1acf6acf0c665841481303603b6ddb02"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_pointer_iterator_v</b></td></tr>
<tr class="memdesc:a1acf6acf0c665841481303603b6ddb02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shorthand for <a class="el" href="structlal_1_1detail_1_1is__pointer__iterator.html">is_pointer_iterator</a>. <br /></td></tr>
<tr class="separator:a1acf6acf0c665841481303603b6ddb02"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Detail namespace. </p>
<p >Most algorithms are included here. Unless you have a really good reason to use the algorithms in this namespace, please, refrain from doing so. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a47195c004957380992b21cdbb2b43cc9" name="a47195c004957380992b21cdbb2b43cc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47195c004957380992b21cdbb2b43cc9">&#9670;&#160;</a></span>centroid_results</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespacelal_1_1detail.html#a47195c004957380992b21cdbb2b43cc9">lal::detail::centroid_results</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The different types of results. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a47195c004957380992b21cdbb2b43cc9ab99249477c8f37e1ad46c4983716d39c" name="a47195c004957380992b21cdbb2b43cc9ab99249477c8f37e1ad46c4983716d39c"></a>only_one_centroidal&#160;</td><td class="fielddoc"><p >Returns only one centroidal vertex. No weights. </p>
</td></tr>
<tr><td class="fieldname"><a id="a47195c004957380992b21cdbb2b43cc9a9ef639b9182eadfee611fc58dd23f9d3" name="a47195c004957380992b21cdbb2b43cc9a9ef639b9182eadfee611fc58dd23f9d3"></a>full_centroid&#160;</td><td class="fielddoc"><p >Returns the full centroid of the tree. No weights. </p>
</td></tr>
<tr><td class="fieldname"><a id="a47195c004957380992b21cdbb2b43cc9ae6e2f4d15b78cfcbb5a70f39f0d9dda8" name="a47195c004957380992b21cdbb2b43cc9ae6e2f4d15b78cfcbb5a70f39f0d9dda8"></a>full_centroid_plus_subtree_sizes&#160;</td><td class="fielddoc"><p >Returns the full centroid of the tree. Also returns the weights. </p>
</td></tr>
<tr><td class="fieldname"><a id="a47195c004957380992b21cdbb2b43cc9a454774b2983a333885b75c8845707e38" name="a47195c004957380992b21cdbb2b43cc9a454774b2983a333885b75c8845707e38"></a>full_centroid_plus_edge_sizes&#160;</td><td class="fielddoc"><p >Returns the full centroid of the tree. Also returns the <a class="el" href="structlal_1_1detail_1_1edge__size.html" title="Struct used in many algorithms to sort edges according to some integer value.">edge_size</a> array. </p>
</td></tr>
</table>

</div>
</div>
<a id="ae7e27c62d46601d7b2c7b75cbfdeda85" name="ae7e27c62d46601d7b2c7b75cbfdeda85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7e27c62d46601d7b2c7b75cbfdeda85">&#9670;&#160;</a></span>linarr_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespacelal_1_1detail.html#ae7e27c62d46601d7b2c7b75cbfdeda85">lal::detail::linarr_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Type of arrangement. </p>
<p >Used to call functions that have arrangements as input parameters. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ae7e27c62d46601d7b2c7b75cbfdeda85aff483d1ff591898a9942916050d2ca3f" name="ae7e27c62d46601d7b2c7b75cbfdeda85aff483d1ff591898a9942916050d2ca3f"></a>identity&#160;</td><td class="fielddoc"><p >Identity arrangement. \(\pi(i)=i\). </p>
</td></tr>
<tr><td class="fieldname"><a id="ae7e27c62d46601d7b2c7b75cbfdeda85a78463cb21909f69c5bb59611db0b7575" name="ae7e27c62d46601d7b2c7b75cbfdeda85a78463cb21909f69c5bb59611db0b7575"></a>nonident&#160;</td><td class="fielddoc"><p >Non-identity arrangement. An arrangement that is not the identity. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a0c3f637b02ebf8c6b82b6098cfbc40ca" name="a0c3f637b02ebf8c6b82b6098cfbc40ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c3f637b02ebf8c6b82b6098cfbc40ca">&#9670;&#160;</a></span>alpha()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr uint64_t lal::detail::alpha </td>
          <td>(</td>
          <td class="paramtype">const int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t&#160;</td>
          <td class="paramname"><em>d1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t&#160;</td>
          <td class="paramname"><em>d2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Amount of crossings pairs of edges of given lengths. </p>
<p >Complexity: constant time. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of edges in the linear arrangement. </td></tr>
    <tr><td class="paramname">d1</td><td>Length of the first edge. </td></tr>
    <tr><td class="paramname">d2</td><td>Length of the second edge. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The amount of pairs of edges of lengths <em>d1</em> and <em>d2</em> respectively that can cross in a linear arrangement. </dd></dl>

</div>
</div>
<a id="a99e564e21a58d5a88f53503f71317136" name="a99e564e21a58d5a88f53503f71317136"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99e564e21a58d5a88f53503f71317136">&#9670;&#160;</a></span>append_adjacency_lists()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::detail::append_adjacency_lists </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacelal.html#aef91d923414879a998619e9c65181d1f">neighbourhood</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacelal.html#aef91d923414879a998619e9c65181d1f">neighbourhood</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append adjacency list 'source' to list 'target'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>List into which <em>source</em> will be appended to. </td></tr>
    <tr><td class="paramname">source</td><td>List to append to <em>target</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9823742c3280224c7954665a51d2ada8" name="a9823742c3280224c7954665a51d2ada8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9823742c3280224c7954665a51d2ada8">&#9670;&#160;</a></span>assign_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string lal::detail::assign_name </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a>&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *const&#160;</td>
          <td class="paramname"><em>names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns a name to node 'u', root of the current subtree. </p>
<p >For further details on the algorithm, see <a class="el" href="citelist.html#CITEREF_Aho1974a">[1]</a> for further details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input rooted tree </td></tr>
    <tr><td class="paramname">u</td><td>Root of the subtree whose name we want to calculate </td></tr>
    <tr><td class="paramname">names</td><td>An array of strings where the names are stored (as in a dynamic programming algorithm). The size of this array must be at least the number of vertices in the subtree of 't' rooted at 'u'. Actually, less memory suffices, but I don't know how much less: better be safe than sorry. </td></tr>
    <tr><td class="paramname">idx</td><td>A pointer to the position within <em>names</em> that will contain the name of the first child of 'u'. The position <em>names</em>[idx+1] will contain the name of the second child of 'u'. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The code for the subtree rooted at 'u'. </dd></dl>

</div>
</div>
<a id="ae099c00bbf83490409b4dfacdb4efde6" name="ae099c00bbf83490409b4dfacdb4efde6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae099c00bbf83490409b4dfacdb4efde6">&#9670;&#160;</a></span>assign_name_and_keep()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::detail::assign_name_and_keep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a>&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *const&#160;</td>
          <td class="paramname"><em>aux_memory_for_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *const&#160;</td>
          <td class="paramname"><em>keep_name_of</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns a name to node 'u', root of the current subtree. </p>
<p >This function stores the names of every node in the subtree rooted at 'u'. This is useful if we want to make lots of comparisons between subtrees</p>
<p >For further details on the algorithm, see <a class="el" href="citelist.html#CITEREF_Aho1974a">[1]</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input rooted tree </td></tr>
    <tr><td class="paramname">u</td><td>Root of the subtree whose name we want to calculate </td></tr>
    <tr><td class="paramname">idx</td><td>A pointer to the position within <em>names</em> that will contain the name of the first child of 'u'. The position <em>names</em>[idx+1] will contain the name of the second child of 'u'. </td></tr>
    <tr><td class="paramname">aux_memory_for_names</td><td>Auxiliary memory used to sort names of subtrees. </td></tr>
    <tr><td class="paramname">keep_name_of</td><td>An array of strings where the names are stored (as in a dynamic programming algorithm). The size of this array must be at least the number of vertices in the subtree of 't' rooted at 'u'. Actually, less memory suffices, but I don't know how much less: better be safe than sorry. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad403e3fe175466a9544301b3d679eb9e" name="ad403e3fe175466a9544301b3d679eb9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad403e3fe175466a9544301b3d679eb9e">&#9670;&#160;</a></span>beta()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr uint64_t lal::detail::beta </td>
          <td>(</td>
          <td class="paramtype">const int64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t&#160;</td>
          <td class="paramname"><em>d1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t&#160;</td>
          <td class="paramname"><em>d2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Amount of pairs of edges of given lengths. </p>
<p >Complexity: constant time. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of edges in the linear arrangement. </td></tr>
    <tr><td class="paramname">d1</td><td>Length of the first edge. </td></tr>
    <tr><td class="paramname">d2</td><td>Length of the second edge. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The amount of pairs of edges of lengths <em>d1</em> and <em>d2</em> respectively that can cross in a linear arrangement. </dd></dl>

</div>
</div>
<a id="a3b8f436879c464b089f1f2a67e507ffb" name="a3b8f436879c464b089f1f2a67e507ffb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b8f436879c464b089f1f2a67e507ffb">&#9670;&#160;</a></span>calculate_bidirectional_sizes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tree_t , typename iterator_t , std::enable_if_t&lt; std::is_base_of_v&lt; <a class="el" href="classlal_1_1graphs_1_1tree.html">graphs::tree</a>, tree_t &gt; and <a class="el" href="namespacelal_1_1detail.html#a1acf6acf0c665841481303603b6ddb02">is_pointer_iterator_v</a>&lt; <a class="el" href="structlal_1_1detail_1_1edge__size.html">edge_size</a>, iterator_t &gt;, bool &gt;  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lal::detail::calculate_bidirectional_sizes </td>
          <td>(</td>
          <td class="paramtype">const tree_t &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a>&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a>&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterator_t &amp;&#160;</td>
          <td class="paramname"><em>it</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the values \(s(u,v)\) for the edges \((s,t)\) reachable from \(v\) in the subtree \(T^u_v\). </p>
<p >This function calculates the 'map' relating each edge \((u, v)\) with the size of the subtree rooted at \(v\) with respect to the hypothetical root \(u\). This is an implementation of the algorithm described in <a class="el" href="citelist.html#CITEREF_Hochberg2003a">[24]</a> (proof of lemma 8 (page 63), and the beginning of section 6 (page 65)).</p>
<p >Notice that the values are not stored in an actual map (std::map, or similar), but in a vector. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">iterated_t</td><td>The type that stores the sizes. </td></tr>
    <tr><td class="paramname">iterator_t</td><td>The type of the iterator on a container containing values of type iterated_t. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input tree. </td></tr>
    <tr><td class="paramname">n</td><td>Size of the connected component to which edge \((u,v)\) belongs to. </td></tr>
    <tr><td class="paramname">u</td><td>First vertex of the edge. </td></tr>
    <tr><td class="paramname">v</td><td>Second vertex of the edge. </td></tr>
    <tr><td class="paramname">it</td><td>An iterator to the container that holds the size values. Such container must have size equal to twice the number of edges in the connected component of <em>u</em> and <em>v</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Vertices <em>u</em> and <em>v</em> belong to the same connected component. </dd></dl>

</div>
</div>
<a id="a332f440b66ce4e8dc243706901575023" name="a332f440b66ce4e8dc243706901575023"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a332f440b66ce4e8dc243706901575023">&#9670;&#160;</a></span>calculate_bidirectional_sizes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tree_t , typename iterator_t , std::enable_if_t&lt; std::is_base_of_v&lt; <a class="el" href="classlal_1_1graphs_1_1tree.html">graphs::tree</a>, tree_t &gt; and <a class="el" href="namespacelal_1_1detail.html#a1acf6acf0c665841481303603b6ddb02">is_pointer_iterator_v</a>&lt; <a class="el" href="structlal_1_1detail_1_1edge__size.html">edge_size</a>, iterator_t &gt;, bool &gt;  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::detail::calculate_bidirectional_sizes </td>
          <td>(</td>
          <td class="paramtype">const tree_t &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterator_t&#160;</td>
          <td class="paramname"><em>it</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the values \(s_u(v)\) for the edges \((u,v)\) reachable from vertex <em>x</em>. </p>
<p >Calculates the values \(s_u(v)\) for all edges \((u,v)\) in linear time. This is an implementation of the algorithm described in <a class="el" href="citelist.html#CITEREF_Hochberg2003a">[24]</a> (proof of lemma 8 (page 63), and the beginning of section 6 (page 65)).</p>
<p >For any edge \((u,v)\) let \(T^u\) be the tree \(T\) rooted at \(u\). The value \(s_u(v)\) is the size of the subtree of \(T^u\) rooted at \(v\), i.e., \(s_u(v)=|V(T^u_v)|\).</p>
<p >Example of usage (mind the vector! its initial size is \(2*m\)).</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> free_tree t = ... ;</div>
<div class="line">vector&lt;pair&lt;edge,uint64_t&gt;&gt; sizes_edges(2*t.get_num_edges());</div>
<div class="line"><span class="keyword">auto</span> it = sizes_edges.begin();</div>
<div class="line"><a class="code hl_function" href="namespacelal_1_1detail.html#a3b8f436879c464b089f1f2a67e507ffb">detail::calculate_bidirectional_sizes</a>(t, t.get_num_nodes(), 0, it);</div>
<div class="ttc" id="anamespacelal_1_1detail_html_a3b8f436879c464b089f1f2a67e507ffb"><div class="ttname"><a href="namespacelal_1_1detail.html#a3b8f436879c464b089f1f2a67e507ffb">lal::detail::calculate_bidirectional_sizes</a></div><div class="ttdeci">uint64_t calculate_bidirectional_sizes(const tree_t &amp;t, const uint64_t n, const node u, const node v, iterator_t &amp;it) noexcept</div><div class="ttdoc">Calculates the values  for the edges  reachable from  in the subtree .</div><div class="ttdef"><b>Definition:</b> size_subtrees.hpp:158</div></div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">tree_t</td><td>Type of the tree. Must be 'rooted_tree' or 'free_tree'. </td></tr>
    <tr><td class="paramname">iterated_t</td><td>The type that stores the sizes. </td></tr>
    <tr><td class="paramname">iterator_t</td><td>The type of the iterator on a container containing values of type iterated_t. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input tree </td></tr>
    <tr><td class="paramname">n</td><td>Number of nodes in the connected component of vertex <em>x</em> </td></tr>
    <tr><td class="paramname">x</td><td>Node of the connected component for which we want to calculate the bidirectional sizes </td></tr>
    <tr><td class="paramname">it</td><td>An iterator to the container that holds the size values. Such container must have size equal to twice the number of edges in the connected component of <em>u</em> and <em>v</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa20b450ba80542fb87c883a99c5d63b2" name="aa20b450ba80542fb87c883a99c5d63b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa20b450ba80542fb87c883a99c5d63b2">&#9670;&#160;</a></span>calculate_dependencies_and_span()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class depflux , class arrangement_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::detail::calculate_dependencies_and_span </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arrangement_t &amp;&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; <a class="el" href="namespacelal.html#af8e55c3f8923a4ba55e8117a20a75b4a">edge_t</a>, uint64_t &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>edge_with_max_pos_at</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelal.html#a5c3f34575ec933a44ed7b6d81e8c75f6">position</a>&#160;</td>
          <td class="paramname"><em>cur_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; depflux &gt; &amp;&#160;</td>
          <td class="paramname"><em>flux</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacelal.html#a5969ec7ecc85697ebb9ec0ace78fbcab">edge</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cur_deps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the dependencies and their span. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">arrangement_t</td><td>Type of arrangement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">t</td><td>Input tree. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">arr</td><td>Input linear arrangement. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">edge_with_max_pos_at</td><td></td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cur_pos</td><td>Current position in the arrangement for which we calculate the dependencies. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">flux</td><td>The flux at this position. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cur_deps</td><td>The dependencies crossing this position. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a38e173ec404e2222f2d4b5a20dcdfe8b" name="a38e173ec404e2222f2d4b5a20dcdfe8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38e173ec404e2222f2d4b5a20dcdfe8b">&#9670;&#160;</a></span>calculate_weight()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lal::detail::calculate_weight </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacelal.html#a5969ec7ecc85697ebb9ec0ace78fbcab">edge</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dependencies</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;&#160;</td>
          <td class="paramname"><em>ug</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the weight of a set of dependencies in a flux. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dependencies</td><td>Input dependencies. </td></tr>
    <tr><td class="paramname">ug</td><td>Input undirected graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size of the largest subset of independent dependencies. </dd></dl>

</div>
</div>
<a id="a6fd5e9f2690515fe4c713e0127e3e0bf" name="a6fd5e9f2690515fe4c713e0127e3e0bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fd5e9f2690515fe4c713e0127e3e0bf">&#9670;&#160;</a></span>centroidal_vertex_plus_adjacency_list()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tree_t , std::enable_if_t&lt; std::is_base_of_v&lt; <a class="el" href="classlal_1_1graphs_1_1tree.html">graphs::tree</a>, tree_t &gt;, bool &gt;  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a>, <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> &gt; lal::detail::centroidal_vertex_plus_adjacency_list </td>
          <td>(</td>
          <td class="paramtype">const tree_t &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="structlal_1_1detail_1_1node__size.html">node_size</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the centroid and the corresponding rooted adjacency list. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">t</td><td>Treer type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">t</td><td>Input tree. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">x</td><td>Node belonging to a connected component whose centroid we want. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">L</td><td>Adjacency list-like data structure. \(L[u]\) is a list of pairs \((v, s_u(v))\) where \(v\) is a neighbour (with respect to a fictional root taken to be a centroidal vertex of the tree) of \(u\) and \(n_u(v)=|V(T^u_v)|\) is the size of the subtree \(T^u_v\) in vertices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb3b1129ae180b2186dd38f82b8091a8" name="acb3b1129ae180b2186dd38f82b8091a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb3b1129ae180b2186dd38f82b8091a8">&#9670;&#160;</a></span>check_correctness_treebank()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool decide&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; decide, bool, std::vector&lt; <a class="el" href="classlal_1_1io_1_1report__treebank__file.html">io::report_treebank_file</a> &gt; &gt; lal::detail::check_correctness_treebank </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>treebank_filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find errors in a treebank file. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">decide</td><td>When true, return a value as soon as an error is found. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">treebank_filename</td><td>Name of the treebank file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Boolean if <em>decide</em> is true, a list of errors if otherwise. </dd></dl>

</div>
</div>
<a id="ab9fc8ab44169e4da6445f31598703572" name="ab9fc8ab44169e4da6445f31598703572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9fc8ab44169e4da6445f31598703572">&#9670;&#160;</a></span>check_correctness_treebank_collection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool decide&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; decide, bool, std::vector&lt; <a class="el" href="classlal_1_1io_1_1report__treebank__collection.html">io::report_treebank_collection</a> &gt; &gt; lal::detail::check_correctness_treebank_collection </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>main_file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n_threads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find errors in a treebank collection. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">decide</td><td>When true, return a value as soon as an error is found. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">main_file_name</td><td>Name of the collection's main file. </td></tr>
    <tr><td class="paramname">n_threads</td><td>Number of threads that this function can use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Boolean if <em>decide</em> is true, a list of errors if otherwise. </dd></dl>

</div>
</div>
<a id="ab361b7ab281d4d1e27ac91526f4ce28f" name="ab361b7ab281d4d1e27ac91526f4ce28f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab361b7ab281d4d1e27ac91526f4ce28f">&#9670;&#160;</a></span>classify_tree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tree_t , std::enable_if_t&lt; std::is_base_of_v&lt; <a class="el" href="classlal_1_1graphs_1_1tree.html">graphs::tree</a>, tree_t &gt;, bool &gt;  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::detail::classify_tree </td>
          <td>(</td>
          <td class="paramtype">const tree_t &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; bool, <a class="el" href="namespacelal_1_1graphs.html#a1895a9ed855ad1d85cd9510de714a732">graphs::__tree_type_size</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Classify a tree into one of the types <a class="el" href="namespacelal_1_1graphs.html#a18d52542088507e2be6241759722835b">lal::graphs::tree_type</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">tree_t</td><td>Type of tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">t</td><td>Input tree. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">array</td><td>A set of bits (or flags) each indicating whether or not <em>t</em> is of a certain tree type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2547121a9b242032eb4a4be0d318a7d5" name="a2547121a9b242032eb4a4be0d318a7d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2547121a9b242032eb4a4be0d318a7d5">&#9670;&#160;</a></span>fast_non_iso()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tree_t , std::enable_if_t&lt; std::is_base_of_v&lt; <a class="el" href="classlal_1_1graphs_1_1tree.html">graphs::tree</a>, tree_t &gt;, bool &gt;  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char lal::detail::fast_non_iso </td>
          <td>(</td>
          <td class="paramtype">const tree_t &amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tree_t &amp;&#160;</td>
          <td class="paramname"><em>t2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fast tree non-isomorphism test. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">tree_t</td><td>Tree type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t1</td><td>One tree. </td></tr>
    <tr><td class="paramname">t2</td><td>Another tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the input trees are, might be, or are not isomorphic. </dd>
<dd>
0 if the trees ARE isomorphic </dd>
<dd>
1 if the trees ARE NOT isomorphic:<ul>
<li>number of vertices do not coincide,</li>
<li>number of leaves do not coincide,</li>
<li>second moment of degree do not coincide,</li>
<li>maximum vertex degrees do not coincide, </li>
</ul>
</dd>
<dd>
2 if the trees MIGHT BE isomorphic </dd></dl>

</div>
</div>
<a id="a53d74be21f492cfc19a875e6409dda6d" name="a53d74be21f492cfc19a875e6409dda6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53d74be21f492cfc19a875e6409dda6d">&#9670;&#160;</a></span>find_centroidal_vertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacelal_1_1detail.html#a47195c004957380992b21cdbb2b43cc9">centroid_results</a> mode, class tree_t , std::enable_if_t&lt; std::is_base_of_v&lt; <a class="el" href="classlal_1_1graphs_1_1tree.html">graphs::tree</a>, tree_t &gt;, bool &gt;  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacelal_1_1detail.html#aefed716de4c6c3a2384f4403613d1d1b">conditional_list_t</a>&lt; <a class="el" href="structlal_1_1detail_1_1bool__sequence.html">bool_sequence</a>&lt; m1(mode), m2(mode), m3(mode), m4(mode) &gt;, <a class="el" href="structlal_1_1detail_1_1type__sequence.html">type_sequence</a>&lt; <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a>, std::pair&lt; <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">lal::node</a>, <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">lal::node</a> &gt;, std::pair&lt; std::pair&lt; <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">lal::node</a>, <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">lal::node</a> &gt;, <a class="el" href="structlal_1_1detail_1_1data__array.html">data_array</a>&lt; uint64_t &gt; &gt;, std::pair&lt; std::pair&lt; <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">lal::node</a>, <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">lal::node</a> &gt;, <a class="el" href="structlal_1_1detail_1_1data__array.html">data_array</a>&lt; <a class="el" href="structlal_1_1detail_1_1edge__size.html">edge_size</a> &gt; &gt; &gt; &gt; lal::detail::find_centroidal_vertex </td>
          <td>(</td>
          <td class="paramtype">const tree_t &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a>&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the centroid of a tree. </p>
<p >See <a class="el" href="LAL_concepts.html#LAL_concepts__centre_centroid">Centre and centroid of a tree</a> for details on what the centroid of a tree is.</p>
<p >If subtree sizes are to be returned, they come in an array of size the number of vertices of the tree.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">mode</td><td>Indicates the value to be returned by this function. If:<ul>
<li>mode == <a class="el" href="namespacelal_1_1detail.html#a47195c004957380992b21cdbb2b43cc9ab99249477c8f37e1ad46c4983716d39c">centroid_results::only_one_centroidal</a>, the result of the function is a node.</li>
<li>mode == <a class="el" href="namespacelal_1_1detail.html#a47195c004957380992b21cdbb2b43cc9a9ef639b9182eadfee611fc58dd23f9d3">centroid_results::full_centroid</a>, the result of the function is a pair of (possibly) two nodes. The second node may have an invalid value, indicating that the tree has only one centroidal vertex.</li>
<li>mode == <a class="el" href="namespacelal_1_1detail.html#a47195c004957380992b21cdbb2b43cc9ae6e2f4d15b78cfcbb5a70f39f0d9dda8">centroid_results::full_centroid_plus_subtree_sizes</a>, the result of the function is a pair of (possibly) two nodes and the sizes of all the subtrees with respect to the first centroidal node in the pair.</li>
<li>mode == <a class="el" href="namespacelal_1_1detail.html#a47195c004957380992b21cdbb2b43cc9a454774b2983a333885b75c8845707e38">centroid_results::full_centroid_plus_edge_sizes</a>, the result of the function is a pair of (possibly) two nodes and an array of the form \((u,v, s(u,v))\) for all directed edges \((u,v)\) that point away from the first centroidal node in the pair. </li>
</ul>
</td></tr>
    <tr><td class="paramname">tree_t</td><td>Type of tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input tree. </td></tr>
    <tr><td class="paramname">x</td><td>Node belonging to a connected component whose centroid we want. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa996c0eb5455d4f727cc3b5cada84ffa" name="aa996c0eb5455d4f727cc3b5cada84ffa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa996c0eb5455d4f727cc3b5cada84ffa">&#9670;&#160;</a></span>find_cycle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::detail::find_cycle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a>&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *const __restrict__&#160;</td>
          <td class="paramname"><em>visited</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *const __restrict__&#160;</td>
          <td class="paramname"><em>in_stack</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if, and only if, the graph has cycles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">u</td><td>Node of the directed graph </td></tr>
    <tr><td class="paramname">visited</td><td>For each node, has it been visited? </td></tr>
    <tr><td class="paramname">in_stack</td><td>For each node, is it in the recursion stack? </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6f57039e53dcd5976c7397a439b3f7ee" name="a6f57039e53dcd5976c7397a439b3f7ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f57039e53dcd5976c7397a439b3f7ee">&#9670;&#160;</a></span>find_errors() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool decide&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; decide, bool, std::vector&lt; <a class="el" href="classlal_1_1io_1_1report__treebank__file.html">io::report_treebank_file</a> &gt; &gt; lal::detail::find_errors </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#a2eb5b7f5b50ff908a7a67889a9ea744d">head_vector</a> &amp;&#160;</td>
          <td class="paramname"><em>hv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find errors in a head vector. </p>
<p >The head vector may correspond to the contents of a line in a treebank file. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">decide</td><td>When true, return a value as soon as an error is found. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hv</td><td>Input head vector. </td></tr>
    <tr><td class="paramname">line</td><td>Line number of the treebank, if appropriate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Boolean if <em>decide</em> is true, a list of errors if otherwise. </dd></dl>

</div>
</div>
<a id="ab50dcafac1d535062aab1c8f46e27b35" name="ab50dcafac1d535062aab1c8f46e27b35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab50dcafac1d535062aab1c8f46e27b35">&#9670;&#160;</a></span>find_errors() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool decide&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; decide, bool, std::vector&lt; <a class="el" href="classlal_1_1io_1_1report__treebank__file.html">io::report_treebank_file</a> &gt; &gt; lal::detail::find_errors </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>current_line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find errors in a line of a treebank. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">decide</td><td>When true, return a value as soon as an error is found. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">current_line</td><td>The line being analyzed. </td></tr>
    <tr><td class="paramname">line</td><td>Line number of the treebank. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Boolean if <em>decide</em> is true, a list of errors if otherwise. </dd></dl>

</div>
</div>
<a id="aaa0095a6495c62a6dcdec7319e82b5ea" name="aaa0095a6495c62a6dcdec7319e82b5ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa0095a6495c62a6dcdec7319e82b5ea">&#9670;&#160;</a></span>from_edge_list_to_graph()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class graph_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">graph_t lal::detail::from_edge_list_to_graph </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacelal.html#a5969ec7ecc85697ebb9ec0ace78fbcab">edge</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>edge_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>normalise</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts an edge list into a graph. </p>
<p >An edge list is a list of pairs of indices, each index in the pair being different and in \([0,n-1]\)., where \(n\) is the number of vertices of the tree.</p>
<p >Methods <a class="el" href="namespacelal_1_1io.html#a96f4f6a65fa430f95a84b60d01169178">lal::io::read_edge_list</a> read an edge list from a file in disk. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edge_list</td><td>An edge list. </td></tr>
    <tr><td class="paramname">normalise</td><td>Should the graph be normalised? </td></tr>
    <tr><td class="paramname">check</td><td>In case the graph is not to be normalised, should we check whether it is nor not? </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html" title="Rooted tree graph class.">lal::graphs::rooted_tree</a> obtained from the head vector. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>No edge in the list is repeated. </dd></dl>

</div>
</div>
<a id="a4600371144fff09b6ad77aa1feb6d13a" name="a4600371144fff09b6ad77aa1feb6d13a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4600371144fff09b6ad77aa1feb6d13a">&#9670;&#160;</a></span>from_head_vector_to_tree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tree_t , bool is_rooted = std::is_base_of_v&lt;graphs::rooted_tree, tree_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; is_rooted, <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a>, std::pair&lt; <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a>, <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> &gt; &gt; lal::detail::from_head_vector_to_tree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#a2eb5b7f5b50ff908a7a67889a9ea744d">head_vector</a> &amp;&#160;</td>
          <td class="paramname"><em>hv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>normalise</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a head vector into a tree. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">tree_t</td><td>Type of input tree </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hv</td><td>Input head vector. </td></tr>
    <tr><td class="paramname">normalise</td><td>Normalise the resulting tree. </td></tr>
    <tr><td class="paramname">check</td><td>Check whether the constructed tree is normalised. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">lal::graphs::rooted_tree</a> or a pair of <a class="el" href="classlal_1_1graphs_1_1free__tree.html">lal::graphs::free_tree</a> and the root encoded in the head vector. </dd></dl>

</div>
</div>
<a id="ab530db874bc4a1c9e65a8984742350a8" name="ab530db874bc4a1c9e65a8984742350a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab530db874bc4a1c9e65a8984742350a8">&#9670;&#160;</a></span>from_tree_to_head_vector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacelal_1_1detail.html#ae7e27c62d46601d7b2c7b75cbfdeda85">detail::linarr_type</a> arr_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacelal.html#a2eb5b7f5b50ff908a7a67889a9ea744d">head_vector</a> lal::detail::from_tree_to_head_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlal_1_1detail_1_1linarr__wrapper.html">detail::linarr_wrapper</a>&lt; arr_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a>&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the head vector representation of a tree. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">arr_type</td><td>Type of arrangement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input free tree. </td></tr>
    <tr><td class="paramname">r</td><td>Root of the tree. </td></tr>
    <tr><td class="paramname">arr</td><td>Linear arrangement of the vertices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A head vector </dd></dl>

</div>
</div>
<a id="abb17951c3b57fdde267388a5f3e1a91c" name="abb17951c3b57fdde267388a5f3e1a91c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb17951c3b57fdde267388a5f3e1a91c">&#9670;&#160;</a></span>from_tree_to_head_vector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacelal_1_1detail.html#ae7e27c62d46601d7b2c7b75cbfdeda85">detail::linarr_type</a> arr_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacelal.html#a2eb5b7f5b50ff908a7a67889a9ea744d">head_vector</a> lal::detail::from_tree_to_head_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlal_1_1detail_1_1linarr__wrapper.html">detail::linarr_wrapper</a>&lt; arr_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>arr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the head vector representation of a tree. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">arr_type</td><td>Type of arrangement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input rooted tree. </td></tr>
    <tr><td class="paramname">arr</td><td>Linear arrangement of the vertices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A head vector encoding the tree. </dd></dl>

</div>
</div>
<a id="a6380645d003f5db7d59f3547401002a7" name="a6380645d003f5db7d59f3547401002a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6380645d003f5db7d59f3547401002a7">&#9670;&#160;</a></span>get_bool_neighbours()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class graph_t , typename char_type , std::enable_if_t&lt; std::is_base_of_v&lt; <a class="el" href="classlal_1_1graphs_1_1graph.html">graphs::graph</a>, graph_t &gt; &amp;&amp;std::is_integral_v&lt; char_type &gt;, bool &gt;  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::detail::get_bool_neighbours </td>
          <td>(</td>
          <td class="paramtype">const graph_t &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a>&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char_type *const&#160;</td>
          <td class="paramname"><em>neighs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the neighbours of a node in an undirected graph as a list of 0-1 values. </p>
<p >Sets to 1 the positions in <em>neighs</em> that correspond to the nodes neighours of <em>u</em>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">u</td><td>Input node. </td></tr>
    <tr><td class="paramname">neighs</td><td>0-1 list of neighbours of <em>u</em> in <em>g</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The contents of <em>neighs</em> must be all 0 (or false). </dd></dl>

</div>
</div>
<a id="a30ff5eb84d0bde7f88cf0762dcd4effe" name="a30ff5eb84d0bde7f88cf0762dcd4effe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30ff5eb84d0bde7f88cf0762dcd4effe">&#9670;&#160;</a></span>get_edges_subtree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool get_subsizes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; <a class="el" href="namespacelal.html#a5969ec7ecc85697ebb9ec0ace78fbcab">edge</a> &gt;, uint64_t * &gt; lal::detail::get_edges_subtree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a>&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>relabel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the edges of a subtree. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">get_subsizes</td><td>Should the result also keep the sizes of the subtrees? </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>Input rooted tree. </td></tr>
    <tr><td class="paramname">u</td><td>Root of the subtree. </td></tr>
    <tr><td class="paramname">relabel</td><td>Relabel the vertices? If so, vertex 'u' is relabelled to 0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair consisting of the list of edges and, optionally, a raw pointer to memory containing the sizes of the subtrees. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The tree is a valid rooted tree. </dd>
<dd>
The tree has vertex 'u'. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The function has NO ownership of the raw pointer returned in the pair. </dd>
<dd>
The pointer returned is not nullptr only when T.size_subtrees_valid() AND the boolean parameter sizes are BOTH true. </dd></dl>

</div>
</div>
<a id="a07c5f3a005c23b6fb759e7bef0dc8053" name="a07c5f3a005c23b6fb759e7bef0dc8053"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07c5f3a005c23b6fb759e7bef0dc8053">&#9670;&#160;</a></span>get_size_subtrees() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tree_t , std::enable_if_t&lt; std::is_base_of_v&lt; <a class="el" href="classlal_1_1graphs_1_1tree.html">graphs::tree</a>, tree_t &gt;, bool &gt;  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::detail::get_size_subtrees </td>
          <td>(</td>
          <td class="paramtype">const tree_t &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a>&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a>&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *const&#160;</td>
          <td class="paramname"><em>sizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the size of every subtree of the tree <em>t</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input tree. </td></tr>
    <tr><td class="paramname">u</td><td>Parent node (the first call should be an invalid value (e.g., n+1)). </td></tr>
    <tr><td class="paramname">v</td><td>Next node in the exploration of the tree. </td></tr>
    <tr><td class="paramname">sizes</td><td>The size of the subtree rooted at every reachable node from <em>r</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Parameter <em>sizes</em> has size the number of vertices. </dd></dl>

</div>
</div>
<a id="a7228078ded7f5e5aaab16cbc64a86284" name="a7228078ded7f5e5aaab16cbc64a86284"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7228078ded7f5e5aaab16cbc64a86284">&#9670;&#160;</a></span>get_size_subtrees() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tree_t , std::enable_if_t&lt; std::is_base_of_v&lt; <a class="el" href="classlal_1_1graphs_1_1tree.html">graphs::tree</a>, tree_t &gt;, bool &gt;  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::detail::get_size_subtrees </td>
          <td>(</td>
          <td class="paramtype">const tree_t &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a>&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *const&#160;</td>
          <td class="paramname"><em>sizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the size of every subtree of tree <em>t</em>. </p>
<p >The method starts calculating the sizes at node <em>r</em>. Since rooted trees have directed edges, starting at a node different from the tree's root may not calculate every subtree's size. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input rooted tree. </td></tr>
    <tr><td class="paramname">r</td><td>Start calculating sizes of subtrees at this node. </td></tr>
    <tr><td class="paramname">sizes</td><td>The size of the subtree rooted at every reachable node from <em>r</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Parameter <em>sizes</em> has size the number of vertices. </dd></dl>

</div>
</div>
<a id="ad493ddcc9165c55d4b14b228da5cdc4d" name="ad493ddcc9165c55d4b14b228da5cdc4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad493ddcc9165c55d4b14b228da5cdc4d">&#9670;&#160;</a></span>has_directed_cycles() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::detail::has_directed_cycles </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if, and only if, the graph has DIRECTED cycles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the graph has cycles or not. </dd></dl>

</div>
</div>
<a id="aa89ef322801fbacd0782763afb9c5f3a" name="aa89ef322801fbacd0782763afb9c5f3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa89ef322801fbacd0782763afb9c5f3a">&#9670;&#160;</a></span>has_directed_cycles() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::detail::has_directed_cycles </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *const __restrict__&#160;</td>
          <td class="paramname"><em>vis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *const __restrict__&#160;</td>
          <td class="paramname"><em>in_stack</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if, and only if, the graph has <em>DIRECTED</em> cycles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">vis</td><td>Array of size 'n', where 'n' is the number of vertices of 'g'. </td></tr>
    <tr><td class="paramname">in_stack</td><td>Array of size 'n', where 'n' is the number of vertices of 'g'. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the graph has cycles or not. </dd></dl>

</div>
</div>
<a id="af38edbbd2619cd3b319c1a54ce0638ed" name="af38edbbd2619cd3b319c1a54ce0638ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af38edbbd2619cd3b319c1a54ce0638ed">&#9670;&#160;</a></span>has_undirected_cycles() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class graph_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::detail::has_undirected_cycles </td>
          <td>(</td>
          <td class="paramtype">const graph_t &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if, and only if, the graph has UNDIRECTED cycles. </p>
<p >In case the input graph is a directed graph, reverse edges are considered. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">graph_t</td><td>Type of graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the graph has cycles or not. </dd></dl>

</div>
</div>
<a id="aac1d5fb0c4578d6be926acf180d657c4" name="aac1d5fb0c4578d6be926acf180d657c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac1d5fb0c4578d6be926acf180d657c4">&#9670;&#160;</a></span>has_undirected_cycles() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class graph_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::detail::has_undirected_cycles </td>
          <td>(</td>
          <td class="paramtype">const graph_t &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlal_1_1detail_1_1BFS.html">BFS</a>&lt; graph_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>bfs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if, and only if, the graph has UNDIRECTED cycles. </p>
<p >In case the input graph is a directed graph, reverse edges are considered. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">graph_t</td><td>Type of graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">bfs</td><td>Breadth-First Search object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the graph has cycles or not. </dd></dl>

</div>
</div>
<a id="ace97a861f8ce972d844103dd12a2af62" name="ace97a861f8ce972d844103dd12a2af62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace97a861f8ce972d844103dd12a2af62">&#9670;&#160;</a></span>head_initial()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename result_t , class arrangement_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">result_t lal::detail::head_initial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arrangement_t &amp;&#160;</td>
          <td class="paramname"><em>arr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Proposition of right branching edges in a directed graph. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">result_t</td><td>Type of return value. </td></tr>
    <tr><td class="paramname">arrangement_t</td><td>Type of arrangement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input directed graph. </td></tr>
    <tr><td class="paramname">arr</td><td>Input linear arrangement. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a58af58031ebc33bbfb5dfcd8f798ebf4" name="a58af58031ebc33bbfb5dfcd8f798ebf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58af58031ebc33bbfb5dfcd8f798ebf4">&#9670;&#160;</a></span>is_graph_a_tree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class graph_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::detail::is_graph_a_tree </td>
          <td>(</td>
          <td class="paramtype">const graph_t &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the input graph a tree? </p>
<p >By definition, an undirected graph is a tree if it does not contain cycles and has one single connected component. Note that isloated nodes count as single connected components. Directed graphs are allowed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if, and only if, the graph is a tree. </dd></dl>

</div>
</div>
<a id="a2ed32b72077e3f6f6119b321084d7ed6" name="a2ed32b72077e3f6f6119b321084d7ed6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ed32b72077e3f6f6119b321084d7ed6">&#9670;&#160;</a></span>is_n_C_brute_force_lesseq_than() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class graph_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lal::detail::is_n_C_brute_force_lesseq_than </td>
          <td>(</td>
          <td class="paramtype">const graph_t &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>upper_bound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the number of crossings is less than a given constant. </p>
<p >Given a graph \(G\) and a linear arrangements \(\pi\) of its nodes, returns the number of edge crossings \(C_{\pi}(G)\) if it is less than or equal to the given upper bound constant \(u\). In case the number of crossings is greater, returns a value strictly larger than the upper bound. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">graph_t</td><td>Type of graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arr</td><td>Linear arrangement of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
    <tr><td class="paramname">upper_bound</td><td>Constant (upper bound). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of crossings \(C\) if said number is less than or equal to the upper bound. The function returns a value strictly larger than the upper bound if otherwise. </dd></dl>

</div>
</div>
<a id="a52af8ab2c0352a408cce9e05de472e88" name="a52af8ab2c0352a408cce9e05de472e88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52af8ab2c0352a408cce9e05de472e88">&#9670;&#160;</a></span>is_n_C_brute_force_lesseq_than() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class graph_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; uint64_t &gt; lal::detail::is_n_C_brute_force_lesseq_than </td>
          <td>(</td>
          <td class="paramtype">const graph_t &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>arrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>upper_bounds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the number of crossings is less than a given constant. </p>
<p >Given a graph \(G\) and a linear arrangements \(\pi\) of its nodes, returns the number of edge crossings \(C_{\pi}(G)\) if it is less than or equal to the given upper bound constant \(u\). In case the number of crossings is greater, returns a value strictly larger than the upper bound.</p>
<p >This is applied to every linear arrangement in <em>pi</em>. To each arrangement corresponds only one upper bound. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">graph_t</td><td>Type of graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arrs</td><td>List of \(k\) linear arrangements of the nodes \(\Pi = \{\pi_i\}_{i=1}^k\). When one is omitted, \(\pi_I\) is used. </td></tr>
    <tr><td class="paramname">upper_bounds</td><td>List of constants (each an upper bound). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of crossings \(C\) if said number is less than or equal to the upper bound. The function returns a value strictly larger than the upper bound if otherwise. </dd></dl>

</div>
</div>
<a id="a7699f35ac7f97fd77fefa96bfb546635" name="a7699f35ac7f97fd77fefa96bfb546635"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7699f35ac7f97fd77fefa96bfb546635">&#9670;&#160;</a></span>is_n_C_brute_force_lesseq_than() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class graph_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; uint64_t &gt; lal::detail::is_n_C_brute_force_lesseq_than </td>
          <td>(</td>
          <td class="paramtype">const graph_t &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>arrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>upper_bound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the number of crossings is less than a given constant. </p>
<p >Given a graph \(G\) and a linear arrangements \(\pi\) of its nodes, returns the number of edge crossings \(C_{\pi}(G)\) if it is less than or equal to the given upper bound constant \(u\). In case the number of crossings is greater, returns a value strictly larger than the upper bound.</p>
<p >This is applied to every linear arrangement in <em>pi</em>. The upper bound <em>upper_bound</em> is applied to all linear arrangements. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">graph_t</td><td>Type of graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arrs</td><td>Linear arrangement of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
    <tr><td class="paramname">upper_bound</td><td>Constant (upper bound). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of crossings \(C\) if said number is less than or equal to the upper bound. The function returns a value strictly larger than the upper bound if otherwise. </dd></dl>

</div>
</div>
<a id="a0b6239adc7d16f0d1a8d4ea8e7979a5d" name="a0b6239adc7d16f0d1a8d4ea8e7979a5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b6239adc7d16f0d1a8d4ea8e7979a5d">&#9670;&#160;</a></span>is_n_C_dynamic_programming_lesseq_than() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class graph_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lal::detail::is_n_C_dynamic_programming_lesseq_than </td>
          <td>(</td>
          <td class="paramtype">const graph_t &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>upper_bound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fast calculation of \(C\) if it is less than or equal to an upper bound. </p>
<p >Given a graph \(G\) and a linear arrangements \(\pi\) of its nodes, returns the number of edge crossings \(C_{\pi}(G)\) if it is less than or equal to the given upper bound constant \(u\). In case the number of crossings is greater, returns a value strictly larger than the upper bound.</p>
<p >This is applied to every linear arrangement in <em>pi</em>. The upper bound <em>upper_bound</em> is applied to all linear arrangements. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">graph_t</td><td>Type of graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arr</td><td>Linear arrangement of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
    <tr><td class="paramname">upper_bound</td><td>Constant (upper bound). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of crossings \(C\) if said number is less than or equal to the upper bound. The function returns a value strictly larger than the upper bound if otherwise. </dd></dl>

</div>
</div>
<a id="aaa37dcfd68ac36acf6031b605ab75abc" name="aaa37dcfd68ac36acf6031b605ab75abc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa37dcfd68ac36acf6031b605ab75abc">&#9670;&#160;</a></span>is_n_C_dynamic_programming_lesseq_than() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class graph_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; uint64_t &gt; lal::detail::is_n_C_dynamic_programming_lesseq_than </td>
          <td>(</td>
          <td class="paramtype">const graph_t &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>arrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>upper_bounds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fast calculation of \(C\) if it is less than or equal to an upper bound. </p>
<p >Given a graph \(G\) and a linear arrangements \(\pi\) of its nodes, returns the number of edge crossings \(C_{\pi}(G)\) if it is less than or equal to the given upper bound constant \(u\). In case the number of crossings is greater, returns a value strictly larger than the upper bound.</p>
<p >This is applied to every linear arrangement in <em>pi</em>. To each arrangement corresponds only one upper bound. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">graph_t</td><td>Type of graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arrs</td><td>List of \(k\) linear arrangements of the nodes \(\Pi = \{\pi_i\}_{i=1}^k\). When one is omitted, \(\pi_I\) is used. </td></tr>
    <tr><td class="paramname">upper_bounds</td><td>List of constants (each an upper bound). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of crossings \(C\) if said number is less than or equal to the upper bound. The function returns a value strictly larger than the upper bound if otherwise. </dd></dl>

</div>
</div>
<a id="aa40e0c850c9d2b700f0d850547ae9ba5" name="aa40e0c850c9d2b700f0d850547ae9ba5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa40e0c850c9d2b700f0d850547ae9ba5">&#9670;&#160;</a></span>is_n_C_dynamic_programming_lesseq_than() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class graph_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; uint64_t &gt; lal::detail::is_n_C_dynamic_programming_lesseq_than </td>
          <td>(</td>
          <td class="paramtype">const graph_t &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>arrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>upper_bound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fast calculation of \(C\) if it is less than or equal to an upper bound. </p>
<p >Given a graph \(G\) and a linear arrangements \(\pi\) of its nodes, returns the number of edge crossings \(C_{\pi}(G)\) if it is less than or equal to the given upper bound constant \(u\). In case the number of crossings is greater, returns a value strictly larger than the upper bound.</p>
<p >This is applied to every linear arrangement in <em>pi</em>. To each arrangement corresponds only one upper bound. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">graph_t</td><td>Type of graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arrs</td><td>List of \(k\) linear arrangements of the nodes \(\Pi = \{\pi_i\}_{i=1}^k\). When one is omitted, \(\pi_I\) is used. </td></tr>
    <tr><td class="paramname">upper_bound</td><td>Constant (upper bound). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of crossings \(C\) if said number is less than or equal to the upper bound. The function returns a value strictly larger than the upper bound if otherwise. </dd></dl>

</div>
</div>
<a id="a12b35b7ee96b1b71634a019129cf74ea" name="a12b35b7ee96b1b71634a019129cf74ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12b35b7ee96b1b71634a019129cf74ea">&#9670;&#160;</a></span>is_n_C_ladder_lesseq_than() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class graph_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lal::detail::is_n_C_ladder_lesseq_than </td>
          <td>(</td>
          <td class="paramtype">const graph_t &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>upper_bound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fast calculation of \(C\) if it is less than or equal to an upper bound. </p>
<p >Given a graph \(G\) and a linear arrangements \(\pi\) of its nodes, returns the number of edge crossings \(C_{\pi}(G)\) if it is less than or equal to the given upper bound constant \(u\). In case the number of crossings is greater, returns a value strictly larger than the upper bound. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">graph_t</td><td>Type of graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arr</td><td>Linear arrangement of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
    <tr><td class="paramname">upper_bound</td><td>Constant (upper bound). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of crossings \(C\) if said number is less than or equal to the upper bound. The function returns a value strictly larger than the upper bound if otherwise. </dd></dl>

</div>
</div>
<a id="a4a313d37b28c1b5efec442077b09c4ab" name="a4a313d37b28c1b5efec442077b09c4ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a313d37b28c1b5efec442077b09c4ab">&#9670;&#160;</a></span>is_n_C_ladder_lesseq_than() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class graph_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; uint64_t &gt; lal::detail::is_n_C_ladder_lesseq_than </td>
          <td>(</td>
          <td class="paramtype">const graph_t &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>arrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>upper_bounds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fast calculation of \(C\) if it is less than or equal to an upper bound. </p>
<p >Given a graph \(G\) and a linear arrangements \(\pi\) of its nodes, returns the number of edge crossings \(C_{\pi}(G)\) if it is less than or equal to the given upper bound constant \(u\). In case the number of crossings is greater, returns a value strictly larger than the upper bound.</p>
<p >This is applied to every linear arrangement in <em>pi</em>. To each arrangement corresponds only one upper bound. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">graph_t</td><td>Type of graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arrs</td><td>List of \(k\) linear arrangements of the nodes \(\Pi = \{\pi_i\}_{i=1}^k\). When one is omitted, \(\pi_I\) is used. </td></tr>
    <tr><td class="paramname">upper_bounds</td><td>List of constants (each an upper bound). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of crossings \(C\) if said number is less than or equal to the upper bound. The function returns a value strictly larger than the upper bound if otherwise. </dd></dl>

</div>
</div>
<a id="ac485b276e1592aa9b4fbf88393497206" name="ac485b276e1592aa9b4fbf88393497206"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac485b276e1592aa9b4fbf88393497206">&#9670;&#160;</a></span>is_n_C_ladder_lesseq_than() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class graph_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; uint64_t &gt; lal::detail::is_n_C_ladder_lesseq_than </td>
          <td>(</td>
          <td class="paramtype">const graph_t &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>arrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>upper_bound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fast calculation of \(C\) if it is less than or equal to an upper bound. </p>
<p >Given a graph \(G\) and a linear arrangements \(\pi\) of its nodes, returns the number of edge crossings \(C_{\pi}(G)\) if it is less than or equal to the given upper bound constant \(u\). In case the number of crossings is greater, returns a value strictly larger than the upper bound.</p>
<p >This is applied to every linear arrangement in <em>pi</em>. The upper bound <em>upper_bound</em> is applied to all linear arrangements. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">graph_t</td><td>Type of graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arrs</td><td>List of \(k\) linear arrangements of the nodes \(\Pi = \{\pi_i\}_{i=1}^k\). When one is omitted, \(\pi_I\) is used. </td></tr>
    <tr><td class="paramname">upper_bound</td><td>Constant (upper bound). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of crossings \(C\) if said number is less than or equal to the upper bound. The function returns a value strictly larger than the upper bound if otherwise. </dd></dl>

</div>
</div>
<a id="a66ef8619b0afb6b4f1fe6bf2b055c182" name="a66ef8619b0afb6b4f1fe6bf2b055c182"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66ef8619b0afb6b4f1fe6bf2b055c182">&#9670;&#160;</a></span>is_n_C_stack_based_lesseq_than() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class graph_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lal::detail::is_n_C_stack_based_lesseq_than </td>
          <td>(</td>
          <td class="paramtype">const graph_t &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>upper_bound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fast calculation of \(C\) if it is less than or equal to an upper bound. </p>
<p >Given a graph \(G\) and a linear arrangements \(\pi\) of its nodes, returns the number of edge crossings \(C_{\pi}(G)\) if it is less than or equal to the given upper bound constant \(u\). In case the number of crossings is greater, returns a value strictly larger than the upper bound. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">graph_t</td><td>Type of graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arr</td><td>Linear arrangement of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
    <tr><td class="paramname">upper_bound</td><td>Constant (upper bound). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of crossings \(C\) if said number is less than or equal to the upper bound. The function returns a value strictly larger than the upper bound if otherwise. </dd></dl>

</div>
</div>
<a id="aac9327821de6e918b01ac58c5e5f8ec2" name="aac9327821de6e918b01ac58c5e5f8ec2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac9327821de6e918b01ac58c5e5f8ec2">&#9670;&#160;</a></span>is_n_C_stack_based_lesseq_than() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class graph_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; uint64_t &gt; lal::detail::is_n_C_stack_based_lesseq_than </td>
          <td>(</td>
          <td class="paramtype">const graph_t &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>arrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>upper_bounds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fast calculation of \(C\) if it is less than or equal to an upper bound. </p>
<p >Given a graph \(G\) and a linear arrangements \(\pi\) of its nodes, returns the number of edge crossings \(C_{\pi}(G)\) if it is less than or equal to the given upper bound constant \(u\). In case the number of crossings is greater, returns a value strictly larger than the upper bound.</p>
<p >This is applied to every linear arrangement in <em>pi</em>. To each arrangement corresponds only one upper bound. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">graph_t</td><td>Type of graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arrs</td><td>List of \(k\) linear arrangements of the nodes \(\Pi = \{\pi_i\}_{i=1}^k\). When one is omitted, \(\pi_I\) is used. </td></tr>
    <tr><td class="paramname">upper_bounds</td><td>List of constants (each an upper bound). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of crossings \(C\) if said number is less than or equal to the upper bound. The function returns a value strictly larger than the upper bound if otherwise. </dd></dl>

</div>
</div>
<a id="ac578078f7000be585dce35b5dead731a" name="ac578078f7000be585dce35b5dead731a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac578078f7000be585dce35b5dead731a">&#9670;&#160;</a></span>is_n_C_stack_based_lesseq_than() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class graph_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; uint64_t &gt; lal::detail::is_n_C_stack_based_lesseq_than </td>
          <td>(</td>
          <td class="paramtype">const graph_t &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>arrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>upper_bound</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fast calculation of \(C\) if it is less than or equal to an upper bound. </p>
<p >Given a graph \(G\) and a linear arrangements \(\pi\) of its nodes, returns the number of edge crossings \(C_{\pi}(G)\) if it is less than or equal to the given upper bound constant \(u\). In case the number of crossings is greater, returns a value strictly larger than the upper bound.</p>
<p >This is applied to every linear arrangement in <em>pi</em>. The upper bound <em>upper_bound</em> is applied to all linear arrangements. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">graph_t</td><td>Type of graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arrs</td><td>List of \(k\) linear arrangements of the nodes \(\Pi = \{\pi_i\}_{i=1}^k\). When one is omitted, \(\pi_I\) is used. </td></tr>
    <tr><td class="paramname">upper_bound</td><td>Constant (upper bound). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of crossings \(C\) if said number is less than or equal to the upper bound. The function returns a value strictly larger than the upper bound if otherwise. </dd></dl>

</div>
</div>
<a id="a81e5bdc0c496cec1dc8764ff73d9eff3" name="a81e5bdc0c496cec1dc8764ff73d9eff3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81e5bdc0c496cec1dc8764ff73d9eff3">&#9670;&#160;</a></span>is_node_reachable_from()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class graph_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::detail::is_node_reachable_from </td>
          <td>(</td>
          <td class="paramtype">const graph_t &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a>&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a>&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is a node reachable from another? </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">source</td><td>Node where the search starts at. </td></tr>
    <tr><td class="paramname">target</td><td>The node we want to know whether it is reachable from <em>source</em> or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if, and only if, node target is reachable from node source. </dd></dl>

</div>
</div>
<a id="a770859f44e2ce4b5b18f393c4bb0978d" name="a770859f44e2ce4b5b18f393c4bb0978d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a770859f44e2ce4b5b18f393c4bb0978d">&#9670;&#160;</a></span>is_projective()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacelal_1_1detail.html#ae7e27c62d46601d7b2c7b75cbfdeda85">detail::linarr_type</a> arr_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::detail::is_projective </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;&#160;</td>
          <td class="paramname"><em>rt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlal_1_1detail_1_1linarr__wrapper.html">detail::linarr_wrapper</a>&lt; arr_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>arr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is a given arrangement projective? </p>
<p >A projective arrangement of a rooted tree is an arrangement that is planar and the root is not covered by any edge. The root is covered if, for a given input arrangement \(\pi\), there exists an edge of the tree \(\{s,t\}\) such that \(\pi(s) &lt; \pi(r) &lt; \pi(t)\) or \(\pi(t) &lt; \pi(r) &lt; \pi(s)\).</p>
<p >If the input arrangement is empty then the identity arrangement \(\pi_I\) is used.</p>
<p >See method <a class="el" href="namespacelal_1_1linarr.html#aaeb1b7dcc4cda2e1c366e02b2d03c627">lal::linarr::is_planar</a> for further details on the definition of planar arrangements. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">arr_type</td><td>Type of arrangement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rt</td><td>Input rooted tree </td></tr>
    <tr><td class="paramname">arr</td><td>Input linear arrangement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the input rooted tree arranged with the input arrangement is projective. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The input rooted tree must be a valid rooted tree (see <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#af464d98b1b5dfdbaaacea553d9c89154">lal::graphs::rooted_tree::is_rooted_tree</a>). </dd></dl>

</div>
</div>
<a id="ae10cd880698b3b3e49fd2232fe51bd40" name="ae10cd880698b3b3e49fd2232fe51bd40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae10cd880698b3b3e49fd2232fe51bd40">&#9670;&#160;</a></span>is_root_covered()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacelal_1_1detail.html#ae7e27c62d46601d7b2c7b75cbfdeda85">detail::linarr_type</a> arr_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::detail::is_root_covered </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;&#160;</td>
          <td class="paramname"><em>rt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlal_1_1detail_1_1linarr__wrapper.html">detail::linarr_wrapper</a>&lt; arr_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>arr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the root of a rooted tree covered in a given arrangement? </p>
<p >The root is covered if, for a given input arrangement \(\pi\), there exists an edge of the tree \(\{s,t\}\) such that \(\pi(s) &lt; \pi(r) &lt; \pi(t)\) or \(\pi(t) &lt; \pi(r) &lt; \pi(s)\).</p>
<p >If the input arrangement is empty then the identity arrangement \(\pi_I\) is used. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">arr_type</td><td>Type of arrangement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rt</td><td>Input rooted tree </td></tr>
    <tr><td class="paramname">arr</td><td>Input linear arrangement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the root is covered in the given arrangement. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The input rooted tree must be a valid rooted tree (see <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#af464d98b1b5dfdbaaacea553d9c89154">lal::graphs::rooted_tree::is_rooted_tree</a>). </dd></dl>

</div>
</div>
<a id="ad5600ed70f6b12c07d428870c0734e64" name="ad5600ed70f6b12c07d428870c0734e64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5600ed70f6b12c07d428870c0734e64">&#9670;&#160;</a></span>level_sequence_to_ftree() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> lal::detail::level_sequence_to_ftree </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>normalise</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the level sequence of a tree into a graph structure. </p>
<p >See <a class="el" href="namespacelal_1_1detail.html#abd3c29c1187ac3421bc676fcd3eef7ba">lal::detail::level_sequence_to_ftree(const uint64_t*, uint64_t, bool, bool)</a> for further details. </p>

</div>
</div>
<a id="abd3c29c1187ac3421bc676fcd3eef7ba" name="abd3c29c1187ac3421bc676fcd3eef7ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd3c29c1187ac3421bc676fcd3eef7ba">&#9670;&#160;</a></span>level_sequence_to_ftree() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> lal::detail::level_sequence_to_ftree </td>
          <td>(</td>
          <td class="paramtype">const uint64_t *const&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>normalise</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the level sequence of a tree into a graph structure. </p>
<p >Examples of level sequences:</p><ul>
<li>linear tree of n nodes: <pre class="fragment">    0 1 2 3 4 ... (n-1) n</pre></li>
<li>star tree of n nodes <pre class="fragment">    0 1 2 2 2 .... 2 2
       |------------| &gt; (n-1) two's</pre></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>The level sequence, in preorder. </td></tr>
    <tr><td class="paramname">n</td><td>Number of nodes of the tree. </td></tr>
    <tr><td class="paramname">normalise</td><td>Should the tree be normalised? </td></tr>
    <tr><td class="paramname">check</td><td>Should it be checked whether the tree is normalized or not? </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The tree built with the sequence level <em>L</em>. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>n &gt;= 2. </dd>
<dd>
The size of L is exactly <em>n</em> + 1. </dd>
<dd>
The first value of a sequence must be a zero. </dd>
<dd>
The second value of a sequence must be a one. </dd></dl>

</div>
</div>
<a id="a41b38d88fe84f185d9fd54d431438724" name="a41b38d88fe84f185d9fd54d431438724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41b38d88fe84f185d9fd54d431438724">&#9670;&#160;</a></span>make_arrangement_permutations() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::detail::make_arrangement_permutations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a>&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a>&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelal.html#a5c3f34575ec933a44ed7b6d81e8c75f6">position</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;&#160;</td>
          <td class="paramname"><em>arr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make an arrangement using permutations. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">container</td><td>Object containing the permutations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">T</td><td>Input rooted tree. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">parent</td><td>Parent of node <em>u</em>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">u</td><td>Root of the current subtree. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">data</td><td>The permutations used to construct the arrangement. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pos</td><td>Current position in the arrangement. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">arr</td><td>Arrangement constructed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1e642d379033a5a82b9a26aed5e1ebcf" name="a1e642d379033a5a82b9a26aed5e1ebcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e642d379033a5a82b9a26aed5e1ebcf">&#9670;&#160;</a></span>make_arrangement_permutations() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> lal::detail::make_arrangement_permutations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a>&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make an arrangement using permutations. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">container</td><td>Object containing the permutations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>Input rooted tree. </td></tr>
    <tr><td class="paramname">root</td><td>Node used as root. </td></tr>
    <tr><td class="paramname">data</td><td>The permutations to construct the arrangement from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The arrangement constructed with the permutations. </dd></dl>

</div>
</div>
<a id="a1a50073a5ef6744e0e15a8ccd85b73fd" name="a1a50073a5ef6744e0e15a8ccd85b73fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a50073a5ef6744e0e15a8ccd85b73fd">&#9670;&#160;</a></span>make_arrangement_permutations() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> lal::detail::make_arrangement_permutations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make an arrangement using permutations. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">container</td><td>Object containing the permutations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>Input rooted tree. </td></tr>
    <tr><td class="paramname">data</td><td>The permutations to construct the arrangement from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The arrangement constructed with the permutations. </dd></dl>

</div>
</div>
<a id="a8767f98f8f22c1efe6183422848e76aa" name="a8767f98f8f22c1efe6183422848e76aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8767f98f8f22c1efe6183422848e76aa">&#9670;&#160;</a></span>make_arrangement_permutations() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::detail::make_arrangement_permutations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a>&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelal.html#a5c3f34575ec933a44ed7b6d81e8c75f6">position</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;&#160;</td>
          <td class="paramname"><em>arr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make an arrangement using permutations. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">container</td><td>Object containing the permutations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">T</td><td>Input rooted tree. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">r</td><td>Root of the current subtree. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">data</td><td>The permutations used to construct the arrangement. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pos</td><td>Current position in the arrangement. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">arr</td><td>Arrangement constructed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aba881f87432bdfa65bc26d67244de6aa" name="aba881f87432bdfa65bc26d67244de6aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba881f87432bdfa65bc26d67244de6aa">&#9670;&#160;</a></span>make_array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , T... ARGS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::array&lt; T, sizeof...(ARGS)&gt; lal::detail::make_array </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make an array with the values given as parameters of the template. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the array </td></tr>
    <tr><td class="paramname">ARGS</td><td>List of values to be stored in the array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adfd794b7d5d1d3b62c7faa1572342dfe" name="adfd794b7d5d1d3b62c7faa1572342dfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfd794b7d5d1d3b62c7faa1572342dfe">&#9670;&#160;</a></span>make_array_with_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t array_size, T value_to_fill_with&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::array&lt; T, array_size &gt; lal::detail::make_array_with_value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an array initialised at a given value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the array's elements. </td></tr>
    <tr><td class="paramname">array_size</td><td>Size of the array. </td></tr>
    <tr><td class="paramname">value_to_fill_with</td><td>The value to fill the array with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab1c13d4871396a062ae9ce2533867b15" name="ab1c13d4871396a062ae9ce2533867b15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1c13d4871396a062ae9ce2533867b15">&#9670;&#160;</a></span>make_array_with_value_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t size, T v, std::size_t... I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::array&lt; T, size &gt; lal::detail::make_array_with_value_impl </td>
          <td>(</td>
          <td class="paramtype">std::index_sequence&lt; I... &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of <a class="el" href="namespacelal_1_1detail.html#adfd794b7d5d1d3b62c7faa1572342dfe">lal::detail::make_array_with_value</a>. </p>
<p >Function used by <a class="el" href="namespacelal_1_1detail.html#adfd794b7d5d1d3b62c7faa1572342dfe">lal::detail::make_array_with_value()</a>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the value. </td></tr>
    <tr><td class="paramname">size</td><td>Size of the array. </td></tr>
    <tr><td class="paramname">v</td><td>Value to use. </td></tr>
    <tr><td class="paramname">I</td><td>Index sequence. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An array of the given size where all elements are equal to <em>v</em>. </dd></dl>

</div>
</div>
<a id="a4f454be47191d83eb42085332877424e" name="a4f454be47191d83eb42085332877424e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f454be47191d83eb42085332877424e">&#9670;&#160;</a></span>mean_sum_edge_lengths()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename result_t , class graph_t , class arrangement_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">result_t lal::detail::mean_sum_edge_lengths </td>
          <td>(</td>
          <td class="paramtype">const graph_t &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arrangement_t &amp;&#160;</td>
          <td class="paramname"><em>arr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Average sum of edge lengths in a graph. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">result_t</td><td>Type of return value. </td></tr>
    <tr><td class="paramname">graph_t</td><td>Type of graph. </td></tr>
    <tr><td class="paramname">arrangement_t</td><td>Type of arrangement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input directed graph. </td></tr>
    <tr><td class="paramname">arr</td><td>Input linear arrangement. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a811da8587db802ee4de53fe9c4d26b7c" name="a811da8587db802ee4de53fe9c4d26b7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a811da8587db802ee4de53fe9c4d26b7c">&#9670;&#160;</a></span>mpq_divide_mpq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::detail::mpq_divide_mpq </td>
          <td>(</td>
          <td class="paramtype">mpq_t &amp;&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mpq_t &amp;&#160;</td>
          <td class="paramname"><em>den</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rational-Rational division. </p>
<p >Divide a rational \(r_1\) by another rational \(r_2\). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">num</td><td>The rational to be divided by \(k\). Result is \(r_1 := r_1/r_2\). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">den</td><td>The rational that divides the rational. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a52b8428c64f43950e2e231a38e2a730b" name="a52b8428c64f43950e2e231a38e2a730b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52b8428c64f43950e2e231a38e2a730b">&#9670;&#160;</a></span>mpz_divide_mpq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::detail::mpz_divide_mpq </td>
          <td>(</td>
          <td class="paramtype">mpq_t &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mpz_t &amp;&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rational-Integer division. </p>
<p >Divide a rational \(r\) by an integer \(k\). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">r</td><td>The rational to be divided by \(k\). Result is \(r := r/k\). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>The integer that divides the rational. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aadddf96b5de80a3d63d05ec36f9cb672" name="aadddf96b5de80a3d63d05ec36f9cb672"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadddf96b5de80a3d63d05ec36f9cb672">&#9670;&#160;</a></span>mpz_pow_mpz()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::detail::mpz_pow_mpz </td>
          <td>(</td>
          <td class="paramtype">mpz_t &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mpz_t &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mpz_t &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the exponentiation of a big integer to another big integer. </p>
<p >Fast exponentiation algorithm.</p>
<p >This function has, as an exception, its output parameter as its first parameter. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">r</td><td>Result. \(r = b^e\). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Base. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>Exponent. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8dfcbe004ac9a216754bf3eae410c32b" name="a8dfcbe004ac9a216754bf3eae410c32b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dfcbe004ac9a216754bf3eae410c32b">&#9670;&#160;</a></span>n_C_brute_force() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class graph_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lal::detail::n_C_brute_force </td>
          <td>(</td>
          <td class="paramtype">const graph_t &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;&#160;</td>
          <td class="paramname"><em>arr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the number of crossings in the linear arrangement less than a constant? </p>
<p >Given a graph, and a linear arrangement of its nodes, computes by brute force the number of edges that cross in such linear arrangement. If the arrangement is not specified, the identity arrangement is used. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">graph_t</td><td>Type of graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arr</td><td>Linear arrangement of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of crossings \(C\). </dd></dl>

</div>
</div>
<a id="a9aaadea543154a22dd77ce1179b9ab42" name="a9aaadea543154a22dd77ce1179b9ab42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aaadea543154a22dd77ce1179b9ab42">&#9670;&#160;</a></span>n_C_brute_force() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class graph_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; uint64_t &gt; lal::detail::n_C_brute_force </td>
          <td>(</td>
          <td class="paramtype">const graph_t &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>arrs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the number of crossings in the linear arrangement less than a constant? </p>
<p >Given a graph, and a linear arrangement of its nodes, computes by brute force the number of edges that cross in such linear arrangement. If the arrangement is not specified, the identity arrangement is used. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">graph_t</td><td>Type of graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arrs</td><td>List of \(k\) linear arrangements of the nodes \(\Pi = \{\pi_i\}_{i=1}^k\). When one is omitted, \(\pi_I\) is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list \(L\) where \(L_i = C_{\pi_i}(g)\). </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>None of the arrangements is empty. </dd></dl>

</div>
</div>
<a id="ace62b8ae72aa81e2f7220ed5ab94d62b" name="ace62b8ae72aa81e2f7220ed5ab94d62b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace62b8ae72aa81e2f7220ed5ab94d62b">&#9670;&#160;</a></span>n_C_dynamic_programming() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class graph_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lal::detail::n_C_dynamic_programming </td>
          <td>(</td>
          <td class="paramtype">const graph_t &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;&#160;</td>
          <td class="paramname"><em>arr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the number of crossings in the linear arrangement less than a constant? </p>
<p >Given a graph, and a linear arrangement of its nodes, computes by brute force the number of edges that cross in such linear arrangement. If the arrangement is not specified, the identity arrangement is used. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">graph_t</td><td>Type of graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arr</td><td>Linear arrangement of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of crossings \(C\). </dd></dl>

</div>
</div>
<a id="ab6fb4a73feef834d6f6083017c77ffad" name="ab6fb4a73feef834d6f6083017c77ffad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6fb4a73feef834d6f6083017c77ffad">&#9670;&#160;</a></span>n_C_dynamic_programming() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class graph_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; uint64_t &gt; lal::detail::n_C_dynamic_programming </td>
          <td>(</td>
          <td class="paramtype">const graph_t &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>arrs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the number of crossings in the linear arrangement less than a constant? </p>
<p >Given a graph, and a linear arrangement of its nodes, computes by brute force the number of edges that cross in such linear arrangement. If the arrangement is not specified, the identity arrangement is used. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">graph_t</td><td>Type of graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arrs</td><td>List of \(k\) linear arrangements of the nodes \(\Pi = \{\pi_i\}_{i=1}^k\). When one is omitted, \(\pi_I\) is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list \(L\) where \(L_i = C_{\pi_i}(g)\). </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>None of the arrangements is empty. </dd></dl>

</div>
</div>
<a id="a0ff3d3faa9937f42252a89c79809d20f" name="a0ff3d3faa9937f42252a89c79809d20f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ff3d3faa9937f42252a89c79809d20f">&#9670;&#160;</a></span>n_C_ladder() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class graph_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lal::detail::n_C_ladder </td>
          <td>(</td>
          <td class="paramtype">const graph_t &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;&#160;</td>
          <td class="paramname"><em>arr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the number of crossings in the linear arrangement less than a constant? </p>
<p >Given a graph, and a linear arrangement of its nodes, computes by brute force the number of edges that cross in such linear arrangement. If the arrangement is not specified, the identity arrangement is used. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">graph_t</td><td>Type of graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arr</td><td>Linear arrangement of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of crossings \(C\). </dd></dl>

</div>
</div>
<a id="a5860c3c8273d95209e36bdd689943629" name="a5860c3c8273d95209e36bdd689943629"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5860c3c8273d95209e36bdd689943629">&#9670;&#160;</a></span>n_C_ladder() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class graph_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; uint64_t &gt; lal::detail::n_C_ladder </td>
          <td>(</td>
          <td class="paramtype">const graph_t &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>arrs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the number of crossings in the linear arrangement less than a constant? </p>
<p >Given a graph, and a linear arrangement of its nodes, computes by brute force the number of edges that cross in such linear arrangement. If the arrangement is not specified, the identity arrangement is used. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">graph_t</td><td>Type of graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arrs</td><td>List of \(k\) linear arrangements of the nodes \(\Pi = \{\pi_i\}_{i=1}^k\). When one is omitted, \(\pi_I\) is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list \(L\) where \(L_i = C_{\pi_i}(g)\). </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>None of the arrangements is empty. </dd></dl>

</div>
</div>
<a id="a1d67b4d927bc4ada1816b903f278bcff" name="a1d67b4d927bc4ada1816b903f278bcff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d67b4d927bc4ada1816b903f278bcff">&#9670;&#160;</a></span>n_C_stack_based() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class graph_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lal::detail::n_C_stack_based </td>
          <td>(</td>
          <td class="paramtype">const graph_t &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;&#160;</td>
          <td class="paramname"><em>arr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the number of crossings in the linear arrangement less than a constant? </p>
<p >Given a graph, and a linear arrangement of its nodes, computes by brute force the number of edges that cross in such linear arrangement. If the arrangement is not specified, the identity arrangement is used. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">graph_t</td><td>Type of graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arr</td><td>A linear arrangement of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of crossings \(C\). </dd></dl>

</div>
</div>
<a id="a2dcc673a543201a113c8c6f1d0f3e1ad" name="a2dcc673a543201a113c8c6f1d0f3e1ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dcc673a543201a113c8c6f1d0f3e1ad">&#9670;&#160;</a></span>n_C_stack_based() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class graph_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; uint64_t &gt; lal::detail::n_C_stack_based </td>
          <td>(</td>
          <td class="paramtype">const graph_t &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>arrs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the number of crossings in the linear arrangement less than a constant? </p>
<p >Given a graph, and a linear arrangement of its nodes, computes by brute force the number of edges that cross in such linear arrangement. If the arrangement is not specified, the identity arrangement is used. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">graph_t</td><td>Type of graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arrs</td><td>List of \(k\) linear arrangements of the nodes \(\Pi = \{\pi_i\}_{i=1}^k\). When one is omitted, \(\pi_I\) is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list \(L\) where \(L_i = C_{\pi_i}(g)\). </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>None of the arrangements is empty. </dd></dl>

</div>
</div>
<a id="ac06bbc1aa13b66438da3a404b295ef3f" name="ac06bbc1aa13b66438da3a404b295ef3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac06bbc1aa13b66438da3a404b295ef3f">&#9670;&#160;</a></span>operate_power() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::detail::operate_power </td>
          <td>(</td>
          <td class="paramtype">mpq_t &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mpz_t &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Power operation. </p>
<p >Raise a rational value \(r\) to a certain power \(p\). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">r</td><td>Rational value. Result is \(r = r^p\). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Exponent. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a82682656557db49caf9f7f0c0db9137f" name="a82682656557db49caf9f7f0c0db9137f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82682656557db49caf9f7f0c0db9137f">&#9670;&#160;</a></span>operate_power() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::detail::operate_power </td>
          <td>(</td>
          <td class="paramtype">mpq_t &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Power operation. </p>
<p >Raise a rational value \(r\) to a certain power \(p\). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">r</td><td>Rational value. Result is \(r = r^p\). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Exponent. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8965e5ea6dab322a1bfdd7ee94c7050f" name="a8965e5ea6dab322a1bfdd7ee94c7050f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8965e5ea6dab322a1bfdd7ee94c7050f">&#9670;&#160;</a></span>predict_C_using_edge_lengths()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename result_t , class graph_t , class arrangement_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">result_t lal::detail::predict_C_using_edge_lengths </td>
          <td>(</td>
          <td class="paramtype">const graph_t &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arrangement_t &amp;&#160;</td>
          <td class="paramname"><em>arr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Predicted number of crossings based on the sum of edge lengths. </p>
<p >See <a class="el" href="citelist.html#CITEREF_Ferrer2014a">[16]</a> for further details. This functions implements \(E_2[C]\). </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">result_t</td><td>Type of the return value. </td></tr>
    <tr><td class="paramname">graph_t</td><td>Type of graph. </td></tr>
    <tr><td class="paramname">arrangement_t</td><td>Type of arrangement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arr</td><td>Input arrangement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of \(E_2[C]\). </dd></dl>

</div>
</div>
<a id="a83729c5ce96b983fa2fc7f86f07cffcd" name="a83729c5ce96b983fa2fc7f86f07cffcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83729c5ce96b983fa2fc7f86f07cffcd">&#9670;&#160;</a></span>Prufer_sequence_to_ftree() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> lal::detail::Prufer_sequence_to_ftree </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>normalise</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the Prüfer sequence of a labelled tree into a tree structure. </p>
<p >For details on Prüfer sequences, see <a class="el" href="citelist.html#CITEREF_Pruefer1918a">[32]</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seq</td><td>The Prufer sequence sequence. </td></tr>
    <tr><td class="paramname">n</td><td>Number of nodes of the tree. </td></tr>
    <tr><td class="paramname">normalise</td><td>Should the tree be normalised? </td></tr>
    <tr><td class="paramname">check</td><td>Should it be checked whether the tree is normalized or not? </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The tree built with <em>seq</em>. </dd></dl>

</div>
</div>
<a id="a9fa4324d332b6ab02db4492055333fe7" name="a9fa4324d332b6ab02db4492055333fe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fa4324d332b6ab02db4492055333fe7">&#9670;&#160;</a></span>Prufer_sequence_to_ftree() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> lal::detail::Prufer_sequence_to_ftree </td>
          <td>(</td>
          <td class="paramtype">const uint64_t *const&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>normalise</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the Prüfer sequence of a labelled tree into a tree structure. </p>
<p >For details on Prüfer sequences, see <a class="el" href="citelist.html#CITEREF_Pruefer1918a">[32]</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seq</td><td>The Prufer sequence sequence. </td></tr>
    <tr><td class="paramname">n</td><td>Number of nodes of the tree. </td></tr>
    <tr><td class="paramname">normalise</td><td>Should the tree be normalised? </td></tr>
    <tr><td class="paramname">check</td><td>Should it be checked whether the tree is normalized or not? </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The tree built with <em>seq</em>. </dd></dl>

</div>
</div>
<a id="a968ddb05fafc9ff668ed947d506d29a1" name="a968ddb05fafc9ff668ed947d506d29a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a968ddb05fafc9ff668ed947d506d29a1">&#9670;&#160;</a></span>retrieve_centre()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tree_t , std::enable_if_t&lt; std::is_base_of_v&lt; <a class="el" href="classlal_1_1graphs_1_1tree.html">graphs::tree</a>, tree_t &gt;, bool &gt;  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a>, <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> &gt; lal::detail::retrieve_centre </td>
          <td>(</td>
          <td class="paramtype">const tree_t &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a>&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the centre of the connected component that has node <em>x</em>. </p>
<p >See <a class="el" href="LAL_concepts.html#LAL_concepts__centre_centroid">Centre and centroid of a tree</a> for details on what the centre of a tree is.</p>
<p >A graph of type <a class="el" href="classlal_1_1graphs_1_1tree.html">lal::graphs::tree</a> may lack some edges tree so it has several connected components. Vertex <em>x</em> belongs to one of these connected components.</p>
<p >This method finds the central nodes of the connected components node 'x' belongs to.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">tree_t</td><td>type of tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input tree. </td></tr>
    <tr><td class="paramname">X</td><td>Input node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Input tree <em>t</em> may be a forest. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A tuple of the two nodes in the centre. If the tree has a single central node, only the first node is valid and the second is assigned an invalid vertex index. It is guaranteed that the first vertex has smaller index value than the second. </dd></dl>

</div>
</div>
<a id="adae348ce62d716de5e5796448b4e97c6" name="adae348ce62d716de5e5796448b4e97c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adae348ce62d716de5e5796448b4e97c6">&#9670;&#160;</a></span>retrieve_centroid() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tree_t , std::enable_if_t&lt; std::is_base_of_v&lt; <a class="el" href="classlal_1_1graphs_1_1tree.html">graphs::tree</a>, tree_t &gt;, bool &gt;  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a>, <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> &gt; lal::detail::retrieve_centroid </td>
          <td>(</td>
          <td class="paramtype">const tree_t &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the centroid of the tree <em>t</em>. </p>
<p >See page <a class="el" href="LAL_concepts.html#LAL_concepts__centre_centroid">Centre and centroid of a tree</a> for a definition of centre and centroid.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">tree_t</td><td>Type of the input tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tuple of two values: the nodes in the centroid. If the tree has a single centroidal node, only the first node is valid and the second is assigned an invalid vertex index. It is guaranteed that the first vertex has smaller index value than the second. </dd></dl>

</div>
</div>
<a id="a25d097aefd29d279d75bae3b29c00a9c" name="a25d097aefd29d279d75bae3b29c00a9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25d097aefd29d279d75bae3b29c00a9c">&#9670;&#160;</a></span>retrieve_centroid() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tree_t , std::enable_if_t&lt; std::is_base_of_v&lt; <a class="el" href="classlal_1_1graphs_1_1tree.html">graphs::tree</a>, tree_t &gt;, bool &gt;  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a>, <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> &gt; lal::detail::retrieve_centroid </td>
          <td>(</td>
          <td class="paramtype">const tree_t &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a>&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the centroid of the connected component that has node <em>x</em>. </p>
<p >For details on the parameters and return value see documentation of the function above. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">tree_t</td><td>Type of tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input tree </td></tr>
    <tr><td class="paramname">x</td><td>Node belonging to a connected component whose centroid we want. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tuple of two values: the nodes in the centroid. If the tree has a single centroidal node, only the first node is valid and the second is assigned an invalid vertex index. It is guaranteed that the first vertex has smaller index value than the second. </dd></dl>

</div>
</div>
<a id="a5730f2fef2524437fafcbeb1383d9d96" name="a5730f2fef2524437fafcbeb1383d9d96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5730f2fef2524437fafcbeb1383d9d96">&#9670;&#160;</a></span>right_branching_edges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class arrangement_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lal::detail::right_branching_edges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arrangement_t &amp;&#160;</td>
          <td class="paramname"><em>arr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of right branching edges in a directed graph. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">arrangement_t</td><td>Type of arrangement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input directed graph. </td></tr>
    <tr><td class="paramname">arr</td><td>Input linear arrangement. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5bb2c6db85eddc1623aa2e3e4b0cbb29" name="a5bb2c6db85eddc1623aa2e3e4b0cbb29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bb2c6db85eddc1623aa2e3e4b0cbb29">&#9670;&#160;</a></span>set_edges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class graph_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespacelal.html#a5969ec7ecc85697ebb9ec0ace78fbcab">edge</a> &gt; lal::detail::set_edges </td>
          <td>(</td>
          <td class="paramtype">const graph_t &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumerate the set of edges of the input graph <em>g</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector with all <em>g's</em> edges. </dd></dl>

</div>
</div>
<a id="adfa1dbbb9ce95e8374be50fe57e34922" name="adfa1dbbb9ce95e8374be50fe57e34922"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfa1dbbb9ce95e8374be50fe57e34922">&#9670;&#160;</a></span>set_pairs_independent_edges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class graph_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespacelal.html#a235d5351556fbc73aa51767ab7765f5c">edge_pair</a> &gt; lal::detail::set_pairs_independent_edges </td>
          <td>(</td>
          <td class="paramtype">const graph_t &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>qs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumerate the set of pairs of independent edges of the input graph <em>g</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">qs</td><td>Total amount of pairs of independent edges. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector with all <em>g's</em> pairs of independent edges. </dd></dl>

</div>
</div>
<a id="a8452716fdc28399856f71906ef872b6c" name="a8452716fdc28399856f71906ef872b6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8452716fdc28399856f71906ef872b6c">&#9670;&#160;</a></span>sum_edge_lengths()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class graph_t , class arrangement_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lal::detail::sum_edge_lengths </td>
          <td>(</td>
          <td class="paramtype">const graph_t &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arrangement_t &amp;&#160;</td>
          <td class="paramname"><em>arr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sum of edge lengths in a graph. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">graph_t</td><td>Type of graph. </td></tr>
    <tr><td class="paramname">arrangement_t</td><td>Type of arrangement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input directed graph. </td></tr>
    <tr><td class="paramname">arr</td><td>Input linear arrangement. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a187fa2c26689d24012a0b50b80b676a2" name="a187fa2c26689d24012a0b50b80b676a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a187fa2c26689d24012a0b50b80b676a2">&#9670;&#160;</a></span>syntactic_dependency_structure_to_string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::string_view lal::detail::syntactic_dependency_structure_to_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal_1_1linarr.html#a3e8b744d4c81d3bb4463ec203f9199d6">linarr::syntactic_dependency_structure</a> &amp;&#160;</td>
          <td class="paramname"><em>tt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Converts a value of the enumeration <a class="el" href="namespacelal_1_1linarr.html#a3e8b744d4c81d3bb4463ec203f9199d6">lal::linarr::syntactic_dependency_structure</a> into a string. </p>

</div>
</div>
<a id="a34526c181f7e86c1e94205fb12e899cb" name="a34526c181f7e86c1e94205fb12e899cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34526c181f7e86c1e94205fb12e899cb">&#9670;&#160;</a></span>tree_diameter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tree_t , std::enable_if_t&lt; std::is_base_of_v&lt; <a class="el" href="classlal_1_1graphs_1_1tree.html">graphs::tree</a>, tree_t &gt;, bool &gt;  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lal::detail::tree_diameter </td>
          <td>(</td>
          <td class="paramtype">const tree_t &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a>&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the diameter of a tree. </p>
<p >See <a class="el" href="LAL_concepts.html#LAL_concepts__tree_diameter">Diameter of a tree</a> for details on the definition of the diameter of a tree.</p>
<p >The diameter of the connected component to which node <em>x</em> belongs to. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">tree_t</td><td>Type of tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input tree. </td></tr>
    <tr><td class="paramname">x</td><td>Input node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The diameter of the tree. </dd></dl>

</div>
</div>
<a id="af50760eaee3200e963cc77c4c95470d6" name="af50760eaee3200e963cc77c4c95470d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af50760eaee3200e963cc77c4c95470d6">&#9670;&#160;</a></span>update_unionfind_after_add_edge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tree_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::detail::update_unionfind_after_add_edge </td>
          <td>(</td>
          <td class="paramtype">const tree_t &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a>&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a>&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> *const&#160;</td>
          <td class="paramname"><em>root_of</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *const&#160;</td>
          <td class="paramname"><em>root_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the Union-Find data structure after an edge addition to a tree. </p>
<p >This function updates the union-find data structure of a tree after the addition of the edge between the edges 'u' and 'v'. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">tree_t</td><td>Type of tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input tree </td></tr>
    <tr><td class="paramname">u</td><td>Node </td></tr>
    <tr><td class="paramname">v</td><td>Node </td></tr>
    <tr><td class="paramname">root_of</td><td>Pointer to an array where <em>root_of</em>[<em>s</em>] = <em>t</em> if the root of the connected component of <em>s</em> is <em>t</em> </td></tr>
    <tr><td class="paramname">root_size</td><td>Sizes of each connected component. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The edge \(\{u,v\}\) must exist. </dd></dl>

</div>
</div>
<a id="a773e3f33dbdcf3c44007f621eea0e4de" name="a773e3f33dbdcf3c44007f621eea0e4de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a773e3f33dbdcf3c44007f621eea0e4de">&#9670;&#160;</a></span>update_unionfind_after_remove_edge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tree_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::detail::update_unionfind_after_remove_edge </td>
          <td>(</td>
          <td class="paramtype">const tree_t &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a>&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a>&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> *const&#160;</td>
          <td class="paramname"><em>root_of</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *const&#160;</td>
          <td class="paramname"><em>root_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates Union-Find after an edge removal. </p>
<p >This function updates the union-find data structure of a tree after the removal of the edge between the edges 'u' and 'v'. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">tree_t</td><td>Type of tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input tree </td></tr>
    <tr><td class="paramname">u</td><td>Node </td></tr>
    <tr><td class="paramname">v</td><td>Node </td></tr>
    <tr><td class="paramname">root_of</td><td>Pointer to an array where <em>root_of</em>[<em>s</em>] = <em>t</em> if the root of the connected component of <em>s</em> is <em>t</em> </td></tr>
    <tr><td class="paramname">root_size</td><td>Sizes of each connected component. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The edge \(\{u,v\}\) must exist. </dd></dl>

</div>
</div>
<a id="a877790b322b3fcb13601ffd1ddd5a3a9" name="a877790b322b3fcb13601ffd1ddd5a3a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a877790b322b3fcb13601ffd1ddd5a3a9">&#9670;&#160;</a></span>update_unionfind_before_remove_edges_incident_to() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tree_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::detail::update_unionfind_before_remove_edges_incident_to </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlal_1_1detail_1_1BFS.html">BFS</a>&lt; tree_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>bfs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a>&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> *const&#160;</td>
          <td class="paramname"><em>root_of</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *const&#160;</td>
          <td class="paramname"><em>root_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update Union-Find after a vertex removal. </p>
<p >This function updates the union-find data structure of a tree prior to the removal of the edge (u,v).</p>
<p >This function is called by the function lal::detail::UnionFind_update_roots_before_remove_all_incident_to</p>
<p >In particular, it updates the information associated to the vertices found in the direction (u,v). </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">tree_t</td><td>Type of tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bfs</td><td>Breadth-First Search object. </td></tr>
    <tr><td class="paramname">v</td><td>Node to be removed. </td></tr>
    <tr><td class="paramname">root_of</td><td>Pointer to an array where <em>root_of</em>[<em>s</em>] = <em>t</em> if the root of the connected component of <em>s</em> is <em>t</em> </td></tr>
    <tr><td class="paramname">root_size</td><td>Sizes of each connected component. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae70b74a1214f7f18bb95fb1b940fc66a" name="ae70b74a1214f7f18bb95fb1b940fc66a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae70b74a1214f7f18bb95fb1b940fc66a">&#9670;&#160;</a></span>update_unionfind_before_remove_edges_incident_to() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename tree_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::detail::update_unionfind_before_remove_edges_incident_to </td>
          <td>(</td>
          <td class="paramtype">const tree_t &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a>&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> *const&#160;</td>
          <td class="paramname"><em>root_of</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *const&#160;</td>
          <td class="paramname"><em>root_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update Union-Find after a vertex removal. </p>
<p >This function updates the union-find data structure of a tree prior to the removal of the edge (u,v).</p>
<p >This function is called by the function lal::detail::UnionFind_update_roots_before_remove_all_incident_to</p>
<p >In particular, it updates the information associated to the vertices found in the direction (u,v). </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">tree_t</td><td>Type of tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input tree. </td></tr>
    <tr><td class="paramname">u</td><td>Node to be removed. </td></tr>
    <tr><td class="paramname">root_of</td><td>Pointer to an array where <em>root_of</em>[<em>s</em>] = <em>t</em> if the root of the connected component of <em>s</em> is <em>t</em> </td></tr>
    <tr><td class="paramname">root_size</td><td>Sizes of each connected component. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
