<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LAL: Linear Arrangement Library: lal::linarr Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">LAL: Linear Arrangement Library<span id="projectnumber">&#160;23.01.00</span>
   </div>
   <div id="projectbrief">A library focused on algorithms on linear arrangements of graphs.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacelal.html">lal</a></li><li class="navelem"><a class="el" href="namespacelal_1_1linarr.html">linarr</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">lal::linarr Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Namespace for all linear-arrangement-dependent algorithms.  
<a href="namespacelal_1_1linarr.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1linarr_1_1dependency__flux.html">dependency_flux</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dependency flux.  <a href="classlal_1_1linarr_1_1dependency__flux.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:aa7dc22d99964e6a6bb1fe5dd096e64b7"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1linarr.html#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> { <a class="el" href="namespacelal_1_1linarr.html#aa7dc22d99964e6a6bb1fe5dd096e64b7a14eb8fb55e00336d36cb281764c88aa5">brute_force</a>
, <a class="el" href="namespacelal_1_1linarr.html#aa7dc22d99964e6a6bb1fe5dd096e64b7a724c4582f391c030da5a79ad83de9ecf">dynamic_programming</a>
, <a class="el" href="namespacelal_1_1linarr.html#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">ladder</a>
, <a class="el" href="namespacelal_1_1linarr.html#aa7dc22d99964e6a6bb1fe5dd096e64b7aea9e5920d6313045f9549b9a8808c8a7">stack_based</a>
 }</td></tr>
<tr class="memdesc:aa7dc22d99964e6a6bb1fe5dd096e64b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The different algorithms for computing the number of crossings.  <a href="namespacelal_1_1linarr.html#aa7dc22d99964e6a6bb1fe5dd096e64b7">More...</a><br /></td></tr>
<tr class="separator:aa7dc22d99964e6a6bb1fe5dd096e64b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c6a617eb12e032ee641fd390776ff3f"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1linarr.html#a1c6a617eb12e032ee641fd390776ff3f">algorithms_Dmin</a> { <a class="el" href="namespacelal_1_1linarr.html#a1c6a617eb12e032ee641fd390776ff3fae04de66d6cf0f6c6ec4036288f66bbed">Shiloach</a>
, <a class="el" href="namespacelal_1_1linarr.html#a1c6a617eb12e032ee641fd390776ff3fa6b1d14e66c988ccd420887b0774de1d6">Chung_2</a>
 }</td></tr>
<tr class="memdesc:a1c6a617eb12e032ee641fd390776ff3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The different algorithms for computing the minimum sum of the length of the edges \(D\).  <a href="namespacelal_1_1linarr.html#a1c6a617eb12e032ee641fd390776ff3f">More...</a><br /></td></tr>
<tr class="separator:a1c6a617eb12e032ee641fd390776ff3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a49efcc64c3b63502ad8cc18d508ce3"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1linarr.html#a4a49efcc64c3b63502ad8cc18d508ce3">algorithms_Dmin_planar</a> { <a class="el" href="namespacelal_1_1linarr.html#a4a49efcc64c3b63502ad8cc18d508ce3a37e3b966cac6fa2c0f649bd5cb42adca">AlemanyEstebanFerrer</a>
, <a class="el" href="namespacelal_1_1linarr.html#a4a49efcc64c3b63502ad8cc18d508ce3a5420b4f3654df1cf130da66c7a7aba6b">HochbergStallmann</a>
 }</td></tr>
<tr class="memdesc:a4a49efcc64c3b63502ad8cc18d508ce3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The different algorithms for computing the minimum sum of the length of the edges \(D\) in planar arrangements of free trees.  <a href="namespacelal_1_1linarr.html#a4a49efcc64c3b63502ad8cc18d508ce3">More...</a><br /></td></tr>
<tr class="separator:a4a49efcc64c3b63502ad8cc18d508ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30bc00af5439a56f037ed84875f1911f"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1linarr.html#a30bc00af5439a56f037ed84875f1911f">algorithms_Dmin_projective</a> { <a class="el" href="namespacelal_1_1linarr.html#a30bc00af5439a56f037ed84875f1911fa37e3b966cac6fa2c0f649bd5cb42adca">AlemanyEstebanFerrer</a>
, <a class="el" href="namespacelal_1_1linarr.html#a30bc00af5439a56f037ed84875f1911fa5420b4f3654df1cf130da66c7a7aba6b">HochbergStallmann</a>
 }</td></tr>
<tr class="memdesc:a30bc00af5439a56f037ed84875f1911f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The different algorithms for computing the minimum sum of the length of the edges \(D\) in projective arrangements of rooted trees.  <a href="namespacelal_1_1linarr.html#a30bc00af5439a56f037ed84875f1911f">More...</a><br /></td></tr>
<tr class="separator:a30bc00af5439a56f037ed84875f1911f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e8b744d4c81d3bb4463ec203f9199d6"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1linarr.html#a3e8b744d4c81d3bb4463ec203f9199d6">syntactic_dependency_structure</a> { <br />
&#160;&#160;<a class="el" href="namespacelal_1_1linarr.html#a3e8b744d4c81d3bb4463ec203f9199d6a118c01813b90ed2f2630b6d66992ef7d">EC1</a>
, <a class="el" href="namespacelal_1_1linarr.html#a3e8b744d4c81d3bb4463ec203f9199d6a3be411765e710adc7764f5056e44138c">planar</a>
, <a class="el" href="namespacelal_1_1linarr.html#a3e8b744d4c81d3bb4463ec203f9199d6a768db0c0fba3c72a9886b833efe822ce">projective</a>
, <a class="el" href="namespacelal_1_1linarr.html#a3e8b744d4c81d3bb4463ec203f9199d6acf92d51d12b1fc006d0a126c327caa14">WG1</a>
, <br />
&#160;&#160;<a class="el" href="namespacelal_1_1linarr.html#a3e8b744d4c81d3bb4463ec203f9199d6aad921d60486366258809553a3db49a4a">unknown</a>
<br />
 }</td></tr>
<tr class="memdesc:a3e8b744d4c81d3bb4463ec203f9199d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The different types of syntactic dependency tree structures.  <a href="namespacelal_1_1linarr.html#a3e8b744d4c81d3bb4463ec203f9199d6">More...</a><br /></td></tr>
<tr class="separator:a3e8b744d4c81d3bb4463ec203f9199d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae5d17b6e4ea1521b436dbb20817f41b1"><td class="memTemplParams" colspan="2">template&lt;class graph_t &gt; </td></tr>
<tr class="memitem:ae5d17b6e4ea1521b436dbb20817f41b1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelal_1_1linarr.html#ae5d17b6e4ea1521b436dbb20817f41b1">mean_dependency_distance_1level_rational</a> (const std::vector&lt; graph_t &gt; &amp;L, const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;P={}) noexcept</td></tr>
<tr class="memdesc:ae5d17b6e4ea1521b436dbb20817f41b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">1-level Mean Dependency Distance \(MDD\) over an ensemble of graphs.  <a href="namespacelal_1_1linarr.html#ae5d17b6e4ea1521b436dbb20817f41b1">More...</a><br /></td></tr>
<tr class="separator:ae5d17b6e4ea1521b436dbb20817f41b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f8c78736426eea6282258b26534c7e5"><td class="memTemplParams" colspan="2">template&lt;class graph_t &gt; </td></tr>
<tr class="memitem:a1f8c78736426eea6282258b26534c7e5"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelal_1_1linarr.html#a1f8c78736426eea6282258b26534c7e5">mean_dependency_distance_1level</a> (const std::vector&lt; graph_t &gt; &amp;L, const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;P={}) noexcept</td></tr>
<tr class="memdesc:a1f8c78736426eea6282258b26534c7e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">1-level Mean Dependency Distance \(MDD\) over an ensemble of graphs.  <a href="namespacelal_1_1linarr.html#a1f8c78736426eea6282258b26534c7e5">More...</a><br /></td></tr>
<tr class="separator:a1f8c78736426eea6282258b26534c7e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b2bbd3f6c94e03091186afd5ec3ae89"><td class="memTemplParams" colspan="2">template&lt;class graph_t &gt; </td></tr>
<tr class="memitem:a0b2bbd3f6c94e03091186afd5ec3ae89"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelal_1_1linarr.html#a0b2bbd3f6c94e03091186afd5ec3ae89">mean_dependency_distance_2level_rational</a> (const std::vector&lt; graph_t &gt; &amp;L, const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;P={}) noexcept</td></tr>
<tr class="memdesc:a0b2bbd3f6c94e03091186afd5ec3ae89"><td class="mdescLeft">&#160;</td><td class="mdescRight">2-level Mean Dependency Distance \(MDD\) over an ensemble of graphs.  <a href="namespacelal_1_1linarr.html#a0b2bbd3f6c94e03091186afd5ec3ae89">More...</a><br /></td></tr>
<tr class="separator:a0b2bbd3f6c94e03091186afd5ec3ae89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac837af66d13aa3e2865a6737aec34e7a"><td class="memTemplParams" colspan="2">template&lt;class graph_t &gt; </td></tr>
<tr class="memitem:ac837af66d13aa3e2865a6737aec34e7a"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelal_1_1linarr.html#ac837af66d13aa3e2865a6737aec34e7a">mean_dependency_distance_2level</a> (const std::vector&lt; graph_t &gt; &amp;L, const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;P={}) noexcept</td></tr>
<tr class="memdesc:ac837af66d13aa3e2865a6737aec34e7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">2-level Mean Dependency Distance \(MDD\) over an ensemble of graphs.  <a href="namespacelal_1_1linarr.html#ac837af66d13aa3e2865a6737aec34e7a">More...</a><br /></td></tr>
<tr class="separator:ac837af66d13aa3e2865a6737aec34e7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3806eb869914f45cf79c15e8aa7d2a51"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1linarr.html#a3806eb869914f45cf79c15e8aa7d2a51">num_crossings</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;G, const <a class="el" href="namespacelal_1_1linarr.html#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;A=<a class="el" href="namespacelal_1_1linarr.html#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a>) noexcept</td></tr>
<tr class="memdesc:a3806eb869914f45cf79c15e8aa7d2a51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the number of edge crossings in a linear arrangement.  <a href="namespacelal_1_1linarr.html#a3806eb869914f45cf79c15e8aa7d2a51">More...</a><br /></td></tr>
<tr class="separator:a3806eb869914f45cf79c15e8aa7d2a51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d16bf5730076cd9fabd4f25a38f61de"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1linarr.html#a3d16bf5730076cd9fabd4f25a38f61de">num_crossings</a> (const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;G, const <a class="el" href="namespacelal_1_1linarr.html#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;A=<a class="el" href="namespacelal_1_1linarr.html#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a>) noexcept</td></tr>
<tr class="memdesc:a3d16bf5730076cd9fabd4f25a38f61de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the number of edge crossings in a linear arrangement.  <a href="namespacelal_1_1linarr.html#a3d16bf5730076cd9fabd4f25a38f61de">More...</a><br /></td></tr>
<tr class="separator:a3d16bf5730076cd9fabd4f25a38f61de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92f697f47063d903d2c092a6c4984595"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1linarr.html#a92f697f47063d903d2c092a6c4984595">num_crossings</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;G, const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;arr, const <a class="el" href="namespacelal_1_1linarr.html#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;A=<a class="el" href="namespacelal_1_1linarr.html#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a>) noexcept</td></tr>
<tr class="memdesc:a92f697f47063d903d2c092a6c4984595"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the number of edge crossings in a linear arrangement.  <a href="namespacelal_1_1linarr.html#a92f697f47063d903d2c092a6c4984595">More...</a><br /></td></tr>
<tr class="separator:a92f697f47063d903d2c092a6c4984595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a1346c7b927d34465602d1a0a5010c9"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1linarr.html#a9a1346c7b927d34465602d1a0a5010c9">num_crossings</a> (const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;G, const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;arr, const <a class="el" href="namespacelal_1_1linarr.html#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;A=<a class="el" href="namespacelal_1_1linarr.html#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a>) noexcept</td></tr>
<tr class="memdesc:a9a1346c7b927d34465602d1a0a5010c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the number of edge crossings in a linear arrangement.  <a href="namespacelal_1_1linarr.html#a9a1346c7b927d34465602d1a0a5010c9">More...</a><br /></td></tr>
<tr class="separator:a9a1346c7b927d34465602d1a0a5010c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a986371a18404f18e4589c7b709c55315"><td class="memItemLeft" align="right" valign="top">std::vector&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1linarr.html#a986371a18404f18e4589c7b709c55315">num_crossings_list</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;G, const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;arrs, const <a class="el" href="namespacelal_1_1linarr.html#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;A=<a class="el" href="namespacelal_1_1linarr.html#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a>) noexcept</td></tr>
<tr class="memdesc:a986371a18404f18e4589c7b709c55315"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the number of edge crossings in a linear arrangement.  <a href="namespacelal_1_1linarr.html#a986371a18404f18e4589c7b709c55315">More...</a><br /></td></tr>
<tr class="separator:a986371a18404f18e4589c7b709c55315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6282f5b1fb20e9f86a8fd6747d543262"><td class="memItemLeft" align="right" valign="top">std::vector&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1linarr.html#a6282f5b1fb20e9f86a8fd6747d543262">num_crossings_list</a> (const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;G, const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;arrs, const <a class="el" href="namespacelal_1_1linarr.html#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;A=<a class="el" href="namespacelal_1_1linarr.html#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a>) noexcept</td></tr>
<tr class="memdesc:a6282f5b1fb20e9f86a8fd6747d543262"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the number of edge crossings in a linear arrangement.  <a href="namespacelal_1_1linarr.html#a6282f5b1fb20e9f86a8fd6747d543262">More...</a><br /></td></tr>
<tr class="separator:a6282f5b1fb20e9f86a8fd6747d543262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae48dfe48482e78fb610bc5a5817565d4"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1linarr.html#ae48dfe48482e78fb610bc5a5817565d4">is_num_crossings_lesseq_than</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;G, uint64_t upper_bound, const <a class="el" href="namespacelal_1_1linarr.html#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;A=<a class="el" href="namespacelal_1_1linarr.html#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a>) noexcept</td></tr>
<tr class="memdesc:ae48dfe48482e78fb610bc5a5817565d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the number of crossings in the linear arrangement less than a constant?  <a href="namespacelal_1_1linarr.html#ae48dfe48482e78fb610bc5a5817565d4">More...</a><br /></td></tr>
<tr class="separator:ae48dfe48482e78fb610bc5a5817565d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a707361d3830e22545270ab2a7c398d57"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1linarr.html#a707361d3830e22545270ab2a7c398d57">is_num_crossings_lesseq_than</a> (const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;G, uint64_t upper_bound, const <a class="el" href="namespacelal_1_1linarr.html#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;A=<a class="el" href="namespacelal_1_1linarr.html#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a>) noexcept</td></tr>
<tr class="memdesc:a707361d3830e22545270ab2a7c398d57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the number of crossings in the linear arrangement less than a constant?  <a href="namespacelal_1_1linarr.html#a707361d3830e22545270ab2a7c398d57">More...</a><br /></td></tr>
<tr class="separator:a707361d3830e22545270ab2a7c398d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca19286a03060c4e67d8969d2664b2b3"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1linarr.html#aca19286a03060c4e67d8969d2664b2b3">is_num_crossings_lesseq_than</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;G, const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;arr, uint64_t upper_bound, const <a class="el" href="namespacelal_1_1linarr.html#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;A=<a class="el" href="namespacelal_1_1linarr.html#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a>) noexcept</td></tr>
<tr class="memdesc:aca19286a03060c4e67d8969d2664b2b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the number of crossings in the linear arrangement less than a constant?  <a href="namespacelal_1_1linarr.html#aca19286a03060c4e67d8969d2664b2b3">More...</a><br /></td></tr>
<tr class="separator:aca19286a03060c4e67d8969d2664b2b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a881660afb04df9fd72297dc17dd5ba7f"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1linarr.html#a881660afb04df9fd72297dc17dd5ba7f">is_num_crossings_lesseq_than</a> (const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;G, const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;arr, uint64_t upper_bound, const <a class="el" href="namespacelal_1_1linarr.html#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;A=<a class="el" href="namespacelal_1_1linarr.html#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a>) noexcept</td></tr>
<tr class="memdesc:a881660afb04df9fd72297dc17dd5ba7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the number of crossings in the linear arrangement less than a constant?  <a href="namespacelal_1_1linarr.html#a881660afb04df9fd72297dc17dd5ba7f">More...</a><br /></td></tr>
<tr class="separator:a881660afb04df9fd72297dc17dd5ba7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e9efc4309a83614df4a0de5b7e4f7ae"><td class="memItemLeft" align="right" valign="top">std::vector&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1linarr.html#a7e9efc4309a83614df4a0de5b7e4f7ae">is_num_crossings_lesseq_than_list</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;G, const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;arrs, uint64_t upper_bound, const <a class="el" href="namespacelal_1_1linarr.html#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;A=<a class="el" href="namespacelal_1_1linarr.html#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a>) noexcept</td></tr>
<tr class="memdesc:a7e9efc4309a83614df4a0de5b7e4f7ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the number of crossings in the linear arrangement less than a constant?  <a href="namespacelal_1_1linarr.html#a7e9efc4309a83614df4a0de5b7e4f7ae">More...</a><br /></td></tr>
<tr class="separator:a7e9efc4309a83614df4a0de5b7e4f7ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27e838cc735e0840f88ee4394af6ff77"><td class="memItemLeft" align="right" valign="top">std::vector&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1linarr.html#a27e838cc735e0840f88ee4394af6ff77">is_num_crossings_lesseq_than_list</a> (const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;G, const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;arrs, uint64_t upper_bound, const <a class="el" href="namespacelal_1_1linarr.html#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;A=<a class="el" href="namespacelal_1_1linarr.html#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a>) noexcept</td></tr>
<tr class="memdesc:a27e838cc735e0840f88ee4394af6ff77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the number of crossings in the linear arrangement less than a constant?  <a href="namespacelal_1_1linarr.html#a27e838cc735e0840f88ee4394af6ff77">More...</a><br /></td></tr>
<tr class="separator:a27e838cc735e0840f88ee4394af6ff77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae06f54984c51091894dd9bb8946547f7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1linarr.html#ae06f54984c51091894dd9bb8946547f7">is_num_crossings_lesseq_than_list</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;G, const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;arrs, const std::vector&lt; uint64_t &gt; &amp;upper_bounds, const <a class="el" href="namespacelal_1_1linarr.html#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;A=<a class="el" href="namespacelal_1_1linarr.html#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a>) noexcept</td></tr>
<tr class="memdesc:ae06f54984c51091894dd9bb8946547f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the number of crossings in the linear arrangement less than a constant?  <a href="namespacelal_1_1linarr.html#ae06f54984c51091894dd9bb8946547f7">More...</a><br /></td></tr>
<tr class="separator:ae06f54984c51091894dd9bb8946547f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a406b2456d635ac4efcbd7ed7270bf173"><td class="memItemLeft" align="right" valign="top">std::vector&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1linarr.html#a406b2456d635ac4efcbd7ed7270bf173">is_num_crossings_lesseq_than_list</a> (const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;G, const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;arrs, const std::vector&lt; uint64_t &gt; &amp;upper_bounds, const <a class="el" href="namespacelal_1_1linarr.html#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;A=<a class="el" href="namespacelal_1_1linarr.html#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a>) noexcept</td></tr>
<tr class="memdesc:a406b2456d635ac4efcbd7ed7270bf173"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the number of crossings in the linear arrangement less than a constant?  <a href="namespacelal_1_1linarr.html#a406b2456d635ac4efcbd7ed7270bf173">More...</a><br /></td></tr>
<tr class="separator:a406b2456d635ac4efcbd7ed7270bf173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5078b16561c6ebe15a88a9b6b5b574bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1linarr.html#a5078b16561c6ebe15a88a9b6b5b574bc">predicted_num_crossings_rational</a> (const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;g, const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;arr={}) noexcept</td></tr>
<tr class="memdesc:a5078b16561c6ebe15a88a9b6b5b574bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicts the number of crossings.  <a href="namespacelal_1_1linarr.html#a5078b16561c6ebe15a88a9b6b5b574bc">More...</a><br /></td></tr>
<tr class="separator:a5078b16561c6ebe15a88a9b6b5b574bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24d733f3e2029e5cfe5497708a3baf64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1linarr.html#a24d733f3e2029e5cfe5497708a3baf64">predicted_num_crossings_rational</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;g, const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;arr={}) noexcept</td></tr>
<tr class="memdesc:a24d733f3e2029e5cfe5497708a3baf64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicts the number of crossings.  <a href="namespacelal_1_1linarr.html#a24d733f3e2029e5cfe5497708a3baf64">More...</a><br /></td></tr>
<tr class="separator:a24d733f3e2029e5cfe5497708a3baf64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9db950bbaa1d8623c561142f14f06920"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1linarr.html#a9db950bbaa1d8623c561142f14f06920">predicted_num_crossings</a> (const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;g, const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;arr={}) noexcept</td></tr>
<tr class="memdesc:a9db950bbaa1d8623c561142f14f06920"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximates the number of crossings.  <a href="namespacelal_1_1linarr.html#a9db950bbaa1d8623c561142f14f06920">More...</a><br /></td></tr>
<tr class="separator:a9db950bbaa1d8623c561142f14f06920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a659d080affa5219805b9a40f6f0164e6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1linarr.html#a659d080affa5219805b9a40f6f0164e6">predicted_num_crossings</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;g, const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;arr={}) noexcept</td></tr>
<tr class="memdesc:a659d080affa5219805b9a40f6f0164e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximates the number of crossings.  <a href="namespacelal_1_1linarr.html#a659d080affa5219805b9a40f6f0164e6">More...</a><br /></td></tr>
<tr class="separator:a659d080affa5219805b9a40f6f0164e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c33c7725ebeca22b2489b29ebc78071"><td class="memItemLeft" align="right" valign="top">std::array&lt; bool, <a class="el" href="namespacelal_1_1linarr.html#a71f12918a0e2775e9a97181fddd1f7bc">__syntactic_dependency_structure_size</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1linarr.html#a6c33c7725ebeca22b2489b29ebc78071">syntactic_dependency_structure_class</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;t, uint64_t C, const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;pi={}) noexcept</td></tr>
<tr class="memdesc:a6c33c7725ebeca22b2489b29ebc78071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the type of syntactic dependency tree.  <a href="namespacelal_1_1linarr.html#a6c33c7725ebeca22b2489b29ebc78071">More...</a><br /></td></tr>
<tr class="separator:a6c33c7725ebeca22b2489b29ebc78071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1c3ede6e41fd6313d017ee2d932dada"><td class="memItemLeft" align="right" valign="top">std::array&lt; bool, <a class="el" href="namespacelal_1_1linarr.html#a71f12918a0e2775e9a97181fddd1f7bc">__syntactic_dependency_structure_size</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1linarr.html#ac1c3ede6e41fd6313d017ee2d932dada">syntactic_dependency_structure_class</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;t, const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;pi={}) noexcept</td></tr>
<tr class="memdesc:ac1c3ede6e41fd6313d017ee2d932dada"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the type of syntactic dependency tree.  <a href="namespacelal_1_1linarr.html#ac1c3ede6e41fd6313d017ee2d932dada">More...</a><br /></td></tr>
<tr class="separator:ac1c3ede6e41fd6313d017ee2d932dada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab70693683a8da54a2e4350c665067cf1"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1linarr.html#ab70693683a8da54a2e4350c665067cf1">sum_edge_lengths</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;g, const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;pi={}) noexcept</td></tr>
<tr class="memdesc:ab70693683a8da54a2e4350c665067cf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sum of the length of the edges in a linear arrangement.  <a href="namespacelal_1_1linarr.html#ab70693683a8da54a2e4350c665067cf1">More...</a><br /></td></tr>
<tr class="separator:ab70693683a8da54a2e4350c665067cf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7ded133434870e08c4473c12e7a03ce"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1linarr.html#ad7ded133434870e08c4473c12e7a03ce">sum_edge_lengths</a> (const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;g, const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;pi={}) noexcept</td></tr>
<tr class="memdesc:ad7ded133434870e08c4473c12e7a03ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sum of the length of the edges in a linear arrangement.  <a href="namespacelal_1_1linarr.html#ad7ded133434870e08c4473c12e7a03ce">More...</a><br /></td></tr>
<tr class="separator:ad7ded133434870e08c4473c12e7a03ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a679b59e355c13c9ac4969f897b731582"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1linarr.html#a679b59e355c13c9ac4969f897b731582">mean_dependency_distance_rational</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;g, const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;pi={}) noexcept</td></tr>
<tr class="memdesc:a679b59e355c13c9ac4969f897b731582"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the mean dependency distance \(MDD\) as an exact rational value.  <a href="namespacelal_1_1linarr.html#a679b59e355c13c9ac4969f897b731582">More...</a><br /></td></tr>
<tr class="separator:a679b59e355c13c9ac4969f897b731582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77d3933929930331d44200deed260a41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1linarr.html#a77d3933929930331d44200deed260a41">mean_dependency_distance_rational</a> (const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;g, const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;pi={}) noexcept</td></tr>
<tr class="memdesc:a77d3933929930331d44200deed260a41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the mean dependency distance \(MDD\) as an exact rational value.  <a href="namespacelal_1_1linarr.html#a77d3933929930331d44200deed260a41">More...</a><br /></td></tr>
<tr class="separator:a77d3933929930331d44200deed260a41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2030c0f279ced9571405cebe5675e241"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1linarr.html#a2030c0f279ced9571405cebe5675e241">mean_dependency_distance</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;g, const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;pi={}) noexcept</td></tr>
<tr class="memdesc:a2030c0f279ced9571405cebe5675e241"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the mean dependency distance \(MDD\) as a floating point value.  <a href="namespacelal_1_1linarr.html#a2030c0f279ced9571405cebe5675e241">More...</a><br /></td></tr>
<tr class="separator:a2030c0f279ced9571405cebe5675e241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43bba5ac9ff41d48b5320b70d9e4f403"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1linarr.html#a43bba5ac9ff41d48b5320b70d9e4f403">mean_dependency_distance</a> (const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;g, const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;pi={}) noexcept</td></tr>
<tr class="memdesc:a43bba5ac9ff41d48b5320b70d9e4f403"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the mean dependency distance \(MDD\) as a floating point value.  <a href="namespacelal_1_1linarr.html#a43bba5ac9ff41d48b5320b70d9e4f403">More...</a><br /></td></tr>
<tr class="separator:a43bba5ac9ff41d48b5320b70d9e4f403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aece830c5bd25ce649ef421799677bbff"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classlal_1_1linarr_1_1dependency__flux.html">dependency_flux</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1linarr.html#aece830c5bd25ce649ef421799677bbff">compute_flux</a> (const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;t, const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;pi={}) noexcept</td></tr>
<tr class="memdesc:aece830c5bd25ce649ef421799677bbff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the flux of a dependency tree.  <a href="namespacelal_1_1linarr.html#aece830c5bd25ce649ef421799677bbff">More...</a><br /></td></tr>
<tr class="separator:aece830c5bd25ce649ef421799677bbff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fbd328b68242fee1f44a6f1e537b0e3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classlal_1_1linarr_1_1dependency__flux.html">dependency_flux</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1linarr.html#a8fbd328b68242fee1f44a6f1e537b0e3">compute_flux</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;t, const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;pi={}) noexcept</td></tr>
<tr class="memdesc:a8fbd328b68242fee1f44a6f1e537b0e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the flux of a dependency tree.  <a href="namespacelal_1_1linarr.html#a8fbd328b68242fee1f44a6f1e537b0e3">More...</a><br /></td></tr>
<tr class="separator:a8fbd328b68242fee1f44a6f1e537b0e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadd6d6ed9cadb57228200d32c3a99191"><td class="memItemLeft" align="right" valign="top">std::pair&lt; uint64_t, <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1linarr.html#aadd6d6ed9cadb57228200d32c3a99191">max_sum_edge_lengths_planar</a> (const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:aadd6d6ed9cadb57228200d32c3a99191"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the maximum value of \(D\) in trees under the planarity constraint.  <a href="namespacelal_1_1linarr.html#aadd6d6ed9cadb57228200d32c3a99191">More...</a><br /></td></tr>
<tr class="separator:aadd6d6ed9cadb57228200d32c3a99191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95e4fa9607ca43dfe0ba110eb9e2ddd7"><td class="memItemLeft" align="right" valign="top">std::pair&lt; uint64_t, <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1linarr.html#a95e4fa9607ca43dfe0ba110eb9e2ddd7">max_sum_edge_lengths_planar</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:a95e4fa9607ca43dfe0ba110eb9e2ddd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the maximum value of \(D\) in trees under the planarity constraint.  <a href="namespacelal_1_1linarr.html#a95e4fa9607ca43dfe0ba110eb9e2ddd7">More...</a><br /></td></tr>
<tr class="separator:a95e4fa9607ca43dfe0ba110eb9e2ddd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a605f9fb7f2214a6dfd4021c12134a85c"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; uint64_t &gt;, <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1linarr.html#a605f9fb7f2214a6dfd4021c12134a85c">max_sum_edge_lengths_projective_roots</a> (const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:a605f9fb7f2214a6dfd4021c12134a85c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the maximum value of \(D\) in trees under the projectivity constraint at every vertex of the tree.  <a href="namespacelal_1_1linarr.html#a605f9fb7f2214a6dfd4021c12134a85c">More...</a><br /></td></tr>
<tr class="separator:a605f9fb7f2214a6dfd4021c12134a85c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d92a7d183caf25d9c881f8ee9d3833c"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; uint64_t &gt;, <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1linarr.html#a4d92a7d183caf25d9c881f8ee9d3833c">max_sum_edge_lengths_projective_roots</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:a4d92a7d183caf25d9c881f8ee9d3833c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the maximum value of \(D\) in trees under the projectivity constraint at every vertex of the tree.  <a href="namespacelal_1_1linarr.html#a4d92a7d183caf25d9c881f8ee9d3833c">More...</a><br /></td></tr>
<tr class="separator:a4d92a7d183caf25d9c881f8ee9d3833c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0886a4326be3b40cf34ee526514d60ab"><td class="memItemLeft" align="right" valign="top">std::pair&lt; uint64_t, <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1linarr.html#a0886a4326be3b40cf34ee526514d60ab">max_sum_edge_lengths_projective</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:a0886a4326be3b40cf34ee526514d60ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the maximum value of \(D\) in rooted trees under the projectivity constraint.  <a href="namespacelal_1_1linarr.html#a0886a4326be3b40cf34ee526514d60ab">More...</a><br /></td></tr>
<tr class="separator:a0886a4326be3b40cf34ee526514d60ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a450d0dd41fec42a39bb1204ecedaaa91"><td class="memItemLeft" align="right" valign="top">std::pair&lt; uint64_t, <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1linarr.html#a450d0dd41fec42a39bb1204ecedaaa91">min_sum_edge_lengths</a> (const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;t, const <a class="el" href="namespacelal_1_1linarr.html#a1c6a617eb12e032ee641fd390776ff3f">algorithms_Dmin</a> &amp;a=<a class="el" href="namespacelal_1_1linarr.html#a1c6a617eb12e032ee641fd390776ff3fae04de66d6cf0f6c6ec4036288f66bbed">algorithms_Dmin::Shiloach</a>) noexcept</td></tr>
<tr class="memdesc:a450d0dd41fec42a39bb1204ecedaaa91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the minimum value of \(D\) in free trees.  <a href="namespacelal_1_1linarr.html#a450d0dd41fec42a39bb1204ecedaaa91">More...</a><br /></td></tr>
<tr class="separator:a450d0dd41fec42a39bb1204ecedaaa91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22429c80001ad8fd3dbed68a59ef29fb"><td class="memItemLeft" align="right" valign="top">std::pair&lt; uint64_t, <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1linarr.html#a22429c80001ad8fd3dbed68a59ef29fb">min_sum_edge_lengths</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;t, const <a class="el" href="namespacelal_1_1linarr.html#a1c6a617eb12e032ee641fd390776ff3f">algorithms_Dmin</a> &amp;a=<a class="el" href="namespacelal_1_1linarr.html#a1c6a617eb12e032ee641fd390776ff3fae04de66d6cf0f6c6ec4036288f66bbed">algorithms_Dmin::Shiloach</a>) noexcept</td></tr>
<tr class="memdesc:a22429c80001ad8fd3dbed68a59ef29fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the minimum value of \(D\) in trees.  <a href="namespacelal_1_1linarr.html#a22429c80001ad8fd3dbed68a59ef29fb">More...</a><br /></td></tr>
<tr class="separator:a22429c80001ad8fd3dbed68a59ef29fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ee049d439a7e8dd41ac0145679a84bb"><td class="memItemLeft" align="right" valign="top">std::pair&lt; uint64_t, <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1linarr.html#a8ee049d439a7e8dd41ac0145679a84bb">min_sum_edge_lengths_planar</a> (const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;t, const <a class="el" href="namespacelal_1_1linarr.html#a4a49efcc64c3b63502ad8cc18d508ce3">algorithms_Dmin_planar</a> &amp;a=<a class="el" href="namespacelal_1_1linarr.html#a4a49efcc64c3b63502ad8cc18d508ce3a37e3b966cac6fa2c0f649bd5cb42adca">algorithms_Dmin_planar::AlemanyEstebanFerrer</a>) noexcept</td></tr>
<tr class="memdesc:a8ee049d439a7e8dd41ac0145679a84bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the minimum value of \(D\) in trees under the planarity constraint.  <a href="namespacelal_1_1linarr.html#a8ee049d439a7e8dd41ac0145679a84bb">More...</a><br /></td></tr>
<tr class="separator:a8ee049d439a7e8dd41ac0145679a84bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab154f955e7f6887c6d8115108a4bf242"><td class="memItemLeft" align="right" valign="top">std::pair&lt; uint64_t, <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1linarr.html#ab154f955e7f6887c6d8115108a4bf242">min_sum_edge_lengths_planar</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;t, const <a class="el" href="namespacelal_1_1linarr.html#a4a49efcc64c3b63502ad8cc18d508ce3">algorithms_Dmin_planar</a> &amp;a=<a class="el" href="namespacelal_1_1linarr.html#a4a49efcc64c3b63502ad8cc18d508ce3a37e3b966cac6fa2c0f649bd5cb42adca">algorithms_Dmin_planar::AlemanyEstebanFerrer</a>) noexcept</td></tr>
<tr class="memdesc:ab154f955e7f6887c6d8115108a4bf242"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the minimum value of \(D\) in trees under the planarity constraint.  <a href="namespacelal_1_1linarr.html#ab154f955e7f6887c6d8115108a4bf242">More...</a><br /></td></tr>
<tr class="separator:ab154f955e7f6887c6d8115108a4bf242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff8ac86ade398306f32ee39692ebfe4a"><td class="memItemLeft" align="right" valign="top">std::pair&lt; uint64_t, <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1linarr.html#aff8ac86ade398306f32ee39692ebfe4a">min_sum_edge_lengths_projective</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;t, const <a class="el" href="namespacelal_1_1linarr.html#a30bc00af5439a56f037ed84875f1911f">algorithms_Dmin_projective</a> &amp;a=<a class="el" href="namespacelal_1_1linarr.html#a30bc00af5439a56f037ed84875f1911fa37e3b966cac6fa2c0f649bd5cb42adca">algorithms_Dmin_projective::AlemanyEstebanFerrer</a>) noexcept</td></tr>
<tr class="memdesc:aff8ac86ade398306f32ee39692ebfe4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the minimum value of \(D\) in rooted trees under the projectivity constraint.  <a href="namespacelal_1_1linarr.html#aff8ac86ade398306f32ee39692ebfe4a">More...</a><br /></td></tr>
<tr class="separator:aff8ac86ade398306f32ee39692ebfe4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b3203432e13dfec29563796643e6187"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1linarr.html#a6b3203432e13dfec29563796643e6187">is_permutation</a> (const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;arr={}) noexcept</td></tr>
<tr class="memdesc:a6b3203432e13dfec29563796643e6187"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is a given input arrangement a permutation?  <a href="namespacelal_1_1linarr.html#a6b3203432e13dfec29563796643e6187">More...</a><br /></td></tr>
<tr class="separator:a6b3203432e13dfec29563796643e6187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b1d2f0e450b5f30c29e111884cc9ce8"><td class="memTemplParams" colspan="2">template&lt;class graph_t &gt; </td></tr>
<tr class="memitem:a6b1d2f0e450b5f30c29e111884cc9ce8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelal_1_1linarr.html#a6b1d2f0e450b5f30c29e111884cc9ce8">is_arrangement</a> (const graph_t &amp;g, const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;arr) noexcept</td></tr>
<tr class="memdesc:a6b1d2f0e450b5f30c29e111884cc9ce8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is a given arrangement valid?  <a href="namespacelal_1_1linarr.html#a6b1d2f0e450b5f30c29e111884cc9ce8">More...</a><br /></td></tr>
<tr class="separator:a6b1d2f0e450b5f30c29e111884cc9ce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeb1b7dcc4cda2e1c366e02b2d03c627"><td class="memTemplParams" colspan="2">template&lt;class graph_t &gt; </td></tr>
<tr class="memitem:aaeb1b7dcc4cda2e1c366e02b2d03c627"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelal_1_1linarr.html#aaeb1b7dcc4cda2e1c366e02b2d03c627">is_planar</a> (const graph_t &amp;g, const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;arr={}) noexcept</td></tr>
<tr class="memdesc:aaeb1b7dcc4cda2e1c366e02b2d03c627"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is a given arrangement planar?  <a href="namespacelal_1_1linarr.html#aaeb1b7dcc4cda2e1c366e02b2d03c627">More...</a><br /></td></tr>
<tr class="separator:aaeb1b7dcc4cda2e1c366e02b2d03c627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78b17d7726acf0ce82625c3d13987bfa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1linarr.html#a78b17d7726acf0ce82625c3d13987bfa">is_root_covered</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;rt, const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;arr) noexcept</td></tr>
<tr class="memdesc:a78b17d7726acf0ce82625c3d13987bfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the root of a rooted tree covered in a given arrangement?  <a href="namespacelal_1_1linarr.html#a78b17d7726acf0ce82625c3d13987bfa">More...</a><br /></td></tr>
<tr class="separator:a78b17d7726acf0ce82625c3d13987bfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae404b93b3b1730f61299f78f4ba89585"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1linarr.html#ae404b93b3b1730f61299f78f4ba89585">is_projective</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;rt, const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;arr) noexcept</td></tr>
<tr class="memdesc:ae404b93b3b1730f61299f78f4ba89585"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is a given arrangement projective?  <a href="namespacelal_1_1linarr.html#ae404b93b3b1730f61299f78f4ba89585">More...</a><br /></td></tr>
<tr class="separator:ae404b93b3b1730f61299f78f4ba89585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a057b0d2eb4b8df8ed96d2a258b83035f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1linarr.html#a057b0d2eb4b8df8ed96d2a258b83035f">head_initial_rational</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;g, const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;pi={}) noexcept</td></tr>
<tr class="memdesc:a057b0d2eb4b8df8ed96d2a258b83035f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the headedness of a directed graph as an exact rational number.  <a href="namespacelal_1_1linarr.html#a057b0d2eb4b8df8ed96d2a258b83035f">More...</a><br /></td></tr>
<tr class="separator:a057b0d2eb4b8df8ed96d2a258b83035f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc15417e84e2d272ca8d49a266929e12"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1linarr.html#acc15417e84e2d272ca8d49a266929e12">head_initial</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;g, const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;pi={}) noexcept</td></tr>
<tr class="memdesc:acc15417e84e2d272ca8d49a266929e12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the headedness of a linearly arranged directed graph.  <a href="namespacelal_1_1linarr.html#acc15417e84e2d272ca8d49a266929e12">More...</a><br /></td></tr>
<tr class="separator:acc15417e84e2d272ca8d49a266929e12"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a71f12918a0e2775e9a97181fddd1f7bc"><td class="memItemLeft" align="right" valign="top"><a id="a71f12918a0e2775e9a97181fddd1f7bc" name="a71f12918a0e2775e9a97181fddd1f7bc"></a>
constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>__syntactic_dependency_structure_size</b></td></tr>
<tr class="memdesc:a71f12918a0e2775e9a97181fddd1f7bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of elements within enumeration <a class="el" href="namespacelal_1_1linarr.html#a3e8b744d4c81d3bb4463ec203f9199d6">syntactic_dependency_structure</a>. <br /></td></tr>
<tr class="separator:a71f12918a0e2775e9a97181fddd1f7bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Namespace for all linear-arrangement-dependent algorithms. </p>
<p >This namespace contains functions to calculate properties of graphs that depend on a linear arrangement. Said arrangement van be given explicitly, i.e., by constructing a <a class="el" href="classlal_1_1linear__arrangement.html">lal::linear_arrangement</a> object, or by omitting it in the functions to let these use the labelling of the graph (to read more about the concept of linear arrangement see the <a class="el" href="LAL_concepts.html#LAL_concepts__linear_arrangement">Linear Arrangement</a> page). For example, given a graph</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classlal_1_1graphs_1_1undirected__graph.html">lal::graphs::undirected_graph</a> g;</div>
<div class="ttc" id="aclasslal_1_1graphs_1_1undirected__graph_html"><div class="ttname"><a href="classlal_1_1graphs_1_1undirected__graph.html">lal::graphs::undirected_graph</a></div><div class="ttdoc">Undirected graph class.</div><div class="ttdef"><b>Definition:</b> undirected_graph.hpp:67</div></div>
</div><!-- fragment --><p >we can calculate the sum of length of the edges using function <a class="el" href="namespacelal_1_1linarr.html#ab70693683a8da54a2e4350c665067cf1">lal::linarr::sum_edge_lengths</a> in two different ways. The first is by omitting the arrangement:</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="namespacelal_1_1linarr.html#ab70693683a8da54a2e4350c665067cf1">lal::linarr::sum_edge_lengths</a>(g);</div>
<div class="ttc" id="anamespacelal_1_1linarr_html_ab70693683a8da54a2e4350c665067cf1"><div class="ttname"><a href="namespacelal_1_1linarr.html#ab70693683a8da54a2e4350c665067cf1">lal::linarr::sum_edge_lengths</a></div><div class="ttdeci">uint64_t sum_edge_lengths(const graphs::directed_graph &amp;g, const linear_arrangement &amp;pi={}) noexcept</div><div class="ttdoc">Computes the sum of the length of the edges in a linear arrangement.</div></div>
</div><!-- fragment --><p >or by giving one explicitly</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="namespacelal_1_1linarr.html#ab70693683a8da54a2e4350c665067cf1">lal::linarr::sum_edge_lengths</a>(g, {...});</div>
</div><!-- fragment --> </div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="aa7dc22d99964e6a6bb1fe5dd096e64b7" name="aa7dc22d99964e6a6bb1fe5dd096e64b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">&#9670;&#160;</a></span>algorithms_C</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespacelal_1_1linarr.html#aa7dc22d99964e6a6bb1fe5dd096e64b7">lal::linarr::algorithms_C</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The different algorithms for computing the number of crossings. </p>
<p >Two edges \(\{s,t\},\{u,v\}\) of a graph \(G\) cross in a linear arrangement \(\pi\) of its nodes if, and only if, their positions interleave in the linear arrangement. More formally, given an arrangement \(\pi\) of a graph \(G\), the edges \(\{s,t\},\{u,v\}\) cros iff \(\pi(s) &lt; \pi(u) &lt; \pi(t) &lt; \pi(v)\) . </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa7dc22d99964e6a6bb1fe5dd096e64b7a14eb8fb55e00336d36cb281764c88aa5" name="aa7dc22d99964e6a6bb1fe5dd096e64b7a14eb8fb55e00336d36cb281764c88aa5"></a>brute_force&#160;</td><td class="fielddoc"><p >Brute force computation of the number of crossings. </p>
<p >Complexity: time \(O(m^2)\), space \(O(1)\). </p>
</td></tr>
<tr><td class="fieldname"><a id="aa7dc22d99964e6a6bb1fe5dd096e64b7a724c4582f391c030da5a79ad83de9ecf" name="aa7dc22d99964e6a6bb1fe5dd096e64b7a724c4582f391c030da5a79ad83de9ecf"></a>dynamic_programming&#160;</td><td class="fielddoc"><p >Dynamic programming algorithm <a class="el" href="citelist.html#CITEREF_Alemany2019a">[8]</a>. </p>
<p >Complexity: time \(O(n^2)\), space \(O(n^2)\). </p>
</td></tr>
<tr><td class="fieldname"><a id="aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06" name="aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06"></a>ladder&#160;</td><td class="fielddoc"><p >Dynamic programming algorithm <a class="el" href="citelist.html#CITEREF_Alemany2019a">[8]</a>. </p>
<p >Complexity: time \(O(n^2)\), space \(O(n)\). </p>
</td></tr>
<tr><td class="fieldname"><a id="aa7dc22d99964e6a6bb1fe5dd096e64b7aea9e5920d6313045f9549b9a8808c8a7" name="aa7dc22d99964e6a6bb1fe5dd096e64b7aea9e5920d6313045f9549b9a8808c8a7"></a>stack_based&#160;</td><td class="fielddoc"><p >Algorithm based on sorting <a class="el" href="citelist.html#CITEREF_Alemany2019a">[8]</a>. </p>
<p >Complexity: time \(O(m\log n)\), space \(O(m)\). </p>
</td></tr>
</table>

</div>
</div>
<a id="a1c6a617eb12e032ee641fd390776ff3f" name="a1c6a617eb12e032ee641fd390776ff3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c6a617eb12e032ee641fd390776ff3f">&#9670;&#160;</a></span>algorithms_Dmin</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespacelal_1_1linarr.html#a1c6a617eb12e032ee641fd390776ff3f">lal::linarr::algorithms_Dmin</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The different algorithms for computing the minimum sum of the length of the edges \(D\). </p>
<p >This enumeration's values are used to choose the algorithm which the functions <a class="el" href="namespacelal_1_1linarr.html#a450d0dd41fec42a39bb1204ecedaaa91">lal::linarr::min_sum_edge_lengths</a> use to compute the minimum value of the sum of the length of the edges \(D\). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1c6a617eb12e032ee641fd390776ff3fae04de66d6cf0f6c6ec4036288f66bbed" name="a1c6a617eb12e032ee641fd390776ff3fae04de66d6cf0f6c6ec4036288f66bbed"></a>Shiloach&#160;</td><td class="fielddoc"><p >Yossi Shiloach's algorithm. </p>
<p >Shiloach's quadratic algorithm \(O(n^{2.2})\). Said algorithm was published in <a class="el" href="citelist.html#CITEREF_Shiloach1979a">[34]</a>, but the implementation applies the correction published in <a class="el" href="citelist.html#CITEREF_Esteban2017a">[13]</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1c6a617eb12e032ee641fd390776ff3fa6b1d14e66c988ccd420887b0774de1d6" name="a1c6a617eb12e032ee641fd390776ff3fa6b1d14e66c988ccd420887b0774de1d6"></a>Chung_2&#160;</td><td class="fielddoc"><p >Fan Chung's quadratic algorithm. </p>
<p >Fan Chung's quadratic algorithm \(O(n^2)\). Said algorithm was published in <a class="el" href="citelist.html#CITEREF_Chung1984a">[11]</a>. In particular, this implements Fan Chung's quadratic algorithm (Section 3). </p>
</td></tr>
</table>

</div>
</div>
<a id="a4a49efcc64c3b63502ad8cc18d508ce3" name="a4a49efcc64c3b63502ad8cc18d508ce3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a49efcc64c3b63502ad8cc18d508ce3">&#9670;&#160;</a></span>algorithms_Dmin_planar</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespacelal_1_1linarr.html#a4a49efcc64c3b63502ad8cc18d508ce3">lal::linarr::algorithms_Dmin_planar</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The different algorithms for computing the minimum sum of the length of the edges \(D\) in planar arrangements of free trees. </p>
<p >Recall that a planar arrangement is one in which there are no edge crossings.</p>
<p >This enumeration's values are used to choose the algorithm which the functions <a class="el" href="namespacelal_1_1linarr.html#a8ee049d439a7e8dd41ac0145679a84bb">lal::linarr::min_sum_edge_lengths_planar</a> use to compute the minimum value of the sum of the length of the edges \(D\). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a4a49efcc64c3b63502ad8cc18d508ce3a37e3b966cac6fa2c0f649bd5cb42adca" name="a4a49efcc64c3b63502ad8cc18d508ce3a37e3b966cac6fa2c0f649bd5cb42adca"></a>AlemanyEstebanFerrer&#160;</td><td class="fielddoc"><p >Alemany-Esteban-Ferrer's algorithm. </p>
<p >Interval-based approach to the calculation of minimum planar arrangements. Algorithm published in <a class="el" href="citelist.html#CITEREF_Alemany2022a">[7]</a>.</p>
<p >This algorithm's complexity is \(O(n)\). </p>
</td></tr>
<tr><td class="fieldname"><a id="a4a49efcc64c3b63502ad8cc18d508ce3a5420b4f3654df1cf130da66c7a7aba6b" name="a4a49efcc64c3b63502ad8cc18d508ce3a5420b4f3654df1cf130da66c7a7aba6b"></a>HochbergStallmann&#160;</td><td class="fielddoc"><p >Hochberg-Stallmann's algorithm. </p>
<p >Displacement-based approach to the calculation of minimum planar arrangements. The algorithm was originally published in <a class="el" href="citelist.html#CITEREF_Hochberg2003a">[24]</a>, however, the implementation uses the correction in <a class="el" href="citelist.html#CITEREF_Alemany2022a">[7]</a>.</p>
<p >This algorithm's complexity is \(O(n)\). </p>
</td></tr>
</table>

</div>
</div>
<a id="a30bc00af5439a56f037ed84875f1911f" name="a30bc00af5439a56f037ed84875f1911f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30bc00af5439a56f037ed84875f1911f">&#9670;&#160;</a></span>algorithms_Dmin_projective</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespacelal_1_1linarr.html#a30bc00af5439a56f037ed84875f1911f">lal::linarr::algorithms_Dmin_projective</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The different algorithms for computing the minimum sum of the length of the edges \(D\) in projective arrangements of rooted trees. </p>
<p >Recall that a projective arrangement is one in which there are no edge crossings and the root is not covered by any edge.</p>
<p >This enumeration's values are used to choose the algorithm which the functions <a class="el" href="namespacelal_1_1linarr.html#aff8ac86ade398306f32ee39692ebfe4a">lal::linarr::min_sum_edge_lengths_projective</a> use to compute the minimum value of the sum of the length of the edges \(D\). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a30bc00af5439a56f037ed84875f1911fa37e3b966cac6fa2c0f649bd5cb42adca" name="a30bc00af5439a56f037ed84875f1911fa37e3b966cac6fa2c0f649bd5cb42adca"></a>AlemanyEstebanFerrer&#160;</td><td class="fielddoc"><p >Alemany-Esteban-Ferrer's algorithm. </p>
<p >Interval-based approach to the calculation of minimum projective arrangements. Algorithm published in <a class="el" href="citelist.html#CITEREF_Alemany2022a">[7]</a>.</p>
<p >This algorithm's complexity is \(O(n)\). </p>
</td></tr>
<tr><td class="fieldname"><a id="a30bc00af5439a56f037ed84875f1911fa5420b4f3654df1cf130da66c7a7aba6b" name="a30bc00af5439a56f037ed84875f1911fa5420b4f3654df1cf130da66c7a7aba6b"></a>HochbergStallmann&#160;</td><td class="fielddoc"><p >Hochberg-Stallmann's algorithm. </p>
<p >Displacement-based approach to the calculation of minimum projective arrangements. The algorithm was originally published in <a class="el" href="citelist.html#CITEREF_Hochberg2003a">[24]</a>, however, the implementation uses the correction in <a class="el" href="citelist.html#CITEREF_Alemany2022a">[7]</a>.</p>
<p >This algorithm's complexity is \(O(n)\). </p>
</td></tr>
</table>

</div>
</div>
<a id="a3e8b744d4c81d3bb4463ec203f9199d6" name="a3e8b744d4c81d3bb4463ec203f9199d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e8b744d4c81d3bb4463ec203f9199d6">&#9670;&#160;</a></span>syntactic_dependency_structure</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespacelal_1_1linarr.html#a3e8b744d4c81d3bb4463ec203f9199d6">lal::linarr::syntactic_dependency_structure</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The different types of syntactic dependency tree structures. </p>
<p >Any tree with its nodes linearly arranged can be classified into several different classes.</p>
<p >We can currently identify the following structures:</p><ul>
<li>Projective structures (see <a class="el" href="namespacelal_1_1linarr.html#a3e8b744d4c81d3bb4463ec203f9199d6a768db0c0fba3c72a9886b833efe822ce">syntactic_dependency_structure::projective</a>),</li>
<li>Planar structures (see <a class="el" href="namespacelal_1_1linarr.html#a3e8b744d4c81d3bb4463ec203f9199d6a3be411765e710adc7764f5056e44138c">syntactic_dependency_structure::planar</a>),</li>
<li>Well nested trees with maximum degree gap 1 (see <a class="el" href="namespacelal_1_1linarr.html#a3e8b744d4c81d3bb4463ec203f9199d6acf92d51d12b1fc006d0a126c327caa14">syntactic_dependency_structure::WG1</a>),</li>
<li>1-Endpoint Crossing (see <a class="el" href="namespacelal_1_1linarr.html#a3e8b744d4c81d3bb4463ec203f9199d6a118c01813b90ed2f2630b6d66992ef7d">syntactic_dependency_structure::EC1</a>), </li>
</ul>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a3e8b744d4c81d3bb4463ec203f9199d6a118c01813b90ed2f2630b6d66992ef7d" name="a3e8b744d4c81d3bb4463ec203f9199d6a118c01813b90ed2f2630b6d66992ef7d"></a>EC1&#160;</td><td class="fielddoc"><p >1-Endpoint Crossing. </p>
<p >A structure is 1-endpoint crossing if, given any dependency, all other dependencies crossing it are incident to a common node. See <a class="el" href="citelist.html#CITEREF_Pitler2013a">[33]</a> for further details. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3e8b744d4c81d3bb4463ec203f9199d6a3be411765e710adc7764f5056e44138c" name="a3e8b744d4c81d3bb4463ec203f9199d6a3be411765e710adc7764f5056e44138c"></a>planar&#160;</td><td class="fielddoc"><p >Planar structures. </p>
<p >A structure is planar if none of its dependencies cross. Two dependencies \((s,t), (u,v)\) cross if, and only if, their positions in the arrangement are interleaved, i.e., if \(\pi(s) &lt; \pi(u) &lt; \pi(t) &lt; \pi(v)\), assuming that \(s\) precedes \(t\) and \(u\) precedes \(v\) in the arrangement. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3e8b744d4c81d3bb4463ec203f9199d6a768db0c0fba3c72a9886b833efe822ce" name="a3e8b744d4c81d3bb4463ec203f9199d6a768db0c0fba3c72a9886b833efe822ce"></a>projective&#160;</td><td class="fielddoc"><p >Projective structures. </p>
<p >A structure is projective if it is <a class="el" href="namespacelal_1_1linarr.html#a3e8b744d4c81d3bb4463ec203f9199d6a3be411765e710adc7764f5056e44138c">syntactic_dependency_structure::planar</a> and the root is not covered by any dependency. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3e8b744d4c81d3bb4463ec203f9199d6acf92d51d12b1fc006d0a126c327caa14" name="a3e8b744d4c81d3bb4463ec203f9199d6acf92d51d12b1fc006d0a126c327caa14"></a>WG1&#160;</td><td class="fielddoc"><p >Well nested trees with maximum gap-degree 1. </p>
<p >For further details and a thorough discussion, see <a class="el" href="citelist.html#CITEREF_Gomez2011a">[21]</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3e8b744d4c81d3bb4463ec203f9199d6aad921d60486366258809553a3db49a4a" name="a3e8b744d4c81d3bb4463ec203f9199d6aad921d60486366258809553a3db49a4a"></a>unknown&#160;</td><td class="fielddoc"><p >The structure could not be classified. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aece830c5bd25ce649ef421799677bbff" name="aece830c5bd25ce649ef421799677bbff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aece830c5bd25ce649ef421799677bbff">&#9670;&#160;</a></span>compute_flux() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classlal_1_1linarr_1_1dependency__flux.html">dependency_flux</a> &gt; lal::linarr::compute_flux </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;&#160;</td>
          <td class="paramname"><em>pi</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the flux of a dependency tree. </p>
<p >This function is implemented based on the explanations given in <a class="el" href="citelist.html#CITEREF_Kahane2017a">[26]</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input free tree (or dependency tree). </td></tr>
    <tr><td class="paramname">pi</td><td>A linear arrangement of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The set of dependency fluxes in the arrangement. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The tree <em>t</em> is a valid free tree. Method <a class="el" href="classlal_1_1graphs_1_1tree.html#a25c8d57865fa5f7cb5d101fd5d07fe2d" title="Is this graph is an actual tree?">graphs::free_tree::is_tree</a> returns true. </dd></dl>

</div>
</div>
<a id="a8fbd328b68242fee1f44a6f1e537b0e3" name="a8fbd328b68242fee1f44a6f1e537b0e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fbd328b68242fee1f44a6f1e537b0e3">&#9670;&#160;</a></span>compute_flux() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classlal_1_1linarr_1_1dependency__flux.html">dependency_flux</a> &gt; lal::linarr::compute_flux </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;&#160;</td>
          <td class="paramname"><em>pi</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the flux of a dependency tree. </p>
<p >This function is implemented based on the explanations given in <a class="el" href="citelist.html#CITEREF_Kahane2017a">[26]</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input rooted tree (or dependency tree). </td></tr>
    <tr><td class="paramname">pi</td><td>A linear arrangement of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The set of dependency fluxes in the arrangement. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The tree <em>t</em> is a valid rooted tree. Method <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#af464d98b1b5dfdbaaacea553d9c89154" title="Is this tree a valid rooted tree?">graphs::rooted_tree::is_rooted_tree</a> returns true. </dd></dl>

</div>
</div>
<a id="acc15417e84e2d272ca8d49a266929e12" name="acc15417e84e2d272ca8d49a266929e12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc15417e84e2d272ca8d49a266929e12">&#9670;&#160;</a></span>head_initial()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double lal::linarr::head_initial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;&#160;</td>
          <td class="paramname"><em>pi</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the headedness of a linearly arranged directed graph. </p>
<p >See <a class="el" href="namespacelal_1_1linarr.html#a057b0d2eb4b8df8ed96d2a258b83035f">lal::linarr::head_initial_rational</a> for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">pi</td><td>Permutation of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return value is a floating point value. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>\(m &gt; 0\). </dd></dl>

</div>
</div>
<a id="a057b0d2eb4b8df8ed96d2a258b83035f" name="a057b0d2eb4b8df8ed96d2a258b83035f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a057b0d2eb4b8df8ed96d2a258b83035f">&#9670;&#160;</a></span>head_initial_rational()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a> lal::linarr::head_initial_rational </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;&#160;</td>
          <td class="paramname"><em>pi</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the headedness of a directed graph as an exact rational number. </p>
<p >Given a graph and a permutation of its nodes, the headedness \(h\) is the ratio of right-branching edges over the total amount of edges. More precisely, it is</p>
<p >\(h = \frac{r}{m}\)</p>
<p >where \(r\) is the number of right-branching edges and \(m\) is the number of edges of the graph.</p>
<p >A value of 0 indicates perfect left branching, and a value of 1 indicates perfect right-branching. See <a class="el" href="citelist.html#CITEREF_Liu2010a">[27]</a> for further detals. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">pi</td><td>Permutation of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The headedness ratio as an exact rational number. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>\(m &gt; 0\). </dd></dl>

</div>
</div>
<a id="a6b1d2f0e450b5f30c29e111884cc9ce8" name="a6b1d2f0e450b5f30c29e111884cc9ce8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b1d2f0e450b5f30c29e111884cc9ce8">&#9670;&#160;</a></span>is_arrangement()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class graph_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::linarr::is_arrangement </td>
          <td>(</td>
          <td class="paramtype">const graph_t &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;&#160;</td>
          <td class="paramname"><em>arr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is a given arrangement valid? </p>
<p >Checks that an input arrangement is valid for the corresponding input graph. An arrangement is valid if it is a valid permutation of the vertices of the graph. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arr</td><td>Input arrangement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the input arrangement is a valid permutation. </dd></dl>

</div>
</div>
<a id="aca19286a03060c4e67d8969d2664b2b3" name="aca19286a03060c4e67d8969d2664b2b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca19286a03060c4e67d8969d2664b2b3">&#9670;&#160;</a></span>is_num_crossings_lesseq_than() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lal::linarr::is_num_crossings_lesseq_than </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>upper_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal_1_1linarr.html#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em> = <code><a class="el" href="namespacelal_1_1linarr.html#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the number of crossings in the linear arrangement less than a constant? </p>
<p >Given a graph \(G\) and a linear arrangements \(\pi\) of its nodes, returns the number of edge crossings \(C_{\pi}(G)\) if it is less than or equal to the given upper bound constant \(u\). In case the number of crossings is greater, returns a value strictly larger than the upper bound. This function uses a modified version of the algorithm specified by the parameter <em>A</em>. The modification involves early termination in case the actual number of crossings is strictly larger than the upper bound. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arr</td><td>A linear arrangement of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
    <tr><td class="paramname">upper_bound</td><td>Upper bound on the number of crossings. </td></tr>
    <tr><td class="paramname">A</td><td>Algorithm to use to compute the number of crossings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of crossings \(C\) if said number is less than or equal to the upper bound. The function returns a value strictly larger than the upper bound if otherwise. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The preconditions of this function depend on the choice of algorithm. See the preconditions of each algorithm in <a class="el" href="namespacelal_1_1linarr.html#aa7dc22d99964e6a6bb1fe5dd096e64b7">lal::linarr::algorithms_C</a>. </dd></dl>

</div>
</div>
<a id="ae48dfe48482e78fb610bc5a5817565d4" name="ae48dfe48482e78fb610bc5a5817565d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae48dfe48482e78fb610bc5a5817565d4">&#9670;&#160;</a></span>is_num_crossings_lesseq_than() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lal::linarr::is_num_crossings_lesseq_than </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>upper_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal_1_1linarr.html#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em> = <code><a class="el" href="namespacelal_1_1linarr.html#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the number of crossings in the linear arrangement less than a constant? </p>
<p >Given a graph \(G\) computes the number of edge crossings using the identity arrangement \(\pi_I\), \(C_{\pi_I}(G)\), if it is less than or equal to the given upper bound constant \(u\). In case the number of crossings is greater, returns a value strictly larger than the upper bound. This function uses a modified version of the algorithm specified by the parameter <em>A</em>. The modification involves early termination in case the actual number of crossings is strictly larger than the upper bound. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>Input graph. </td></tr>
    <tr><td class="paramname">upper_bound</td><td>Upper bound on the number of crossings. </td></tr>
    <tr><td class="paramname">A</td><td>Algorithm to use to compute the number of crossings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of crossings \(C\) if said number is less than or equal to the upper bound. The function returns a value strictly larger than the upper bound if otherwise. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The preconditions of this function depend on the choice of algorithm. See the preconditions of each algorithm in <a class="el" href="namespacelal_1_1linarr.html#aa7dc22d99964e6a6bb1fe5dd096e64b7">lal::linarr::algorithms_C</a>. </dd></dl>

</div>
</div>
<a id="a881660afb04df9fd72297dc17dd5ba7f" name="a881660afb04df9fd72297dc17dd5ba7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a881660afb04df9fd72297dc17dd5ba7f">&#9670;&#160;</a></span>is_num_crossings_lesseq_than() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lal::linarr::is_num_crossings_lesseq_than </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>upper_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal_1_1linarr.html#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em> = <code><a class="el" href="namespacelal_1_1linarr.html#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the number of crossings in the linear arrangement less than a constant? </p>
<p >Given a graph \(G\) and a linear arrangements \(\pi\) of its nodes, returns the number of edge crossings \(C_{\pi}(G)\) if is less than or equal to the given upper bound constant \(u\). In case the number of crossings is greater, returns a value strictly larger than the upper bound. This function uses a modified version of the algorithm specified by the parameter <em>A</em>. The modification involves early termination in case the actual number of crossings is strictly larger than the upper bound. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arr</td><td>A linear arrangement of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
    <tr><td class="paramname">upper_bound</td><td>Upper bound on the number of crossings. </td></tr>
    <tr><td class="paramname">A</td><td>Algorithm to use to compute the number of crossings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of crossings \(C\) if said number is less than or equal to the upper bound. The function returns a value strictly larger than than the upper bound if otherwise. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The preconditions of this function depend on the choice of algorithm. See the preconditions of each algorithm in <a class="el" href="namespacelal_1_1linarr.html#aa7dc22d99964e6a6bb1fe5dd096e64b7">lal::linarr::algorithms_C</a>. </dd></dl>

</div>
</div>
<a id="a707361d3830e22545270ab2a7c398d57" name="a707361d3830e22545270ab2a7c398d57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a707361d3830e22545270ab2a7c398d57">&#9670;&#160;</a></span>is_num_crossings_lesseq_than() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lal::linarr::is_num_crossings_lesseq_than </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>upper_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal_1_1linarr.html#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em> = <code><a class="el" href="namespacelal_1_1linarr.html#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the number of crossings in the linear arrangement less than a constant? </p>
<p >Given a graph \(G\) computes the number of edge crossings using the identity arrangement \(\pi_I\), \(C_{\pi_I}(G)\), if it is less than or equal to the given upper bound constant \(u\). In case the number of crossings is greater, returns a value strictly larger than the upper bound. This function uses a modified version of the algorithm specified by the parameter <em>A</em>. The modification involves early termination in case the actual number of crossings is strictly larger than the upper bound. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>Input graph. </td></tr>
    <tr><td class="paramname">upper_bound</td><td>Upper bound on the number of crossings. </td></tr>
    <tr><td class="paramname">A</td><td>Algorithm to use to compute the number of crossings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of crossings \(C\) if said number is less than or equal to the upper bound. The function returns a value strictly larger than the upper bound if otherwise. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The preconditions of this function depend on the choice of algorithm. See the preconditions of each algorithm in <a class="el" href="namespacelal_1_1linarr.html#aa7dc22d99964e6a6bb1fe5dd096e64b7">lal::linarr::algorithms_C</a>. </dd></dl>

</div>
</div>
<a id="ae06f54984c51091894dd9bb8946547f7" name="ae06f54984c51091894dd9bb8946547f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae06f54984c51091894dd9bb8946547f7">&#9670;&#160;</a></span>is_num_crossings_lesseq_than_list() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; uint64_t &gt; lal::linarr::is_num_crossings_lesseq_than_list </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>arrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>upper_bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal_1_1linarr.html#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em> = <code><a class="el" href="namespacelal_1_1linarr.html#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the number of crossings in the linear arrangement less than a constant? </p>
<p >Given a graph \(G\), a list of linear arrangements \(L=\{\pi_i\}_{i=1}^k\) of its nodes and a list of upper bounds \(\{u_i\}_{i=1}^k\), computes the number of edge crossings for each of the linear arrangements \(\pi_i\) if that amount is less than or equal to the given upper bound \(u_i\), i.e., computes \(\{ f_i \}_{i=1}^k\), where \(f_i=C_{\pi_i}(G)\) if \(C_{\pi_i}(G)\le u_i\), or a value larger than \(u_i\) if \(C_{\pi_i}(G)&gt;u_i\). This function uses a modified version of the algorithm specified by the parameter <em>A</em>. The modification involves early termination in case the actual number of crossings is strictly larger than the upper bound. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arrs</td><td>A linear arrangement of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
    <tr><td class="paramname">upper_bounds</td><td>A list of upper bounds on the number of crossings for each linear arrangement. </td></tr>
    <tr><td class="paramname">A</td><td>Algorithm to use to compute the number of crossings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of crossings \(C\) if said number is less than or equal to the upper bound. The function returns a value strictly larger than the upper bound if otherwise. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>There must be as many linear arrangements as upper bounds. </dd>
<dd>
The preconditions of this function depend on the choice of algorithm. See the preconditions of each algorithm in <a class="el" href="namespacelal_1_1linarr.html#aa7dc22d99964e6a6bb1fe5dd096e64b7">lal::linarr::algorithms_C</a>. </dd></dl>

</div>
</div>
<a id="a7e9efc4309a83614df4a0de5b7e4f7ae" name="a7e9efc4309a83614df4a0de5b7e4f7ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e9efc4309a83614df4a0de5b7e4f7ae">&#9670;&#160;</a></span>is_num_crossings_lesseq_than_list() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; uint64_t &gt; lal::linarr::is_num_crossings_lesseq_than_list </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>arrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>upper_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal_1_1linarr.html#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em> = <code><a class="el" href="namespacelal_1_1linarr.html#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the number of crossings in the linear arrangement less than a constant? </p>
<p >Given a graph \(G\) and a list of linear arrangements \(L=\{\pi_i\}_{i=1}^k\) of its nodes, computes the number of edge crossings for each of the linear arrangements \(\pi_i\) if that amount is less than or equal to the given upper bound \(u\), i.e., computes \(\{f_i\}_{i=1}^k\), where \(f_i=C_{\pi_i}(G)\) if \(C_{\pi_i}(G)\le u\), or a value strictly larger than the upper bound \(u\) if \(C_{\pi_i}(G)&gt;u\). This function uses a modified version of the algorithm specified by the parameter <em>A</em>. The modification involves early termination in case the actual number of crossings is strictly larger than the upper bound. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arrs</td><td>A linear arrangement of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
    <tr><td class="paramname">upper_bound</td><td>Upper bound on the number of crossings. </td></tr>
    <tr><td class="paramname">A</td><td>Algorithm to use to compute the number of crossings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of crossings \(C\) if said number is less than or equal to the upper bound. The function returns a value strictly larger than the upper bound if otherwise. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The preconditions of this function depend on the choice of algorithm. See the preconditions of each algorithm in <a class="el" href="namespacelal_1_1linarr.html#aa7dc22d99964e6a6bb1fe5dd096e64b7">lal::linarr::algorithms_C</a>. </dd></dl>

</div>
</div>
<a id="a406b2456d635ac4efcbd7ed7270bf173" name="a406b2456d635ac4efcbd7ed7270bf173"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a406b2456d635ac4efcbd7ed7270bf173">&#9670;&#160;</a></span>is_num_crossings_lesseq_than_list() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; uint64_t &gt; lal::linarr::is_num_crossings_lesseq_than_list </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>arrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>upper_bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal_1_1linarr.html#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em> = <code><a class="el" href="namespacelal_1_1linarr.html#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the number of crossings in the linear arrangement less than a constant? </p>
<p >Given a graph \(G\), a list of linear arrangements \(L=\{\pi_i\}_{i=1}^k\) of its nodes and a list of upper bounds \(\{u_i\}_{i=1}^k\), computes the number of edge crossings for each of the linear arrangements \(\pi_i\) if that amount is less than or equal to the given upper bound \(u_i\), i.e., computes \(\{ f_i \}_{i=1}^k\), where \(f_i=C_{\pi_i}(G)\) if \(C_{\pi_i}(G)\le u_i\), or \(f_i&gt;m^2\) if \(C_{\pi_i}(G)&gt;u_i\). This function uses a modified version of the algorithm specified by the parameter <em>A</em>. The modification involves early termination in case the actual number of crossings is strictly larger than the upper bound. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arrs</td><td>A linear arrangement of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
    <tr><td class="paramname">upper_bounds</td><td>A list of upper bounds on the number of crossings for each linear arrangement. </td></tr>
    <tr><td class="paramname">A</td><td>Algorithm to use to compute the number of crossings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of crossings \(C\) if said number is less than or equal to the upper bound. The function returns a value strictly larger than the upper bound if otherwise. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>There must be as many linear arrangements as upper bounds. </dd>
<dd>
The preconditions of this function depend on the choice of algorithm. See the preconditions of each algorithm in <a class="el" href="namespacelal_1_1linarr.html#aa7dc22d99964e6a6bb1fe5dd096e64b7">lal::linarr::algorithms_C</a>. </dd></dl>

</div>
</div>
<a id="a27e838cc735e0840f88ee4394af6ff77" name="a27e838cc735e0840f88ee4394af6ff77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27e838cc735e0840f88ee4394af6ff77">&#9670;&#160;</a></span>is_num_crossings_lesseq_than_list() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; uint64_t &gt; lal::linarr::is_num_crossings_lesseq_than_list </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>arrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>upper_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal_1_1linarr.html#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em> = <code><a class="el" href="namespacelal_1_1linarr.html#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the number of crossings in the linear arrangement less than a constant? </p>
<p >Given a graph \(G\) and a list of linear arrangements \(L=\{\pi_i\}_{i=1}^k\) of its nodes, computes the number of edge crossings for each of the linear arrangements \(\pi_i\) if that amount is less than or equal to the given upper bound \(u\), i.e., computes \(\{f_i\}_{i=1}^k\), where \(f_i=C_{\pi_i}(G)\) if \(C_{\pi_i}(G)\le u\), or \(f_i&gt;m^2\) if \(C_{\pi_i}(G)&gt;u\). This function uses a modified version of the algorithm specified by the parameter <em>A</em>. The modification involves early termination in case the actual number of crossings is strictly larger than the upper bound. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arrs</td><td>A linear arrangement of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
    <tr><td class="paramname">upper_bound</td><td>Upper bound on the number of crossings. </td></tr>
    <tr><td class="paramname">A</td><td>Algorithm to use to compute the number of crossings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of crossings \(C\) if said number is less than or equal to the upper bound. The function returns a value strictly larger than the upper bound if otherwise. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The preconditions of this function depend on the choice of algorithm. See the preconditions of each algorithm in <a class="el" href="namespacelal_1_1linarr.html#aa7dc22d99964e6a6bb1fe5dd096e64b7">lal::linarr::algorithms_C</a>. </dd></dl>

</div>
</div>
<a id="a6b3203432e13dfec29563796643e6187" name="a6b3203432e13dfec29563796643e6187"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b3203432e13dfec29563796643e6187">&#9670;&#160;</a></span>is_permutation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::linarr::is_permutation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;&#160;</td>
          <td class="paramname"><em>arr</em> = <code>{}</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is a given input arrangement a permutation? </p>
<p >A linear arrangement is a permutation if all the positions are numbers in \([0,n-1]\), where \(n\) denotes the size of the arrangement and if no two numbers appear twice in the arrangement. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>Input linear arrangement </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the input arrangement is a valid permutation. </dd></dl>

</div>
</div>
<a id="aaeb1b7dcc4cda2e1c366e02b2d03c627" name="aaeb1b7dcc4cda2e1c366e02b2d03c627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeb1b7dcc4cda2e1c366e02b2d03c627">&#9670;&#160;</a></span>is_planar()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class graph_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::linarr::is_planar </td>
          <td>(</td>
          <td class="paramtype">const graph_t &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;&#160;</td>
          <td class="paramname"><em>arr</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is a given arrangement planar? </p>
<p >A planar arrangement of a graph is an arrangement in which there are no edge crossings. If the input arrangement is empty then the identity arrangement \(\pi_I\) is used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arr</td><td>Input linear arrangement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the input graph arranged with the input arrangement is planar. </dd></dl>

</div>
</div>
<a id="ae404b93b3b1730f61299f78f4ba89585" name="ae404b93b3b1730f61299f78f4ba89585"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae404b93b3b1730f61299f78f4ba89585">&#9670;&#160;</a></span>is_projective()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::linarr::is_projective </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;&#160;</td>
          <td class="paramname"><em>rt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;&#160;</td>
          <td class="paramname"><em>arr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is a given arrangement projective? </p>
<p >A projective arrangement of a rooted tree is an arrangement that is planar and the root is not covered by any edge. The root is covered if, for a given input arrangement \(\pi\), there exists an edge of the tree \(\{s,t\}\) such that \(\pi(s) &lt; \pi(r) &lt; \pi(t)\) or \(\pi(t) &lt; \pi(r) &lt; \pi(s)\).</p>
<p >If the input arrangement is empty then the identity arrangement \(\pi_I\) is used.</p>
<p >See method <a class="el" href="namespacelal_1_1linarr.html#aaeb1b7dcc4cda2e1c366e02b2d03c627">is_planar</a> for further details on the characterisation of planar arrangements. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rt</td><td>Input rooted tree </td></tr>
    <tr><td class="paramname">arr</td><td>Input linear arrangement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the input rooted tree arranged with the input arrangement is projective. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The input rooted tree must be a valid rooted tree (see <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#af464d98b1b5dfdbaaacea553d9c89154">lal::graphs::rooted_tree::is_rooted_tree</a>). </dd></dl>

</div>
</div>
<a id="a78b17d7726acf0ce82625c3d13987bfa" name="a78b17d7726acf0ce82625c3d13987bfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78b17d7726acf0ce82625c3d13987bfa">&#9670;&#160;</a></span>is_root_covered()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::linarr::is_root_covered </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;&#160;</td>
          <td class="paramname"><em>rt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;&#160;</td>
          <td class="paramname"><em>arr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the root of a rooted tree covered in a given arrangement? </p>
<p >The root is covered if, for a given input arrangement \(\pi\), there exists an edge of the tree \(\{s,t\}\) such that \(\pi(s) &lt; \pi(r) &lt; \pi(t)\) or \(\pi(t) &lt; \pi(r) &lt; \pi(s)\).</p>
<p >If the input arrangement is empty then the identity arrangement \(\pi_I\) is used. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rt</td><td>Input rooted tree </td></tr>
    <tr><td class="paramname">arr</td><td>Input linear arrangement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the root is covered in the given arrangement. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The input rooted tree must be a valid rooted tree (see <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#af464d98b1b5dfdbaaacea553d9c89154">lal::graphs::rooted_tree::is_rooted_tree</a>). </dd></dl>

</div>
</div>
<a id="aadd6d6ed9cadb57228200d32c3a99191" name="aadd6d6ed9cadb57228200d32c3a99191"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadd6d6ed9cadb57228200d32c3a99191">&#9670;&#160;</a></span>max_sum_edge_lengths_planar() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; uint64_t, <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; lal::linarr::max_sum_edge_lengths_planar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the maximum value of \(D\) in trees under the planarity constraint. </p>
<p >Calculates the maximum value of \(D\) over all planar arrangements of the input tree. This function also returns the linear arrangement that yields the maximum value. The caller can choose the algorithm to calculate such maximum value.</p>
<p >See <a class="el" href="LAL_concepts.html#LAL_concepts__linear_arrangement__types">Types of arrangements</a> for the definition of planar arrangement.</p>
<p >This function implements the algorithm described in <a class="el" href="citelist.html#CITEREF_Alemany2022d">[6]</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input free tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The maximum value of \(D\) and a maximum arrangement. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Input tree <em>t</em> must be a valid tree (see <a class="el" href="classlal_1_1graphs_1_1tree.html#a25c8d57865fa5f7cb5d101fd5d07fe2d">lal::graphs::tree::is_tree()</a>). </dd></dl>

</div>
</div>
<a id="a95e4fa9607ca43dfe0ba110eb9e2ddd7" name="a95e4fa9607ca43dfe0ba110eb9e2ddd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95e4fa9607ca43dfe0ba110eb9e2ddd7">&#9670;&#160;</a></span>max_sum_edge_lengths_planar() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; uint64_t, <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; lal::linarr::max_sum_edge_lengths_planar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the maximum value of \(D\) in trees under the planarity constraint. </p>
<p >Calculates the maximum value of \(D\) over all planar arrangements of the input tree. This function also returns the linear arrangement that yields the maximum value. The caller can choose the algorithm to calculate such maximum value.</p>
<p >See <a class="el" href="LAL_concepts.html#LAL_concepts__linear_arrangement__types">Types of arrangements</a> for the definition of planar arrangement.</p>
<p >This function implements the algorithm described in <a class="el" href="citelist.html#CITEREF_Alemany2022d">[6]</a>.</p>
<p >This function converts the input rooted into a free tree (see <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#aed04cf971952eb8389ea823369b6fb11">lal::graphs::rooted_tree::to_free_tree()</a>) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input rooted tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The maximum value of \(D\) and a maximum arrangement. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Input tree <em>t</em> must be a valid tree (see <a class="el" href="classlal_1_1graphs_1_1tree.html#a25c8d57865fa5f7cb5d101fd5d07fe2d">lal::graphs::tree::is_tree()</a>). </dd></dl>

</div>
</div>
<a id="a0886a4326be3b40cf34ee526514d60ab" name="a0886a4326be3b40cf34ee526514d60ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0886a4326be3b40cf34ee526514d60ab">&#9670;&#160;</a></span>max_sum_edge_lengths_projective()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; uint64_t, <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; lal::linarr::max_sum_edge_lengths_projective </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the maximum value of \(D\) in rooted trees under the projectivity constraint. </p>
<p >Calculates the maximum value of \(D\) over all projective arrangements of the input tree. This function also returns the linear arrangement that yields the maximum value. The caller can choose the algorithm to calculate such maximum value.</p>
<p >See <a class="el" href="LAL_concepts.html#LAL_concepts__linear_arrangement__types">Types of arrangements</a> for the definition of projective arrangement.</p>
<p >This function implements the algorithm described in <a class="el" href="citelist.html#CITEREF_Alemany2022d">[6]</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input rooted tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The maximum value of \(D\) and a maximum arrangement. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Input tree <em>t</em> must be a valid tree (see <a class="el" href="classlal_1_1graphs_1_1tree.html#a25c8d57865fa5f7cb5d101fd5d07fe2d">lal::graphs::tree::is_tree()</a>). </dd></dl>

</div>
</div>
<a id="a605f9fb7f2214a6dfd4021c12134a85c" name="a605f9fb7f2214a6dfd4021c12134a85c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a605f9fb7f2214a6dfd4021c12134a85c">&#9670;&#160;</a></span>max_sum_edge_lengths_projective_roots() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; uint64_t &gt;, <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> &gt; lal::linarr::max_sum_edge_lengths_projective_roots </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the maximum value of \(D\) in trees under the projectivity constraint at every vertex of the tree. </p>
<p >Calculates the maximum sum of edge lengths under the projectivity constraint at every vertex of the tree, that is, the result returned is a list of values \(\{M_1,M_2,\dots,M_n\}\) where \(M_i\) is the maximum sum of edge lengths under projectivity for the tree rooted at the \(i\)-th vertex.</p>
<p >See <a class="el" href="LAL_concepts.html#LAL_concepts__linear_arrangement__types">Types of arrangements</a> for the definition of projective arrangement.</p>
<p >This function implements the algorithm described in <a class="el" href="citelist.html#CITEREF_Alemany2022d">[6]</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input free tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The maximum value of \(D\) and a maximum arrangement. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Input tree <em>t</em> must be a valid tree (see <a class="el" href="classlal_1_1graphs_1_1tree.html#a25c8d57865fa5f7cb5d101fd5d07fe2d">lal::graphs::tree::is_tree()</a>). </dd></dl>

</div>
</div>
<a id="a4d92a7d183caf25d9c881f8ee9d3833c" name="a4d92a7d183caf25d9c881f8ee9d3833c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d92a7d183caf25d9c881f8ee9d3833c">&#9670;&#160;</a></span>max_sum_edge_lengths_projective_roots() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; uint64_t &gt;, <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> &gt; lal::linarr::max_sum_edge_lengths_projective_roots </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the maximum value of \(D\) in trees under the projectivity constraint at every vertex of the tree. </p>
<p >Calculates the maximum sum of edge lengths under the projectivity constraint at every vertex of the tree, that is, the result returned is a list of values \(\{M_1,M_2,\dots,M_n\}\) where \(M_i\) is the maximum sum of edge lengths under projectivity for the tree rooted at the \(i\)-th vertex.</p>
<p >See <a class="el" href="LAL_concepts.html#LAL_concepts__linear_arrangement__types">Types of arrangements</a> for the definition of projective arrangement.</p>
<p >This function implements the algorithm described in <a class="el" href="citelist.html#CITEREF_Alemany2022d">[6]</a>.</p>
<p >This function converts the input rooted into a free tree (see <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#aed04cf971952eb8389ea823369b6fb11">lal::graphs::rooted_tree::to_free_tree()</a>). Therefore, the root is ignored. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input free tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The maximum value of \(D\) and a maximum arrangement. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Input tree <em>t</em> must be a valid tree (see <a class="el" href="classlal_1_1graphs_1_1tree.html#a25c8d57865fa5f7cb5d101fd5d07fe2d">lal::graphs::tree::is_tree()</a>). </dd></dl>

</div>
</div>
<a id="a2030c0f279ced9571405cebe5675e241" name="a2030c0f279ced9571405cebe5675e241"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2030c0f279ced9571405cebe5675e241">&#9670;&#160;</a></span>mean_dependency_distance() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double lal::linarr::mean_dependency_distance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;&#160;</td>
          <td class="paramname"><em>pi</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the mean dependency distance \(MDD\) as a floating point value. </p>
<p >See <a class="el" href="namespacelal_1_1linarr.html#a679b59e355c13c9ac4969f897b731582">lal::linarr::mean_dependency_distance_rational</a> for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">pi</td><td>Linear arrangement of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return value is a floating point value. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>\(m &gt; 0\). </dd></dl>

</div>
</div>
<a id="a43bba5ac9ff41d48b5320b70d9e4f403" name="a43bba5ac9ff41d48b5320b70d9e4f403"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43bba5ac9ff41d48b5320b70d9e4f403">&#9670;&#160;</a></span>mean_dependency_distance() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double lal::linarr::mean_dependency_distance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;&#160;</td>
          <td class="paramname"><em>pi</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the mean dependency distance \(MDD\) as a floating point value. </p>
<p >See <a class="el" href="namespacelal_1_1linarr.html#a679b59e355c13c9ac4969f897b731582">lal::linarr::mean_dependency_distance_rational</a> for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">pi</td><td>Linear arrangement of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return value is a floating point value. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>\(m &gt; 0\). </dd></dl>

</div>
</div>
<a id="a1f8c78736426eea6282258b26534c7e5" name="a1f8c78736426eea6282258b26534c7e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f8c78736426eea6282258b26534c7e5">&#9670;&#160;</a></span>mean_dependency_distance_1level()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class graph_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double lal::linarr::mean_dependency_distance_1level </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; graph_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>1-level Mean Dependency Distance \(MDD\) over an ensemble of graphs. </p>
<p >See <a class="el" href="namespacelal_1_1linarr.html#ae5d17b6e4ea1521b436dbb20817f41b1">lal::linarr::mean_dependency_distance_1level_rational</a> for further details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>List of input graphs. </td></tr>
    <tr><td class="paramname">P</td><td>List of linear arrangements of the nodes \(Pi = \{\pi_i\}_{i=1}^k\). When omitted, \(\pi_I\) is used for every graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">graph_t</td><td>A graph type. A class that derives from <a class="el" href="classlal_1_1graphs_1_1graph.html">lal::graphs::graph</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Jing's and Liu's 1-level \(MDD\) for an ensemble of graphs as a floating point value. </dd></dl>

</div>
</div>
<a id="ae5d17b6e4ea1521b436dbb20817f41b1" name="ae5d17b6e4ea1521b436dbb20817f41b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5d17b6e4ea1521b436dbb20817f41b1">&#9670;&#160;</a></span>mean_dependency_distance_1level_rational()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class graph_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a> lal::linarr::mean_dependency_distance_1level_rational </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; graph_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>1-level Mean Dependency Distance \(MDD\) over an ensemble of graphs. </p>
<p >Given a list of graphs \(L\) and a list of linear arrangements for each of them, \(P\), computes the 1-level Mean Dependency Distance as the quotient of \(D\), the sum of all the edge lengths of each graph, and of \(M\) the sum of the number of edges of all the graphs.</p>
<p >Formally, given a list of graphs \(L = \{L_i\}_{i=1}^k\) and a list of linear arrangements \(\Pi = \{\pi_i\}_{i=1}^k\), computes \(D/M\), where</p><ul>
<li>\(D = \sum_{i=1}^k D(L_i, \pi_i)\) is the sum of edge lengths of all graphs.</li>
<li>\(M = \sum_{i=1}^k |E(L_i)|\) is the sum of the number of edges of all graphs.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>List of input graphs. </td></tr>
    <tr><td class="paramname">P</td><td>List of linear arrangements of the nodes \(\Pi = \{\pi_i\}_{i=1}^k\). When omitted, \(\pi_I\) is used for every graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">graph_t</td><td>A graph type. A class that derives from <a class="el" href="classlal_1_1graphs_1_1graph.html">lal::graphs::graph</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Jing's and Liu's 1-level \(MDD\) for an ensemble of graphs as an exact rational value. </dd></dl>

</div>
</div>
<a id="ac837af66d13aa3e2865a6737aec34e7a" name="ac837af66d13aa3e2865a6737aec34e7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac837af66d13aa3e2865a6737aec34e7a">&#9670;&#160;</a></span>mean_dependency_distance_2level()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class graph_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double lal::linarr::mean_dependency_distance_2level </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; graph_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>2-level Mean Dependency Distance \(MDD\) over an ensemble of graphs. </p>
<p >See <a class="el" href="namespacelal_1_1linarr.html#a0b2bbd3f6c94e03091186afd5ec3ae89">lal::linarr::mean_dependency_distance_2level_rational</a> for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>List of input graphs. </td></tr>
    <tr><td class="paramname">P</td><td>List of linear arrangements of the nodes \(L = \{\pi_i\}_{i=1}^k\). When omitted, \(\pi_I\) is used for every graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">graph_t</td><td>A graph type. A class that derives from <a class="el" href="classlal_1_1graphs_1_1graph.html">lal::graphs::graph</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Jing's and Liu's 2-level \(MDD\) for an ensemble of graphs as a floating point value. </dd></dl>

</div>
</div>
<a id="a0b2bbd3f6c94e03091186afd5ec3ae89" name="a0b2bbd3f6c94e03091186afd5ec3ae89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b2bbd3f6c94e03091186afd5ec3ae89">&#9670;&#160;</a></span>mean_dependency_distance_2level_rational()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class graph_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a> lal::linarr::mean_dependency_distance_2level_rational </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; graph_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>2-level Mean Dependency Distance \(MDD\) over an ensemble of graphs. </p>
<p >Given a list of graphs \(L\) and a list of linear arrangements of the nodes for each of them, \(P\), computes the 2-level Mean Dependency Distance, i.e., it computes the average Mean Dependency Distance of the graphs in the list.</p>
<p >Formally, given a list of graphs \(L = \{L_i\}_{i=1}^k\) and a list of linear arrangements \(P = \{\pi_i\}_{i=1}^k\), computes \((1/k)S_{&lt;d&gt;}\), where \(S_{&lt;d&gt;} = \sum_{i=1}^k MDD(L_i, \pi_i)\) is the sum of the mean dependency distances of every graph (see <a class="el" href="namespacelal_1_1linarr.html#a679b59e355c13c9ac4969f897b731582">lal::linarr::mean_dependency_distance_rational</a> for details on the definition of the Mean Dependency Distance).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>List of input graphs. </td></tr>
    <tr><td class="paramname">P</td><td>List of linear arrangements of the nodes \(P = \{\pi_i\}_{i=1}^k\). When omitted, \(\pi_I\) is used for every graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">graph_t</td><td>A graph type. A class that derives from <a class="el" href="classlal_1_1graphs_1_1graph.html">lal::graphs::graph</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Jing's and Liu's 2-level \(MDD\) for an ensemble of graphs as an exact rational value. </dd></dl>

</div>
</div>
<a id="a679b59e355c13c9ac4969f897b731582" name="a679b59e355c13c9ac4969f897b731582"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a679b59e355c13c9ac4969f897b731582">&#9670;&#160;</a></span>mean_dependency_distance_rational() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a> lal::linarr::mean_dependency_distance_rational </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;&#160;</td>
          <td class="paramname"><em>pi</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the mean dependency distance \(MDD\) as an exact rational value. </p>
<p >Given a graph \(G\) and a linear arrangement of its nodes \(\pi\), computes the average edge length, or the mean dependency distance (see <a class="el" href="citelist.html#CITEREF_Jing2015a">[25]</a>). Formally, it computes \(\frac{D_{\pi}(G)}{|E(G)|}\). See function <a class="el" href="namespacelal_1_1linarr.html#ab70693683a8da54a2e4350c665067cf1">sum_edge_lengths</a> for further details on \(D_{\pi}(G)\).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">pi</td><td>Linear arrangement of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Jing's and Liu's \(MDD\). </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>\(m &gt; 0\). </dd></dl>

</div>
</div>
<a id="a77d3933929930331d44200deed260a41" name="a77d3933929930331d44200deed260a41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77d3933929930331d44200deed260a41">&#9670;&#160;</a></span>mean_dependency_distance_rational() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a> lal::linarr::mean_dependency_distance_rational </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;&#160;</td>
          <td class="paramname"><em>pi</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the mean dependency distance \(MDD\) as an exact rational value. </p>
<p >Given a graph \(G\) and a linear arrangement of its nodes \(\pi\), computes the average edge length, or the mean dependency distance (see <a class="el" href="citelist.html#CITEREF_Jing2015a">[25]</a>). Formally, it computes \(\frac{D_{\pi}(G)}{|E(G)|}\). See function <a class="el" href="namespacelal_1_1linarr.html#ab70693683a8da54a2e4350c665067cf1">sum_edge_lengths</a> for further details on \(D_{\pi}(G)\).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">pi</td><td>Linear arrangement of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Jing's and Liu's \(MDD\). </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>\(m &gt; 0\). </dd></dl>

</div>
</div>
<a id="a450d0dd41fec42a39bb1204ecedaaa91" name="a450d0dd41fec42a39bb1204ecedaaa91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a450d0dd41fec42a39bb1204ecedaaa91">&#9670;&#160;</a></span>min_sum_edge_lengths() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; uint64_t, <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; lal::linarr::min_sum_edge_lengths </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal_1_1linarr.html#a1c6a617eb12e032ee641fd390776ff3f">algorithms_Dmin</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em> = <code><a class="el" href="namespacelal_1_1linarr.html#a1c6a617eb12e032ee641fd390776ff3fae04de66d6cf0f6c6ec4036288f66bbed">algorithms_Dmin::Shiloach</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the minimum value of \(D\) in free trees. </p>
<p >Calculates the minimum value of \(D\) over all possible arrangements of the input tree. This function also returns the linear arrangement that yields the minimum value. The caller can choose the algorithm to calculate such minimum value.</p>
<p >See the description of the values in <a class="el" href="namespacelal_1_1linarr.html#a1c6a617eb12e032ee641fd390776ff3f">lal::linarr::algorithms_Dmin</a> for details on the algorithm implemented and to see references to the papers. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input free tree. </td></tr>
    <tr><td class="paramname">a</td><td>The algorithm to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The minimum value of \(D\) and a minimum arrangement. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Input tree <em>t</em> must be a valid tree (see <a class="el" href="classlal_1_1graphs_1_1tree.html#a25c8d57865fa5f7cb5d101fd5d07fe2d">lal::graphs::tree::is_tree()</a>). </dd>
<dd>
This function has as extra preconditions those specified in the enumeration passed as parameter. </dd></dl>

</div>
</div>
<a id="a22429c80001ad8fd3dbed68a59ef29fb" name="a22429c80001ad8fd3dbed68a59ef29fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22429c80001ad8fd3dbed68a59ef29fb">&#9670;&#160;</a></span>min_sum_edge_lengths() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; uint64_t, <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; lal::linarr::min_sum_edge_lengths </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal_1_1linarr.html#a1c6a617eb12e032ee641fd390776ff3f">algorithms_Dmin</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em> = <code><a class="el" href="namespacelal_1_1linarr.html#a1c6a617eb12e032ee641fd390776ff3fae04de66d6cf0f6c6ec4036288f66bbed">algorithms_Dmin::Shiloach</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the minimum value of \(D\) in trees. </p>
<p >Calculates the minimum value of \(D\) over all possible arrangements of the input tree. This function also returns the linear arrangement that yields the minimum value. The caller can choose the algorithm to calculate such minimum value.</p>
<p >See the description of the values in <a class="el" href="namespacelal_1_1linarr.html#a1c6a617eb12e032ee641fd390776ff3f">lal::linarr::algorithms_Dmin</a> for details on the algorithm to be used and to see references to the papers.</p>
<p >This function converts the input rooted into a free tree (see <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#aed04cf971952eb8389ea823369b6fb11">lal::graphs::rooted_tree::to_free_tree()</a>) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input rooted tree. </td></tr>
    <tr><td class="paramname">a</td><td>The algorithm to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The minimum value of \(D\) and a minimum arrangement. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Input tree <em>t</em> must be a valid tree (see <a class="el" href="classlal_1_1graphs_1_1tree.html#a25c8d57865fa5f7cb5d101fd5d07fe2d">lal::graphs::tree::is_tree()</a>). </dd>
<dd>
This function has as extra preconditions those specified in the enumeration passed as parameter. </dd></dl>

</div>
</div>
<a id="a8ee049d439a7e8dd41ac0145679a84bb" name="a8ee049d439a7e8dd41ac0145679a84bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ee049d439a7e8dd41ac0145679a84bb">&#9670;&#160;</a></span>min_sum_edge_lengths_planar() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; uint64_t, <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; lal::linarr::min_sum_edge_lengths_planar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal_1_1linarr.html#a4a49efcc64c3b63502ad8cc18d508ce3">algorithms_Dmin_planar</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em> = <code><a class="el" href="namespacelal_1_1linarr.html#a4a49efcc64c3b63502ad8cc18d508ce3a37e3b966cac6fa2c0f649bd5cb42adca">algorithms_Dmin_planar::AlemanyEstebanFerrer</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the minimum value of \(D\) in trees under the planarity constraint. </p>
<p >Calculates the minimum value of \(D\) over all planar arrangements of the input tree. This function also returns the linear arrangement that yields the minimum value. The caller can choose the algorithm to calculate such minimum value.</p>
<p >See <a class="el" href="LAL_concepts.html#LAL_concepts__linear_arrangement__types">Types of arrangements</a> for the definition of planar arrangement.</p>
<p >See the description of the values in <a class="el" href="namespacelal_1_1linarr.html#a4a49efcc64c3b63502ad8cc18d508ce3">lal::linarr::algorithms_Dmin_planar</a> for details on the algorithm to be used and to see references to the papers. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input free tree. </td></tr>
    <tr><td class="paramname">a</td><td>The algorithm to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The minimum value of \(D\) and a minimum arrangement. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Input tree <em>t</em> must be a valid tree (see <a class="el" href="classlal_1_1graphs_1_1tree.html#a25c8d57865fa5f7cb5d101fd5d07fe2d">lal::graphs::tree::is_tree()</a>). </dd></dl>

</div>
</div>
<a id="ab154f955e7f6887c6d8115108a4bf242" name="ab154f955e7f6887c6d8115108a4bf242"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab154f955e7f6887c6d8115108a4bf242">&#9670;&#160;</a></span>min_sum_edge_lengths_planar() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; uint64_t, <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; lal::linarr::min_sum_edge_lengths_planar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal_1_1linarr.html#a4a49efcc64c3b63502ad8cc18d508ce3">algorithms_Dmin_planar</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em> = <code><a class="el" href="namespacelal_1_1linarr.html#a4a49efcc64c3b63502ad8cc18d508ce3a37e3b966cac6fa2c0f649bd5cb42adca">algorithms_Dmin_planar::AlemanyEstebanFerrer</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the minimum value of \(D\) in trees under the planarity constraint. </p>
<p >Calculates the minimum value of \(D\) over all planar arrangements of the input tree. This function also returns the linear arrangement that yields the minimum value. The caller can choose the algorithm to calculate such minimum value.</p>
<p >See <a class="el" href="LAL_concepts.html#LAL_concepts__linear_arrangement__types">Types of arrangements</a> for the definition of planar arrangement.</p>
<p >See the description of the values in <a class="el" href="namespacelal_1_1linarr.html#a4a49efcc64c3b63502ad8cc18d508ce3">lal::linarr::algorithms_Dmin_planar</a> for details on the algorithm to be used and to see references to the papers.</p>
<p >This function converts the input rooted into a free tree (see <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#aed04cf971952eb8389ea823369b6fb11">lal::graphs::rooted_tree::to_free_tree()</a>) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input rooted tree. </td></tr>
    <tr><td class="paramname">a</td><td>The algorithm to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The minimum value of \(D\) and a minimum arrangement. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Input tree <em>t</em> must be a valid tree (see <a class="el" href="classlal_1_1graphs_1_1tree.html#a25c8d57865fa5f7cb5d101fd5d07fe2d">lal::graphs::tree::is_tree()</a>). </dd></dl>

</div>
</div>
<a id="aff8ac86ade398306f32ee39692ebfe4a" name="aff8ac86ade398306f32ee39692ebfe4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff8ac86ade398306f32ee39692ebfe4a">&#9670;&#160;</a></span>min_sum_edge_lengths_projective()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; uint64_t, <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; lal::linarr::min_sum_edge_lengths_projective </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal_1_1linarr.html#a30bc00af5439a56f037ed84875f1911f">algorithms_Dmin_projective</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em> = <code><a class="el" href="namespacelal_1_1linarr.html#a30bc00af5439a56f037ed84875f1911fa37e3b966cac6fa2c0f649bd5cb42adca">algorithms_Dmin_projective::AlemanyEstebanFerrer</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the minimum value of \(D\) in rooted trees under the projectivity constraint. </p>
<p >Calculates the minimum value of \(D\) over all projective arrangements of the input tree. This function also returns the linear arrangement that yields the minimum value. The caller can choose the algorithm to calculate such minimum value.</p>
<p >See <a class="el" href="LAL_concepts.html#LAL_concepts__linear_arrangement__types">Types of arrangements</a> for the definition of projective arrangement.</p>
<p >See the description of the values in <a class="el" href="namespacelal_1_1linarr.html#a30bc00af5439a56f037ed84875f1911f">lal::linarr::algorithms_Dmin_projective</a> for details on the algorithm to be used and to see references to the papers. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input rooted tree. </td></tr>
    <tr><td class="paramname">a</td><td>The algorithm to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The minimum value of \(D\) and a minimum arrangement. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Input tree <em>t</em> must be a valid tree (see <a class="el" href="classlal_1_1graphs_1_1tree.html#a25c8d57865fa5f7cb5d101fd5d07fe2d">lal::graphs::tree::is_tree()</a>). </dd></dl>

</div>
</div>
<a id="a3806eb869914f45cf79c15e8aa7d2a51" name="a3806eb869914f45cf79c15e8aa7d2a51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3806eb869914f45cf79c15e8aa7d2a51">&#9670;&#160;</a></span>num_crossings() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lal::linarr::num_crossings </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal_1_1linarr.html#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em> = <code><a class="el" href="namespacelal_1_1linarr.html#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the number of edge crossings in a linear arrangement. </p>
<p >Given a graph \(G\), computes the number of edge crossings using the identity arrangement \(\pi_I\), i.e., computes \(C_{\pi_I}(G)\) using the algorithm specified by the parameter <em>A</em>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>Input graph. </td></tr>
    <tr><td class="paramname">A</td><td>Algorithm to use to compute the number of crossings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of crossings \(C\). </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The preconditions of this function depend on the choice of algorithm. See the preconditions of each algorithm in <a class="el" href="namespacelal_1_1linarr.html#aa7dc22d99964e6a6bb1fe5dd096e64b7">lal::linarr::algorithms_C</a>. </dd></dl>

</div>
</div>
<a id="a92f697f47063d903d2c092a6c4984595" name="a92f697f47063d903d2c092a6c4984595"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92f697f47063d903d2c092a6c4984595">&#9670;&#160;</a></span>num_crossings() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lal::linarr::num_crossings </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal_1_1linarr.html#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em> = <code><a class="el" href="namespacelal_1_1linarr.html#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the number of edge crossings in a linear arrangement. </p>
<p >Given a graph \(G\) and a linear arrangements \(\pi\) of its nodes, computes the number of edge crossings \(C_{\pi}(G)\) using the algorithm specified by the parameter <em>A</em>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arr</td><td>A linear arrangement of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
    <tr><td class="paramname">A</td><td>Algorithm to use to compute the number of crossings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of crossings \(C\). </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The preconditions of this function depend on the choice of algorithm. See the preconditions of each algorithm in <a class="el" href="namespacelal_1_1linarr.html#aa7dc22d99964e6a6bb1fe5dd096e64b7">lal::linarr::algorithms_C</a>. </dd></dl>

</div>
</div>
<a id="a3d16bf5730076cd9fabd4f25a38f61de" name="a3d16bf5730076cd9fabd4f25a38f61de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d16bf5730076cd9fabd4f25a38f61de">&#9670;&#160;</a></span>num_crossings() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lal::linarr::num_crossings </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal_1_1linarr.html#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em> = <code><a class="el" href="namespacelal_1_1linarr.html#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the number of edge crossings in a linear arrangement. </p>
<p >Given a graph \(G\), computes the number of edge crossings using the identity arrangement \(\pi_I\), i.e., computes \(C_{\pi_I}(G)\) using the algorithm specified by the parameter <em>A</em>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>Input graph. </td></tr>
    <tr><td class="paramname">A</td><td>Algorithm to use to compute the number of crossings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of crossings \(C\). </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The preconditions of this function depend on the choice of algorithm. See the preconditions of each algorithm in <a class="el" href="namespacelal_1_1linarr.html#aa7dc22d99964e6a6bb1fe5dd096e64b7">lal::linarr::algorithms_C</a>. </dd></dl>

</div>
</div>
<a id="a9a1346c7b927d34465602d1a0a5010c9" name="a9a1346c7b927d34465602d1a0a5010c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a1346c7b927d34465602d1a0a5010c9">&#9670;&#160;</a></span>num_crossings() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lal::linarr::num_crossings </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal_1_1linarr.html#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em> = <code><a class="el" href="namespacelal_1_1linarr.html#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the number of edge crossings in a linear arrangement. </p>
<p >Given a graph \(G\) and a linear arrangements \(\pi\) of its nodes, computes the number of edge crossings \(C_{\pi}(G)\) using the algorithm specified by the parameter <em>A</em>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arr</td><td>A linear arrangement of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
    <tr><td class="paramname">A</td><td>Algorithm to use to compute the number of crossings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of crossings \(C\). </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The preconditions of this function depend on the choice of algorithm. See the preconditions of each algorithm in <a class="el" href="namespacelal_1_1linarr.html#aa7dc22d99964e6a6bb1fe5dd096e64b7">lal::linarr::algorithms_C</a>. </dd></dl>

</div>
</div>
<a id="a986371a18404f18e4589c7b709c55315" name="a986371a18404f18e4589c7b709c55315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a986371a18404f18e4589c7b709c55315">&#9670;&#160;</a></span>num_crossings_list() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; uint64_t &gt; lal::linarr::num_crossings_list </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>arrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal_1_1linarr.html#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em> = <code><a class="el" href="namespacelal_1_1linarr.html#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the number of edge crossings in a linear arrangement. </p>
<p >Given a graph \(G\) and a list of linear arrangements \(L=\{\pi_i\}_{i=1}^k\) of its nodes, computes the number of edge crossings for each of the linear arrangements \(\pi_i\), i.e., computes \(\{C_{\pi_i}(G)\}_{i=1}^k\), using the algorithm specified by the parameter <em>A</em>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arrs</td><td>A list of \(k\) linear arrangements of the nodes \(\Pi = \{\pi_i\}_{i=1}^k\). </td></tr>
    <tr><td class="paramname">A</td><td>Algorithm to use to compute the number of crossings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list \(L\) where \(L_i = C_{\pi_i}(G)\). </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>None of the arrangements in <em>pis</em> can be empty. </dd>
<dd>
The preconditions of this function depend on the choice of algorithm. See the preconditions of each algorithm in <a class="el" href="namespacelal_1_1linarr.html#aa7dc22d99964e6a6bb1fe5dd096e64b7">lal::linarr::algorithms_C</a>. </dd></dl>

</div>
</div>
<a id="a6282f5b1fb20e9f86a8fd6747d543262" name="a6282f5b1fb20e9f86a8fd6747d543262"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6282f5b1fb20e9f86a8fd6747d543262">&#9670;&#160;</a></span>num_crossings_list() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; uint64_t &gt; lal::linarr::num_crossings_list </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>arrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal_1_1linarr.html#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em> = <code><a class="el" href="namespacelal_1_1linarr.html#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the number of edge crossings in a linear arrangement. </p>
<p >Given a graph \(G\) and a list of linear arrangements \(L=\{\pi_i\}_{i=1}^k\) of its nodes, computes the number of edge crossings for each of the linear arrangements \(\pi_i\), i.e., computes \(\{C_{\pi_i}(G)\}_{i=1}^k\), using the algorithm specified by the parameter <em>A</em>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arrs</td><td>A list of \(k\) linear arrangements of the nodes \(\Pi = \{\pi_i\}_{i=1}^k\). </td></tr>
    <tr><td class="paramname">A</td><td>Algorithm to use to compute the number of crossings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list \(L\) where \(L_i = C_{\pi_i}(G)\). </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>None of the arrangements in <em>pis</em> can be empty. </dd>
<dd>
The preconditions of this function depend on the choice of algorithm. See the preconditions of each algorithm in <a class="el" href="namespacelal_1_1linarr.html#aa7dc22d99964e6a6bb1fe5dd096e64b7">lal::linarr::algorithms_C</a>. </dd></dl>

</div>
</div>
<a id="a659d080affa5219805b9a40f6f0164e6" name="a659d080affa5219805b9a40f6f0164e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a659d080affa5219805b9a40f6f0164e6">&#9670;&#160;</a></span>predicted_num_crossings() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double lal::linarr::predicted_num_crossings </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;&#160;</td>
          <td class="paramname"><em>arr</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Approximates the number of crossings. </p>
<p >See <a class="el" href="namespacelal_1_1linarr.html#a5078b16561c6ebe15a88a9b6b5b574bc">lal::linarr::predicted_num_crossings_rational</a> for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arr</td><td>A linear arrangement of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Approximation of the number of crossings \(E_2[C_G\;|\;\delta]\). </dd></dl>

</div>
</div>
<a id="a9db950bbaa1d8623c561142f14f06920" name="a9db950bbaa1d8623c561142f14f06920"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9db950bbaa1d8623c561142f14f06920">&#9670;&#160;</a></span>predicted_num_crossings() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double lal::linarr::predicted_num_crossings </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;&#160;</td>
          <td class="paramname"><em>arr</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Approximates the number of crossings. </p>
<p >See <a class="el" href="namespacelal_1_1linarr.html#a5078b16561c6ebe15a88a9b6b5b574bc">lal::linarr::predicted_num_crossings_rational</a> for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arr</td><td>A linear arrangement of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Approximation of the number of crossings \(E_2[C_G\;|\;\delta]\). </dd></dl>

</div>
</div>
<a id="a24d733f3e2029e5cfe5497708a3baf64" name="a24d733f3e2029e5cfe5497708a3baf64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24d733f3e2029e5cfe5497708a3baf64">&#9670;&#160;</a></span>predicted_num_crossings_rational() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a> lal::linarr::predicted_num_crossings_rational </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;&#160;</td>
          <td class="paramname"><em>arr</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Predicts the number of crossings. </p>
<p >Given a linear arrangement, which determines the length of the edges, predict the number of crossings conditioned by the length of the edges in the linear arrangement. Implementation of <a class="el" href="citelist.html#CITEREF_Ferrer2014a">[16]</a>. If the arrangement is not specified, the identity arrangement is used. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arr</td><td>A linear arrangement of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Approximation of the number of crossings \(E_2[C_G\;|\;\delta]\). </dd></dl>

</div>
</div>
<a id="a5078b16561c6ebe15a88a9b6b5b574bc" name="a5078b16561c6ebe15a88a9b6b5b574bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5078b16561c6ebe15a88a9b6b5b574bc">&#9670;&#160;</a></span>predicted_num_crossings_rational() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a> lal::linarr::predicted_num_crossings_rational </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;&#160;</td>
          <td class="paramname"><em>arr</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Predicts the number of crossings. </p>
<p >Given a linear arrangement, which determines the length of the edges, predict the number of crossings conditioned by the length of the edges in the linear arrangement. Implementation of <a class="el" href="citelist.html#CITEREF_Ferrer2014a">[16]</a>. If the arrangement is not specified, the identity arrangement is used. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arr</td><td>A linear arrangement of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Approximation of the number of crossings \(E_2[C_G\;|\;\delta]\). </dd></dl>

</div>
</div>
<a id="ab70693683a8da54a2e4350c665067cf1" name="ab70693683a8da54a2e4350c665067cf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab70693683a8da54a2e4350c665067cf1">&#9670;&#160;</a></span>sum_edge_lengths() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lal::linarr::sum_edge_lengths </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;&#160;</td>
          <td class="paramname"><em>pi</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the sum of the length of the edges in a linear arrangement. </p>
<p >Given a graph \(G\) and a linear arrangement of its nodes \(\pi\), computes the sum of the length of the graph's edges in the arrangement. Formally, this function computes the value \(D_{\pi}(G)=\sum_{uv\in E(G)} |\pi(u) - \pi(v)|\).</p>
<p >If the arrangement is not specified, the identity arrangement is used. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">pi</td><td>Linear arrangement of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of edge lengths \(D\). </dd></dl>

</div>
</div>
<a id="ad7ded133434870e08c4473c12e7a03ce" name="ad7ded133434870e08c4473c12e7a03ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7ded133434870e08c4473c12e7a03ce">&#9670;&#160;</a></span>sum_edge_lengths() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lal::linarr::sum_edge_lengths </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;&#160;</td>
          <td class="paramname"><em>pi</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the sum of the length of the edges in a linear arrangement. </p>
<p >Given a graph \(G\) and a linear arrangement of its nodes \(\pi\), computes the sum of the length of the graph's edges in the arrangement. Formally, this function computes the value \(D_{\pi}(G)=\sum_{uv\in E(G)} |\pi(u) - \pi(v)|\).</p>
<p >If the arrangement is not specified, the identity arrangement is used. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">pi</td><td>Linear arrangement of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of edge lengths \(D\). </dd></dl>

</div>
</div>
<a id="ac1c3ede6e41fd6313d017ee2d932dada" name="ac1c3ede6e41fd6313d017ee2d932dada"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1c3ede6e41fd6313d017ee2d932dada">&#9670;&#160;</a></span>syntactic_dependency_structure_class() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; bool, <a class="el" href="namespacelal_1_1linarr.html#a71f12918a0e2775e9a97181fddd1f7bc">__syntactic_dependency_structure_size</a> &gt; lal::linarr::syntactic_dependency_structure_class </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;&#160;</td>
          <td class="paramname"><em>pi</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the type of syntactic dependency tree. </p>
<p >Given an undirected rooted tree and a linear arrangement of its nodes, computes the class of projective structure the tree belongs to.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input tree. </td></tr>
    <tr><td class="paramname">pi</td><td>Linear arrangement of the nodes. If \(\pi[u]=p\) then node <em>u</em> is placed in position <em>p</em> of the arrangement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The class of projective structure. If the class could not be determined the method returns <a class="el" href="namespacelal_1_1linarr.html#a3e8b744d4c81d3bb4463ec203f9199d6aad921d60486366258809553a3db49a4a">lal::linarr::syntactic_dependency_structure::unknown</a>. </dd></dl>

</div>
</div>
<a id="a6c33c7725ebeca22b2489b29ebc78071" name="a6c33c7725ebeca22b2489b29ebc78071"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c33c7725ebeca22b2489b29ebc78071">&#9670;&#160;</a></span>syntactic_dependency_structure_class() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; bool, <a class="el" href="namespacelal_1_1linarr.html#a71f12918a0e2775e9a97181fddd1f7bc">__syntactic_dependency_structure_size</a> &gt; lal::linarr::syntactic_dependency_structure_class </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;&#160;</td>
          <td class="paramname"><em>pi</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the type of syntactic dependency tree. </p>
<p >Given an undirected rooted tree and a linear arrangement of its nodes, computes the class of projective structure the tree belongs to.</p>
<p >This function admits the precomputed number of edge crossings in the same linear arrangement passed as parameter to this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input tree. </td></tr>
    <tr><td class="paramname">C</td><td>Number of crossings (see <a class="el" href="namespacelal_1_1linarr.html#a3806eb869914f45cf79c15e8aa7d2a51">lal::linarr::num_crossings</a>). </td></tr>
    <tr><td class="paramname">pi</td><td>Linear arrangement of the nodes. If \(\pi[u]=p\) then node <em>u</em> is placed in position <em>p</em> of the arrangement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The class of projective structure. If the class could not be determined the method returns <a class="el" href="namespacelal_1_1linarr.html#a3e8b744d4c81d3bb4463ec203f9199d6aad921d60486366258809553a3db49a4a">lal::linarr::syntactic_dependency_structure::unknown</a>. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
