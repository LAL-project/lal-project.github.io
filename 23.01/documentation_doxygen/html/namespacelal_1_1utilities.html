<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LAL: Linear Arrangement Library: lal::utilities Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">LAL: Linear Arrangement Library<span id="projectnumber">&#160;23.01.00</span>
   </div>
   <div id="projectbrief">A library focused on algorithms on linear arrangements of graphs.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacelal.html">lal</a></li><li class="navelem"><a class="el" href="namespacelal_1_1utilities.html">utilities</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">lal::utilities Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Set of utilities.  
<a href="namespacelal_1_1utilities.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8173609bbe4b83388e3791400524096c"><td class="memTemplParams" colspan="2">template&lt;typename result_t , bool second_set_empty, typename iterator_first_t , typename iterator_second_t , class metric , class accumulate_Q , class accumulate_R , class make_average_Q , class make_average_R , class make_average &gt; </td></tr>
<tr class="memitem:a8173609bbe4b83388e3791400524096c"><td class="memTemplItemLeft" align="right" valign="top">result_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelal_1_1utilities.html#a8173609bbe4b83388e3791400524096c">one_level_aggregation</a> (iterator_first_t bfirst, const iterator_first_t efirst, iterator_second_t bsecond, const iterator_second_t esecond, metric values, accumulate_Q accQ, accumulate_R accR, make_average_Q avgQ, make_average_R avgR, make_average avg) noexcept</td></tr>
<tr class="memdesc:a8173609bbe4b83388e3791400524096c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computation of 1-level aggregation of \(Q\) and \(R\).  <a href="namespacelal_1_1utilities.html#a8173609bbe4b83388e3791400524096c">More...</a><br /></td></tr>
<tr class="separator:a8173609bbe4b83388e3791400524096c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab950bbff0daa58f37c454e2608fda85e"><td class="memTemplParams" colspan="2">template&lt;typename result_t , bool second_set_empty, typename iterator_first_t , typename iterator_second_t , class metric , class combine , class accumulate , class make_average &gt; </td></tr>
<tr class="memitem:ab950bbff0daa58f37c454e2608fda85e"><td class="memTemplItemLeft" align="right" valign="top">result_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelal_1_1utilities.html#ab950bbff0daa58f37c454e2608fda85e">two_level_aggregation</a> (iterator_first_t bfirst, const iterator_first_t efirst, iterator_second_t bsecond, const iterator_second_t esecond, metric values, combine comb_values, accumulate acc_values, make_average avg) noexcept</td></tr>
<tr class="memdesc:ab950bbff0daa58f37c454e2608fda85e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computation of 2-level aggregation of \(Q\) and \(R\).  <a href="namespacelal_1_1utilities.html#ab950bbff0daa58f37c454e2608fda85e">More...</a><br /></td></tr>
<tr class="separator:ab950bbff0daa58f37c454e2608fda85e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d4c9394efc247df916ef3086f657a21"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1utilities.html#a5d4c9394efc247df916ef3086f657a21">are_trees_isomorphic</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;t1, const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;t2) noexcept</td></tr>
<tr class="memdesc:a5d4c9394efc247df916ef3086f657a21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Isomorphism test for unlabelled rooted trees.  <a href="namespacelal_1_1utilities.html#a5d4c9394efc247df916ef3086f657a21">More...</a><br /></td></tr>
<tr class="separator:a5d4c9394efc247df916ef3086f657a21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac66506bda73a20fc64b17e932a7cb208"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1utilities.html#ac66506bda73a20fc64b17e932a7cb208">are_trees_isomorphic</a> (const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;t1, const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;t2) noexcept</td></tr>
<tr class="memdesc:ac66506bda73a20fc64b17e932a7cb208"><td class="mdescLeft">&#160;</td><td class="mdescRight">Isomorphism test for unlabelled free trees.  <a href="namespacelal_1_1utilities.html#ac66506bda73a20fc64b17e932a7cb208">More...</a><br /></td></tr>
<tr class="separator:ac66506bda73a20fc64b17e932a7cb208"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Set of utilities. </p>
<p >This namespace contains several utilities for the library, useful for experimentation. This includes the following functions:</p>
<ul>
<li>Isomorphism tests. For free trees (see <a class="el" href="namespacelal_1_1utilities.html#ac66506bda73a20fc64b17e932a7cb208">lal::utilities::are_trees_isomorphic(const lal::graphs::free_tree&amp;,const lal::graphs::free_tree&amp;)</a>) and for rooted trees (see <a class="el" href="namespacelal_1_1utilities.html#a5d4c9394efc247df916ef3086f657a21">lal::utilities::are_trees_isomorphic(const lal::graphs::rooted_tree&amp;,const graphs::rooted_tree&amp;)</a>). </li>
</ul>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="ac66506bda73a20fc64b17e932a7cb208" name="ac66506bda73a20fc64b17e932a7cb208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac66506bda73a20fc64b17e932a7cb208">&#9670;&#160;</a></span>are_trees_isomorphic() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::utilities::are_trees_isomorphic </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;&#160;</td>
          <td class="paramname"><em>t2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Isomorphism test for unlabelled free trees. </p>
<p >See <a class="el" href="LAL_concepts.html#LAL_concepts__tree_isomorphism">Isomorphism of trees</a> for a short definition of what tree isomorphism is.</p>
<p >The algorithm implemented in this function can be found in <a class="el" href="citelist.html#CITEREF_Aho1974a">[1]</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t1</td><td>Input free tree. </td></tr>
    <tr><td class="paramname">t2</td><td>Input free tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the input trees are isomorphic. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Both input trees are valid free trees (see <a class="el" href="classlal_1_1graphs_1_1tree.html#a25c8d57865fa5f7cb5d101fd5d07fe2d">lal::graphs::free_tree::is_tree</a>). </dd></dl>

</div>
</div>
<a id="a5d4c9394efc247df916ef3086f657a21" name="a5d4c9394efc247df916ef3086f657a21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d4c9394efc247df916ef3086f657a21">&#9670;&#160;</a></span>are_trees_isomorphic() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::utilities::are_trees_isomorphic </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;&#160;</td>
          <td class="paramname"><em>t2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Isomorphism test for unlabelled rooted trees. </p>
<p >See <a class="el" href="LAL_concepts.html#LAL_concepts__tree_isomorphism">Isomorphism of trees</a> for a short definition of what tree isomorphism is.</p>
<p >The algorithm implemented in this function can be found in <a class="el" href="citelist.html#CITEREF_Aho1974a">[1]</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t1</td><td>Input rooted tree. </td></tr>
    <tr><td class="paramname">t2</td><td>Input rooted tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the input trees are isomorphic or not. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Both input trees are valid rooted trees (see <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#af464d98b1b5dfdbaaacea553d9c89154">lal::graphs::rooted_tree::is_rooted_tree</a>). </dd></dl>

</div>
</div>
<a id="a8173609bbe4b83388e3791400524096c" name="a8173609bbe4b83388e3791400524096c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8173609bbe4b83388e3791400524096c">&#9670;&#160;</a></span>one_level_aggregation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename result_t , bool second_set_empty, typename iterator_first_t , typename iterator_second_t , class metric , class accumulate_Q , class accumulate_R , class make_average_Q , class make_average_R , class make_average &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">result_t lal::utilities::one_level_aggregation </td>
          <td>(</td>
          <td class="paramtype">iterator_first_t&#160;</td>
          <td class="paramname"><em>bfirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const iterator_first_t&#160;</td>
          <td class="paramname"><em>efirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterator_second_t&#160;</td>
          <td class="paramname"><em>bsecond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const iterator_second_t&#160;</td>
          <td class="paramname"><em>esecond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">metric&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">accumulate_Q&#160;</td>
          <td class="paramname"><em>accQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">accumulate_R&#160;</td>
          <td class="paramname"><em>accR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">make_average_Q&#160;</td>
          <td class="paramname"><em>avgQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">make_average_R&#160;</td>
          <td class="paramname"><em>avgR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">make_average&#160;</td>
          <td class="paramname"><em>avg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computation of 1-level aggregation of \(Q\) and \(R\). </p>
<p >Given</p><ul>
<li>a list of \(n\) values \(Q_i\) and \(n\) values \(R_i\) (produced by the function <em>values</em>),</li>
<li>an 'accumulator' operator \(\oplus\) for \(Q_i\) (parameter <em>accQ</em>),</li>
<li>an 'accumulator' operator \(\otimes\) for \(R_i\) (parameter <em>accR</em>),</li>
<li>a \(Q\)-average function \(F_Q\) (parameter <em>avgQ</em>),</li>
<li>a \(R\)-average function \(F_R\) (parameter <em>avgR</em>),</li>
<li>and a combination operator \(\odot\) (parameter <em>avg</em>),</li>
</ul>
<p >this function computes the following average</p>
<p >\(A_1(Q,R) = \left( F_Q\left( \bigoplus_{i=1}^n Q_i \right) \right) \odot
         \left( F_R\left( \bigotimes_{i=1}^n R_i \right) \right)\)</p>
<p >The values \(Q_i\) and \(R_i\) are obtained from applying function <em>QR</em> passed as parameter. This function iterates over two sets of elements, where the second is optional and may be empty; this must be known at compile time through the template parameter <em>second_set_empty</em>. These sets are passed with iterators (parameters <em>bfirst</em>, <em>efirst</em>, <em>bsecond</em>, <em>esecond</em>).</p>
<p >If the second set is empty then function <em>QR</em> only has one parameter of the same type as the values in the first set. If the second set is not empty then <em>QR</em> has two parameters: the first parameter is of the same type as the elements in the first set, and the second parameter is of the same type as the elements in the second set. In the latter case, <em>QR</em> is called with the <em>i-th</em> element in the first set and the <em>i-th</em> element in the second set.</p>
<p >The function that average the values \(Q_i\), function <em>avgQ</em>, (resp. \(R_i\), function <em>avgR</em>) has two parameters: the summation of the values \(Q_i\) (resp. \(R_i\)) and the total amount of values.</p>
<p >See the implementation of function <a class="el" href="namespacelal_1_1linarr.html#ae5d17b6e4ea1521b436dbb20817f41b1">lal::linarr::mean_dependency_distance_1level_rational</a> and its documentation for an example of usage of this function.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">result_t</td><td>The type of the result of this function. </td></tr>
    <tr><td class="paramname">second_set_empty</td><td>Is the second set of elements empty? </td></tr>
    <tr><td class="paramname">iterator_first_t</td><td>Iterator type. </td></tr>
    <tr><td class="paramname">iterator_second_t</td><td>Iterator type. </td></tr>
    <tr><td class="paramname">metric</td><td>Function type. </td></tr>
    <tr><td class="paramname">accumulate_Q</td><td>Function type. </td></tr>
    <tr><td class="paramname">accumulate_R</td><td>Function type. </td></tr>
    <tr><td class="paramname">make_average_Q</td><td>Function type. </td></tr>
    <tr><td class="paramname">make_average_R</td><td>Function type. </td></tr>
    <tr><td class="paramname">make_average</td><td>Function type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bfirst</td><td>Iterator at the beginning of the first set. </td></tr>
    <tr><td class="paramname">efirst</td><td>Iterator at the end of the first set. </td></tr>
    <tr><td class="paramname">bsecond</td><td>Iterator at the beginning of the second set. </td></tr>
    <tr><td class="paramname">esecond</td><td>Iterator at the end of the second set. </td></tr>
    <tr><td class="paramname">values</td><td>Function to calculate the values \(Q_i,R_i\) called with the \(i\)-th element in the first set only (if <em>second_set_empty</em> is true) or called with the \(i\)-th elements in the first and second sets (if <em>second_set_empty</em> is false). Implements \(\odot\). </td></tr>
    <tr><td class="paramname">accQ</td><td>Operator \(\oplus\). A function that accumulates the values \(Q_i\). It has two parameters: the total accumulated value (passed by reference), and the value to be accumulated. </td></tr>
    <tr><td class="paramname">accR</td><td>Operator \(\otimes\). A function that accumulates the values \(R_i\). It has two parameters: the total accumulated value (passed by reference), and the value to be accumulated. </td></tr>
    <tr><td class="paramname">avgQ</td><td>Function \(F_Q\) that averages the values \(Q_i\). It has two parameters: the accumulation of the values \(Q_i\) and the total amount of values. </td></tr>
    <tr><td class="paramname">avgR</td><td>Function \(F_R\) that averages the values \(R_i\). It has two parameters: the accumulation of the values \(R_i\) and the total amount of values. </td></tr>
    <tr><td class="paramname">avg</td><td>Operator \(\odot\). A function that is passed the result of \(F_Q\) and \(F_R\).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>If the second set of elements is empty then <em>second_set_empty</em> must be true. It must be false otherwise. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>\(A_1(Q,R)\). </dd></dl>

</div>
</div>
<a id="ab950bbff0daa58f37c454e2608fda85e" name="ab950bbff0daa58f37c454e2608fda85e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab950bbff0daa58f37c454e2608fda85e">&#9670;&#160;</a></span>two_level_aggregation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename result_t , bool second_set_empty, typename iterator_first_t , typename iterator_second_t , class metric , class combine , class accumulate , class make_average &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">result_t lal::utilities::two_level_aggregation </td>
          <td>(</td>
          <td class="paramtype">iterator_first_t&#160;</td>
          <td class="paramname"><em>bfirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const iterator_first_t&#160;</td>
          <td class="paramname"><em>efirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterator_second_t&#160;</td>
          <td class="paramname"><em>bsecond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const iterator_second_t&#160;</td>
          <td class="paramname"><em>esecond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">metric&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">combine&#160;</td>
          <td class="paramname"><em>comb_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">accumulate&#160;</td>
          <td class="paramname"><em>acc_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">make_average&#160;</td>
          <td class="paramname"><em>avg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computation of 2-level aggregation of \(Q\) and \(R\). </p>
<p >Given</p><ul>
<li>a list of \(n\) values \(Q_i\) and \(n\) values \(R_i\) (produced by the function <em>values</em>),</li>
<li>and a combination operator \(\oplus\) to operator two values \(Q_i\) and \(R_i\) (parameter <em>comb_values</em>),</li>
<li>an 'accumulator' operator \(\otimes\) for \(Q_i\oplus R_i\) (parameter <em>acc_values</em>),</li>
<li>a function \(F\) to average the result of \(\otimes\) (parameter <em>avg</em>),</li>
</ul>
<p >this function computes the following average</p>
<p >\(A_2(Q,R) = F\left( \bigotimes_{i=1}^n (Q_i\oplus R_i) \right)\)</p>
<p >The values \(Q_i\) and \(R_i\) are obtained from applying function <em>values</em> passed as parameter. This function iterates over two sets of elements, where the second is optional and may be empty; this must be known at compile time through the template parameter <em>second_set_empty</em>. These sets are passed with iterators (parameters <em>bfirst</em>, <em>efirst</em>, <em>bsecond</em>, <em>esecond</em>).</p>
<p >If the second set is empty then function <em>values</em> only has one parameter of the same type as the values in the first set. If the second set is not empty then <em>values</em> has two parameters: the first parameter is of the same type as the elements in the first set, and the second parameter is of the same type as the elements in the second set. In the latter case, <em>values</em> is called with the <em>i-th</em> element in the first set and the <em>i-th</em> element in the second set.</p>
<p >See the implementation of function <a class="el" href="namespacelal_1_1linarr.html#a0b2bbd3f6c94e03091186afd5ec3ae89">lal::linarr::mean_dependency_distance_2level_rational</a> and its documentation for an example of usage of this function.</p>
<p >Note: this function can be extended to more values than just \(Q\) and \(R\) by implementing the functions accordingly: <em>QR</em> can return a structure with several values, function <em>comb_values</em> should accept said structure and combine the values accordingly, ...</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">result_t</td><td>The type of the result of this function. </td></tr>
    <tr><td class="paramname">second_set_empty</td><td>Is the second set of elements empty? </td></tr>
    <tr><td class="paramname">iterator_first_t</td><td>Iterator type. </td></tr>
    <tr><td class="paramname">iterator_second_t</td><td>Iterator type. </td></tr>
    <tr><td class="paramname">metric</td><td>Function type. </td></tr>
    <tr><td class="paramname">combine</td><td>Function type. </td></tr>
    <tr><td class="paramname">accumulate</td><td>Function type. </td></tr>
    <tr><td class="paramname">make_average</td><td>Function type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bfirst</td><td>Iterator at the beginning of the first set. </td></tr>
    <tr><td class="paramname">efirst</td><td>Iterator at the end of the first set. </td></tr>
    <tr><td class="paramname">bsecond</td><td>Iterator at the beginning of the second set. </td></tr>
    <tr><td class="paramname">esecond</td><td>Iterator at the end of the second set. </td></tr>
    <tr><td class="paramname">values</td><td>Function to calculate the values \(Q_i,R_i\) called with the \(i\)-th element in the first set only (if <em>second_set_empty</em> is true) or called with the \(i\)-th elements in the first and second sets (if <em>second_set_empty</em> is false). </td></tr>
    <tr><td class="paramname">comb_values</td><td>Operator \(\oplus\). Function that combines two values \(Q_i\) and \(R_i\). </td></tr>
    <tr><td class="paramname">acc_values</td><td>Operator \(\otimes\). Function that accumulates the combination of two values \(Q_i\) and \(R_i\). </td></tr>
    <tr><td class="paramname">avg</td><td>Function \(F\) that averages the result of \(\otimes\). It is passed the result of \(\otimes\) and the total amount of elements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>If the second set of elements is empty then <em>second_set_empty</em> must be true. It must be false otherwise. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>\(A_2(Q,R)\). </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
