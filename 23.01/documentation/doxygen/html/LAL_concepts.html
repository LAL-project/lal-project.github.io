<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LAL: Linear Arrangement Library: Important concepts in LAL</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">LAL: Linear Arrangement Library<span id="projectnumber">&#160;23.01.00</span>
   </div>
   <div id="projectbrief">A library focused on algorithms on linear arrangements of graphs.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Important concepts in LAL </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p >Page <a class="el" href="LAL_notation.html">Notation in the library's documentation</a> summarises some of the notation used here and throughout the entire library.</p>
<h1><a class="anchor" id="LAL_conectps_graph_theory"></a>
Graph Theory</h1>
<h2><a class="anchor" id="LAL_concepts__node"></a>
Node / Vertex</h2>
<p >A node of a graph is represented throughout the entire library with the type <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">lal::node</a>. Such type is just an integer, an index of a node. Such index ranges in \([0,n-1]\). Moreover, those functions that return a node, will always return a value greater than or equal to \(n\) in case that such node could not be found.</p>
<p >We typically use letters \(s,t,u,v\) to denote nodes. Letter \(r\) is also used but is often reserved for the root of a rooted tree.</p>
<p >Readers might find the noun <em>vertex</em> used instead of <em>node</em>. These two words then are synonyms.</p>
<h2><a class="anchor" id="LAL_concepts__edge"></a>
Edge</h2>
<p >An edge of a graph is simply a pair of index vertices. An edge is represented with the type <a class="el" href="namespacelal.html#a5969ec7ecc85697ebb9ec0ace78fbcab">lal::edge</a>.</p>
<h2><a class="anchor" id="LAL_concepts__edge_independent_edges"></a>
Pair of independent/disjoint edges</h2>
<p >A pair of independent/disjoint edges \(e_1,e_2\) are two edges that do not share vertices. In other words, if \(e_1=\{s,t\}\) and \(e_2=\{u,v\}\) are independent then the vertices \(s,t,u,v\) are pairwise distinct. An pair of edges (not necessarily independent/disjoint) is represented with the type <a class="el" href="namespacelal.html#a235d5351556fbc73aa51767ab7765f5c">lal::edge_pair</a>.</p>
<h2><a class="anchor" id="LAL_concepts__linear_arrangement"></a>
Linear Arrangement</h2>
<p >A linear arrangement is a well-known concept that relates vertices to distinct positions in a linear ordering. Linear arrangements are often denoted with \(\pi\) in the literature; in this library we also follow this notation. Moreover, in this library linear arrangements are implemented with two arrays describing said relationship. One array gives the values \(\pi(u)\), which is the position of vertex \(u\) in the linear arrangement; the other array gives the values \(\pi^{-1}(p)\), which is the vertex at position \(p\) in the linear arrangement.</p>
<p >In the mathematical sense, a linear arrangement is a permutation, a bijective function \(\pi \;:\; V \longrightarrow [0,n-1]\), for which:</p><ul>
<li>\(\pi(u)=p\) when the position of vertex \(u\) is \(p\).</li>
<li>\(\pi^{-1}(p)=u\) when at position \(p\) we find vertex \(u\).</li>
</ul>
<p >The two arrays underlying a linear arrangement describe the function \(\pi\). One array gives the values \(\pi(u)\) (<a class="el" href="classlal_1_1linear__arrangement.html#ad13a87dc8d3a35f6f890ad7b62fa4c55">lal::linear_arrangement::m_direct</a>); the other array gives the values \(\pi^{-1}(p)\) (<a class="el" href="classlal_1_1linear__arrangement.html#a047c797aabc191b58a160261447b47b2">lal::linear_arrangement::m_inverse</a>).</p>
<p >In code, if <em>arr</em> is a linear arrangement of <em>n</em> nodes:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classlal_1_1linear__arrangement.html">lal::linear_arrangement</a> arr(n);</div>
<div class="ttc" id="aclasslal_1_1linear__arrangement_html"><div class="ttname"><a href="classlal_1_1linear__arrangement.html">lal::linear_arrangement</a></div><div class="ttdoc">Linear arrangement of vertices.</div><div class="ttdef"><b>Definition:</b> linear_arrangement.hpp:103</div></div>
</div><!-- fragment --><p >then the vertex at position <em>p</em> can be retrieved using:</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">lal::node</a> u = arr.get_node_at_position(p);</div>
<div class="ttc" id="anamespacelal_html_ae5688e9acca02d5865dfc724e480ce25"><div class="ttname"><a href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">lal::node</a></div><div class="ttdeci">uint64_t node</div><div class="ttdoc">Node type. See Node / Vertex page for further details.</div><div class="ttdef"><b>Definition:</b> basic_types.hpp:53</div></div>
</div><!-- fragment --><p >and the position of vertex <em>u</em> can be retrieved using:</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="namespacelal.html#a5c3f34575ec933a44ed7b6d81e8c75f6">lal::position</a> p = arr.get_position_of_node(u);</div>
<div class="ttc" id="anamespacelal_html_a5c3f34575ec933a44ed7b6d81e8c75f6"><div class="ttname"><a href="namespacelal.html#a5c3f34575ec933a44ed7b6d81e8c75f6">lal::position</a></div><div class="ttdeci">uint64_t position</div><div class="ttdoc">Node's position type.</div><div class="ttdef"><b>Definition:</b> basic_types.hpp:55</div></div>
</div><!-- fragment --><h3><a class="anchor" id="LAL_concepts__linear_arrangement__identity"></a>
Identity Linear Arrangement</h3>
<p >For the sake of simplicity in documenting this library, we define the identity arrangement \(\pi_I\) as the arrangement that maps each node into the position corresponding to their label. More formally, \(\pi_I(u_i)=i\), where \(u_i\) denotes the \(i\)-th vertex in the graph. This is a special case of linear arrangement used in many functions in this library.</p>
<h3><a class="anchor" id="LAL_concepts__linear_arrangement__properties"></a>
Properties that can be defined in linear arrangements</h3>
<p >Many properties can be defined in a linear arrangement of a graph \(G\). LAL users need to know the following</p>
<ul>
<li>Edge crossings: two edges \(uv\) and \(st\) cross in a linear arrangement \(\pi\) if \(\pi(u) &lt; \pi(s) &lt; \pi(v) &lt; \pi(t)\) or \(\pi(s) &lt; \pi(u) &lt; \pi(t) &lt; \pi(v)\) when assuming, without loss of generality, that \(\pi(u)&lt;\pi(v)\) and \(\pi(s)&lt;\pi(t)\).</li>
<li>Edge lengths: the length of an edge \(uv\) in a linear arrangement \(\pi\) is defined as \(d_{\pi}=|\pi(u) - \pi(v)|\).</li>
<li>Vertex covering: a vertex \(u\) is covered by an edge \(st\) when \(\pi(s)&lt;\pi(u)&lt;\pi(t)\) or \(\pi(t)&lt;\pi(u)&lt;\pi(s)\)</li>
</ul>
<h3><a class="anchor" id="LAL_concepts__linear_arrangement__types"></a>
Types of arrangements</h3>
<p >There are many types of arrangements used in this library. For example, some functions return an arrangement of the types described below, some classes enumerate all arrangements of these types given an input tree.</p>
<ul>
<li>Planar arrangements of a graph: A planar arrangement of a graph is an arrangement in which there are no edge crossings. It does not matter if the graph is a free tree, rooted tree, or otherwise.</li>
<li>Projective arrangements of a rooted tree: A projective arrangement of a rooted graph is an arrangement in which there are no edge crossings and the root vertex of the graph is not covered by any edge. Then, a projective arrangement is also a planar arrangement and the root vertex cannot be covered. Notice that the graph must be rooted, so a tree must be rooted to have a projective arrangement.</li>
</ul>
<h2><a class="anchor" id="LAL_concepts__edge_list"></a>
Edge list</h2>
<p >An edge list is simply a collection of edges (see <a class="el" href="LAL_concepts.html#LAL_concepts__edge">Edge</a>).</p>
<h3><a class="anchor" id="LAL_concepts__edge_list_file"></a>
File with edge list format</h3>
<p >A file containing an edge list is a plain text file where each line contains an edge of the graph. Such edge is represented as a pair of non-negative integer values separated by at least one space character. The file may contain blank lines.</p>
<p >These files may be a bit uglier by allowing several edges to be in the same line (the indices must always be separated by at least one space) and even allow new-line characters inbetween the indices of the same edge.</p>
<p >It must be noted that the edges in such a file are the edges of a single graph.</p>
<h2><a class="anchor" id="LAL_concepts__head_vector"></a>
Head vector</h2>
<p >Head vectors are a very useful and very well-known representation of rooted trees in which the tree is reduced to a series of \(n\) non-negative integer values. A head vector of an \(n\)-vertex tree is, then, a list of non-negative integer numbers. The number at position \(i\) denotes the parent node of the vertex at said position; value '0' denotes the root. In this case, the vertex corresponding to the value '0' is labelled as the root.</p>
<p >Each tree is formatted as a list of whole, positive numbers (including zero), each representing a node of the tree. The number 0 denotes the root of the tree, and a number at a certain position indicates its parent node. For example, when number 4 is at position 9 it means that node 9 has parent node 4. Therefore, if number 0 is at position 1 it means that node 1 is the root of the tree. A complete example of such a tree's representation is the following </p><pre class="fragment">0 3 4 1 6 3
</pre><p> which should be interpreted as </p><pre class="fragment">(a) predecessor:       0 3 4 1 6 3
(b) node of the tree:  1 2 3 4 5 6
</pre><p> Note that lines like these are not valid: </p><pre class="fragment">(1) 0 2 2 2 2 2
(2) 2 0 0
</pre><p> Line (1) is not valid due to a self-reference in the second position, and (2) is not valid since it contains two '0' (i.e., two roots).</p>
<p >Note that sentences can be, very naturally, represented using head vectors.</p>
<h2><a class="anchor" id="LAL_concepts__centre_centroid"></a>
Centre and centroid of a tree</h2>
<p >The concept of "centre" of a tree should never be confused with "centroid" of a tree. The "centre" of a tree are the (at most two) two that result from removing the leaves of a tree all at a time: remove all leaves from the initial tree, remove all leaves from the resulting tree, and so on. The "centroid" should be seen as a centre of masses: these are the (at most two) vertices such that none of their immediate subtrees have more than half of the vertices of the whole tree.</p>
<p >More formally, the "center" is the set of (at most) two vertices that have minimum eccentricity. The "centroid" is the set of (at most) two vertices that have minimum weight, where the weight is the maximum size of the subtrees rooted at that vertex. In both cases, if the set has two vertices then they are adjacent in the tree. See <a class="el" href="citelist.html#CITEREF_Harary1969a">[23]</a> (pages 35-36) for further details.</p>
<h2><a class="anchor" id="LAL_concepts__tree_diameter"></a>
Diameter of a tree</h2>
<p >The diameter is defined as the longest shortest distance between every pair of vertices. The distance is calculated in number of edges; two adjacent vertices are at a distance 1 from each other. See <a class="el" href="citelist.html#CITEREF_Harary1969a">[23]</a> (pages 24, 35) for further details.</p>
<p >The diameter is the length of the longest path. See <a class="el" href="citelist.html#CITEREF_Harary1969a">[23]</a> (pages 24, 35) for further details.</p>
<h2><a class="anchor" id="LAL_concepts__tree_isomorphism"></a>
Isomorphism of trees</h2>
<p >Decides whether the input trees are isomorphic or not. Two trees \(t_1\) and \(t_2\) (or graphs in general) are isomorphic if there exists a mapping \(\phi \;:\; V(t_1) \longrightarrow V(t_2)\) such that</p>
<p >\(\forall u,v\in V(t_1) \; (u,v)\in E(t_1) \longleftrightarrow (\phi(u),\phi(v))\in E(t_2)\)</p>
<p >and \(\phi(r_1)=r_2\) where \(r_1\) and \(r_2\) are, respectively, the roots of \(t_1\) and \(t_2\). Note that \((u,v)\) denotes a directed edge.</p>
<h2><a class="anchor" id="LAL_concepts__tree_types"></a>
The different types of trees</h2>
<p >Here we describe the different types (classes) of trees used in LAL, some of them listed in <a class="el" href="namespacelal_1_1graphs.html#a18d52542088507e2be6241759722835b">lal::graphs::tree_type</a>.</p>
<ul>
<li>Empty tree (<a class="el" href="namespacelal_1_1graphs.html#a18d52542088507e2be6241759722835baa2e4822a98337283e39f7b60acf85ec9">lal::graphs::tree_type::empty</a>). A tree with no vertices at all.</li>
<li>Singleton tree (<a class="el" href="namespacelal_1_1graphs.html#a18d52542088507e2be6241759722835ba2ed500a3529637175e675a8791b7c56e">lal::graphs::tree_type::singleton</a>). A tree of a single vertex.</li>
<li>Caterpillar trees (<a class="el" href="namespacelal_1_1graphs.html#a18d52542088507e2be6241759722835ba0872556d7c53ad9d9f14561d36eeaefd">lal::graphs::tree_type::caterpillar</a>). These are the trees such that a linear tree is produced when its leaves are removed <a class="el" href="citelist.html#CITEREF_Harary1973a">[22]</a>.</li>
<li>Linear trees (<a class="el" href="namespacelal_1_1graphs.html#a18d52542088507e2be6241759722835ba9a932b3cb396238423eb2f33ec17d6aa">lal::graphs::tree_type::linear</a>). A linear tree has only two leaves, and the rest of the vertices (if any) have degree exactly two. This is, precisely, a path graph.</li>
<li>Spider trees (<a class="el" href="namespacelal_1_1graphs.html#a18d52542088507e2be6241759722835baf1a81d782dea6a19bdca383bffe68452">lal::graphs::tree_type::spider</a>). A spider tree has a unique vertex of degree greater than or equal to 3. The other vertices have degree 2 or 1 <a class="el" href="citelist.html#CITEREF_English2019a">[9]</a>, <a class="el" href="citelist.html#CITEREF_MathWorld_SpiderGraph">[29]</a>.</li>
<li>2-linear trees (<a class="el" href="namespacelal_1_1graphs.html#a18d52542088507e2be6241759722835ba5df97d43ced88a5757a0d8c9c574c282">lal::graphs::tree_type::two_linear</a>). A 2-linear tree is a tree in which there are at most two vertices of degree 3 or larger; the other vertices have degree 2 or 1 <a class="el" href="citelist.html#CITEREF_Johnson2020a">[38]</a>, <a class="el" href="citelist.html#CITEREF_OEIS_kLinearTrees">[37]</a>. It can also be seen as the connection of two independent trees \(T_1\) and \(T_2\) where each tree is either a spider tree or a linear tree. If one of \(T_1\) or \(T_2\) is a spider tree, the path must be incident to the spider's hub vertex.</li>
<li>Star trees (<a class="el" href="namespacelal_1_1graphs.html#a18d52542088507e2be6241759722835ba8ff953dd97c4405234a04291dee39e0b">lal::graphs::tree_type::star</a>). Also known as star graphs, trees where all vertices but one have degree 1.</li>
<li>Quasi-star trees (<a class="el" href="namespacelal_1_1graphs.html#a18d52542088507e2be6241759722835baaa9f7865e752d9da45568c80cf6bff5d">lal::graphs::tree_type::quasistar</a>). Also quasi star graphs, trees where all vertices but two have degree 1. One of these two vertices has degree exactly two, the other has degree at least two.</li>
<li>Bi-star trees (<a class="el" href="namespacelal_1_1graphs.html#a18d52542088507e2be6241759722835ba18c6369f9fbd5b37034a0eef9d7bf806">lal::graphs::tree_type::bistar</a>). These trees are made of two star trees joined by an edge at their centers.</li>
<li>unknown tree (<a class="el" href="namespacelal_1_1graphs.html#a18d52542088507e2be6241759722835baad921d60486366258809553a3db49a4a">lal::graphs::tree_type::unknown</a>). Used when a tree does not fall in any of the categories above.</li>
</ul>
<h1><a class="anchor" id="LAL_conecepts_linguistics"></a>
Linguistics</h1>
<h2><a class="anchor" id="LAL_concepts__treebank"></a>
Treebank</h2>
<p >A treebank file is simply a plain text file containing one or more trees represented using their <a class="el" href="LAL_concepts.html#LAL_concepts__head_vector">Head vector</a> representation. Each head vector must be written in a single line and each line must contain at most one such vector.</p>
<h2><a class="anchor" id="LAL_concepts__treebank_collection"></a>
Treebank Collection</h2>
<p >A treebank collection is simply a collection (or group) of treebanks (see <a class="el" href="LAL_concepts.html#LAL_concepts__treebank">Treebank</a>) that are related to one another in some way. A really good example is that of the Universal Dependencies treebank: several treebanks of the same language make up a treebank collection that corresponds to some version of UD. Another example would be the collection of treebanks of books of some author. In this setting, each treebank file will contain all the sentences of a single book.</p>
<p >In order to use treebanks with LAL, see classes <a class="el" href="classlal_1_1io_1_1treebank__reader.html">lal::io::treebank_reader</a>, <a class="el" href="classlal_1_1io_1_1treebank__processor.html">lal::io::treebank_processor</a>).</p>
<h3><a class="anchor" id="LAL_concepts__treebank_collection_main_file"></a>
Main file of a treebank collection</h3>
<p >In order to use treebank collections with LAL (see classes <a class="el" href="classlal_1_1io_1_1treebank__collection__reader.html">lal::io::treebank_collection_reader</a>, <a class="el" href="classlal_1_1io_1_1treebank__collection__processor.html">lal::io::treebank_collection_processor</a>), users must make the <em>main file</em> of the collection before.</p>
<p >The main file references all the treebanks in the collection. Its lines contain only two strings, each line describing a treebank. The first string is a self-descriptive name of the treebank (e.g., the ISO code of a language), and the second is the relative path to the file containing the syntactic dependency trees (e.g., the syntactic dependency trees of a language in a collection). The path is relative to the directory that contains the main file.</p>
<p >For example, the main file could be called <em>stanford.txt</em>, representing the Stanford treebank collection, and could contain: </p><pre class="fragment">arb path/to/file/ar-all.heads2
eus path/to/file/eu-all.heads2
ben path/to/file/bn-all.heads2
...
</pre><p> where the first column contains a string referencing the language (in this case, an ISO code), and the second column contains the relative path to the file with the syntactic dependency trees. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
