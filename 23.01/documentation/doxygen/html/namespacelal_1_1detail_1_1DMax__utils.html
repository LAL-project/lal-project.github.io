<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LAL: Linear Arrangement Library: lal::detail::DMax_utils Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">LAL: Linear Arrangement Library<span id="projectnumber">&#160;23.01.00</span>
   </div>
   <div id="projectbrief">A library focused on algorithms on linear arrangements of graphs.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacelal.html">lal</a></li><li class="navelem"><a class="el" href="namespacelal_1_1detail.html">detail</a></li><li class="navelem"><a class="el" href="namespacelal_1_1detail_1_1DMax__utils.html">DMax_utils</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">lal::detail::DMax_utils Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Utilities for the various maximum linear arrangement algorithms.  
<a href="namespacelal_1_1detail_1_1DMax__utils.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a992783d0d731b50267cfa424b9858ccc"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacelal_1_1detail_1_1Dopt__utils.html#afb9f8ca0301c64d5f9de22fb52885df8">place</a> r_place, bool make_arrangement&gt; </td></tr>
<tr class="memitem:a992783d0d731b50267cfa424b9858ccc"><td class="memTemplItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail_1_1DMax__utils.html#a992783d0d731b50267cfa424b9858ccc">arrange</a> (const std::vector&lt; std::vector&lt; <a class="el" href="structlal_1_1detail_1_1node__size.html">node_size</a> &gt; &gt; &amp;L, const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> r, <a class="el" href="namespacelal.html#a5c3f34575ec933a44ed7b6d81e8c75f6">position</a> ini, <a class="el" href="namespacelal.html#a5c3f34575ec933a44ed7b6d81e8c75f6">position</a> fin, <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;arr) noexcept</td></tr>
<tr class="memdesc:a992783d0d731b50267cfa424b9858ccc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a maximum projective arrangement using the sorted, rooted adjacency list <em>L</em>.  <a href="namespacelal_1_1detail_1_1DMax__utils.html#a992783d0d731b50267cfa424b9858ccc">More...</a><br /></td></tr>
<tr class="separator:a992783d0d731b50267cfa424b9858ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a102a2a163161795113f4cf7de7675a71"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail_1_1DMax__utils.html#a102a2a163161795113f4cf7de7675a71">arrange_projective</a> (uint64_t n, const std::vector&lt; std::vector&lt; <a class="el" href="structlal_1_1detail_1_1node__size.html">node_size</a> &gt; &gt; &amp;L, <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> r, <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;arr) noexcept</td></tr>
<tr class="memdesc:a102a2a163161795113f4cf7de7675a71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper method for the recursive method <a class="el" href="namespacelal_1_1detail_1_1DMax__utils.html#a992783d0d731b50267cfa424b9858ccc">arrange</a>.  <a href="namespacelal_1_1detail_1_1DMax__utils.html#a102a2a163161795113f4cf7de7675a71">More...</a><br /></td></tr>
<tr class="separator:a102a2a163161795113f4cf7de7675a71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa49afd8e33ef91d602a58d2c75502a43"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail_1_1DMax__utils.html#aa49afd8e33ef91d602a58d2c75502a43">arrange_projective</a> (uint64_t n, const std::vector&lt; std::vector&lt; <a class="el" href="structlal_1_1detail_1_1node__size.html">node_size</a> &gt; &gt; &amp;L, <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> r) noexcept</td></tr>
<tr class="memdesc:aa49afd8e33ef91d602a58d2c75502a43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper method for the recursive method <a class="el" href="namespacelal_1_1detail_1_1DMax__utils.html#a992783d0d731b50267cfa424b9858ccc">arrange</a>.  <a href="namespacelal_1_1detail_1_1DMax__utils.html#aa49afd8e33ef91d602a58d2c75502a43">More...</a><br /></td></tr>
<tr class="separator:aa49afd8e33ef91d602a58d2c75502a43"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Utilities for the various maximum linear arrangement algorithms. </p>
<p >Functions useful to calculate the maximum sum of edge lengths. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a992783d0d731b50267cfa424b9858ccc" name="a992783d0d731b50267cfa424b9858ccc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a992783d0d731b50267cfa424b9858ccc">&#9670;&#160;</a></span>arrange()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespacelal_1_1detail_1_1Dopt__utils.html#afb9f8ca0301c64d5f9de22fb52885df8">place</a> r_place, bool make_arrangement&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lal::detail::DMax_utils::arrange </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="structlal_1_1detail_1_1node__size.html">node_size</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a>&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelal.html#a5c3f34575ec933a44ed7b6d81e8c75f6">position</a>&#160;</td>
          <td class="paramname"><em>ini</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelal.html#a5c3f34575ec933a44ed7b6d81e8c75f6">position</a>&#160;</td>
          <td class="paramname"><em>fin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;&#160;</td>
          <td class="paramname"><em>arr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a maximum projective arrangement using the sorted, rooted adjacency list <em>L</em>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">r_place</td><td>Position of node <em>r</em> with respect to its parent. </td></tr>
    <tr><td class="paramname">make_arrangement</td><td>Whether or not the arrangement is to be constructed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">L</td><td>Adjacency list-like data structure. \(L[u]\) is a list of pairs \((v, n_u(v))\) where \(v\) is a neighbour of \(u\) and \(n_u(v)=|V(T^u_v)|\) is the size of the subtree \(T^u_v\) in vertices. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">r</td><td>The vertex root of the subtree whose interval is to be made </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ini</td><td>Left limit of the positions of the arrangement in which the tree has to be arranged. Note that the limits are included [<em>ini</em>,<em>fin</em>]. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">fin</td><td>Right limit of the positions of the arrangement in which the tree has to be arranged. Note that the limits are included [<em>ini</em>,<em>fin</em>]. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">arr</td><td>the arrangement of the tree.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of the length of the outgoing edges from vertex 'r' plus the length of the anchor of the edge from 'r' to its parent. Such length is defined as the number of vertices to the left of 'r' if 'r_place' is RIGHT_PLACE, or as the number of vertices to the right of 'r' if 'r_place' is LEFT_PLACE. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><em>L</em> is sorted decreasingly. </dd></dl>

</div>
</div>
<a id="aa49afd8e33ef91d602a58d2c75502a43" name="aa49afd8e33ef91d602a58d2c75502a43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa49afd8e33ef91d602a58d2c75502a43">&#9670;&#160;</a></span>arrange_projective() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lal::detail::DMax_utils::arrange_projective </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="structlal_1_1detail_1_1node__size.html">node_size</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a>&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper method for the recursive method <a class="el" href="namespacelal_1_1detail_1_1DMax__utils.html#a992783d0d731b50267cfa424b9858ccc">arrange</a>. </p>
<p >A call to this function is done when the goal is not to construct a linear arrangement, only to calculate its cost. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of vertices. </td></tr>
    <tr><td class="paramname">L</td><td>Adjacency list-like data structure. \(L[u]\) is a list of pairs \((v, n_u(v))\) where \(v\) is a neighbour of \(u\) and \(n_u(v)=|V(T^u_v)|\) is the size of the subtree \(T^u_v\) in vertices. </td></tr>
    <tr><td class="paramname">r</td><td>Root of the tree represented by <em>L</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cost of a maximum projective linear arrangement. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><em>L</em> is sorted decreasingly. </dd></dl>

</div>
</div>
<a id="a102a2a163161795113f4cf7de7675a71" name="a102a2a163161795113f4cf7de7675a71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a102a2a163161795113f4cf7de7675a71">&#9670;&#160;</a></span>arrange_projective() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lal::detail::DMax_utils::arrange_projective </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="structlal_1_1detail_1_1node__size.html">node_size</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a>&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;&#160;</td>
          <td class="paramname"><em>arr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper method for the recursive method <a class="el" href="namespacelal_1_1detail_1_1DMax__utils.html#a992783d0d731b50267cfa424b9858ccc">arrange</a>. </p>
<p >A call to this function is done when the goal is to construct a linear arrangement. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">n</td><td>Number of vertices. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">L</td><td>Adjacency list-like data structure. \(L[u]\) is a list of pairs \((v, n_u(v))\) where \(v\) is a neighbour of \(u\) and \(n_u(v)=|V(T^u_v)|\) is the size of the subtree \(T^u_v\) in vertices. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">r</td><td>Root of the tree represented by <em>L</em>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">arr</td><td>maximum projective linear arrangement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cost of a maximum projective linear arrangement. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><em>L</em> is sorted decreasingly. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
