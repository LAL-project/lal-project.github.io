<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LAL: Linear Arrangement Library: lal::linarr Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">LAL: Linear Arrangement Library<span id="projectnumber">&#160;21.07.01</span>
   </div>
   <div id="projectbrief">A library focused on algorithms on linear arrangements of graphs.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacelal.html">lal</a></li><li class="navelem"><a class="el" href="namespacelal_1_1linarr.html">linarr</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">lal::linarr Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Namespace for all linear-arrangement-dependent algorithms.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1linarr_1_1dependency__flux.html">dependency_flux</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dependency flux.  <a href="classlal_1_1linarr_1_1dependency__flux.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:aa7dc22d99964e6a6bb1fe5dd096e64b7" id="r_aa7dc22d99964e6a6bb1fe5dd096e64b7"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> { <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7a14eb8fb55e00336d36cb281764c88aa5">brute_force</a>
, <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7a724c4582f391c030da5a79ad83de9ecf">dynamic_programming</a>
, <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">ladder</a>
, <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7aea9e5920d6313045f9549b9a8808c8a7">stack_based</a>
 }</td></tr>
<tr class="memdesc:aa7dc22d99964e6a6bb1fe5dd096e64b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The different algorithms for computing the number of crossings.  <a href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">More...</a><br /></td></tr>
<tr class="separator:aa7dc22d99964e6a6bb1fe5dd096e64b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c6a617eb12e032ee641fd390776ff3f" id="r_a1c6a617eb12e032ee641fd390776ff3f"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c6a617eb12e032ee641fd390776ff3f">algorithms_Dmin</a> { <a class="el" href="#a1c6a617eb12e032ee641fd390776ff3fab420b0b2364d8210a7cd34babc2467d2">Unconstrained_YS</a>
, <a class="el" href="#a1c6a617eb12e032ee641fd390776ff3faf3da2ea35ec15ef8ca5ddd1fdb8c5c31">Unconstrained_FC</a>
 }</td></tr>
<tr class="memdesc:a1c6a617eb12e032ee641fd390776ff3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The different algorithms for computing the minimum sum of the length of the edges \(D\).  <a href="#a1c6a617eb12e032ee641fd390776ff3f">More...</a><br /></td></tr>
<tr class="separator:a1c6a617eb12e032ee641fd390776ff3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e8b744d4c81d3bb4463ec203f9199d6" id="r_a3e8b744d4c81d3bb4463ec203f9199d6"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e8b744d4c81d3bb4463ec203f9199d6">syntactic_dependency_structure</a> { <br />
&#160;&#160;<a class="el" href="#a3e8b744d4c81d3bb4463ec203f9199d6a118c01813b90ed2f2630b6d66992ef7d">EC1</a>
, <a class="el" href="#a3e8b744d4c81d3bb4463ec203f9199d6a3be411765e710adc7764f5056e44138c">planar</a>
, <a class="el" href="#a3e8b744d4c81d3bb4463ec203f9199d6a768db0c0fba3c72a9886b833efe822ce">projective</a>
, <a class="el" href="#a3e8b744d4c81d3bb4463ec203f9199d6acf92d51d12b1fc006d0a126c327caa14">WG1</a>
, <br />
&#160;&#160;<a class="el" href="#a3e8b744d4c81d3bb4463ec203f9199d6aad921d60486366258809553a3db49a4a">unknown</a>
<br />
 }</td></tr>
<tr class="memdesc:a3e8b744d4c81d3bb4463ec203f9199d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The different types of syntactic dependency tree structures.  <a href="#a3e8b744d4c81d3bb4463ec203f9199d6">More...</a><br /></td></tr>
<tr class="separator:a3e8b744d4c81d3bb4463ec203f9199d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae3ff82b011435622d24736c216d605da" id="r_ae3ff82b011435622d24736c216d605da"><td class="memTemplParams" colspan="2">template&lt;class G &gt; </td></tr>
<tr class="memitem:ae3ff82b011435622d24736c216d605da"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae3ff82b011435622d24736c216d605da">mean_dependency_distance_1level_rational</a> (const std::vector&lt; G &gt; &amp;L, const std::vector&lt; <a class="el" href="namespacelal.html#afa9a90a785b8b5461c516b8a3971c558">linear_arrangement</a> &gt; &amp;P={}) noexcept</td></tr>
<tr class="memdesc:ae3ff82b011435622d24736c216d605da"><td class="mdescLeft">&#160;</td><td class="mdescRight">1-level Mean Dependency Distance \(MDD\) over an ensemble of graphs.  <br /></td></tr>
<tr class="separator:ae3ff82b011435622d24736c216d605da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3ecf6602b92a3e82999baa2e54c8956" id="r_ae3ecf6602b92a3e82999baa2e54c8956"><td class="memTemplParams" colspan="2">template&lt;class G &gt; </td></tr>
<tr class="memitem:ae3ecf6602b92a3e82999baa2e54c8956"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae3ecf6602b92a3e82999baa2e54c8956">mean_dependency_distance_1level</a> (const std::vector&lt; G &gt; &amp;L, const std::vector&lt; <a class="el" href="namespacelal.html#afa9a90a785b8b5461c516b8a3971c558">linear_arrangement</a> &gt; &amp;P={}) noexcept</td></tr>
<tr class="memdesc:ae3ecf6602b92a3e82999baa2e54c8956"><td class="mdescLeft">&#160;</td><td class="mdescRight">1-level Mean Dependency Distance \(MDD\) over an ensemble of graphs.  <br /></td></tr>
<tr class="separator:ae3ecf6602b92a3e82999baa2e54c8956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0711002890a5d19306ac10792000af3" id="r_ae0711002890a5d19306ac10792000af3"><td class="memTemplParams" colspan="2">template&lt;class G &gt; </td></tr>
<tr class="memitem:ae0711002890a5d19306ac10792000af3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae0711002890a5d19306ac10792000af3">mean_dependency_distance_2level_rational</a> (const std::vector&lt; G &gt; &amp;L, const std::vector&lt; <a class="el" href="namespacelal.html#afa9a90a785b8b5461c516b8a3971c558">linear_arrangement</a> &gt; &amp;P={}) noexcept</td></tr>
<tr class="memdesc:ae0711002890a5d19306ac10792000af3"><td class="mdescLeft">&#160;</td><td class="mdescRight">2-level Mean Dependency Distance \(MDD\) over an ensemble of graphs.  <br /></td></tr>
<tr class="separator:ae0711002890a5d19306ac10792000af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45951f9789c2563dbe0f10f36cebba1c" id="r_a45951f9789c2563dbe0f10f36cebba1c"><td class="memTemplParams" colspan="2">template&lt;class G &gt; </td></tr>
<tr class="memitem:a45951f9789c2563dbe0f10f36cebba1c"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a45951f9789c2563dbe0f10f36cebba1c">mean_dependency_distance_2level</a> (const std::vector&lt; G &gt; &amp;L, const std::vector&lt; <a class="el" href="namespacelal.html#afa9a90a785b8b5461c516b8a3971c558">linear_arrangement</a> &gt; &amp;P={}) noexcept</td></tr>
<tr class="memdesc:a45951f9789c2563dbe0f10f36cebba1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">2-level Mean Dependency Distance \(MDD\) over an ensemble of graphs.  <br /></td></tr>
<tr class="separator:a45951f9789c2563dbe0f10f36cebba1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebaebf5dca65223cf0c8c7bd99298f7d" id="r_aebaebf5dca65223cf0c8c7bd99298f7d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aebaebf5dca65223cf0c8c7bd99298f7d">num_crossings</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;G, const <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;A=<a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a>) noexcept</td></tr>
<tr class="memdesc:aebaebf5dca65223cf0c8c7bd99298f7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the number of edge crossings in a linear arrangement.  <br /></td></tr>
<tr class="separator:aebaebf5dca65223cf0c8c7bd99298f7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab79ed6d08d6a8dc6c85ad1c393bed552" id="r_ab79ed6d08d6a8dc6c85ad1c393bed552"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab79ed6d08d6a8dc6c85ad1c393bed552">num_crossings</a> (const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;G, const <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;A=<a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a>) noexcept</td></tr>
<tr class="memdesc:ab79ed6d08d6a8dc6c85ad1c393bed552"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the number of edge crossings in a linear arrangement.  <br /></td></tr>
<tr class="separator:ab79ed6d08d6a8dc6c85ad1c393bed552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7cbca0fdc1fe81d272b9eec8ecb2bff" id="r_aa7cbca0fdc1fe81d272b9eec8ecb2bff"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa7cbca0fdc1fe81d272b9eec8ecb2bff">num_crossings</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;G, const <a class="el" href="namespacelal.html#afa9a90a785b8b5461c516b8a3971c558">linear_arrangement</a> &amp;pi, const <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;A=<a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a>) noexcept</td></tr>
<tr class="memdesc:aa7cbca0fdc1fe81d272b9eec8ecb2bff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the number of edge crossings in a linear arrangement.  <br /></td></tr>
<tr class="separator:aa7cbca0fdc1fe81d272b9eec8ecb2bff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d4afd4bd2981172044c2340451bfdd7" id="r_a6d4afd4bd2981172044c2340451bfdd7"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6d4afd4bd2981172044c2340451bfdd7">num_crossings</a> (const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;G, const <a class="el" href="namespacelal.html#afa9a90a785b8b5461c516b8a3971c558">linear_arrangement</a> &amp;pi, const <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;A=<a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a>) noexcept</td></tr>
<tr class="memdesc:a6d4afd4bd2981172044c2340451bfdd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the number of edge crossings in a linear arrangement.  <br /></td></tr>
<tr class="separator:a6d4afd4bd2981172044c2340451bfdd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f6651bfd247cfbb895c641594af471b" id="r_a9f6651bfd247cfbb895c641594af471b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; uint32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f6651bfd247cfbb895c641594af471b">num_crossings_list</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;G, const std::vector&lt; <a class="el" href="namespacelal.html#afa9a90a785b8b5461c516b8a3971c558">linear_arrangement</a> &gt; &amp;pis, const <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;A=<a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a>) noexcept</td></tr>
<tr class="memdesc:a9f6651bfd247cfbb895c641594af471b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the number of edge crossings in a linear arrangement.  <br /></td></tr>
<tr class="separator:a9f6651bfd247cfbb895c641594af471b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b4935c76e17b2ec4db12fc7bc1525bb" id="r_a8b4935c76e17b2ec4db12fc7bc1525bb"><td class="memItemLeft" align="right" valign="top">std::vector&lt; uint32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b4935c76e17b2ec4db12fc7bc1525bb">num_crossings_list</a> (const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;G, const std::vector&lt; <a class="el" href="namespacelal.html#afa9a90a785b8b5461c516b8a3971c558">linear_arrangement</a> &gt; &amp;pis, const <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;A=<a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a>) noexcept</td></tr>
<tr class="memdesc:a8b4935c76e17b2ec4db12fc7bc1525bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the number of edge crossings in a linear arrangement.  <br /></td></tr>
<tr class="separator:a8b4935c76e17b2ec4db12fc7bc1525bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c61a7238079a47e1510464869339684" id="r_a6c61a7238079a47e1510464869339684"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c61a7238079a47e1510464869339684">is_num_crossings_lesseq_than</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;G, uint32_t upper_bound, const <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;A=<a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a>) noexcept</td></tr>
<tr class="memdesc:a6c61a7238079a47e1510464869339684"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the number of crossings in the linear arrangement less than a constant?  <br /></td></tr>
<tr class="separator:a6c61a7238079a47e1510464869339684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff146360fa078095fb6899238ad518e5" id="r_aff146360fa078095fb6899238ad518e5"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff146360fa078095fb6899238ad518e5">is_num_crossings_lesseq_than</a> (const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;G, uint32_t upper_bound, const <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;A=<a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a>) noexcept</td></tr>
<tr class="memdesc:aff146360fa078095fb6899238ad518e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the number of crossings in the linear arrangement less than a constant?  <br /></td></tr>
<tr class="separator:aff146360fa078095fb6899238ad518e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa20d4dbcce8ebba555654e9bc8bd71a1" id="r_aa20d4dbcce8ebba555654e9bc8bd71a1"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa20d4dbcce8ebba555654e9bc8bd71a1">is_num_crossings_lesseq_than</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;G, const <a class="el" href="namespacelal.html#afa9a90a785b8b5461c516b8a3971c558">linear_arrangement</a> &amp;pi, uint32_t upper_bound, const <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;A=<a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a>) noexcept</td></tr>
<tr class="memdesc:aa20d4dbcce8ebba555654e9bc8bd71a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the number of crossings in the linear arrangement less than a constant?  <br /></td></tr>
<tr class="separator:aa20d4dbcce8ebba555654e9bc8bd71a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af47deba91683ab6146fc2c7bab4faef9" id="r_af47deba91683ab6146fc2c7bab4faef9"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af47deba91683ab6146fc2c7bab4faef9">is_num_crossings_lesseq_than</a> (const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;G, const <a class="el" href="namespacelal.html#afa9a90a785b8b5461c516b8a3971c558">linear_arrangement</a> &amp;pi, uint32_t upper_bound, const <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;A=<a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a>) noexcept</td></tr>
<tr class="memdesc:af47deba91683ab6146fc2c7bab4faef9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the number of crossings in the linear arrangement less than a constant?  <br /></td></tr>
<tr class="separator:af47deba91683ab6146fc2c7bab4faef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5c44d539c4c5cd9639118810858ca05" id="r_ae5c44d539c4c5cd9639118810858ca05"><td class="memItemLeft" align="right" valign="top">std::vector&lt; uint32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae5c44d539c4c5cd9639118810858ca05">is_num_crossings_lesseq_than_list</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;G, const std::vector&lt; <a class="el" href="namespacelal.html#afa9a90a785b8b5461c516b8a3971c558">linear_arrangement</a> &gt; &amp;pis, uint32_t upper_bound, const <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;A=<a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a>) noexcept</td></tr>
<tr class="memdesc:ae5c44d539c4c5cd9639118810858ca05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the number of crossings in the linear arrangement less than a constant?  <br /></td></tr>
<tr class="separator:ae5c44d539c4c5cd9639118810858ca05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7829c750e3d428096d4ebff2003dc40c" id="r_a7829c750e3d428096d4ebff2003dc40c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; uint32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7829c750e3d428096d4ebff2003dc40c">is_num_crossings_lesseq_than_list</a> (const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;G, const std::vector&lt; <a class="el" href="namespacelal.html#afa9a90a785b8b5461c516b8a3971c558">linear_arrangement</a> &gt; &amp;pis, uint32_t upper_bound, const <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;A=<a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a>) noexcept</td></tr>
<tr class="memdesc:a7829c750e3d428096d4ebff2003dc40c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the number of crossings in the linear arrangement less than a constant?  <br /></td></tr>
<tr class="separator:a7829c750e3d428096d4ebff2003dc40c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a630a3e7a98a692fcb35bd2f8be39fb76" id="r_a630a3e7a98a692fcb35bd2f8be39fb76"><td class="memItemLeft" align="right" valign="top">std::vector&lt; uint32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a630a3e7a98a692fcb35bd2f8be39fb76">is_num_crossings_lesseq_than_list</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;G, const std::vector&lt; <a class="el" href="namespacelal.html#afa9a90a785b8b5461c516b8a3971c558">linear_arrangement</a> &gt; &amp;pis, const std::vector&lt; uint32_t &gt; &amp;upper_bounds, const <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;A=<a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a>) noexcept</td></tr>
<tr class="memdesc:a630a3e7a98a692fcb35bd2f8be39fb76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the number of crossings in the linear arrangement less than a constant?  <br /></td></tr>
<tr class="separator:a630a3e7a98a692fcb35bd2f8be39fb76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b41df0243e02f0ec48c8e0c80bb01f1" id="r_a8b41df0243e02f0ec48c8e0c80bb01f1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; uint32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b41df0243e02f0ec48c8e0c80bb01f1">is_num_crossings_lesseq_than_list</a> (const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;G, const std::vector&lt; <a class="el" href="namespacelal.html#afa9a90a785b8b5461c516b8a3971c558">linear_arrangement</a> &gt; &amp;pis, const std::vector&lt; uint32_t &gt; &amp;upper_bounds, const <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;A=<a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a>) noexcept</td></tr>
<tr class="memdesc:a8b41df0243e02f0ec48c8e0c80bb01f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the number of crossings in the linear arrangement less than a constant?  <br /></td></tr>
<tr class="separator:a8b41df0243e02f0ec48c8e0c80bb01f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad593026a63a2b2e8cca0423ed73ff12" id="r_aad593026a63a2b2e8cca0423ed73ff12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad593026a63a2b2e8cca0423ed73ff12">predicted_num_crossings_rational</a> (const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;g, const <a class="el" href="namespacelal.html#afa9a90a785b8b5461c516b8a3971c558">linear_arrangement</a> &amp;pi={}) noexcept</td></tr>
<tr class="memdesc:aad593026a63a2b2e8cca0423ed73ff12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicts the number of crossings.  <br /></td></tr>
<tr class="separator:aad593026a63a2b2e8cca0423ed73ff12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d166077415181690881e3ee43f5894f" id="r_a4d166077415181690881e3ee43f5894f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4d166077415181690881e3ee43f5894f">predicted_num_crossings_rational</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;g, const <a class="el" href="namespacelal.html#afa9a90a785b8b5461c516b8a3971c558">linear_arrangement</a> &amp;pi={}) noexcept</td></tr>
<tr class="memdesc:a4d166077415181690881e3ee43f5894f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicts the number of crossings.  <br /></td></tr>
<tr class="separator:a4d166077415181690881e3ee43f5894f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3eea4d73c7357d1a00c12da11a81baf" id="r_ac3eea4d73c7357d1a00c12da11a81baf"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac3eea4d73c7357d1a00c12da11a81baf">predicted_num_crossings</a> (const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;g, const <a class="el" href="namespacelal.html#afa9a90a785b8b5461c516b8a3971c558">linear_arrangement</a> &amp;pi={}) noexcept</td></tr>
<tr class="memdesc:ac3eea4d73c7357d1a00c12da11a81baf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximates the number of crossings.  <br /></td></tr>
<tr class="separator:ac3eea4d73c7357d1a00c12da11a81baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5737b1b3fb7adc6df6491b27d49f76d7" id="r_a5737b1b3fb7adc6df6491b27d49f76d7"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5737b1b3fb7adc6df6491b27d49f76d7">predicted_num_crossings</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;g, const <a class="el" href="namespacelal.html#afa9a90a785b8b5461c516b8a3971c558">linear_arrangement</a> &amp;pi={}) noexcept</td></tr>
<tr class="memdesc:a5737b1b3fb7adc6df6491b27d49f76d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximates the number of crossings.  <br /></td></tr>
<tr class="separator:a5737b1b3fb7adc6df6491b27d49f76d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1c3ede6e41fd6313d017ee2d932dada" id="r_ac1c3ede6e41fd6313d017ee2d932dada"><td class="memItemLeft" align="right" valign="top">std::array&lt; bool, <a class="el" href="#a71f12918a0e2775e9a97181fddd1f7bc">__syntactic_dependency_structure_size</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac1c3ede6e41fd6313d017ee2d932dada">syntactic_dependency_structure_class</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;t, const <a class="el" href="namespacelal.html#afa9a90a785b8b5461c516b8a3971c558">linear_arrangement</a> &amp;pi={}) noexcept</td></tr>
<tr class="memdesc:ac1c3ede6e41fd6313d017ee2d932dada"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the type of syntactic dependency tree.  <br /></td></tr>
<tr class="separator:ac1c3ede6e41fd6313d017ee2d932dada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4558fab36ed2a75572794f60a17c623f" id="r_a4558fab36ed2a75572794f60a17c623f"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4558fab36ed2a75572794f60a17c623f">sum_edge_lengths</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;g, const <a class="el" href="namespacelal.html#afa9a90a785b8b5461c516b8a3971c558">linear_arrangement</a> &amp;pi={}) noexcept</td></tr>
<tr class="memdesc:a4558fab36ed2a75572794f60a17c623f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sum of the length of the edges in a linear arrangement.  <br /></td></tr>
<tr class="separator:a4558fab36ed2a75572794f60a17c623f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd14e3bf7c6b3b3ce6eaa319c8eee486" id="r_afd14e3bf7c6b3b3ce6eaa319c8eee486"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd14e3bf7c6b3b3ce6eaa319c8eee486">sum_edge_lengths</a> (const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;g, const <a class="el" href="namespacelal.html#afa9a90a785b8b5461c516b8a3971c558">linear_arrangement</a> &amp;pi={}) noexcept</td></tr>
<tr class="memdesc:afd14e3bf7c6b3b3ce6eaa319c8eee486"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sum of the length of the edges in a linear arrangement.  <br /></td></tr>
<tr class="separator:afd14e3bf7c6b3b3ce6eaa319c8eee486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a679b59e355c13c9ac4969f897b731582" id="r_a679b59e355c13c9ac4969f897b731582"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a679b59e355c13c9ac4969f897b731582">mean_dependency_distance_rational</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;g, const <a class="el" href="namespacelal.html#afa9a90a785b8b5461c516b8a3971c558">linear_arrangement</a> &amp;pi={}) noexcept</td></tr>
<tr class="memdesc:a679b59e355c13c9ac4969f897b731582"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the mean dependency distance \(MDD\) as an exact rational value.  <br /></td></tr>
<tr class="separator:a679b59e355c13c9ac4969f897b731582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77d3933929930331d44200deed260a41" id="r_a77d3933929930331d44200deed260a41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a77d3933929930331d44200deed260a41">mean_dependency_distance_rational</a> (const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;g, const <a class="el" href="namespacelal.html#afa9a90a785b8b5461c516b8a3971c558">linear_arrangement</a> &amp;pi={}) noexcept</td></tr>
<tr class="memdesc:a77d3933929930331d44200deed260a41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the mean dependency distance \(MDD\) as an exact rational value.  <br /></td></tr>
<tr class="separator:a77d3933929930331d44200deed260a41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2030c0f279ced9571405cebe5675e241" id="r_a2030c0f279ced9571405cebe5675e241"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2030c0f279ced9571405cebe5675e241">mean_dependency_distance</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;g, const <a class="el" href="namespacelal.html#afa9a90a785b8b5461c516b8a3971c558">linear_arrangement</a> &amp;pi={}) noexcept</td></tr>
<tr class="memdesc:a2030c0f279ced9571405cebe5675e241"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the mean dependency distance \(MDD\) as a floating point value.  <br /></td></tr>
<tr class="separator:a2030c0f279ced9571405cebe5675e241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43bba5ac9ff41d48b5320b70d9e4f403" id="r_a43bba5ac9ff41d48b5320b70d9e4f403"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a43bba5ac9ff41d48b5320b70d9e4f403">mean_dependency_distance</a> (const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;g, const <a class="el" href="namespacelal.html#afa9a90a785b8b5461c516b8a3971c558">linear_arrangement</a> &amp;pi={}) noexcept</td></tr>
<tr class="memdesc:a43bba5ac9ff41d48b5320b70d9e4f403"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the mean dependency distance \(MDD\) as a floating point value.  <br /></td></tr>
<tr class="separator:a43bba5ac9ff41d48b5320b70d9e4f403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a248bd94b7e14e45090144b5d0fcd1c31" id="r_a248bd94b7e14e45090144b5d0fcd1c31"><td class="memItemLeft" align="right" valign="top">std::pair&lt; uint32_t, <a class="el" href="namespacelal.html#afa9a90a785b8b5461c516b8a3971c558">linear_arrangement</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a248bd94b7e14e45090144b5d0fcd1c31">min_sum_edge_lengths</a> (const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;t, const <a class="el" href="#a1c6a617eb12e032ee641fd390776ff3f">algorithms_Dmin</a> &amp;a=<a class="el" href="#a1c6a617eb12e032ee641fd390776ff3fab420b0b2364d8210a7cd34babc2467d2">algorithms_Dmin::Unconstrained_YS</a>) noexcept</td></tr>
<tr class="memdesc:a248bd94b7e14e45090144b5d0fcd1c31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the minimum value of \(D\) in free trees.  <br /></td></tr>
<tr class="separator:a248bd94b7e14e45090144b5d0fcd1c31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae442b1b7bf9d4d6e8bf9d1e030d59524" id="r_ae442b1b7bf9d4d6e8bf9d1e030d59524"><td class="memItemLeft" align="right" valign="top">std::pair&lt; uint32_t, <a class="el" href="namespacelal.html#afa9a90a785b8b5461c516b8a3971c558">linear_arrangement</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae442b1b7bf9d4d6e8bf9d1e030d59524">min_sum_edge_lengths</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;t, const <a class="el" href="#a1c6a617eb12e032ee641fd390776ff3f">algorithms_Dmin</a> &amp;a=<a class="el" href="#a1c6a617eb12e032ee641fd390776ff3fab420b0b2364d8210a7cd34babc2467d2">algorithms_Dmin::Unconstrained_YS</a>) noexcept</td></tr>
<tr class="memdesc:ae442b1b7bf9d4d6e8bf9d1e030d59524"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the minimum value of \(D\) in trees.  <br /></td></tr>
<tr class="separator:ae442b1b7bf9d4d6e8bf9d1e030d59524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9ff71a7bedff3adebf6ad71fe7abc81" id="r_af9ff71a7bedff3adebf6ad71fe7abc81"><td class="memItemLeft" align="right" valign="top">std::pair&lt; uint32_t, <a class="el" href="namespacelal.html#afa9a90a785b8b5461c516b8a3971c558">linear_arrangement</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af9ff71a7bedff3adebf6ad71fe7abc81">min_sum_edge_lengths_planar</a> (const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:af9ff71a7bedff3adebf6ad71fe7abc81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the minimum value of \(D\) in trees under the planarity constraint.  <br /></td></tr>
<tr class="separator:af9ff71a7bedff3adebf6ad71fe7abc81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad13396c38b91587442940d6fdd043d00" id="r_ad13396c38b91587442940d6fdd043d00"><td class="memItemLeft" align="right" valign="top">std::pair&lt; uint32_t, <a class="el" href="namespacelal.html#afa9a90a785b8b5461c516b8a3971c558">linear_arrangement</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad13396c38b91587442940d6fdd043d00">min_sum_edge_lengths_planar</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:ad13396c38b91587442940d6fdd043d00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the minimum value of \(D\) in trees under the planarity constraint.  <br /></td></tr>
<tr class="separator:ad13396c38b91587442940d6fdd043d00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a426766ab65d36b12b3b85929d231667b" id="r_a426766ab65d36b12b3b85929d231667b"><td class="memItemLeft" align="right" valign="top">std::pair&lt; uint32_t, <a class="el" href="namespacelal.html#afa9a90a785b8b5461c516b8a3971c558">linear_arrangement</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a426766ab65d36b12b3b85929d231667b">min_sum_edge_lengths_projective</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:a426766ab65d36b12b3b85929d231667b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the minimum value of \(D\) in rooted trees under the projectivity constraint.  <br /></td></tr>
<tr class="separator:a426766ab65d36b12b3b85929d231667b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aece830c5bd25ce649ef421799677bbff" id="r_aece830c5bd25ce649ef421799677bbff"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classlal_1_1linarr_1_1dependency__flux.html">dependency_flux</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aece830c5bd25ce649ef421799677bbff">compute_flux</a> (const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;t, const <a class="el" href="namespacelal.html#afa9a90a785b8b5461c516b8a3971c558">linear_arrangement</a> &amp;pi={}) noexcept</td></tr>
<tr class="memdesc:aece830c5bd25ce649ef421799677bbff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the flux of a dependency tree.  <br /></td></tr>
<tr class="separator:aece830c5bd25ce649ef421799677bbff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fbd328b68242fee1f44a6f1e537b0e3" id="r_a8fbd328b68242fee1f44a6f1e537b0e3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classlal_1_1linarr_1_1dependency__flux.html">dependency_flux</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8fbd328b68242fee1f44a6f1e537b0e3">compute_flux</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;t, const <a class="el" href="namespacelal.html#afa9a90a785b8b5461c516b8a3971c558">linear_arrangement</a> &amp;pi={}) noexcept</td></tr>
<tr class="memdesc:a8fbd328b68242fee1f44a6f1e537b0e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the flux of a dependency tree.  <br /></td></tr>
<tr class="separator:a8fbd328b68242fee1f44a6f1e537b0e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b3203432e13dfec29563796643e6187" id="r_a6b3203432e13dfec29563796643e6187"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b3203432e13dfec29563796643e6187">is_permutation</a> (const <a class="el" href="namespacelal.html#afa9a90a785b8b5461c516b8a3971c558">linear_arrangement</a> &amp;arr={}) noexcept</td></tr>
<tr class="memdesc:a6b3203432e13dfec29563796643e6187"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is a given input arrangement a permutation?  <br /></td></tr>
<tr class="separator:a6b3203432e13dfec29563796643e6187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6991b736a773a44c41d7fb1b9bd3fe00" id="r_a6991b736a773a44c41d7fb1b9bd3fe00"><td class="memTemplParams" colspan="2">template&lt;class G &gt; </td></tr>
<tr class="memitem:a6991b736a773a44c41d7fb1b9bd3fe00"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6991b736a773a44c41d7fb1b9bd3fe00">is_arrangement</a> (const G &amp;g, const <a class="el" href="namespacelal.html#afa9a90a785b8b5461c516b8a3971c558">linear_arrangement</a> &amp;arr) noexcept</td></tr>
<tr class="memdesc:a6991b736a773a44c41d7fb1b9bd3fe00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is a given arrangement valid?  <br /></td></tr>
<tr class="separator:a6991b736a773a44c41d7fb1b9bd3fe00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8125bbeee0a12292b402f9bfa5911dc" id="r_aa8125bbeee0a12292b402f9bfa5911dc"><td class="memTemplParams" colspan="2">template&lt;class G &gt; </td></tr>
<tr class="memitem:aa8125bbeee0a12292b402f9bfa5911dc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa8125bbeee0a12292b402f9bfa5911dc">is_planar</a> (const G &amp;g, const <a class="el" href="namespacelal.html#afa9a90a785b8b5461c516b8a3971c558">linear_arrangement</a> &amp;arr={}) noexcept</td></tr>
<tr class="memdesc:aa8125bbeee0a12292b402f9bfa5911dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is a given arrangement planar?  <br /></td></tr>
<tr class="separator:aa8125bbeee0a12292b402f9bfa5911dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab708d7b97fc8e2200dfca27846723a08" id="r_ab708d7b97fc8e2200dfca27846723a08"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab708d7b97fc8e2200dfca27846723a08">is_projective</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;rt, const <a class="el" href="namespacelal.html#afa9a90a785b8b5461c516b8a3971c558">linear_arrangement</a> &amp;arr={}) noexcept</td></tr>
<tr class="memdesc:ab708d7b97fc8e2200dfca27846723a08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is a given arrangement projective?  <br /></td></tr>
<tr class="separator:ab708d7b97fc8e2200dfca27846723a08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a057b0d2eb4b8df8ed96d2a258b83035f" id="r_a057b0d2eb4b8df8ed96d2a258b83035f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a057b0d2eb4b8df8ed96d2a258b83035f">head_initial_rational</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;g, const <a class="el" href="namespacelal.html#afa9a90a785b8b5461c516b8a3971c558">linear_arrangement</a> &amp;pi={}) noexcept</td></tr>
<tr class="memdesc:a057b0d2eb4b8df8ed96d2a258b83035f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the headedness of a directed graph as an exact rational number.  <br /></td></tr>
<tr class="separator:a057b0d2eb4b8df8ed96d2a258b83035f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc15417e84e2d272ca8d49a266929e12" id="r_acc15417e84e2d272ca8d49a266929e12"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acc15417e84e2d272ca8d49a266929e12">head_initial</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;g, const <a class="el" href="namespacelal.html#afa9a90a785b8b5461c516b8a3971c558">linear_arrangement</a> &amp;pi={}) noexcept</td></tr>
<tr class="memdesc:acc15417e84e2d272ca8d49a266929e12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the headedness of a linearly arranged directed graph.  <br /></td></tr>
<tr class="separator:acc15417e84e2d272ca8d49a266929e12"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a71f12918a0e2775e9a97181fddd1f7bc" id="r_a71f12918a0e2775e9a97181fddd1f7bc"><td class="memItemLeft" align="right" valign="top"><a id="a71f12918a0e2775e9a97181fddd1f7bc" name="a71f12918a0e2775e9a97181fddd1f7bc"></a>
constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>__syntactic_dependency_structure_size</b></td></tr>
<tr class="memdesc:a71f12918a0e2775e9a97181fddd1f7bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of elements within enumeration <a class="el" href="#a3e8b744d4c81d3bb4463ec203f9199d6">syntactic_dependency_structure</a>. <br /></td></tr>
<tr class="separator:a71f12918a0e2775e9a97181fddd1f7bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Namespace for all linear-arrangement-dependent algorithms. </p>
<p>This namespace contains functions to calculate properties of graphs that depend on a linear arrangement. Said arrangement van be given explicitly, i.e., by constructing a <a class="el" href="namespacelal.html#afa9a90a785b8b5461c516b8a3971c558">lal::linear_arrangement</a> object, or by omitting it in the functions to let these use the labelling of the graph. For example, given a graph </p><div class="fragment"><div class="line"><a class="code hl_class" href="classlal_1_1graphs_1_1undirected__graph.html">lal::graphs::undirected_graph</a> g;</div>
<div class="ttc" id="aclasslal_1_1graphs_1_1undirected__graph_html"><div class="ttname"><a href="classlal_1_1graphs_1_1undirected__graph.html">lal::graphs::undirected_graph</a></div><div class="ttdoc">Undirected graph class.</div><div class="ttdef"><b>Definition</b> undirected_graph.hpp:67</div></div>
</div><!-- fragment --><p> we can calculate the sum of length of the edges using function <a class="el" href="#a4558fab36ed2a75572794f60a17c623f">lal::linarr::sum_edge_lengths</a> in two different ways. The first is by omitting the arrangement: </p><div class="fragment"><div class="line"><a class="code hl_function" href="#a4558fab36ed2a75572794f60a17c623f">lal::linarr::sum_edge_lengths</a>(g);</div>
<div class="ttc" id="anamespacelal_1_1linarr_html_a4558fab36ed2a75572794f60a17c623f"><div class="ttname"><a href="#a4558fab36ed2a75572794f60a17c623f">lal::linarr::sum_edge_lengths</a></div><div class="ttdeci">uint32_t sum_edge_lengths(const graphs::directed_graph &amp;g, const linear_arrangement &amp;pi={}) noexcept</div><div class="ttdoc">Computes the sum of the length of the edges in a linear arrangement.</div></div>
</div><!-- fragment --><p> or by giving one explicitly </p><div class="fragment"><div class="line"><a class="code hl_function" href="#a4558fab36ed2a75572794f60a17c623f">lal::linarr::sum_edge_lengths</a>(g, {...});</div>
</div><!-- fragment --><p>A linear arrangement object is a vector whose size is equal to the number of nodes of its corresponding graph. Note, however, that a linear arrangement has no associated graph; it is just a vector. Throughout this namespace we use the symbol for the number pi, \(\pi\) to denote a linear arrangement, as is usually done in the scientific literature.</p>
<p>The contents of a <a class="el" href="namespacelal.html#afa9a90a785b8b5461c516b8a3971c558">lal::linear_arrangement</a> object are as follows: if \(\pi\) is a linear arrangement then the <em>u-th</em> position of \(\pi\) contains the position of that node in the arrangement. Formally, \(\pi[u] = p\) if, and only if, node <em>u</em> is at position <em>p</em> in the linear arrangement.</p>
<p>The identity arrangement \(\pi_I\) is a special case of linear arrangement used in many functions. Such an arrangement is one that maps each node into the position corresponding to their label, i.e., \( \pi_I(u) = u\). When omitting the arrangement in the functions of this namespace, the user should consider that the arrangement used is the identity arrangement. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="aa7dc22d99964e6a6bb1fe5dd096e64b7" name="aa7dc22d99964e6a6bb1fe5dd096e64b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">&#9670;&#160;</a></span>algorithms_C</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">lal::linarr::algorithms_C</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The different algorithms for computing the number of crossings. </p>
<p>Two edges \(\{s,t\},\{u,v\}\) of a graph \(G\) cross in a linear arrangement \(\pi\) of its nodes if, and only if, their positions interleave in the linear arrangement. More formally, given an arrangement \(\pi\) of a graph \(G\), the edges \(\{s,t\},\{u,v\}\) cros iff \(\pi(s) &lt; \pi(u) &lt; \pi(t) &lt; \pi(v)\) . </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa7dc22d99964e6a6bb1fe5dd096e64b7a14eb8fb55e00336d36cb281764c88aa5" name="aa7dc22d99964e6a6bb1fe5dd096e64b7a14eb8fb55e00336d36cb281764c88aa5"></a>brute_force&#160;</td><td class="fielddoc"><p>Brute force computation of the number of crossings. </p>
<p>Complexity: time \(O(m^2)\), space \(O(1)\). </p>
</td></tr>
<tr><td class="fieldname"><a id="aa7dc22d99964e6a6bb1fe5dd096e64b7a724c4582f391c030da5a79ad83de9ecf" name="aa7dc22d99964e6a6bb1fe5dd096e64b7a724c4582f391c030da5a79ad83de9ecf"></a>dynamic_programming&#160;</td><td class="fielddoc"><p>Dynamic programming algorithm. </p>
<p>Complexity: time \(O(n^2)\), space \(O(n^2)\). </p>
</td></tr>
<tr><td class="fieldname"><a id="aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06" name="aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06"></a>ladder&#160;</td><td class="fielddoc"><p>Dynamic programming algorithm. </p>
<p>Complexity: time \(O(n^2)\), space \(O(n)\). </p>
</td></tr>
<tr><td class="fieldname"><a id="aa7dc22d99964e6a6bb1fe5dd096e64b7aea9e5920d6313045f9549b9a8808c8a7" name="aa7dc22d99964e6a6bb1fe5dd096e64b7aea9e5920d6313045f9549b9a8808c8a7"></a>stack_based&#160;</td><td class="fielddoc"><p>Algorithm based on sorting. </p>
<p>Complexity: time \(O(m\log n)\), space \(O(m)\). </p>
</td></tr>
</table>

</div>
</div>
<a id="a1c6a617eb12e032ee641fd390776ff3f" name="a1c6a617eb12e032ee641fd390776ff3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c6a617eb12e032ee641fd390776ff3f">&#9670;&#160;</a></span>algorithms_Dmin</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a1c6a617eb12e032ee641fd390776ff3f">lal::linarr::algorithms_Dmin</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The different algorithms for computing the minimum sum of the length of the edges \(D\). </p>
<p>This enumeration's values are used to choose the algorithm which the functions <a class="el" href="#a248bd94b7e14e45090144b5d0fcd1c31">lal::linarr::min_sum_edge_lengths</a> use to compute the minimum value of the sum of the length of the edges \(D\). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1c6a617eb12e032ee641fd390776ff3fab420b0b2364d8210a7cd34babc2467d2" name="a1c6a617eb12e032ee641fd390776ff3fab420b0b2364d8210a7cd34babc2467d2"></a>Unconstrained_YS&#160;</td><td class="fielddoc"><p>Yossi Shiloach's algorithm to calculate unconstrained optimal linearization of free trees. </p>
<p>This value makes the <a class="el" href="#a248bd94b7e14e45090144b5d0fcd1c31">lal::linarr::min_sum_edge_lengths</a> function choose the implementation of Yossi Shiloach's algorithm. This algorithm was published in <a class="el" href="citelist.html#CITEREF_Shiloach1979a">[31]</a>. The implementation of this algorithm applies the corrections published in <a class="el" href="citelist.html#CITEREF_Esteban2017a">[11]</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1c6a617eb12e032ee641fd390776ff3faf3da2ea35ec15ef8ca5ddd1fdb8c5c31" name="a1c6a617eb12e032ee641fd390776ff3faf3da2ea35ec15ef8ca5ddd1fdb8c5c31"></a>Unconstrained_FC&#160;</td><td class="fielddoc"><p>Fan Chung's algorithm to calculate unconstrained optimal linearization of free trees. </p>
<p>This value makes the <a class="el" href="#a248bd94b7e14e45090144b5d0fcd1c31">lal::linarr::min_sum_edge_lengths</a> function choose the implementation of Fan Chung's algorithm. This algorithm was published in <a class="el" href="citelist.html#CITEREF_Chung1984a">[10]</a>. In particular, this implements Fan Chung's quadratic algorithm (Section 3). </p>
</td></tr>
</table>

</div>
</div>
<a id="a3e8b744d4c81d3bb4463ec203f9199d6" name="a3e8b744d4c81d3bb4463ec203f9199d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e8b744d4c81d3bb4463ec203f9199d6">&#9670;&#160;</a></span>syntactic_dependency_structure</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a3e8b744d4c81d3bb4463ec203f9199d6">lal::linarr::syntactic_dependency_structure</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The different types of syntactic dependency tree structures. </p>
<p>Any tree with its nodes linearly arranged can be classified into several different classes.</p>
<p>We can currently identify the following structures:</p><ul>
<li>Projective structures (see <a class="el" href="#a3e8b744d4c81d3bb4463ec203f9199d6a768db0c0fba3c72a9886b833efe822ce">syntactic_dependency_structure::projective</a>),</li>
<li>Planar structures (see <a class="el" href="#a3e8b744d4c81d3bb4463ec203f9199d6a3be411765e710adc7764f5056e44138c">syntactic_dependency_structure::planar</a>),</li>
<li>Well nested trees with maximum degree gap 1 (see <a class="el" href="#a3e8b744d4c81d3bb4463ec203f9199d6acf92d51d12b1fc006d0a126c327caa14">syntactic_dependency_structure::WG1</a>),</li>
<li>1-Endpoint Crossing (see <a class="el" href="#a3e8b744d4c81d3bb4463ec203f9199d6a118c01813b90ed2f2630b6d66992ef7d">syntactic_dependency_structure::EC1</a>), </li>
</ul>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a3e8b744d4c81d3bb4463ec203f9199d6a118c01813b90ed2f2630b6d66992ef7d" name="a3e8b744d4c81d3bb4463ec203f9199d6a118c01813b90ed2f2630b6d66992ef7d"></a>EC1&#160;</td><td class="fielddoc"><p>1-Endpoint Crossing. </p>
<p>A structure is 1-endpoint crossing if, given any dependency, all other dependencies crossing it are incident to a common node. See <a class="el" href="citelist.html#CITEREF_Pitler2013a">[30]</a> for further details. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3e8b744d4c81d3bb4463ec203f9199d6a3be411765e710adc7764f5056e44138c" name="a3e8b744d4c81d3bb4463ec203f9199d6a3be411765e710adc7764f5056e44138c"></a>planar&#160;</td><td class="fielddoc"><p>Planar structures. </p>
<p>A structure is planar if none of its dependencies cross. Two dependencies \((s,t), (u,v)\) cross if, and only if, their positions in the arrangement are interleaved, i.e., if \(\pi(s) &lt; \pi(u) &lt; \pi(t) &lt; \pi(v)\), assuming that \(s\) precedes \(t\) and \(u\) precedes \(v\) in the arrangement. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3e8b744d4c81d3bb4463ec203f9199d6a768db0c0fba3c72a9886b833efe822ce" name="a3e8b744d4c81d3bb4463ec203f9199d6a768db0c0fba3c72a9886b833efe822ce"></a>projective&#160;</td><td class="fielddoc"><p>Projective structures. </p>
<p>A structure is projective if it is <a class="el" href="#a3e8b744d4c81d3bb4463ec203f9199d6a3be411765e710adc7764f5056e44138c">syntactic_dependency_structure::planar</a> and the root is not covered by any dependency. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3e8b744d4c81d3bb4463ec203f9199d6acf92d51d12b1fc006d0a126c327caa14" name="a3e8b744d4c81d3bb4463ec203f9199d6acf92d51d12b1fc006d0a126c327caa14"></a>WG1&#160;</td><td class="fielddoc"><p>Well nested trees with maximum gap-degree 1. </p>
<p>For further details and a thorough discussion, see <a class="el" href="citelist.html#CITEREF_Gomez2011a">[17]</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3e8b744d4c81d3bb4463ec203f9199d6aad921d60486366258809553a3db49a4a" name="a3e8b744d4c81d3bb4463ec203f9199d6aad921d60486366258809553a3db49a4a"></a>unknown&#160;</td><td class="fielddoc"><p>The structure could not be classified. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aece830c5bd25ce649ef421799677bbff" name="aece830c5bd25ce649ef421799677bbff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aece830c5bd25ce649ef421799677bbff">&#9670;&#160;</a></span>compute_flux() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classlal_1_1linarr_1_1dependency__flux.html">dependency_flux</a> &gt; lal::linarr::compute_flux </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#afa9a90a785b8b5461c516b8a3971c558">linear_arrangement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pi</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the flux of a dependency tree. </p>
<p>This function is implemented based on the explanations given in <a class="el" href="citelist.html#CITEREF_Kahane2017a">[24]</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input free tree (or dependency tree). </td></tr>
    <tr><td class="paramname">pi</td><td>A linear arrangement of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The tree <em>t</em> is a valid free tree. Method <a class="el" href="classlal_1_1graphs_1_1tree.html#a25c8d57865fa5f7cb5d101fd5d07fe2d" title="Is this graph is an actual tree?">graphs::free_tree::is_tree</a> returns true. </dd></dl>

</div>
</div>
<a id="a8fbd328b68242fee1f44a6f1e537b0e3" name="a8fbd328b68242fee1f44a6f1e537b0e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fbd328b68242fee1f44a6f1e537b0e3">&#9670;&#160;</a></span>compute_flux() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classlal_1_1linarr_1_1dependency__flux.html">dependency_flux</a> &gt; lal::linarr::compute_flux </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#afa9a90a785b8b5461c516b8a3971c558">linear_arrangement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pi</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the flux of a dependency tree. </p>
<p>This function is implemented based on the explanations given in <a class="el" href="citelist.html#CITEREF_Kahane2017a">[24]</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input rooted tree (or dependency tree). </td></tr>
    <tr><td class="paramname">pi</td><td>A linear arrangement of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The tree <em>t</em> is a valid rooted tree. Method <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#af464d98b1b5dfdbaaacea553d9c89154" title="Is this tree a valid rooted tree?">graphs::rooted_tree::is_rooted_tree</a> returns true. </dd></dl>

</div>
</div>
<a id="acc15417e84e2d272ca8d49a266929e12" name="acc15417e84e2d272ca8d49a266929e12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc15417e84e2d272ca8d49a266929e12">&#9670;&#160;</a></span>head_initial()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double lal::linarr::head_initial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#afa9a90a785b8b5461c516b8a3971c558">linear_arrangement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pi</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the headedness of a linearly arranged directed graph. </p>
<p>See <a class="el" href="#a057b0d2eb4b8df8ed96d2a258b83035f">lal::linarr::head_initial_rational</a> for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">pi</td><td>Permutation of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return value is a floating point value. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>\(m &gt; 0\). </dd></dl>

</div>
</div>
<a id="a057b0d2eb4b8df8ed96d2a258b83035f" name="a057b0d2eb4b8df8ed96d2a258b83035f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a057b0d2eb4b8df8ed96d2a258b83035f">&#9670;&#160;</a></span>head_initial_rational()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a> lal::linarr::head_initial_rational </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#afa9a90a785b8b5461c516b8a3971c558">linear_arrangement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pi</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the headedness of a directed graph as an exact rational number. </p>
<p>Given a graph and a permutation of its nodes, the headedness \(h\) is the ratio of right-branching edges over the total amount of edges. More precisely, it is</p>
<p>\(h = \frac{r}{m}\)</p>
<p>where \(r\) is the number of right-branching edges and \(m\) is the number of edges of the graph.</p>
<p>A value of 0 indicates perfect left branching, and a value of 1 indicates perfect right-branching. See <a class="el" href="citelist.html#CITEREF_Liu2010a">[25]</a> for further detals. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">pi</td><td>Permutation of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The headedness ratio as an exact rational number. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>\(m &gt; 0\). </dd></dl>

</div>
</div>
<a id="a6991b736a773a44c41d7fb1b9bd3fe00" name="a6991b736a773a44c41d7fb1b9bd3fe00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6991b736a773a44c41d7fb1b9bd3fe00">&#9670;&#160;</a></span>is_arrangement()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::linarr::is_arrangement </td>
          <td>(</td>
          <td class="paramtype">const G &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#afa9a90a785b8b5461c516b8a3971c558">linear_arrangement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>arr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is a given arrangement valid? </p>
<p>Checks that an input arrangement is valid for the corresponding input graph. An arrangement is valid if it is a valid permutation of the vertices of the graph. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arr</td><td>Input arrangement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the input arrangement is a valid permutation. </dd></dl>

</div>
</div>
<a id="aa20d4dbcce8ebba555654e9bc8bd71a1" name="aa20d4dbcce8ebba555654e9bc8bd71a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa20d4dbcce8ebba555654e9bc8bd71a1">&#9670;&#160;</a></span>is_num_crossings_lesseq_than() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t lal::linarr::is_num_crossings_lesseq_than </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>G</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#afa9a90a785b8b5461c516b8a3971c558">linear_arrangement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pi</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>upper_bound</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the number of crossings in the linear arrangement less than a constant? </p>
<p>Given a graph \(G\) and a linear arrangements \(\pi\) of its nodes, returns the number of edge crossings \(C_{\pi}(G)\) if it is less than or equal to the given upper bound constant \(u\). In case the number of crossings is greater, returns \(m^2\), where \(m\) is the number of edges of the graph. This function uses a modified version of the algorithm specified by the parameter <em>A</em>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>Input graph. </td></tr>
    <tr><td class="paramname">pi</td><td>A linear arrangement of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
    <tr><td class="paramname">upper_bound</td><td>Upper bound on the number of crossings. </td></tr>
    <tr><td class="paramname">A</td><td>Algorithm to use to compute the number of crossings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of crossings \(C\) if said number is less than or equal to the upper bound. The function returns a value strictly larger than \(m^2\) if otherwise. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The preconditions of this function depend on the choice of algorithm. See the preconditions of each algorithm in <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">lal::linarr::algorithms_C</a>. </dd></dl>

</div>
</div>
<a id="a6c61a7238079a47e1510464869339684" name="a6c61a7238079a47e1510464869339684"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c61a7238079a47e1510464869339684">&#9670;&#160;</a></span>is_num_crossings_lesseq_than() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t lal::linarr::is_num_crossings_lesseq_than </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>G</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>upper_bound</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the number of crossings in the linear arrangement less than a constant? </p>
<p>Given a graph \(G\) computes the number of edge crossings using the identity arrangement \(\pi_I\), \(C_{\pi_I}(G)\), if it is less than or equal to the given upper bound constant \(u\). In case the number of crossings is greater, returns \(m^2\), where \(m\) is the number of edges of the graph. This function uses a modified version of the algorithm specified by the parameter <em>A</em>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>Input graph. </td></tr>
    <tr><td class="paramname">upper_bound</td><td>Upper bound on the number of crossings. </td></tr>
    <tr><td class="paramname">A</td><td>Algorithm to use to compute the number of crossings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of crossings \(C\) if said number is less than or equal to the upper bound. The function returns a value strictly larger than \(m^2\) if otherwise. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The preconditions of this function depend on the choice of algorithm. See the preconditions of each algorithm in <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">lal::linarr::algorithms_C</a>. </dd></dl>

</div>
</div>
<a id="af47deba91683ab6146fc2c7bab4faef9" name="af47deba91683ab6146fc2c7bab4faef9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af47deba91683ab6146fc2c7bab4faef9">&#9670;&#160;</a></span>is_num_crossings_lesseq_than() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t lal::linarr::is_num_crossings_lesseq_than </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>G</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#afa9a90a785b8b5461c516b8a3971c558">linear_arrangement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pi</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>upper_bound</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the number of crossings in the linear arrangement less than a constant? </p>
<p>Given a graph \(G\) and a linear arrangements \(\pi\) of its nodes, returns the number of edge crossings \(C_{\pi}(G)\) if is less than or equal to the given upper bound constant \(u\). In case the number of crossings is greater, returns \(m^2\), where \(m\) is the number of edges of the graph. This function uses a modified version of the algorithm specified by the parameter <em>A</em>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>Input graph. </td></tr>
    <tr><td class="paramname">pi</td><td>A linear arrangement of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
    <tr><td class="paramname">upper_bound</td><td>Upper bound on the number of crossings. </td></tr>
    <tr><td class="paramname">A</td><td>Algorithm to use to compute the number of crossings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of crossings \(C\) if said number is less than or equal to the upper bound. The function returns a value strictly larger than \(m^2\) if otherwise. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The preconditions of this function depend on the choice of algorithm. See the preconditions of each algorithm in <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">lal::linarr::algorithms_C</a>. </dd></dl>

</div>
</div>
<a id="aff146360fa078095fb6899238ad518e5" name="aff146360fa078095fb6899238ad518e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff146360fa078095fb6899238ad518e5">&#9670;&#160;</a></span>is_num_crossings_lesseq_than() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t lal::linarr::is_num_crossings_lesseq_than </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>G</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>upper_bound</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the number of crossings in the linear arrangement less than a constant? </p>
<p>Given a graph \(G\) computes the number of edge crossings using the identity arrangement \(\pi_I\), \(C_{\pi_I}(G)\), if it is less than or equal to the given upper bound constant \(u\). In case the number of crossings is greater, returns \(m^2\), where \(m\) is the number of edges of the graph. This function uses a modified version of the algorithm specified by the parameter <em>A</em>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>Input graph. </td></tr>
    <tr><td class="paramname">upper_bound</td><td>Upper bound on the number of crossings. </td></tr>
    <tr><td class="paramname">A</td><td>Algorithm to use to compute the number of crossings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of crossings \(C\) if said number is less than or equal to the upper bound. The function returns a value strictly larger than \(m^2\) if otherwise. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The preconditions of this function depend on the choice of algorithm. See the preconditions of each algorithm in <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">lal::linarr::algorithms_C</a>. </dd></dl>

</div>
</div>
<a id="a630a3e7a98a692fcb35bd2f8be39fb76" name="a630a3e7a98a692fcb35bd2f8be39fb76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a630a3e7a98a692fcb35bd2f8be39fb76">&#9670;&#160;</a></span>is_num_crossings_lesseq_than_list() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; uint32_t &gt; lal::linarr::is_num_crossings_lesseq_than_list </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>G</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacelal.html#afa9a90a785b8b5461c516b8a3971c558">linear_arrangement</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>pis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint32_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>upper_bounds</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the number of crossings in the linear arrangement less than a constant? </p>
<p>Given a graph \(G\), a list of linear arrangements \(L=\{\pi_i\}_{i=1}^k\) of its nodes and a list of upper bounds \(\{u_i\}_{i=1}^k\), computes the number of edge crossings for each of the linear arrangements \(\pi_i\) if that amount is less than or equal to the given upper bound \(u_i\), i.e., computes \(\{ f_i \}_{i=1}^k\), where \(f_i=C_{\pi_i}(G)\) if \(C_{\pi_i}(G)\le u_i\), or \(f_i&gt;m^2\) if \(C_{\pi_i}(G)&gt;u_i\). This function uses a modified version of the algorithm specified by the parameter <em>A</em>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>Input graph. </td></tr>
    <tr><td class="paramname">pis</td><td>A linear arrangement of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
    <tr><td class="paramname">upper_bounds</td><td>A list of upper bounds on the number of crossings for each linear arrangement. </td></tr>
    <tr><td class="paramname">A</td><td>Algorithm to use to compute the number of crossings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of crossings \(C\) if said number is less than or equal to the upper bound. The function returns a value strictly larger than \(m^2\) if otherwise. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>There must be as many linear arrangements as upper bounds. </dd>
<dd>
The preconditions of this function depend on the choice of algorithm. See the preconditions of each algorithm in <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">lal::linarr::algorithms_C</a>. </dd></dl>

</div>
</div>
<a id="ae5c44d539c4c5cd9639118810858ca05" name="ae5c44d539c4c5cd9639118810858ca05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5c44d539c4c5cd9639118810858ca05">&#9670;&#160;</a></span>is_num_crossings_lesseq_than_list() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; uint32_t &gt; lal::linarr::is_num_crossings_lesseq_than_list </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>G</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacelal.html#afa9a90a785b8b5461c516b8a3971c558">linear_arrangement</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>pis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>upper_bound</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the number of crossings in the linear arrangement less than a constant? </p>
<p>Given a graph \(G\) and a list of linear arrangements \(L=\{\pi_i\}_{i=1}^k\) of its nodes, computes the number of edge crossings for each of the linear arrangements \(\pi_i\) if that amount is less than or equal to the given upper bound \(u\), i.e., computes \(\{f_i\}_{i=1}^k\), where \(f_i=C_{\pi_i}(G)\) if \(C_{\pi_i}(G)\le u\), or \(f_i&gt;m^2\) if \(C_{\pi_i}(G)&gt;u\). This function uses a modified version of the algorithm specified by the parameter <em>A</em>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>Input graph. </td></tr>
    <tr><td class="paramname">pis</td><td>A linear arrangement of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
    <tr><td class="paramname">upper_bound</td><td>Upper bound on the number of crossings. </td></tr>
    <tr><td class="paramname">A</td><td>Algorithm to use to compute the number of crossings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of crossings \(C\) if said number is less than or equal to the upper bound. The function returns a value strictly larger than \(m^2\) if otherwise. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The preconditions of this function depend on the choice of algorithm. See the preconditions of each algorithm in <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">lal::linarr::algorithms_C</a>. </dd></dl>

</div>
</div>
<a id="a8b41df0243e02f0ec48c8e0c80bb01f1" name="a8b41df0243e02f0ec48c8e0c80bb01f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b41df0243e02f0ec48c8e0c80bb01f1">&#9670;&#160;</a></span>is_num_crossings_lesseq_than_list() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; uint32_t &gt; lal::linarr::is_num_crossings_lesseq_than_list </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>G</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacelal.html#afa9a90a785b8b5461c516b8a3971c558">linear_arrangement</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>pis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint32_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>upper_bounds</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the number of crossings in the linear arrangement less than a constant? </p>
<p>Given a graph \(G\), a list of linear arrangements \(L=\{\pi_i\}_{i=1}^k\) of its nodes and a list of upper bounds \(\{u_i\}_{i=1}^k\), computes the number of edge crossings for each of the linear arrangements \(\pi_i\) if that amount is less than or equal to the given upper bound \(u_i\), i.e., computes \(\{ f_i \}_{i=1}^k\), where \(f_i=C_{\pi_i}(G)\) if \(C_{\pi_i}(G)\le u_i\), or \(f_i&gt;m^2\) if \(C_{\pi_i}(G)&gt;u_i\). This function uses a modified version of the algorithm specified by the parameter <em>A</em>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>Input graph. </td></tr>
    <tr><td class="paramname">pis</td><td>A linear arrangement of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
    <tr><td class="paramname">upper_bounds</td><td>A list of upper bounds on the number of crossings for each linear arrangement. </td></tr>
    <tr><td class="paramname">A</td><td>Algorithm to use to compute the number of crossings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of crossings \(C\) if said number is less than or equal to the upper bound. The function returns a value strictly larger than \(m^2\) if otherwise. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>There must be as many linear arrangements as upper bounds. </dd>
<dd>
The preconditions of this function depend on the choice of algorithm. See the preconditions of each algorithm in <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">lal::linarr::algorithms_C</a>. </dd></dl>

</div>
</div>
<a id="a7829c750e3d428096d4ebff2003dc40c" name="a7829c750e3d428096d4ebff2003dc40c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7829c750e3d428096d4ebff2003dc40c">&#9670;&#160;</a></span>is_num_crossings_lesseq_than_list() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; uint32_t &gt; lal::linarr::is_num_crossings_lesseq_than_list </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>G</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacelal.html#afa9a90a785b8b5461c516b8a3971c558">linear_arrangement</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>pis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>upper_bound</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the number of crossings in the linear arrangement less than a constant? </p>
<p>Given a graph \(G\) and a list of linear arrangements \(L=\{\pi_i\}_{i=1}^k\) of its nodes, computes the number of edge crossings for each of the linear arrangements \(\pi_i\) if that amount is less than or equal to the given upper bound \(u\), i.e., computes \(\{f_i\}_{i=1}^k\), where \(f_i=C_{\pi_i}(G)\) if \(C_{\pi_i}(G)\le u\), or \(f_i&gt;m^2\) if \(C_{\pi_i}(G)&gt;u\). This function uses a modified version of the algorithm specified by the parameter <em>A</em>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>Input graph. </td></tr>
    <tr><td class="paramname">pis</td><td>A linear arrangement of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
    <tr><td class="paramname">upper_bound</td><td>Upper bound on the number of crossings. </td></tr>
    <tr><td class="paramname">A</td><td>Algorithm to use to compute the number of crossings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of crossings \(C\) if said number is less than or equal to the upper bound. The function returns a value strictly larger than \(m^2\) if otherwise. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The preconditions of this function depend on the choice of algorithm. See the preconditions of each algorithm in <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">lal::linarr::algorithms_C</a>. </dd></dl>

</div>
</div>
<a id="a6b3203432e13dfec29563796643e6187" name="a6b3203432e13dfec29563796643e6187"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b3203432e13dfec29563796643e6187">&#9670;&#160;</a></span>is_permutation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::linarr::is_permutation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#afa9a90a785b8b5461c516b8a3971c558">linear_arrangement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>arr</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is a given input arrangement a permutation? </p>
<p>A linear arrangement is a permutation if all the positions are numbers in \([0,n-1]\), where \(n\) denotes the size of the arrangement and if no two numbers appear twice in the arrangement. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>Input linear arrangement </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the input arrangement is a valid permutation. </dd></dl>

</div>
</div>
<a id="aa8125bbeee0a12292b402f9bfa5911dc" name="aa8125bbeee0a12292b402f9bfa5911dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8125bbeee0a12292b402f9bfa5911dc">&#9670;&#160;</a></span>is_planar()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::linarr::is_planar </td>
          <td>(</td>
          <td class="paramtype">const G &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#afa9a90a785b8b5461c516b8a3971c558">linear_arrangement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>arr</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is a given arrangement planar? </p>
<p>A planar arrangement of a graph is an arrangement in which there are no edge crossings. If the input arrangement is empty then the identity arrangement \(\pi_I\) is used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arr</td><td>Input linear arrangement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the input graph arranged with the input arrangement is planar. </dd></dl>

</div>
</div>
<a id="ab708d7b97fc8e2200dfca27846723a08" name="ab708d7b97fc8e2200dfca27846723a08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab708d7b97fc8e2200dfca27846723a08">&#9670;&#160;</a></span>is_projective()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::linarr::is_projective </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#afa9a90a785b8b5461c516b8a3971c558">linear_arrangement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>arr</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is a given arrangement projective? </p>
<p>A projective arrangement of a rooted tree is an arrangement that is planar and the root is not covered by any edge. The root is covered if, for a given input arrangement \(\pi\), there exists an edge of the tree \(\{s,t\}\) such that \(\pi(s) &lt; \pi(r) &lt; \pi(t)\) or \(\pi(t) &lt; \pi(r) &lt; \pi(s)\).</p>
<p>If the input arrangement is empty then the identity arrangement \(\pi_I\) is used.</p>
<p>See method <a class="el" href="#aa8125bbeee0a12292b402f9bfa5911dc">is_planar</a> for further details on the characterisation of planar arrangements. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rt</td><td>Input rooted tree </td></tr>
    <tr><td class="paramname">arr</td><td>Input linear arrangement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the input rooted tree arranged with the input arrangement is projective. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The input rooted tree must be a valid rooted tree (see <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#af464d98b1b5dfdbaaacea553d9c89154">lal::graphs::rooted_tree::is_rooted_tree</a>). </dd></dl>

</div>
</div>
<a id="a2030c0f279ced9571405cebe5675e241" name="a2030c0f279ced9571405cebe5675e241"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2030c0f279ced9571405cebe5675e241">&#9670;&#160;</a></span>mean_dependency_distance() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double lal::linarr::mean_dependency_distance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#afa9a90a785b8b5461c516b8a3971c558">linear_arrangement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pi</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the mean dependency distance \(MDD\) as a floating point value. </p>
<p>See <a class="el" href="#a679b59e355c13c9ac4969f897b731582">lal::linarr::mean_dependency_distance_rational</a> for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">pi</td><td>Linear arrangement of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return value is a floating point value. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>\(m &gt; 0\). </dd></dl>

</div>
</div>
<a id="a43bba5ac9ff41d48b5320b70d9e4f403" name="a43bba5ac9ff41d48b5320b70d9e4f403"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43bba5ac9ff41d48b5320b70d9e4f403">&#9670;&#160;</a></span>mean_dependency_distance() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double lal::linarr::mean_dependency_distance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#afa9a90a785b8b5461c516b8a3971c558">linear_arrangement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pi</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the mean dependency distance \(MDD\) as a floating point value. </p>
<p>See <a class="el" href="#a679b59e355c13c9ac4969f897b731582">lal::linarr::mean_dependency_distance_rational</a> for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">pi</td><td>Linear arrangement of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return value is a floating point value. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>\(m &gt; 0\). </dd></dl>

</div>
</div>
<a id="ae3ecf6602b92a3e82999baa2e54c8956" name="ae3ecf6602b92a3e82999baa2e54c8956"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3ecf6602b92a3e82999baa2e54c8956">&#9670;&#160;</a></span>mean_dependency_distance_1level()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double lal::linarr::mean_dependency_distance_1level </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; G &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>L</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacelal.html#afa9a90a785b8b5461c516b8a3971c558">linear_arrangement</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>P</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>1-level Mean Dependency Distance \(MDD\) over an ensemble of graphs. </p>
<p>See <a class="el" href="#ae3ff82b011435622d24736c216d605da">lal::linarr::mean_dependency_distance_1level_rational</a> for further details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>List of input graphs. </td></tr>
    <tr><td class="paramname">P</td><td>List of linear arrangements of the nodes \(Pi = \{\pi_i\}_{i=1}^k\). When omitted, \(\pi_I\) is used for every graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">G</td><td>A graph type. A class that derives from <a class="el" href="classlal_1_1graphs_1_1graph.html">lal::graphs::graph</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Jing's and Liu's 1-level \(MDD\) for an ensemble of graphs as a floating point value. </dd></dl>

</div>
</div>
<a id="ae3ff82b011435622d24736c216d605da" name="ae3ff82b011435622d24736c216d605da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3ff82b011435622d24736c216d605da">&#9670;&#160;</a></span>mean_dependency_distance_1level_rational()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a> lal::linarr::mean_dependency_distance_1level_rational </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; G &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>L</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacelal.html#afa9a90a785b8b5461c516b8a3971c558">linear_arrangement</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>P</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>1-level Mean Dependency Distance \(MDD\) over an ensemble of graphs. </p>
<p>Given a list of graphs \(L\) and a list of linear arrangements for each of them, \(P\), computes the 1-level Mean Dependency Distance as the quotient of \(D\), the sum of all the edge lengths of each graph, and of \(M\) the sum of the number of edges of all the graphs.</p>
<p>Formally, given a list of graphs \(L = \{L_i\}_{i=1}^k\) and a list of linear arrangements \(\Pi = \{\pi_i\}_{i=1}^k\), computes \(D/M\), where</p><ul>
<li>\(D = \sum_{i=1}^k D(L_i, \pi_i)\) is the sum of edge lengths of all graphs.</li>
<li>\(M = \sum_{i=1}^k |E(L_i)|\) is the sum of the number of edges of all graphs.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>List of input graphs. </td></tr>
    <tr><td class="paramname">P</td><td>List of linear arrangements of the nodes \(\Pi = \{\pi_i\}_{i=1}^k\). When omitted, \(\pi_I\) is used for every graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">G</td><td>A graph type. A class that derives from <a class="el" href="classlal_1_1graphs_1_1graph.html">lal::graphs::graph</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Jing's and Liu's 1-level \(MDD\) for an ensemble of graphs as an exact rational value. </dd></dl>

</div>
</div>
<a id="a45951f9789c2563dbe0f10f36cebba1c" name="a45951f9789c2563dbe0f10f36cebba1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45951f9789c2563dbe0f10f36cebba1c">&#9670;&#160;</a></span>mean_dependency_distance_2level()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double lal::linarr::mean_dependency_distance_2level </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; G &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>L</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacelal.html#afa9a90a785b8b5461c516b8a3971c558">linear_arrangement</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>P</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>2-level Mean Dependency Distance \(MDD\) over an ensemble of graphs. </p>
<p>See <a class="el" href="#ae0711002890a5d19306ac10792000af3">lal::linarr::mean_dependency_distance_2level_rational</a> for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>List of input graphs. </td></tr>
    <tr><td class="paramname">P</td><td>List of linear arrangements of the nodes \(L = \{\pi_i\}_{i=1}^k\). When omitted, \(\pi_I\) is used for every graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">G</td><td>A graph type. A class that derives from <a class="el" href="classlal_1_1graphs_1_1graph.html">lal::graphs::graph</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Jing's and Liu's 2-level \(MDD\) for an ensemble of graphs as a floating point value. </dd></dl>

</div>
</div>
<a id="ae0711002890a5d19306ac10792000af3" name="ae0711002890a5d19306ac10792000af3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0711002890a5d19306ac10792000af3">&#9670;&#160;</a></span>mean_dependency_distance_2level_rational()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a> lal::linarr::mean_dependency_distance_2level_rational </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; G &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>L</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacelal.html#afa9a90a785b8b5461c516b8a3971c558">linear_arrangement</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>P</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>2-level Mean Dependency Distance \(MDD\) over an ensemble of graphs. </p>
<p>Given a list of graphs \(L\) and a list of linear arrangements of the nodes for each of them, \(P\), computes the 2-level Mean Dependency Distance, i.e., it computes the average Mean Dependency Distance of the graphs in the list.</p>
<p>Formally, given a list of graphs \(L = \{L_i\}_{i=1}^k\) and a list of linear arrangements \(P = \{\pi_i\}_{i=1}^k\), computes \((1/k)S_{&lt;d&gt;}\), where \(S_{&lt;d&gt;} = \sum_{i=1}^k MDD(L_i, \pi_i)\) is the sum of the mean dependency distances of every graph (see <a class="el" href="#a679b59e355c13c9ac4969f897b731582">lal::linarr::mean_dependency_distance_rational</a> for details on the definition of the Mean Dependency Distance).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>List of input graphs. </td></tr>
    <tr><td class="paramname">P</td><td>List of linear arrangements of the nodes \(P = \{\pi_i\}_{i=1}^k\). When omitted, \(\pi_I\) is used for every graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">G</td><td>A graph type. A class that derives from <a class="el" href="classlal_1_1graphs_1_1graph.html">lal::graphs::graph</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Jing's and Liu's 2-level \(MDD\) for an ensemble of graphs as an exact rational value. </dd></dl>

</div>
</div>
<a id="a679b59e355c13c9ac4969f897b731582" name="a679b59e355c13c9ac4969f897b731582"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a679b59e355c13c9ac4969f897b731582">&#9670;&#160;</a></span>mean_dependency_distance_rational() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a> lal::linarr::mean_dependency_distance_rational </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#afa9a90a785b8b5461c516b8a3971c558">linear_arrangement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pi</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the mean dependency distance \(MDD\) as an exact rational value. </p>
<p>Given a graph \(G\) and a linear arrangement of its nodes \(\pi\), computes the average edge length, or the mean dependency distance (see <a class="el" href="citelist.html#CITEREF_Jing2015a">[23]</a>). Formally, it computes \(\frac{D_{\pi}(G)}{|E(G)|}\). See function <a class="el" href="#a4558fab36ed2a75572794f60a17c623f">sum_edge_lengths</a> for further details on \(D_{\pi}(G)\).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">pi</td><td>Linear arrangement of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Jing's and Liu's \(MDD\). </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>\(m &gt; 0\). </dd></dl>

</div>
</div>
<a id="a77d3933929930331d44200deed260a41" name="a77d3933929930331d44200deed260a41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77d3933929930331d44200deed260a41">&#9670;&#160;</a></span>mean_dependency_distance_rational() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a> lal::linarr::mean_dependency_distance_rational </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#afa9a90a785b8b5461c516b8a3971c558">linear_arrangement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pi</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the mean dependency distance \(MDD\) as an exact rational value. </p>
<p>Given a graph \(G\) and a linear arrangement of its nodes \(\pi\), computes the average edge length, or the mean dependency distance (see <a class="el" href="citelist.html#CITEREF_Jing2015a">[23]</a>). Formally, it computes \(\frac{D_{\pi}(G)}{|E(G)|}\). See function <a class="el" href="#a4558fab36ed2a75572794f60a17c623f">sum_edge_lengths</a> for further details on \(D_{\pi}(G)\).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">pi</td><td>Linear arrangement of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Jing's and Liu's \(MDD\). </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>\(m &gt; 0\). </dd></dl>

</div>
</div>
<a id="a248bd94b7e14e45090144b5d0fcd1c31" name="a248bd94b7e14e45090144b5d0fcd1c31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a248bd94b7e14e45090144b5d0fcd1c31">&#9670;&#160;</a></span>min_sum_edge_lengths() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; uint32_t, <a class="el" href="namespacelal.html#afa9a90a785b8b5461c516b8a3971c558">linear_arrangement</a> &gt; lal::linarr::min_sum_edge_lengths </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a1c6a617eb12e032ee641fd390776ff3f">algorithms_Dmin</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a1c6a617eb12e032ee641fd390776ff3fab420b0b2364d8210a7cd34babc2467d2">algorithms_Dmin::Unconstrained_YS</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the minimum value of \(D\) in free trees. </p>
<p>Calculates the minimum value of \(D\) and returns a linear arrangement yielding this value. Such optimal value of \(D\) depends on the choice of algorithm for its calculation.</p>
<p>See the description of the values in <a class="el" href="#a1c6a617eb12e032ee641fd390776ff3f">lal::linarr::algorithms_Dmin</a> for details on the algorithm implemented and to see references to the papers. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input free tree. </td></tr>
    <tr><td class="paramname">a</td><td>The algorithm to be chosen. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The minimum value of \(D\) and an optimum arrangement. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Input tree <em>t</em> must be a valid tree (see <a class="el" href="classlal_1_1graphs_1_1tree.html#a25c8d57865fa5f7cb5d101fd5d07fe2d">lal::graphs::tree::is_tree()</a>). </dd>
<dd>
This function has as extra preconditions those specified in the enumeration passed as parameter. </dd></dl>

</div>
</div>
<a id="ae442b1b7bf9d4d6e8bf9d1e030d59524" name="ae442b1b7bf9d4d6e8bf9d1e030d59524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae442b1b7bf9d4d6e8bf9d1e030d59524">&#9670;&#160;</a></span>min_sum_edge_lengths() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; uint32_t, <a class="el" href="namespacelal.html#afa9a90a785b8b5461c516b8a3971c558">linear_arrangement</a> &gt; lal::linarr::min_sum_edge_lengths </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a1c6a617eb12e032ee641fd390776ff3f">algorithms_Dmin</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a1c6a617eb12e032ee641fd390776ff3fab420b0b2364d8210a7cd34babc2467d2">algorithms_Dmin::Unconstrained_YS</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the minimum value of \(D\) in trees. </p>
<p>Calculates the minimum value of \(D\) and returns a linear arrangement yielding this value. Such optimal value of \(D\) depends on the choice of algorithm for its calculation.</p>
<p>This function converts the input rooted into a free tree (see <a class="el" href="classlal_1_1graphs_1_1directed__graph.html#a8c29e0bf06fa053d8d8b48b5ee77ea88">lal::graphs::rooted_tree::to_undirected()</a>) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input rooted tree. </td></tr>
    <tr><td class="paramname">a</td><td>The algorithm to be chosen. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The minimum value of \(D\) and an optimum arrangement. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Input tree <em>t</em> must be a valid tree (see <a class="el" href="classlal_1_1graphs_1_1tree.html#a25c8d57865fa5f7cb5d101fd5d07fe2d">lal::graphs::tree::is_tree()</a>). </dd>
<dd>
This function has as extra preconditions those specified in the enumeration passed as parameter. </dd></dl>

</div>
</div>
<a id="af9ff71a7bedff3adebf6ad71fe7abc81" name="af9ff71a7bedff3adebf6ad71fe7abc81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9ff71a7bedff3adebf6ad71fe7abc81">&#9670;&#160;</a></span>min_sum_edge_lengths_planar() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; uint32_t, <a class="el" href="namespacelal.html#afa9a90a785b8b5461c516b8a3971c558">linear_arrangement</a> &gt; lal::linarr::min_sum_edge_lengths_planar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the minimum value of \(D\) in trees under the planarity constraint. </p>
<p>This function implements the algorithm published in <a class="el" href="citelist.html#CITEREF_Alemany2021a">[6]</a>.</p>
<p>Computes an optimal planar linear arrangement for free trees. A planar linear arrangement is an arrangement in which there are no edge crossings. This problem was originally tackled by Iordanskii <a class="el" href="citelist.html#CITEREF_Iordanskii1987a">[22]</a> and later by Hochberg and Stallmann <a class="el" href="citelist.html#CITEREF_Hochberg2003a">[20]</a>. See <a class="el" href="citelist.html#CITEREF_Alemany2021a">[6]</a> for a review. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input free tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The minimum value of \(D\) and an optimum arrangement. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Input tree <em>t</em> must be a valid tree (see <a class="el" href="classlal_1_1graphs_1_1tree.html#a25c8d57865fa5f7cb5d101fd5d07fe2d">lal::graphs::tree::is_tree()</a>). </dd></dl>

</div>
</div>
<a id="ad13396c38b91587442940d6fdd043d00" name="ad13396c38b91587442940d6fdd043d00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad13396c38b91587442940d6fdd043d00">&#9670;&#160;</a></span>min_sum_edge_lengths_planar() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; uint32_t, <a class="el" href="namespacelal.html#afa9a90a785b8b5461c516b8a3971c558">linear_arrangement</a> &gt; lal::linarr::min_sum_edge_lengths_planar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the minimum value of \(D\) in trees under the planarity constraint. </p>
<p>This function implements the algorithm published in <a class="el" href="citelist.html#CITEREF_Alemany2021a">[6]</a>.</p>
<p>Computes an optimal planar linear arrangement for free trees. A planar linear arrangement is an arrangement in which there are no edge crossings. This problem was originally tackled by Iordanskii <a class="el" href="citelist.html#CITEREF_Iordanskii1987a">[22]</a> and later by Hochberg and Stallmann <a class="el" href="citelist.html#CITEREF_Hochberg2003a">[20]</a>. See <a class="el" href="citelist.html#CITEREF_Alemany2021a">[6]</a> for a review.</p>
<p>This function converts the input rooted into a free tree (see <a class="el" href="classlal_1_1graphs_1_1directed__graph.html#a8c29e0bf06fa053d8d8b48b5ee77ea88">lal::graphs::rooted_tree::to_undirected()</a>) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input rooted tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The minimum value of \(D\) and an optimum arrangement. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Input tree <em>t</em> must be a valid tree (see <a class="el" href="classlal_1_1graphs_1_1tree.html#a25c8d57865fa5f7cb5d101fd5d07fe2d">lal::graphs::tree::is_tree()</a>). </dd></dl>

</div>
</div>
<a id="a426766ab65d36b12b3b85929d231667b" name="a426766ab65d36b12b3b85929d231667b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a426766ab65d36b12b3b85929d231667b">&#9670;&#160;</a></span>min_sum_edge_lengths_projective()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; uint32_t, <a class="el" href="namespacelal.html#afa9a90a785b8b5461c516b8a3971c558">linear_arrangement</a> &gt; lal::linarr::min_sum_edge_lengths_projective </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the minimum value of \(D\) in rooted trees under the projectivity constraint. </p>
<p>Computes an optimal projective linear arrangement for rooted trees. A projective linear arrangement is an arrangement in which there are no edge crossings and the root is not covered by any edge.</p>
<p>This function implements the algorithm in <a class="el" href="citelist.html#CITEREF_Alemany2021a">[6]</a>. A non-linear time algorithm to solve this problem was oulined in <a class="el" href="citelist.html#CITEREF_Gildea2007a">[15]</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input rooted tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The minimum value of \(D\) and an optimum arrangement. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Input tree <em>t</em> must be a valid tree (see <a class="el" href="classlal_1_1graphs_1_1tree.html#a25c8d57865fa5f7cb5d101fd5d07fe2d">lal::graphs::tree::is_tree()</a>). </dd></dl>

</div>
</div>
<a id="aebaebf5dca65223cf0c8c7bd99298f7d" name="aebaebf5dca65223cf0c8c7bd99298f7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebaebf5dca65223cf0c8c7bd99298f7d">&#9670;&#160;</a></span>num_crossings() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t lal::linarr::num_crossings </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>G</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the number of edge crossings in a linear arrangement. </p>
<p>Given a graph \(G\), computes the number of edge crossings using the identity arrangement \(\pi_I\), i.e., computes \(C_{\pi_I}(G)\) using the algorithm specified by the parameter <em>A</em>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>Input graph. </td></tr>
    <tr><td class="paramname">A</td><td>Algorithm to use to compute the number of crossings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of crossings \(C\). </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The preconditions of this function depend on the choice of algorithm. See the preconditions of each algorithm in <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">lal::linarr::algorithms_C</a>. </dd></dl>

</div>
</div>
<a id="aa7cbca0fdc1fe81d272b9eec8ecb2bff" name="aa7cbca0fdc1fe81d272b9eec8ecb2bff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7cbca0fdc1fe81d272b9eec8ecb2bff">&#9670;&#160;</a></span>num_crossings() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t lal::linarr::num_crossings </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>G</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#afa9a90a785b8b5461c516b8a3971c558">linear_arrangement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pi</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the number of edge crossings in a linear arrangement. </p>
<p>Given a graph \(G\) and a linear arrangements \(\pi\) of its nodes, computes the number of edge crossings \(C_{\pi}(G)\) using the algorithm specified by the parameter <em>A</em>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>Input graph. </td></tr>
    <tr><td class="paramname">pi</td><td>A linear arrangement of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
    <tr><td class="paramname">A</td><td>Algorithm to use to compute the number of crossings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of crossings \(C\). </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The preconditions of this function depend on the choice of algorithm. See the preconditions of each algorithm in <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">lal::linarr::algorithms_C</a>. </dd></dl>

</div>
</div>
<a id="ab79ed6d08d6a8dc6c85ad1c393bed552" name="ab79ed6d08d6a8dc6c85ad1c393bed552"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab79ed6d08d6a8dc6c85ad1c393bed552">&#9670;&#160;</a></span>num_crossings() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t lal::linarr::num_crossings </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>G</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the number of edge crossings in a linear arrangement. </p>
<p>Given a graph \(G\), computes the number of edge crossings using the identity arrangement \(\pi_I\), i.e., computes \(C_{\pi_I}(G)\) using the algorithm specified by the parameter <em>A</em>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>Input graph. </td></tr>
    <tr><td class="paramname">A</td><td>Algorithm to use to compute the number of crossings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of crossings \(C\). </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The preconditions of this function depend on the choice of algorithm. See the preconditions of each algorithm in <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">lal::linarr::algorithms_C</a>. </dd></dl>

</div>
</div>
<a id="a6d4afd4bd2981172044c2340451bfdd7" name="a6d4afd4bd2981172044c2340451bfdd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d4afd4bd2981172044c2340451bfdd7">&#9670;&#160;</a></span>num_crossings() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t lal::linarr::num_crossings </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>G</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#afa9a90a785b8b5461c516b8a3971c558">linear_arrangement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pi</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the number of edge crossings in a linear arrangement. </p>
<p>Given a graph \(G\) and a linear arrangements \(\pi\) of its nodes, computes the number of edge crossings \(C_{\pi}(G)\) using the algorithm specified by the parameter <em>A</em>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>Input graph. </td></tr>
    <tr><td class="paramname">pi</td><td>A linear arrangement of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
    <tr><td class="paramname">A</td><td>Algorithm to use to compute the number of crossings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of crossings \(C\). </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The preconditions of this function depend on the choice of algorithm. See the preconditions of each algorithm in <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">lal::linarr::algorithms_C</a>. </dd></dl>

</div>
</div>
<a id="a9f6651bfd247cfbb895c641594af471b" name="a9f6651bfd247cfbb895c641594af471b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f6651bfd247cfbb895c641594af471b">&#9670;&#160;</a></span>num_crossings_list() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; uint32_t &gt; lal::linarr::num_crossings_list </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>G</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacelal.html#afa9a90a785b8b5461c516b8a3971c558">linear_arrangement</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>pis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the number of edge crossings in a linear arrangement. </p>
<p>Given a graph \(G\) and a list of linear arrangements \(L=\{\pi_i\}_{i=1}^k\) of its nodes, computes the number of edge crossings for each of the linear arrangements \(\pi_i\), i.e., computes \(\{C_{\pi_i}(G)\}_{i=1}^k\), using the algorithm specified by the parameter <em>A</em>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>Input graph. </td></tr>
    <tr><td class="paramname">pis</td><td>A list of \(k\) linear arrangements of the nodes \(\Pi = \{\pi_i\}_{i=1}^k\). </td></tr>
    <tr><td class="paramname">A</td><td>Algorithm to use to compute the number of crossings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list \(L\) where \(L_i = C_{\pi_i}(G)\). </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>None of the arrangements in <em>pis</em> can be empty. </dd>
<dd>
The preconditions of this function depend on the choice of algorithm. See the preconditions of each algorithm in <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">lal::linarr::algorithms_C</a>. </dd></dl>

</div>
</div>
<a id="a8b4935c76e17b2ec4db12fc7bc1525bb" name="a8b4935c76e17b2ec4db12fc7bc1525bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b4935c76e17b2ec4db12fc7bc1525bb">&#9670;&#160;</a></span>num_crossings_list() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; uint32_t &gt; lal::linarr::num_crossings_list </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>G</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacelal.html#afa9a90a785b8b5461c516b8a3971c558">linear_arrangement</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>pis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the number of edge crossings in a linear arrangement. </p>
<p>Given a graph \(G\) and a list of linear arrangements \(L=\{\pi_i\}_{i=1}^k\) of its nodes, computes the number of edge crossings for each of the linear arrangements \(\pi_i\), i.e., computes \(\{C_{\pi_i}(G)\}_{i=1}^k\), using the algorithm specified by the parameter <em>A</em>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>Input graph. </td></tr>
    <tr><td class="paramname">pis</td><td>A list of \(k\) linear arrangements of the nodes \(\Pi = \{\pi_i\}_{i=1}^k\). </td></tr>
    <tr><td class="paramname">A</td><td>Algorithm to use to compute the number of crossings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list \(L\) where \(L_i = C_{\pi_i}(G)\). </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>None of the arrangements in <em>pis</em> can be empty. </dd>
<dd>
The preconditions of this function depend on the choice of algorithm. See the preconditions of each algorithm in <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">lal::linarr::algorithms_C</a>. </dd></dl>

</div>
</div>
<a id="a5737b1b3fb7adc6df6491b27d49f76d7" name="a5737b1b3fb7adc6df6491b27d49f76d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5737b1b3fb7adc6df6491b27d49f76d7">&#9670;&#160;</a></span>predicted_num_crossings() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double lal::linarr::predicted_num_crossings </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#afa9a90a785b8b5461c516b8a3971c558">linear_arrangement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pi</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Approximates the number of crossings. </p>
<p>See <a class="el" href="#aad593026a63a2b2e8cca0423ed73ff12">lal::linarr::predicted_num_crossings_rational</a> for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">pi</td><td>A linear arrangement of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return value is a floating point value. </dd></dl>

</div>
</div>
<a id="ac3eea4d73c7357d1a00c12da11a81baf" name="ac3eea4d73c7357d1a00c12da11a81baf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3eea4d73c7357d1a00c12da11a81baf">&#9670;&#160;</a></span>predicted_num_crossings() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double lal::linarr::predicted_num_crossings </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#afa9a90a785b8b5461c516b8a3971c558">linear_arrangement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pi</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Approximates the number of crossings. </p>
<p>See <a class="el" href="#aad593026a63a2b2e8cca0423ed73ff12">lal::linarr::predicted_num_crossings_rational</a> for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">pi</td><td>A linear arrangement of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return value is a floating point value. </dd></dl>

</div>
</div>
<a id="a4d166077415181690881e3ee43f5894f" name="a4d166077415181690881e3ee43f5894f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d166077415181690881e3ee43f5894f">&#9670;&#160;</a></span>predicted_num_crossings_rational() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a> lal::linarr::predicted_num_crossings_rational </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#afa9a90a785b8b5461c516b8a3971c558">linear_arrangement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pi</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Predicts the number of crossings. </p>
<p>Given a linear arrangement, which determines the length of the edges, predict the number of crossings conditioned by the length of the edges in the linear arrangement. Implementation of <a class="el" href="citelist.html#CITEREF_Ferrer2014a">[13]</a>. If the arrangement is not specified, the identity arrangement is used. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">pi</td><td>A linear arrangement of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Approximation of the number of crossings \(E_s[C_G\;|\;\delta]\). </dd></dl>

</div>
</div>
<a id="aad593026a63a2b2e8cca0423ed73ff12" name="aad593026a63a2b2e8cca0423ed73ff12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad593026a63a2b2e8cca0423ed73ff12">&#9670;&#160;</a></span>predicted_num_crossings_rational() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a> lal::linarr::predicted_num_crossings_rational </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#afa9a90a785b8b5461c516b8a3971c558">linear_arrangement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pi</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Predicts the number of crossings. </p>
<p>Given a linear arrangement, which determines the length of the edges, predict the number of crossings conditioned by the length of the edges in the linear arrangement. Implementation of <a class="el" href="citelist.html#CITEREF_Ferrer2014a">[13]</a>. If the arrangement is not specified, the identity arrangement is used. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">pi</td><td>A linear arrangement of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Approximation of the number of crossings \(E_s[C_G\;|\;\delta]\). </dd></dl>

</div>
</div>
<a id="a4558fab36ed2a75572794f60a17c623f" name="a4558fab36ed2a75572794f60a17c623f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4558fab36ed2a75572794f60a17c623f">&#9670;&#160;</a></span>sum_edge_lengths() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t lal::linarr::sum_edge_lengths </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#afa9a90a785b8b5461c516b8a3971c558">linear_arrangement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pi</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the sum of the length of the edges in a linear arrangement. </p>
<p>Given a graph \(G\) and a linear arrangement of its nodes \(\pi\), computes the sum of the length of the graph's edges in the arrangement. Formally, this function computes the value \(D_{\pi}(G)=\sum_{uv\in E(G)} |\pi(u) - \pi(v)|\).</p>
<p>If the arrangement is not specified, the identity arrangement is used. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">pi</td><td>Linear arrangement of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of edge lengths \(D\). </dd></dl>

</div>
</div>
<a id="afd14e3bf7c6b3b3ce6eaa319c8eee486" name="afd14e3bf7c6b3b3ce6eaa319c8eee486"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd14e3bf7c6b3b3ce6eaa319c8eee486">&#9670;&#160;</a></span>sum_edge_lengths() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t lal::linarr::sum_edge_lengths </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#afa9a90a785b8b5461c516b8a3971c558">linear_arrangement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pi</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the sum of the length of the edges in a linear arrangement. </p>
<p>Given a graph \(G\) and a linear arrangement of its nodes \(\pi\), computes the sum of the length of the graph's edges in the arrangement. Formally, this function computes the value \(D_{\pi}(G)=\sum_{uv\in E(G)} |\pi(u) - \pi(v)|\).</p>
<p>If the arrangement is not specified, the identity arrangement is used. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">pi</td><td>Linear arrangement of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of edge lengths \(D\). </dd></dl>

</div>
</div>
<a id="ac1c3ede6e41fd6313d017ee2d932dada" name="ac1c3ede6e41fd6313d017ee2d932dada"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1c3ede6e41fd6313d017ee2d932dada">&#9670;&#160;</a></span>syntactic_dependency_structure_class()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; bool, <a class="el" href="#a71f12918a0e2775e9a97181fddd1f7bc">__syntactic_dependency_structure_size</a> &gt; lal::linarr::syntactic_dependency_structure_class </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#afa9a90a785b8b5461c516b8a3971c558">linear_arrangement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pi</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the type of syntactic dependency tree. </p>
<p>Given an undirected rooted tree and a linear arrangement of its nodes, computes the class of projective structure the tree belongs to.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input tree. </td></tr>
    <tr><td class="paramname">pi</td><td>Linear arrangement of the nodes. If \(\pi[u]=p\) then node <em>u</em> is placed in position <em>p</em> of the arrangement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The class of projective structure. If the class could not be determined the method returns <a class="el" href="#a3e8b744d4c81d3bb4463ec203f9199d6aad921d60486366258809553a3db49a4a">lal::linarr::syntactic_dependency_structure::unknown</a>. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
