<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LAL: Linear Arrangement Library: lal::graphs::free_tree Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">LAL: Linear Arrangement Library<span id="projectnumber">&#160;21.07.01</span>
   </div>
   <div id="projectbrief">A library focused on algorithms on linear arrangements of graphs.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacelal.html">lal</a></li><li class="navelem"><a class="el" href="namespacelal_1_1graphs.html">graphs</a></li><li class="navelem"><a class="el" href="classlal_1_1graphs_1_1free__tree.html">free_tree</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="classlal_1_1graphs_1_1free__tree-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">lal::graphs::free_tree Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Free tree graph class.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="free__tree_8hpp_source.html">free_tree.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for lal::graphs::free_tree:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classlal_1_1graphs_1_1free__tree.png" usemap="#lal::graphs::free_5Ftree_map" alt=""/>
  <map id="lal::graphs::free_5Ftree_map" name="lal::graphs::free_5Ftree_map">
<area href="classlal_1_1graphs_1_1undirected__graph.html" title="Undirected graph class." alt="lal::graphs::undirected_graph" shape="rect" coords="0,56,176,80"/>
<area href="classlal_1_1graphs_1_1tree.html" title="Tree graph class." alt="lal::graphs::tree" shape="rect" coords="186,56,362,80"/>
<area href="classlal_1_1graphs_1_1graph.html" title="Abstract class for graphs." alt="lal::graphs::graph" shape="rect" coords="0,0,176,24"/>
<area href="classlal_1_1graphs_1_1graph.html" title="Abstract class for graphs." alt="lal::graphs::graph" shape="rect" coords="186,0,362,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af72bdb56a1ea046816b4a981934692e0" id="r_af72bdb56a1ea046816b4a981934692e0"><td class="memItemLeft" align="right" valign="top"><a id="af72bdb56a1ea046816b4a981934692e0" name="af72bdb56a1ea046816b4a981934692e0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>free_tree</b> () noexcept</td></tr>
<tr class="memdesc:af72bdb56a1ea046816b4a981934692e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty constructor. <br /></td></tr>
<tr class="separator:af72bdb56a1ea046816b4a981934692e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e41ebac4988aecc3fc63951ac5465df" id="r_a5e41ebac4988aecc3fc63951ac5465df"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e41ebac4988aecc3fc63951ac5465df">free_tree</a> (uint32_t n) noexcept</td></tr>
<tr class="memdesc:a5e41ebac4988aecc3fc63951ac5465df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor with number of vertices.  <br /></td></tr>
<tr class="separator:a5e41ebac4988aecc3fc63951ac5465df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabef5740830ba0c42d08b889ba23aa34" id="r_aabef5740830ba0c42d08b889ba23aa34"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aabef5740830ba0c42d08b889ba23aa34">free_tree</a> (const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">free_tree</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:aabef5740830ba0c42d08b889ba23aa34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <br /></td></tr>
<tr class="separator:aabef5740830ba0c42d08b889ba23aa34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b92250b425c48b2a23b07cdb5fa00aa" id="r_a3b92250b425c48b2a23b07cdb5fa00aa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b92250b425c48b2a23b07cdb5fa00aa">free_tree</a> (<a class="el" href="classlal_1_1graphs_1_1free__tree.html">free_tree</a> &amp;&amp;t) noexcept</td></tr>
<tr class="memdesc:a3b92250b425c48b2a23b07cdb5fa00aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <br /></td></tr>
<tr class="separator:a3b92250b425c48b2a23b07cdb5fa00aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76a30d6b99453d8c67669255ebbe8e4f" id="r_a76a30d6b99453d8c67669255ebbe8e4f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a76a30d6b99453d8c67669255ebbe8e4f">free_tree</a> (const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">undirected_graph</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:a76a30d6b99453d8c67669255ebbe8e4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor with undirected graph.  <br /></td></tr>
<tr class="separator:a76a30d6b99453d8c67669255ebbe8e4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adde8c9de43511c4a3de90a83678f75fc" id="r_adde8c9de43511c4a3de90a83678f75fc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adde8c9de43511c4a3de90a83678f75fc">free_tree</a> (<a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">undirected_graph</a> &amp;&amp;t) noexcept</td></tr>
<tr class="memdesc:adde8c9de43511c4a3de90a83678f75fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor with undirected graph.  <br /></td></tr>
<tr class="separator:adde8c9de43511c4a3de90a83678f75fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abffd582a082333883c1458379e82aec5" id="r_abffd582a082333883c1458379e82aec5"><td class="memItemLeft" align="right" valign="top"><a id="abffd582a082333883c1458379e82aec5" name="abffd582a082333883c1458379e82aec5"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~free_tree</b> () noexcept</td></tr>
<tr class="memdesc:abffd582a082333883c1458379e82aec5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:abffd582a082333883c1458379e82aec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab695106a6d1f24fe72eaa6f83483e6ef" id="r_ab695106a6d1f24fe72eaa6f83483e6ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1graphs_1_1free__tree.html">free_tree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab695106a6d1f24fe72eaa6f83483e6ef">operator=</a> (const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">free_tree</a> &amp;f) noexcept</td></tr>
<tr class="memdesc:ab695106a6d1f24fe72eaa6f83483e6ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator.  <br /></td></tr>
<tr class="separator:ab695106a6d1f24fe72eaa6f83483e6ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0b5312915e7119e82bb3319da8b863b" id="r_ae0b5312915e7119e82bb3319da8b863b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1graphs_1_1free__tree.html">free_tree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae0b5312915e7119e82bb3319da8b863b">operator=</a> (<a class="el" href="classlal_1_1graphs_1_1free__tree.html">free_tree</a> &amp;&amp;f) noexcept</td></tr>
<tr class="memdesc:ae0b5312915e7119e82bb3319da8b863b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator.  <br /></td></tr>
<tr class="separator:ae0b5312915e7119e82bb3319da8b863b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09753d6e59c2ec951c2820803cd1907e" id="r_a09753d6e59c2ec951c2820803cd1907e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1graphs_1_1free__tree.html">free_tree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a09753d6e59c2ec951c2820803cd1907e">add_edge</a> (<a class="el" href="namespacelal.html#abd94045faecfc68a03268dde9c9a13eb">node</a> s, <a class="el" href="namespacelal.html#abd94045faecfc68a03268dde9c9a13eb">node</a> t, bool norm=true, bool check_norm=true) noexcept</td></tr>
<tr class="memdesc:a09753d6e59c2ec951c2820803cd1907e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an edge to the tree.  <br /></td></tr>
<tr class="separator:a09753d6e59c2ec951c2820803cd1907e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4894c8ed210c5fe7532427930244422c" id="r_a4894c8ed210c5fe7532427930244422c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1graphs_1_1free__tree.html">free_tree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4894c8ed210c5fe7532427930244422c">add_edge_bulk</a> (<a class="el" href="namespacelal.html#abd94045faecfc68a03268dde9c9a13eb">node</a> s, <a class="el" href="namespacelal.html#abd94045faecfc68a03268dde9c9a13eb">node</a> t) noexcept</td></tr>
<tr class="memdesc:a4894c8ed210c5fe7532427930244422c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an edge to the graph.  <br /></td></tr>
<tr class="separator:a4894c8ed210c5fe7532427930244422c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad64cfa05c23d84dc799f47a3fdf6f9e" id="r_aad64cfa05c23d84dc799f47a3fdf6f9e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad64cfa05c23d84dc799f47a3fdf6f9e">finish_bulk_add</a> (bool norm=true, bool check=true) noexcept</td></tr>
<tr class="memdesc:aad64cfa05c23d84dc799f47a3fdf6f9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes adding edges in bulk.  <br /></td></tr>
<tr class="separator:aad64cfa05c23d84dc799f47a3fdf6f9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3567112a1772f34ba748a23fabc37955" id="r_a3567112a1772f34ba748a23fabc37955"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1graphs_1_1free__tree.html">free_tree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3567112a1772f34ba748a23fabc37955">add_edges</a> (const std::vector&lt; <a class="el" href="namespacelal.html#a5969ec7ecc85697ebb9ec0ace78fbcab">edge</a> &gt; &amp;edges, bool norm=true, bool check_norm=true) noexcept</td></tr>
<tr class="memdesc:a3567112a1772f34ba748a23fabc37955"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a list of edges to the graph.  <br /></td></tr>
<tr class="separator:a3567112a1772f34ba748a23fabc37955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c46a4bb10d19dff5ae1a9f5121638d8" id="r_a5c46a4bb10d19dff5ae1a9f5121638d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1graphs_1_1free__tree.html">free_tree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c46a4bb10d19dff5ae1a9f5121638d8">set_edges</a> (const std::vector&lt; <a class="el" href="namespacelal.html#a5969ec7ecc85697ebb9ec0ace78fbcab">edge</a> &gt; &amp;edges, bool norm=true, bool check_norm=true) noexcept</td></tr>
<tr class="memdesc:a5c46a4bb10d19dff5ae1a9f5121638d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the edges to the graph.  <br /></td></tr>
<tr class="separator:a5c46a4bb10d19dff5ae1a9f5121638d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b6b4482407f28f0dd6bab48a0e75e8f" id="r_a5b6b4482407f28f0dd6bab48a0e75e8f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlal_1_1graphs_1_1free__tree.html">free_tree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b6b4482407f28f0dd6bab48a0e75e8f">remove_edges_incident_to</a> (<a class="el" href="namespacelal.html#abd94045faecfc68a03268dde9c9a13eb">node</a> u, bool norm=true, bool check_norm=true) noexcept</td></tr>
<tr class="memdesc:a5b6b4482407f28f0dd6bab48a0e75e8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all edges incident to a given vertex.  <br /></td></tr>
<tr class="separator:a5b6b4482407f28f0dd6bab48a0e75e8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be70179238b5a9a42e0fc1365dd26e8" id="r_a8be70179238b5a9a42e0fc1365dd26e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8be70179238b5a9a42e0fc1365dd26e8">disjoint_union</a> (const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">free_tree</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:a8be70179238b5a9a42e0fc1365dd26e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disjoint union of trees.  <br /></td></tr>
<tr class="separator:a8be70179238b5a9a42e0fc1365dd26e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2355fb9491fe13bf32b32dd44d472977" id="r_a2355fb9491fe13bf32b32dd44d472977"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2355fb9491fe13bf32b32dd44d472977">calculate_tree_type</a> () noexcept</td></tr>
<tr class="memdesc:a2355fb9491fe13bf32b32dd44d472977"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the type of tree.  <br /></td></tr>
<tr class="separator:a2355fb9491fe13bf32b32dd44d472977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4c98020b21b21fd31b06e7fec77986e" id="r_af4c98020b21b21fd31b06e7fec77986e"><td class="memItemLeft" align="right" valign="top"><a id="af4c98020b21b21fd31b06e7fec77986e" name="af4c98020b21b21fd31b06e7fec77986e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_rooted</b> () const noexcept</td></tr>
<tr class="memdesc:af4c98020b21b21fd31b06e7fec77986e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether this tree is a rooted tree. <br /></td></tr>
<tr class="separator:af4c98020b21b21fd31b06e7fec77986e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7001f7fb135377a7de010a72cd20da54" id="r_a7001f7fb135377a7de010a72cd20da54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacelal.html#ac185793c961485ef0f9e4dbdd571d595">head_vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7001f7fb135377a7de010a72cd20da54">get_head_vector</a> (<a class="el" href="namespacelal.html#abd94045faecfc68a03268dde9c9a13eb">node</a> r=0) const noexcept</td></tr>
<tr class="memdesc:a7001f7fb135377a7de010a72cd20da54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a free tree into a head vector.  <br /></td></tr>
<tr class="separator:a7001f7fb135377a7de010a72cd20da54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac000d0b567b5d842fe8f66a67db73472" id="r_ac000d0b567b5d842fe8f66a67db73472"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">undirected_graph</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1undirected__graph.html#ac000d0b567b5d842fe8f66a67db73472">remove_edge</a> (<a class="el" href="namespacelal.html#abd94045faecfc68a03268dde9c9a13eb">node</a> s, <a class="el" href="namespacelal.html#abd94045faecfc68a03268dde9c9a13eb">node</a> t, bool norm=false, bool check_norm=true) noexcept</td></tr>
<tr class="memdesc:ac000d0b567b5d842fe8f66a67db73472"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an edge from this graph.  <br /></td></tr>
<tr class="separator:ac000d0b567b5d842fe8f66a67db73472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34a2d08fad8a4ce2498e2101bafcc50b" id="r_a34a2d08fad8a4ce2498e2101bafcc50b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">undirected_graph</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1undirected__graph.html#a34a2d08fad8a4ce2498e2101bafcc50b">remove_edges</a> (const std::vector&lt; <a class="el" href="namespacelal.html#a5969ec7ecc85697ebb9ec0ace78fbcab">edge</a> &gt; &amp;edges, bool norm=true, bool check_norm=true) noexcept</td></tr>
<tr class="memdesc:a34a2d08fad8a4ce2498e2101bafcc50b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an edge from this graph.  <br /></td></tr>
<tr class="separator:a34a2d08fad8a4ce2498e2101bafcc50b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a742dbaac9c82914744e76de4bdcec277" id="r_a742dbaac9c82914744e76de4bdcec277"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacelal.html#a235d5351556fbc73aa51767ab7765f5c">edge_pair</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1undirected__graph.html#a742dbaac9c82914744e76de4bdcec277">get_Q</a> () const noexcept</td></tr>
<tr class="memdesc:a742dbaac9c82914744e76de4bdcec277"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all independent pairs of edges of this graph.  <br /></td></tr>
<tr class="separator:a742dbaac9c82914744e76de4bdcec277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb63aa2d6c44840ef94a50139f5d630e" id="r_acb63aa2d6c44840ef94a50139f5d630e"><td class="memItemLeft" align="right" valign="top"><a id="acb63aa2d6c44840ef94a50139f5d630e" name="acb63aa2d6c44840ef94a50139f5d630e"></a>
std::vector&lt; <a class="el" href="namespacelal.html#a5969ec7ecc85697ebb9ec0ace78fbcab">edge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>get_edges</b> () const noexcept</td></tr>
<tr class="memdesc:acb63aa2d6c44840ef94a50139f5d630e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all edges of this graph. <br /></td></tr>
<tr class="separator:acb63aa2d6c44840ef94a50139f5d630e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af183c6590c16eb280043248f3600800b" id="r_af183c6590c16eb280043248f3600800b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacelal.html#aef91d923414879a998619e9c65181d1f">neighbourhood</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1undirected__graph.html#af183c6590c16eb280043248f3600800b">get_neighbours</a> (<a class="el" href="namespacelal.html#abd94045faecfc68a03268dde9c9a13eb">node</a> u) const noexcept</td></tr>
<tr class="memdesc:af183c6590c16eb280043248f3600800b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the neighbourhood of node <em>u</em>.  <br /></td></tr>
<tr class="separator:af183c6590c16eb280043248f3600800b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af00aa442a78dba81f82ab3cca990fba1" id="r_af00aa442a78dba81f82ab3cca990fba1"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1undirected__graph.html#af00aa442a78dba81f82ab3cca990fba1">get_degree</a> (<a class="el" href="namespacelal.html#abd94045faecfc68a03268dde9c9a13eb">node</a> u) const noexcept</td></tr>
<tr class="memdesc:af00aa442a78dba81f82ab3cca990fba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of neighbours of <em>u</em>.  <br /></td></tr>
<tr class="separator:af00aa442a78dba81f82ab3cca990fba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6816c0a895d62acef945e5c21399138c" id="r_a6816c0a895d62acef945e5c21399138c"><td class="memItemLeft" align="right" valign="top"><a id="a6816c0a895d62acef945e5c21399138c" name="a6816c0a895d62acef945e5c21399138c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>has_edge</b> (<a class="el" href="namespacelal.html#abd94045faecfc68a03268dde9c9a13eb">node</a> u, <a class="el" href="namespacelal.html#abd94045faecfc68a03268dde9c9a13eb">node</a> v) const noexcept</td></tr>
<tr class="memdesc:a6816c0a895d62acef945e5c21399138c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the edge \(\{u,v\}\) exists in the graph. <br /></td></tr>
<tr class="separator:a6816c0a895d62acef945e5c21399138c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71cbdc53c8f16b374bd96aa88e392866" id="r_a71cbdc53c8f16b374bd96aa88e392866"><td class="memItemLeft" align="right" valign="top"><a id="a71cbdc53c8f16b374bd96aa88e392866" name="a71cbdc53c8f16b374bd96aa88e392866"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_directed</b> () const noexcept</td></tr>
<tr class="memdesc:a71cbdc53c8f16b374bd96aa88e392866"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether this graph is directed or not. <br /></td></tr>
<tr class="separator:a71cbdc53c8f16b374bd96aa88e392866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42be0b6d02deb2ad807ebf86384fca30" id="r_a42be0b6d02deb2ad807ebf86384fca30"><td class="memItemLeft" align="right" valign="top"><a id="a42be0b6d02deb2ad807ebf86384fca30" name="a42be0b6d02deb2ad807ebf86384fca30"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_undirected</b> () const noexcept</td></tr>
<tr class="memdesc:a42be0b6d02deb2ad807ebf86384fca30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether this graph is undirected or not. <br /></td></tr>
<tr class="separator:a42be0b6d02deb2ad807ebf86384fca30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25c8d57865fa5f7cb5d101fd5d07fe2d" id="r_a25c8d57865fa5f7cb5d101fd5d07fe2d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1tree.html#a25c8d57865fa5f7cb5d101fd5d07fe2d">is_tree</a> () const noexcept</td></tr>
<tr class="memdesc:a25c8d57865fa5f7cb5d101fd5d07fe2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this graph is an actual tree?  <br /></td></tr>
<tr class="separator:a25c8d57865fa5f7cb5d101fd5d07fe2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dc7af6976411270258d50b9c7f00af8" id="r_a2dc7af6976411270258d50b9c7f00af8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1tree.html#a2dc7af6976411270258d50b9c7f00af8">can_add_edge</a> (<a class="el" href="namespacelal.html#abd94045faecfc68a03268dde9c9a13eb">node</a> s, <a class="el" href="namespacelal.html#abd94045faecfc68a03268dde9c9a13eb">node</a> t) const noexcept</td></tr>
<tr class="memdesc:a2dc7af6976411270258d50b9c7f00af8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can this edge be added?  <br /></td></tr>
<tr class="separator:a2dc7af6976411270258d50b9c7f00af8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace1349eb9e5c32c61f98022a73f8e870" id="r_ace1349eb9e5c32c61f98022a73f8e870"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1tree.html#ace1349eb9e5c32c61f98022a73f8e870">can_add_edges</a> (const std::vector&lt; <a class="el" href="namespacelal.html#a5969ec7ecc85697ebb9ec0ace78fbcab">edge</a> &gt; &amp;edges) const noexcept</td></tr>
<tr class="memdesc:ace1349eb9e5c32c61f98022a73f8e870"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can these edges be added?  <br /></td></tr>
<tr class="separator:ace1349eb9e5c32c61f98022a73f8e870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8045a162ec2a1647c695a5795243c187" id="r_a8045a162ec2a1647c695a5795243c187"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1tree.html#a8045a162ec2a1647c695a5795243c187">get_num_nodes_component</a> (<a class="el" href="namespacelal.html#abd94045faecfc68a03268dde9c9a13eb">node</a> u) const noexcept</td></tr>
<tr class="memdesc:a8045a162ec2a1647c695a5795243c187"><td class="mdescLeft">&#160;</td><td class="mdescRight">Amount of nodes in a connected component of the tree.  <br /></td></tr>
<tr class="separator:a8045a162ec2a1647c695a5795243c187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06ce8cc7afb074d2fecf70a0842adaaa" id="r_a06ce8cc7afb074d2fecf70a0842adaaa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1tree.html#a06ce8cc7afb074d2fecf70a0842adaaa">is_of_tree_type</a> (const <a class="el" href="namespacelal_1_1graphs.html#a18d52542088507e2be6241759722835b">tree_type</a> &amp;tt) const noexcept</td></tr>
<tr class="memdesc:a06ce8cc7afb074d2fecf70a0842adaaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether this tree is of type <em>tt</em>.  <br /></td></tr>
<tr class="separator:a06ce8cc7afb074d2fecf70a0842adaaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fc7f9e08db601f10982da6a01315cb3" id="r_a9fc7f9e08db601f10982da6a01315cb3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1tree.html#a9fc7f9e08db601f10982da6a01315cb3">is_tree_type_valid</a> () const noexcept</td></tr>
<tr class="memdesc:a9fc7f9e08db601f10982da6a01315cb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the type of this tree valid?  <br /></td></tr>
<tr class="separator:a9fc7f9e08db601f10982da6a01315cb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae51ce9ddffc9287f375545e2b2fec3e3" id="r_ae51ce9ddffc9287f375545e2b2fec3e3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1tree.html#ae51ce9ddffc9287f375545e2b2fec3e3">get_tree_type_list</a> () const noexcept</td></tr>
<tr class="memdesc:ae51ce9ddffc9287f375545e2b2fec3e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the list of types as a list of strings.  <br /></td></tr>
<tr class="separator:ae51ce9ddffc9287f375545e2b2fec3e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94098eb987f7c24d4d248571fe32e893" id="r_a94098eb987f7c24d4d248571fe32e893"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1graph.html#a94098eb987f7c24d4d248571fe32e893">init</a> (uint32_t n) noexcept</td></tr>
<tr class="memdesc:a94098eb987f7c24d4d248571fe32e893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates the necessary memory for this class.  <br /></td></tr>
<tr class="separator:a94098eb987f7c24d4d248571fe32e893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8ba9ec6acf2306c84d9ddbd88fc8474" id="r_af8ba9ec6acf2306c84d9ddbd88fc8474"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1graph.html#af8ba9ec6acf2306c84d9ddbd88fc8474">clear</a> () noexcept</td></tr>
<tr class="memdesc:af8ba9ec6acf2306c84d9ddbd88fc8474"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the memory occupied by this graph.  <br /></td></tr>
<tr class="separator:af8ba9ec6acf2306c84d9ddbd88fc8474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32fef69d99615a885bb8a0f421108c76" id="r_a32fef69d99615a885bb8a0f421108c76"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1graph.html#a32fef69d99615a885bb8a0f421108c76">normalise</a> () noexcept</td></tr>
<tr class="memdesc:a32fef69d99615a885bb8a0f421108c76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalises the graph.  <br /></td></tr>
<tr class="separator:a32fef69d99615a885bb8a0f421108c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af992e20fc9b8c988c8189bbc6e2f68c0" id="r_af992e20fc9b8c988c8189bbc6e2f68c0"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1graph.html#af992e20fc9b8c988c8189bbc6e2f68c0">check_normalised</a> () noexcept</td></tr>
<tr class="memdesc:af992e20fc9b8c988c8189bbc6e2f68c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the graph is normalised.  <br /></td></tr>
<tr class="separator:af992e20fc9b8c988c8189bbc6e2f68c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade7d7dfb09b3da30c49c8f6a47aa4987" id="r_ade7d7dfb09b3da30c49c8f6a47aa4987"><td class="memItemLeft" align="right" valign="top"><a id="ade7d7dfb09b3da30c49c8f6a47aa4987" name="ade7d7dfb09b3da30c49c8f6a47aa4987"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_normalised</b> (bool v=true) noexcept</td></tr>
<tr class="memdesc:ade7d7dfb09b3da30c49c8f6a47aa4987"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether this graph is normalised or not. <br /></td></tr>
<tr class="separator:ade7d7dfb09b3da30c49c8f6a47aa4987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c03143c2956cc87a14cd55e03107d10" id="r_a1c03143c2956cc87a14cd55e03107d10"><td class="memItemLeft" align="right" valign="top"><a id="a1c03143c2956cc87a14cd55e03107d10" name="a1c03143c2956cc87a14cd55e03107d10"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>has_node</b> (<a class="el" href="namespacelal.html#abd94045faecfc68a03268dde9c9a13eb">node</a> u) const noexcept</td></tr>
<tr class="memdesc:a1c03143c2956cc87a14cd55e03107d10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if node <em>u</em> is in this graph. <br /></td></tr>
<tr class="separator:a1c03143c2956cc87a14cd55e03107d10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c334a5bbfc9557c25e98af3ec40e1c2" id="r_a9c334a5bbfc9557c25e98af3ec40e1c2"><td class="memItemLeft" align="right" valign="top"><a id="a9c334a5bbfc9557c25e98af3ec40e1c2" name="a9c334a5bbfc9557c25e98af3ec40e1c2"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>get_num_nodes</b> () const noexcept</td></tr>
<tr class="memdesc:a9c334a5bbfc9557c25e98af3ec40e1c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of ndoes. <br /></td></tr>
<tr class="separator:a9c334a5bbfc9557c25e98af3ec40e1c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4853c4505fe9fb997dcd1f9608297ec" id="r_ac4853c4505fe9fb997dcd1f9608297ec"><td class="memItemLeft" align="right" valign="top"><a id="ac4853c4505fe9fb997dcd1f9608297ec" name="ac4853c4505fe9fb997dcd1f9608297ec"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>get_num_edges</b> () const noexcept</td></tr>
<tr class="memdesc:ac4853c4505fe9fb997dcd1f9608297ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of edges. <br /></td></tr>
<tr class="separator:ac4853c4505fe9fb997dcd1f9608297ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20e3c4adafeb9a479e4fa6b5b5fa5a32" id="r_a20e3c4adafeb9a479e4fa6b5b5fa5a32"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1graph.html#a20e3c4adafeb9a479e4fa6b5b5fa5a32">is_normalised</a> () const noexcept</td></tr>
<tr class="memdesc:a20e3c4adafeb9a479e4fa6b5b5fa5a32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether this graph is normalised or not.  <br /></td></tr>
<tr class="separator:a20e3c4adafeb9a479e4fa6b5b5fa5a32"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aa6560a483bf12381f5ddbdbac180a837" id="r_aa6560a483bf12381f5ddbdbac180a837"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa6560a483bf12381f5ddbdbac180a837">_init</a> (uint32_t n) noexcept</td></tr>
<tr class="separator:aa6560a483bf12381f5ddbdbac180a837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cb8aa8679935feee03aee1402dc978e" id="r_a9cb8aa8679935feee03aee1402dc978e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9cb8aa8679935feee03aee1402dc978e">_clear</a> () noexcept</td></tr>
<tr class="separator:a9cb8aa8679935feee03aee1402dc978e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6749cbbd757cd6bfd1674c279f256ca5" id="r_a6749cbbd757cd6bfd1674c279f256ca5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6749cbbd757cd6bfd1674c279f256ca5">call_union_find_after_add</a> (<a class="el" href="namespacelal.html#abd94045faecfc68a03268dde9c9a13eb">node</a> u, <a class="el" href="namespacelal.html#abd94045faecfc68a03268dde9c9a13eb">node</a> v, uint32_t *const root_of, uint32_t *const root_size) noexcept</td></tr>
<tr class="memdesc:a6749cbbd757cd6bfd1674c279f256ca5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A call to the union find method.  <br /></td></tr>
<tr class="separator:a6749cbbd757cd6bfd1674c279f256ca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac32f26f0c02af443ea83e22454603bce" id="r_ac32f26f0c02af443ea83e22454603bce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac32f26f0c02af443ea83e22454603bce">call_union_find_after_add</a> (<a class="el" href="namespacelal.html#abd94045faecfc68a03268dde9c9a13eb">node</a> u, <a class="el" href="namespacelal.html#abd94045faecfc68a03268dde9c9a13eb">node</a> v, uint32_t *const root_of, uint32_t *const root_size) const noexcept</td></tr>
<tr class="memdesc:ac32f26f0c02af443ea83e22454603bce"><td class="mdescLeft">&#160;</td><td class="mdescRight">A const call to the union find method.  <br /></td></tr>
<tr class="separator:ac32f26f0c02af443ea83e22454603bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c3161a45a66989a80a57b5354cb7f91" id="r_a7c3161a45a66989a80a57b5354cb7f91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c3161a45a66989a80a57b5354cb7f91">call_union_find_after_remove</a> (<a class="el" href="namespacelal.html#abd94045faecfc68a03268dde9c9a13eb">node</a> u, <a class="el" href="namespacelal.html#abd94045faecfc68a03268dde9c9a13eb">node</a> v, uint32_t *const root_of, uint32_t *const root_size) noexcept</td></tr>
<tr class="memdesc:a7c3161a45a66989a80a57b5354cb7f91"><td class="mdescLeft">&#160;</td><td class="mdescRight">A call to the union find method.  <br /></td></tr>
<tr class="separator:a7c3161a45a66989a80a57b5354cb7f91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a643d1bf0cdefcce401ef77caa6d675d7" id="r_a643d1bf0cdefcce401ef77caa6d675d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a643d1bf0cdefcce401ef77caa6d675d7">call_union_find_after_remove</a> (<a class="el" href="namespacelal.html#abd94045faecfc68a03268dde9c9a13eb">node</a> u, <a class="el" href="namespacelal.html#abd94045faecfc68a03268dde9c9a13eb">node</a> v, uint32_t *const root_of, uint32_t *const root_size) const noexcept</td></tr>
<tr class="memdesc:a643d1bf0cdefcce401ef77caa6d675d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">A const call to the union find method.  <br /></td></tr>
<tr class="separator:a643d1bf0cdefcce401ef77caa6d675d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aa66d7341e21149c6bb757296586145" id="r_a0aa66d7341e21149c6bb757296586145"><td class="memItemLeft" align="right" valign="top"><a id="a0aa66d7341e21149c6bb757296586145" name="a0aa66d7341e21149c6bb757296586145"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>copy_full_free_tree</b> (const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">free_tree</a> &amp;f) noexcept</td></tr>
<tr class="memdesc:a0aa66d7341e21149c6bb757296586145"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies all members of this class and the parent class. <br /></td></tr>
<tr class="separator:a0aa66d7341e21149c6bb757296586145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6179ca9a9b5a900c04617b9cc5dee767" id="r_a6179ca9a9b5a900c04617b9cc5dee767"><td class="memItemLeft" align="right" valign="top"><a id="a6179ca9a9b5a900c04617b9cc5dee767" name="a6179ca9a9b5a900c04617b9cc5dee767"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>move_full_free_tree</b> (<a class="el" href="classlal_1_1graphs_1_1free__tree.html">free_tree</a> &amp;&amp;f) noexcept</td></tr>
<tr class="memdesc:a6179ca9a9b5a900c04617b9cc5dee767"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves all members of this class and the parent class. <br /></td></tr>
<tr class="separator:a6179ca9a9b5a900c04617b9cc5dee767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f7df5dd2a55f14be25c51b00511dc82" id="r_a2f7df5dd2a55f14be25c51b00511dc82"><td class="memItemLeft" align="right" valign="top"><a id="a2f7df5dd2a55f14be25c51b00511dc82" name="a2f7df5dd2a55f14be25c51b00511dc82"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>copy_full_undirected_graph</b> (const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">undirected_graph</a> &amp;u) noexcept</td></tr>
<tr class="memdesc:a2f7df5dd2a55f14be25c51b00511dc82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies all members of this class and the parent class. <br /></td></tr>
<tr class="separator:a2f7df5dd2a55f14be25c51b00511dc82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a307b1122f7ab4aa102a34305c793411c" id="r_a307b1122f7ab4aa102a34305c793411c"><td class="memItemLeft" align="right" valign="top"><a id="a307b1122f7ab4aa102a34305c793411c" name="a307b1122f7ab4aa102a34305c793411c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>move_full_undirected_graph</b> (<a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">undirected_graph</a> &amp;&amp;u) noexcept</td></tr>
<tr class="memdesc:a307b1122f7ab4aa102a34305c793411c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves all members of this class and the parent class. <br /></td></tr>
<tr class="separator:a307b1122f7ab4aa102a34305c793411c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5336916f0e68fdd2e023db806275ad7" id="r_aa5336916f0e68fdd2e023db806275ad7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1tree.html#aa5336916f0e68fdd2e023db806275ad7">tree_only_init</a> (uint32_t n) noexcept</td></tr>
<tr class="memdesc:aa5336916f0e68fdd2e023db806275ad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialises only the memory of class <a class="el" href="classlal_1_1graphs_1_1tree.html">tree</a>.  <br /></td></tr>
<tr class="separator:aa5336916f0e68fdd2e023db806275ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade9b9ff890e9c0a809cdb39dd6a45d03" id="r_ade9b9ff890e9c0a809cdb39dd6a45d03"><td class="memItemLeft" align="right" valign="top"><a id="ade9b9ff890e9c0a809cdb39dd6a45d03" name="ade9b9ff890e9c0a809cdb39dd6a45d03"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>tree_only_clear</b> () noexcept</td></tr>
<tr class="memdesc:ade9b9ff890e9c0a809cdb39dd6a45d03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the memory used by only class <a class="el" href="classlal_1_1graphs_1_1tree.html">tree</a>. <br /></td></tr>
<tr class="separator:ade9b9ff890e9c0a809cdb39dd6a45d03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a98caa30febd772b6536f15aea33ea1" id="r_a3a98caa30febd772b6536f15aea33ea1"><td class="memItemLeft" align="right" valign="top"><a id="a3a98caa30febd772b6536f15aea33ea1" name="a3a98caa30febd772b6536f15aea33ea1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>tree_only_copy</b> (const <a class="el" href="classlal_1_1graphs_1_1tree.html">tree</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:a3a98caa30febd772b6536f15aea33ea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies only members of class <a class="el" href="classlal_1_1graphs_1_1tree.html">tree</a>. <br /></td></tr>
<tr class="separator:a3a98caa30febd772b6536f15aea33ea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c0ab812a8dead61f6e2e9253730f62a" id="r_a4c0ab812a8dead61f6e2e9253730f62a"><td class="memItemLeft" align="right" valign="top"><a id="a4c0ab812a8dead61f6e2e9253730f62a" name="a4c0ab812a8dead61f6e2e9253730f62a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>tree_only_move</b> (<a class="el" href="classlal_1_1graphs_1_1tree.html">tree</a> &amp;&amp;t) noexcept</td></tr>
<tr class="memdesc:a4c0ab812a8dead61f6e2e9253730f62a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves only members of class <a class="el" href="classlal_1_1graphs_1_1tree.html">tree</a>. <br /></td></tr>
<tr class="separator:a4c0ab812a8dead61f6e2e9253730f62a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a548ec1078cc864b617008323b2cfcb07" id="r_a548ec1078cc864b617008323b2cfcb07"><td class="memItemLeft" align="right" valign="top"><a id="a548ec1078cc864b617008323b2cfcb07" name="a548ec1078cc864b617008323b2cfcb07"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>extra_work_per_edge_add</b> (<a class="el" href="namespacelal.html#abd94045faecfc68a03268dde9c9a13eb">node</a> u, <a class="el" href="namespacelal.html#abd94045faecfc68a03268dde9c9a13eb">node</a> v) noexcept</td></tr>
<tr class="memdesc:a548ec1078cc864b617008323b2cfcb07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do some extra work after an edge has been added. <br /></td></tr>
<tr class="separator:a548ec1078cc864b617008323b2cfcb07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5d4ed1e6ec06df2308130b3df367a6f" id="r_ab5d4ed1e6ec06df2308130b3df367a6f"><td class="memItemLeft" align="right" valign="top"><a id="ab5d4ed1e6ec06df2308130b3df367a6f" name="ab5d4ed1e6ec06df2308130b3df367a6f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>extra_work_per_edge_remove</b> (<a class="el" href="namespacelal.html#abd94045faecfc68a03268dde9c9a13eb">node</a> u, <a class="el" href="namespacelal.html#abd94045faecfc68a03268dde9c9a13eb">node</a> v) noexcept</td></tr>
<tr class="memdesc:ab5d4ed1e6ec06df2308130b3df367a6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do some extra work after an edge has been removed. <br /></td></tr>
<tr class="separator:ab5d4ed1e6ec06df2308130b3df367a6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeb1360f7847f2c29f70c68b54a73b18" id="r_adeb1360f7847f2c29f70c68b54a73b18"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1tree.html#adeb1360f7847f2c29f70c68b54a73b18">tree_only_extra_work_edges_set</a> () noexcept</td></tr>
<tr class="separator:adeb1360f7847f2c29f70c68b54a73b18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48fd37ac155705661e59e72b61bf9c75" id="r_a48fd37ac155705661e59e72b61bf9c75"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1tree.html#a48fd37ac155705661e59e72b61bf9c75">fill_union_find</a> () noexcept</td></tr>
<tr class="separator:a48fd37ac155705661e59e72b61bf9c75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ea60f01e9535ae965e54b9caa3d08fd" id="r_a0ea60f01e9535ae965e54b9caa3d08fd"><td class="memItemLeft" align="right" valign="top"><a id="a0ea60f01e9535ae965e54b9caa3d08fd" name="a0ea60f01e9535ae965e54b9caa3d08fd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>copy_full_graph</b> (const <a class="el" href="classlal_1_1graphs_1_1graph.html">graph</a> &amp;g) noexcept</td></tr>
<tr class="memdesc:a0ea60f01e9535ae965e54b9caa3d08fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies all members of this class. <br /></td></tr>
<tr class="separator:a0ea60f01e9535ae965e54b9caa3d08fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca19fcaa6d290a97c92ef95df92160ae" id="r_aca19fcaa6d290a97c92ef95df92160ae"><td class="memItemLeft" align="right" valign="top"><a id="aca19fcaa6d290a97c92ef95df92160ae" name="aca19fcaa6d290a97c92ef95df92160ae"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>move_full_graph</b> (<a class="el" href="classlal_1_1graphs_1_1graph.html">graph</a> &amp;&amp;g) noexcept</td></tr>
<tr class="memdesc:aca19fcaa6d290a97c92ef95df92160ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves all members of this class. <br /></td></tr>
<tr class="separator:aca19fcaa6d290a97c92ef95df92160ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2953c51682d770519cac771dc26c77ee" id="r_a2953c51682d770519cac771dc26c77ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1graph.html#a2953c51682d770519cac771dc26c77ee">__disjoint_union</a> (const <a class="el" href="classlal_1_1graphs_1_1graph.html">graph</a> &amp;g) noexcept</td></tr>
<tr class="memdesc:a2953c51682d770519cac771dc26c77ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disjoint union of graphs.  <br /></td></tr>
<tr class="separator:a2953c51682d770519cac771dc26c77ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac20a37d52aae815d45d150f1952cfcf0" id="r_ac20a37d52aae815d45d150f1952cfcf0"><td class="memItemLeft" align="right" valign="top"><a id="ac20a37d52aae815d45d150f1952cfcf0" name="ac20a37d52aae815d45d150f1952cfcf0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>normalise_after_add</b> (bool norm, bool check) noexcept</td></tr>
<tr class="memdesc:ac20a37d52aae815d45d150f1952cfcf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalise the graph after one (or more) edges have been added. <br /></td></tr>
<tr class="separator:ac20a37d52aae815d45d150f1952cfcf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc06f71010fd4a4bb706ae779ace05ab" id="r_abc06f71010fd4a4bb706ae779ace05ab"><td class="memItemLeft" align="right" valign="top"><a id="abc06f71010fd4a4bb706ae779ace05ab" name="abc06f71010fd4a4bb706ae779ace05ab"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>normalise_after_remove</b> (bool norm, bool check) noexcept</td></tr>
<tr class="memdesc:abc06f71010fd4a4bb706ae779ace05ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalise the graph after one (or more) edges have been removed. <br /></td></tr>
<tr class="separator:abc06f71010fd4a4bb706ae779ace05ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a544bb4ac5c61bac5c401b06b46eb629b" id="r_a544bb4ac5c61bac5c401b06b46eb629b"><td class="memItemLeft" align="right" valign="top"><a id="a544bb4ac5c61bac5c401b06b46eb629b" name="a544bb4ac5c61bac5c401b06b46eb629b"></a>
std::vector&lt; <a class="el" href="namespacelal.html#abd94045faecfc68a03268dde9c9a13eb">node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_root_of</b></td></tr>
<tr class="memdesc:a544bb4ac5c61bac5c401b06b46eb629b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The root of every vertex in the union-find data structure. <br /></td></tr>
<tr class="separator:a544bb4ac5c61bac5c401b06b46eb629b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6dab82fca5d3606b81228ca8c69654d" id="r_ad6dab82fca5d3606b81228ca8c69654d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; uint32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1tree.html#ad6dab82fca5d3606b81228ca8c69654d">m_root_size</a></td></tr>
<tr class="memdesc:ad6dab82fca5d3606b81228ca8c69654d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of the connected component that a <em>root</em> belongs to.  <br /></td></tr>
<tr class="separator:ad6dab82fca5d3606b81228ca8c69654d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac27ba83912b248cd1160e0c6a0147b35" id="r_ac27ba83912b248cd1160e0c6a0147b35"><td class="memItemLeft" align="right" valign="top"><a id="ac27ba83912b248cd1160e0c6a0147b35" name="ac27ba83912b248cd1160e0c6a0147b35"></a>
std::array&lt; bool, <a class="el" href="namespacelal_1_1graphs.html#a1895a9ed855ad1d85cd9510de714a732">__tree_type_size</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_tree_type</b></td></tr>
<tr class="memdesc:ac27ba83912b248cd1160e0c6a0147b35"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of this tree. <br /></td></tr>
<tr class="separator:ac27ba83912b248cd1160e0c6a0147b35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a951a57e760385ce3de285089627b7bbb" id="r_a951a57e760385ce3de285089627b7bbb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1tree.html#a951a57e760385ce3de285089627b7bbb">m_is_tree_type_valid</a> = false</td></tr>
<tr class="memdesc:a951a57e760385ce3de285089627b7bbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the type of this tree valid?  <br /></td></tr>
<tr class="separator:a951a57e760385ce3de285089627b7bbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad87c640988218838def15ea96645bb84" id="r_ad87c640988218838def15ea96645bb84"><td class="memItemLeft" align="right" valign="top"><a id="ad87c640988218838def15ea96645bb84" name="ad87c640988218838def15ea96645bb84"></a>
std::vector&lt; <a class="el" href="namespacelal.html#aef91d923414879a998619e9c65181d1f">neighbourhood</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_adjacency_list</b></td></tr>
<tr class="memdesc:ad87c640988218838def15ea96645bb84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure that implements the graph. <br /></td></tr>
<tr class="separator:ad87c640988218838def15ea96645bb84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94279fece660b0028a7d0d53482d26d9" id="r_a94279fece660b0028a7d0d53482d26d9"><td class="memItemLeft" align="right" valign="top"><a id="a94279fece660b0028a7d0d53482d26d9" name="a94279fece660b0028a7d0d53482d26d9"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>m_num_edges</b> = 0</td></tr>
<tr class="memdesc:a94279fece660b0028a7d0d53482d26d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Amount of edges of this graph. <br /></td></tr>
<tr class="separator:a94279fece660b0028a7d0d53482d26d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbd9fef263d20c982a21371e3d1e9307" id="r_afbd9fef263d20c982a21371e3d1e9307"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1graph.html#afbd9fef263d20c982a21371e3d1e9307">m_normalised</a> = true</td></tr>
<tr class="memdesc:afbd9fef263d20c982a21371e3d1e9307"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this graph normalised?  <br /></td></tr>
<tr class="separator:afbd9fef263d20c982a21371e3d1e9307"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a2e605f13fa6bb9158dead67b242bd30d" id="r_a2e605f13fa6bb9158dead67b242bd30d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e605f13fa6bb9158dead67b242bd30d">disjoint_union</a> (const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">undirected_graph</a> &amp;g) noexcept</td></tr>
<tr class="memdesc:a2e605f13fa6bb9158dead67b242bd30d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disjoint union of graphs.  <br /></td></tr>
<tr class="separator:a2e605f13fa6bb9158dead67b242bd30d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9358e59dc7c717b29f746985e0428fae" id="r_a9358e59dc7c717b29f746985e0428fae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1undirected__graph.html#a9358e59dc7c717b29f746985e0428fae">remove_single_edge</a> (<a class="el" href="namespacelal.html#abd94045faecfc68a03268dde9c9a13eb">node</a> u, <a class="el" href="namespacelal.html#abd94045faecfc68a03268dde9c9a13eb">node</a> v, <a class="el" href="namespacelal.html#aef91d923414879a998619e9c65181d1f">neighbourhood</a> &amp;out_u, <a class="el" href="namespacelal.html#aef91d923414879a998619e9c65181d1f">neighbourhood</a> &amp;in_v) noexcept</td></tr>
<tr class="memdesc:a9358e59dc7c717b29f746985e0428fae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a single edge.  <br /></td></tr>
<tr class="separator:a9358e59dc7c717b29f746985e0428fae"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Free tree graph class. </p>
<p>This class constrains the addition of edges so that the resulting graphs does not contain cycles. Furthermore, the edges added are undirected.</p>
<p>For another type of tree-like graphs, see <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">rooted_tree</a>. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a5e41ebac4988aecc3fc63951ac5465df" name="a5e41ebac4988aecc3fc63951ac5465df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e41ebac4988aecc3fc63951ac5465df">&#9670;&#160;</a></span>free_tree() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">lal::graphs::free_tree::free_tree </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor with number of vertices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of vertices </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aabef5740830ba0c42d08b889ba23aa34" name="aabef5740830ba0c42d08b889ba23aa34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabef5740830ba0c42d08b889ba23aa34">&#9670;&#160;</a></span>free_tree() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">lal::graphs::free_tree::free_tree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">free_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Free tree. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3b92250b425c48b2a23b07cdb5fa00aa" name="a3b92250b425c48b2a23b07cdb5fa00aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b92250b425c48b2a23b07cdb5fa00aa">&#9670;&#160;</a></span>free_tree() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">lal::graphs::free_tree::free_tree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlal_1_1graphs_1_1free__tree.html">free_tree</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Free tree. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a76a30d6b99453d8c67669255ebbe8e4f" name="a76a30d6b99453d8c67669255ebbe8e4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76a30d6b99453d8c67669255ebbe8e4f">&#9670;&#160;</a></span>free_tree() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">lal::graphs::free_tree::free_tree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">undirected_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor with undirected graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>An undirected graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Graph <em>t</em> is a tree. </dd></dl>

</div>
</div>
<a id="adde8c9de43511c4a3de90a83678f75fc" name="adde8c9de43511c4a3de90a83678f75fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adde8c9de43511c4a3de90a83678f75fc">&#9670;&#160;</a></span>free_tree() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">lal::graphs::free_tree::free_tree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">undirected_graph</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor with undirected graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>An undirected graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Graph <em>t</em> is a tree. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a2953c51682d770519cac771dc26c77ee" name="a2953c51682d770519cac771dc26c77ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2953c51682d770519cac771dc26c77ee">&#9670;&#160;</a></span>__disjoint_union()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::graph::__disjoint_union </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1graph.html">graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disjoint union of graphs. </p>
<p>Given a graph, append it to the current graph.</p>
<p>All the nodes in <em>g</em> are relabelled starting at <em>n</em>, the number of nodes of the current graph. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>This graph and <em>g</em> must be of the same type (both must be either undirected, or both directed). </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The graph is normalised only if it was normalised before the call and <em>g</em> is also normalised. </dd></dl>

</div>
</div>
<a id="a9cb8aa8679935feee03aee1402dc978e" name="a9cb8aa8679935feee03aee1402dc978e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cb8aa8679935feee03aee1402dc978e">&#9670;&#160;</a></span>_clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void lal::graphs::free_tree::_clear </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clears the memory of <a class="el" href="classlal_1_1graphs_1_1free__tree.html">free_tree</a>, <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">undirected_graph</a> and <a class="el" href="classlal_1_1graphs_1_1graph.html">graph</a> classes. </p>

<p>Reimplemented from <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html#a2eec85a279662dd070b548b39a026067">lal::graphs::undirected_graph</a>.</p>

</div>
</div>
<a id="aa6560a483bf12381f5ddbdbac180a837" name="aa6560a483bf12381f5ddbdbac180a837"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6560a483bf12381f5ddbdbac180a837">&#9670;&#160;</a></span>_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void lal::graphs::free_tree::_init </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initialises memory of <a class="el" href="classlal_1_1graphs_1_1free__tree.html">free_tree</a>, <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">undirected_graph</a> and <a class="el" href="classlal_1_1graphs_1_1graph.html">graph</a> classes. </p>

<p>Reimplemented from <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html#aa3292f1f5c3b27d7c660e28b03f3732f">lal::graphs::undirected_graph</a>.</p>

</div>
</div>
<a id="a09753d6e59c2ec951c2820803cd1907e" name="a09753d6e59c2ec951c2820803cd1907e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09753d6e59c2ec951c2820803cd1907e">&#9670;&#160;</a></span>add_edge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1graphs_1_1free__tree.html">free_tree</a> &amp; lal::graphs::free_tree::add_edge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacelal.html#abd94045faecfc68a03268dde9c9a13eb">node</a></td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelal.html#abd94045faecfc68a03268dde9c9a13eb">node</a></td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>norm</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>check_norm</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an edge to the tree. </p>
<p>This operation checks that the edge added does not produce cycles only in a <em>debug</em> compilation of the library. For a more controlled addition of the edges, see <a class="el" href="classlal_1_1graphs_1_1tree.html#a2dc7af6976411270258d50b9c7f00af8">can_add_edge</a>.</p>
<p><b>For developers:</b> method <a class="el" href="classlal_1_1graphs_1_1graph.html#a0f5a5e810aceb0e557a4e1debf79a8a3">graph::extra_work_per_edge_add</a> is called after the edge has been added. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Valid node index: \(0 \le s &lt; n\). </td></tr>
    <tr><td class="paramname">t</td><td>Valid node index: \(0 \le t &lt; n\). </td></tr>
    <tr><td class="paramname">norm</td><td>Should the graph be normalised? </td></tr>
    <tr><td class="paramname">check_norm</td><td>If <em>norm</em> is false then, should we check whether the result is normalised or not? This might be useful in case the resulting graph is normalised. If <em>norm</em> is true then <em>check_norm</em> is ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>\(s \neq t\) </dd>
<dd>
Edge \(\{s,t\}\) is not part of the graph. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>If <em>norm</em> is true the graph is guaranteed to be normalised after the addition of the edge. </dd></dl>

<p>Reimplemented from <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html#a8502b0b2d57ac07f370189b5c49a4cdd">lal::graphs::undirected_graph</a>.</p>

</div>
</div>
<a id="a4894c8ed210c5fe7532427930244422c" name="a4894c8ed210c5fe7532427930244422c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4894c8ed210c5fe7532427930244422c">&#9670;&#160;</a></span>add_edge_bulk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1graphs_1_1free__tree.html">free_tree</a> &amp; lal::graphs::free_tree::add_edge_bulk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacelal.html#abd94045faecfc68a03268dde9c9a13eb">node</a></td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelal.html#abd94045faecfc68a03268dde9c9a13eb">node</a></td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an edge to the graph. </p>
<p>This method only adds an edge, and does no other work: normalisation is not checked, and no extra work per edge is done. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Valid node index: \(0 \le s &lt; n\). </td></tr>
    <tr><td class="paramname">t</td><td>Valid node index: \(0 \le t &lt; n\). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>\(u \neq v\). </dd>
<dd>
The edge \(\{s,t\}\) is not part of the graph. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>If <em>norm</em> is true the graph is guaranteed to be normalised after the addition of the edge. </dd></dl>

</div>
</div>
<a id="a3567112a1772f34ba748a23fabc37955" name="a3567112a1772f34ba748a23fabc37955"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3567112a1772f34ba748a23fabc37955">&#9670;&#160;</a></span>add_edges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1graphs_1_1free__tree.html">free_tree</a> &amp; lal::graphs::free_tree::add_edges </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacelal.html#a5969ec7ecc85697ebb9ec0ace78fbcab">edge</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>edges</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>norm</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>check_norm</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a list of edges to the graph. </p>
<p>This function checks that edges will not produce cycles only in a <em>debug</em> compilation of the library. Moreover, this operation is faster than calling <a class="el" href="#a09753d6e59c2ec951c2820803cd1907e">add_edge</a> since the edges are added in bulk. For a more controlled addition of the edges, see <a class="el" href="classlal_1_1graphs_1_1tree.html#ace1349eb9e5c32c61f98022a73f8e870">can_add_edges</a>.</p>
<p><b>For developers:</b> method <a class="el" href="classlal_1_1graphs_1_1graph.html#a0f5a5e810aceb0e557a4e1debf79a8a3">graph::extra_work_per_edge_add</a> is called after each edge has been added. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edges</td><td>The edges to be added. </td></tr>
    <tr><td class="paramname">norm</td><td>Normalise the graph after the insertions. </td></tr>
    <tr><td class="paramname">check_norm</td><td>If <em>norm</em> is false then, should we check whether the result is normalised or not? This might be useful in case the resulting graph is normalised. If <em>norm</em> is true then <em>check_norm</em> is ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>All the edges in <em>edges</em> must meet the precondition of method <a class="el" href="#a09753d6e59c2ec951c2820803cd1907e">add_edge</a>. </dd>
<dd>
None of the subsets of the list of edges can produce cycles when added. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>If <em>norm</em> is true the graph is guaranteed to be normalised after the addition of the edges. </dd></dl>

<p>Reimplemented from <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html#ad8255183f59620fe545c1e9a40cc02ca">lal::graphs::undirected_graph</a>.</p>

</div>
</div>
<a id="a2355fb9491fe13bf32b32dd44d472977" name="a2355fb9491fe13bf32b32dd44d472977"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2355fb9491fe13bf32b32dd44d472977">&#9670;&#160;</a></span>calculate_tree_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::free_tree::calculate_tree_type </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the type of tree. </p>
<p>See <a class="el" href="namespacelal_1_1graphs.html#a18d52542088507e2be6241759722835b">tree_type</a> for the list of different tree types. </p>

<p>Implements <a class="el" href="classlal_1_1graphs_1_1tree.html#aa8a453d924452a46b781f1cf6bfb8360">lal::graphs::tree</a>.</p>

</div>
</div>
<a id="ac32f26f0c02af443ea83e22454603bce" name="ac32f26f0c02af443ea83e22454603bce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac32f26f0c02af443ea83e22454603bce">&#9670;&#160;</a></span>call_union_find_after_add() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::free_tree::call_union_find_after_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacelal.html#abd94045faecfc68a03268dde9c9a13eb">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelal.html#abd94045faecfc68a03268dde9c9a13eb">node</a></td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *const</td>          <td class="paramname"><span class="paramname"><em>root_of</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *const</td>          <td class="paramname"><span class="paramname"><em>root_size</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A const call to the union find method. </p>
<p>This is a helper method to be able to call a template in the lal::internal namespace which updates the union find data structure under addition of an edge. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>Node that is connected to <em>v</em>. </td></tr>
    <tr><td class="paramname">v</td><td>Node that is connected to <em>u</em>. </td></tr>
    <tr><td class="paramname">root_of</td><td>Array of <em>n</em> elements relating each vertex to its root in the union find data structure. </td></tr>
    <tr><td class="paramname">root_size</td><td>Array of <em>n</em> elements relating each vertex to the size of the connected component it belongs to. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classlal_1_1graphs_1_1tree.html#adcad4416f8a064579dfc2e26f128433e">lal::graphs::tree</a>.</p>

</div>
</div>
<a id="a6749cbbd757cd6bfd1674c279f256ca5" name="a6749cbbd757cd6bfd1674c279f256ca5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6749cbbd757cd6bfd1674c279f256ca5">&#9670;&#160;</a></span>call_union_find_after_add() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::free_tree::call_union_find_after_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacelal.html#abd94045faecfc68a03268dde9c9a13eb">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelal.html#abd94045faecfc68a03268dde9c9a13eb">node</a></td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *const</td>          <td class="paramname"><span class="paramname"><em>root_of</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *const</td>          <td class="paramname"><span class="paramname"><em>root_size</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A call to the union find method. </p>
<p>This is a helper method to be able to call a template in the lal::internal namespace which updates the union find data structure under addition of an edge. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>Node that is connected to <em>v</em>. </td></tr>
    <tr><td class="paramname">v</td><td>Node that is connected to <em>u</em>. </td></tr>
    <tr><td class="paramname">root_of</td><td>Array of <em>n</em> elements relating each vertex to its root in the union find data structure. </td></tr>
    <tr><td class="paramname">root_size</td><td>Array of <em>n</em> elements relating each vertex to the size of the connected component it belongs to. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classlal_1_1graphs_1_1tree.html#acc697ec286f1f3a48cf4480e9e544479">lal::graphs::tree</a>.</p>

</div>
</div>
<a id="a643d1bf0cdefcce401ef77caa6d675d7" name="a643d1bf0cdefcce401ef77caa6d675d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a643d1bf0cdefcce401ef77caa6d675d7">&#9670;&#160;</a></span>call_union_find_after_remove() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::free_tree::call_union_find_after_remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacelal.html#abd94045faecfc68a03268dde9c9a13eb">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelal.html#abd94045faecfc68a03268dde9c9a13eb">node</a></td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *const</td>          <td class="paramname"><span class="paramname"><em>root_of</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *const</td>          <td class="paramname"><span class="paramname"><em>root_size</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A const call to the union find method. </p>
<p>This is a helper method to be able to call a template in the lal::internal namespace which updates the union find data structure under removal of an edge. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>Node that is connected to <em>v</em>. </td></tr>
    <tr><td class="paramname">v</td><td>Node that is connected to <em>u</em>. </td></tr>
    <tr><td class="paramname">root_of</td><td>Array of <em>n</em> elements relating each vertex to its root in the union find data structure. </td></tr>
    <tr><td class="paramname">root_size</td><td>Array of <em>n</em> elements relating each vertex to the size of the connected component it belongs to. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classlal_1_1graphs_1_1tree.html#a68127df634adb52b0fa20ce65737ca4c">lal::graphs::tree</a>.</p>

</div>
</div>
<a id="a7c3161a45a66989a80a57b5354cb7f91" name="a7c3161a45a66989a80a57b5354cb7f91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c3161a45a66989a80a57b5354cb7f91">&#9670;&#160;</a></span>call_union_find_after_remove() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::free_tree::call_union_find_after_remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacelal.html#abd94045faecfc68a03268dde9c9a13eb">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelal.html#abd94045faecfc68a03268dde9c9a13eb">node</a></td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *const</td>          <td class="paramname"><span class="paramname"><em>root_of</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *const</td>          <td class="paramname"><span class="paramname"><em>root_size</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A call to the union find method. </p>
<p>This is a helper method to be able to call a template in the lal::internal namespace which updates the union find data structure under removal of an edge. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>Node that is connected to <em>v</em>. </td></tr>
    <tr><td class="paramname">v</td><td>Node that is connected to <em>u</em>. </td></tr>
    <tr><td class="paramname">root_of</td><td>Array of <em>n</em> elements relating each vertex to its root in the union find data structure. </td></tr>
    <tr><td class="paramname">root_size</td><td>Array of <em>n</em> elements relating each vertex to the size of the connected component it belongs to. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classlal_1_1graphs_1_1tree.html#ab682c0ee399e4fad19635893c82989ab">lal::graphs::tree</a>.</p>

</div>
</div>
<a id="a2dc7af6976411270258d50b9c7f00af8" name="a2dc7af6976411270258d50b9c7f00af8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dc7af6976411270258d50b9c7f00af8">&#9670;&#160;</a></span>can_add_edge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::graphs::tree::can_add_edge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacelal.html#abd94045faecfc68a03268dde9c9a13eb">node</a></td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelal.html#abd94045faecfc68a03268dde9c9a13eb">node</a></td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Can this edge be added? </p>
<p>In a tree, an edge can only be added if it does not produce cycles, and it has not been added before. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>First node of the edge. </td></tr>
    <tr><td class="paramname">t</td><td>Second node of the edge. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the addition of this new edge can be added to the tree without producing cycles. </dd></dl>

</div>
</div>
<a id="ace1349eb9e5c32c61f98022a73f8e870" name="ace1349eb9e5c32c61f98022a73f8e870"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace1349eb9e5c32c61f98022a73f8e870">&#9670;&#160;</a></span>can_add_edges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::graphs::tree::can_add_edges </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacelal.html#a5969ec7ecc85697ebb9ec0ace78fbcab">edge</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>edges</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Can these edges be added? </p>
<p>In a tree, a set of edges can only be added if their addition to the tree do not produce cycles and none of them have been added before. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edges</td><td>List of edges. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the addition of these new edges can be added to the tree without producing cycles. </dd></dl>

</div>
</div>
<a id="af992e20fc9b8c988c8189bbc6e2f68c0" name="af992e20fc9b8c988c8189bbc6e2f68c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af992e20fc9b8c988c8189bbc6e2f68c0">&#9670;&#160;</a></span>check_normalised()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool lal::graphs::graph::check_normalised </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the graph is normalised. </p>
<p>Checks, whether the graph's adjacency structure is normalised or not. In case it is, attribute <a class="el" href="classlal_1_1graphs_1_1graph.html#afbd9fef263d20c982a21371e3d1e9307">m_normalised</a> is set to true, so method <a class="el" href="classlal_1_1graphs_1_1graph.html#a20e3c4adafeb9a479e4fa6b5b5fa5a32">is_normalised</a> evaluates to true. </p>

<p>Reimplemented in <a class="el" href="classlal_1_1graphs_1_1directed__graph.html#a67a5bb67a3b5ed28c44473d1e0d2f051">lal::graphs::directed_graph</a>.</p>

</div>
</div>
<a id="af8ba9ec6acf2306c84d9ddbd88fc8474" name="af8ba9ec6acf2306c84d9ddbd88fc8474"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8ba9ec6acf2306c84d9ddbd88fc8474">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void lal::graphs::graph::clear </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Frees the memory occupied by this graph. </p>
<p>See <a class="el" href="#a9cb8aa8679935feee03aee1402dc978e">_clear</a> for details. </p><dl class="section post"><dt>Postcondition</dt><dd>The graph is normalised. The number of edges is 0. </dd></dl>

</div>
</div>
<a id="a8be70179238b5a9a42e0fc1365dd26e8" name="a8be70179238b5a9a42e0fc1365dd26e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8be70179238b5a9a42e0fc1365dd26e8">&#9670;&#160;</a></span>disjoint_union() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::free_tree::disjoint_union </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">free_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disjoint union of trees. </p>
<p>Given a free tree, append it to the current tree.</p>
<p>All the nodes in <em>t</em> are relabelled starting at <em>n</em>, the number of nodes of the current tree. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>The current tree is not an actual tree, i.e., method <a class="el" href="classlal_1_1graphs_1_1tree.html#a25c8d57865fa5f7cb5d101fd5d07fe2d">is_tree()</a> returns false since the resulting tree lacks an edge. </dd></dl>

</div>
</div>
<a id="a2e605f13fa6bb9158dead67b242bd30d" name="a2e605f13fa6bb9158dead67b242bd30d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e605f13fa6bb9158dead67b242bd30d">&#9670;&#160;</a></span>disjoint_union() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::undirected_graph::disjoint_union </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">undirected_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disjoint union of graphs. </p>
<p>Given a graph, append it to the current graph.</p>
<p>All the nodes in <em>g</em> are relabelled starting at <em>n</em>, the number of nodes of the current graph. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>The graph is normalised only if it was normalised before the call and <em>g</em> is also normalised. </dd></dl>

</div>
</div>
<a id="a48fd37ac155705661e59e72b61bf9c75" name="a48fd37ac155705661e59e72b61bf9c75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48fd37ac155705661e59e72b61bf9c75">&#9670;&#160;</a></span>fill_union_find()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::tree::fill_union_find </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fills the Union-Find data structure assuming that the graph structure has all of its edges. </p>

</div>
</div>
<a id="aad64cfa05c23d84dc799f47a3fdf6f9e" name="aad64cfa05c23d84dc799f47a3fdf6f9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad64cfa05c23d84dc799f47a3fdf6f9e">&#9670;&#160;</a></span>finish_bulk_add()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::free_tree::finish_bulk_add </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>norm</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>check</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finishes adding edges in bulk. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">norm</td><td>Normalise the tree. </td></tr>
    <tr><td class="paramname">check</td><td>Check whether the tree is normalised or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>All edges have been added. </dd></dl>

<p>Implements <a class="el" href="classlal_1_1graphs_1_1graph.html#a8557150991968f72048da41cef993413">lal::graphs::graph</a>.</p>

</div>
</div>
<a id="af00aa442a78dba81f82ab3cca990fba1" name="af00aa442a78dba81f82ab3cca990fba1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af00aa442a78dba81f82ab3cca990fba1">&#9670;&#160;</a></span>get_degree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t lal::graphs::undirected_graph::get_degree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacelal.html#abd94045faecfc68a03268dde9c9a13eb">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of neighbours of <em>u</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>Node to be queried. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of adjacent nodes. </dd></dl>

</div>
</div>
<a id="a7001f7fb135377a7de010a72cd20da54" name="a7001f7fb135377a7de010a72cd20da54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7001f7fb135377a7de010a72cd20da54">&#9670;&#160;</a></span>get_head_vector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacelal.html#ac185793c961485ef0f9e4dbdd571d595">head_vector</a> lal::graphs::free_tree::get_head_vector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacelal.html#abd94045faecfc68a03268dde9c9a13eb">node</a></td>          <td class="paramname"><span class="paramname"><em>r</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a free tree into a head vector. </p>
<p>A head vector of an <em>n-vertex</em> tree is a list of non-negative integer numbers. The number at position <em>i</em> denotes the parent node of the vertex at said position. Value '0' denotes the root. In this case, the vertex corresponding to the value '0' is not labelled as a root.</p>
<p>Each tree is formatted as a list of whole, positive numbers (including zero), each representing a node of the tree. The number 0 denotes the root of the tree, and a number at a certain position indicates its parent node. For example, when number 4 is at position 9 it means that node 9 has parent node 4. Therefore, if number 0 is at position 1 it means that node 1 is the root of the tree. A complete example of such a tree's representation is the following </p><pre class="fragment">  0 3 4 1 6 3
</pre><p>which should be interpreted as </p><pre class="fragment">(a) predecessor:       0 3 4 1 6 3
(b) node of the tree:  1 2 3 4 5 6
</pre><p>Note that lines like these are not valid: </p><pre class="fragment">(1) 0 2 2 2 2 2
(2) 2 0 0
</pre><p>Line (1) is not valid due to a self-reference in the second position, and (2) is not valid since it contains two '0' (i.e., two roots).</p>
<p>Methods <a class="el" href="namespacelal_1_1io.html#a98d52e64ccfa65237be07129a4968338">lal::io::read_head_vector</a> read a head vector from a file in disk. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>A fictional root to be used to calculate the head vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The head vector representation of this tree. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>This tree is a valid free tree (see <a class="el" href="classlal_1_1graphs_1_1tree.html#a25c8d57865fa5f7cb5d101fd5d07fe2d">is_tree</a>). </dd></dl>

</div>
</div>
<a id="af183c6590c16eb280043248f3600800b" name="af183c6590c16eb280043248f3600800b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af183c6590c16eb280043248f3600800b">&#9670;&#160;</a></span>get_neighbours()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacelal.html#aef91d923414879a998619e9c65181d1f">neighbourhood</a> &amp; lal::graphs::undirected_graph::get_neighbours </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacelal.html#abd94045faecfc68a03268dde9c9a13eb">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the neighbourhood of node <em>u</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>Node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The list of nodes adjacent to node <em>u</em>. </dd></dl>

</div>
</div>
<a id="a8045a162ec2a1647c695a5795243c187" name="a8045a162ec2a1647c695a5795243c187"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8045a162ec2a1647c695a5795243c187">&#9670;&#160;</a></span>get_num_nodes_component()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t lal::graphs::tree::get_num_nodes_component </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacelal.html#abd94045faecfc68a03268dde9c9a13eb">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Amount of nodes in a connected component of the tree. </p>
<p>When tree has had an edge removed, or when it is not completely built, i.e., it lack some edges, the resulting graph is clearly a forest. This function returns the size of the forest node <em>u</em> belongs to.</p>
<p>In directed trees one has to see this amount as the number of nodes of the component in the undirected version of the forest. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>Input node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size of the connected component of <em>u</em>. </dd></dl>

</div>
</div>
<a id="a742dbaac9c82914744e76de4bdcec277" name="a742dbaac9c82914744e76de4bdcec277"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a742dbaac9c82914744e76de4bdcec277">&#9670;&#160;</a></span>get_Q()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespacelal.html#a235d5351556fbc73aa51767ab7765f5c">edge_pair</a> &gt; lal::graphs::undirected_graph::get_Q </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns all independent pairs of edges of this graph. </p>
<p>The set \(Q(G)\) is defined as the pairs of edges of \(G\), \(E(G) \times E(G)\), that are independent, that is, that share no nodes. </p>

<p>Implements <a class="el" href="classlal_1_1graphs_1_1graph.html#a91155aa7578956540e8811aa896d06c5">lal::graphs::graph</a>.</p>

</div>
</div>
<a id="ae51ce9ddffc9287f375545e2b2fec3e3" name="ae51ce9ddffc9287f375545e2b2fec3e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae51ce9ddffc9287f375545e2b2fec3e3">&#9670;&#160;</a></span>get_tree_type_list()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; lal::graphs::tree::get_tree_type_list </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the list of types as a list of strings. </p>
<dl class="section return"><dt>Returns</dt><dd>The list of types as a list of strings. </dd></dl>

</div>
</div>
<a id="a94098eb987f7c24d4d248571fe32e893" name="a94098eb987f7c24d4d248571fe32e893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94098eb987f7c24d4d248571fe32e893">&#9670;&#160;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void lal::graphs::graph::init </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates the necessary memory for this class. </p>
<p>See <a class="el" href="#aa6560a483bf12381f5ddbdbac180a837">_init</a> for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of nodes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a20e3c4adafeb9a479e4fa6b5b5fa5a32" name="a20e3c4adafeb9a479e4fa6b5b5fa5a32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20e3c4adafeb9a479e4fa6b5b5fa5a32">&#9670;&#160;</a></span>is_normalised()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::graphs::graph::is_normalised </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether this graph is normalised or not. </p>
<p>A graph is normalised if every node's adjacency list is sorted increasingly. For this, use method <a class="el" href="classlal_1_1graphs_1_1graph.html#a32fef69d99615a885bb8a0f421108c76">normalise()</a>. </p><dl class="section return"><dt>Returns</dt><dd>The value of <a class="el" href="classlal_1_1graphs_1_1graph.html#afbd9fef263d20c982a21371e3d1e9307">m_normalised</a>. </dd></dl>

</div>
</div>
<a id="a06ce8cc7afb074d2fecf70a0842adaaa" name="a06ce8cc7afb074d2fecf70a0842adaaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06ce8cc7afb074d2fecf70a0842adaaa">&#9670;&#160;</a></span>is_of_tree_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::graphs::tree::is_of_tree_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal_1_1graphs.html#a18d52542088507e2be6241759722835b">tree_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>tt</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether this tree is of type <em>tt</em>. </p>
<p>See method <a class="el" href="#a2355fb9491fe13bf32b32dd44d472977">calculate_tree_type</a> to know how to calculate a tree's type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tt</td><td>Type of tree (see <a class="el" href="namespacelal_1_1graphs.html#a18d52542088507e2be6241759722835b">lal::graphs::tree_type</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this tree is of type <em>tt</em>. </dd></dl>

</div>
</div>
<a id="a25c8d57865fa5f7cb5d101fd5d07fe2d" name="a25c8d57865fa5f7cb5d101fd5d07fe2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25c8d57865fa5f7cb5d101fd5d07fe2d">&#9670;&#160;</a></span>is_tree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::graphs::tree::is_tree </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this graph is an actual tree? </p>
<p>Returns true if the number of edges is one less than the number of nodes. Note that this would not really be true if the addition of edges was not constrained. Since it is constrained in a way that no cycles can be produced (for example, see <a class="el" href="#a09753d6e59c2ec951c2820803cd1907e">free_tree::add_edge</a>, or <a class="el" href="#a3567112a1772f34ba748a23fabc37955">free_tree::add_edges</a>), then we only need to check for the number of edges.</p>
<p>For further characterisations of a tree see <a class="el" href="citelist.html#CITEREF_Harary1969a">[19]</a> (chapter 4, pages 32-33). </p><dl class="section return"><dt>Returns</dt><dd>True or false depending on whether this graph fits the defintion of tree. </dd></dl>

</div>
</div>
<a id="a9fc7f9e08db601f10982da6a01315cb3" name="a9fc7f9e08db601f10982da6a01315cb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fc7f9e08db601f10982da6a01315cb3">&#9670;&#160;</a></span>is_tree_type_valid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::graphs::tree::is_tree_type_valid </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the type of this tree valid? </p>
<p>This function enables users determine when this tree's type should be calculated.</p>
<p>In case this function returns false, users should call function <a class="el" href="#a2355fb9491fe13bf32b32dd44d472977">calculate_tree_type</a> in order to obtain a valid tree type. Note, however, that prior to calling the function the type of this tree might be <a class="el" href="namespacelal_1_1graphs.html#a18d52542088507e2be6241759722835baad921d60486366258809553a3db49a4a">lal::graphs::tree_type::unknown</a> and that the tree type may remain <a class="el" href="namespacelal_1_1graphs.html#a18d52542088507e2be6241759722835baad921d60486366258809553a3db49a4a">lal::graphs::tree_type::unknown</a> even after the type has been calculated. Nevertheless, users should be suspicious of a tree being of <a class="el" href="namespacelal_1_1graphs.html#a18d52542088507e2be6241759722835baad921d60486366258809553a3db49a4a">lal::graphs::tree_type::unknown</a> (in fact, of any) type if this method returns false, yet they should be sure of it if the type was calculated via method <a class="el" href="#a2355fb9491fe13bf32b32dd44d472977">calculate_tree_type</a>. </p><dl class="section return"><dt>Returns</dt><dd>True or false depending on whether the tree type was calculated or not. </dd></dl>

</div>
</div>
<a id="a32fef69d99615a885bb8a0f421108c76" name="a32fef69d99615a885bb8a0f421108c76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32fef69d99615a885bb8a0f421108c76">&#9670;&#160;</a></span>normalise()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void lal::graphs::graph::normalise </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Normalises the graph. </p>
<p>Sorts this graph's adjacency list structure in increasing order.</p>
<p>Besides expensive, this method may be unnecessary. Method <a class="el" href="classlal_1_1graphs_1_1graph.html#af992e20fc9b8c988c8189bbc6e2f68c0">check_normalised()</a> checks whether the graph is normalised or not; in case it is, using this method is completely unnecessary. </p><dl class="section post"><dt>Postcondition</dt><dd>Method <a class="el" href="classlal_1_1graphs_1_1graph.html#a20e3c4adafeb9a479e4fa6b5b5fa5a32">is_normalised</a> evaluates to true. </dd></dl>

<p>Reimplemented in <a class="el" href="classlal_1_1graphs_1_1directed__graph.html#ae1bf2e53e7081b79fa13ee24daef9993">lal::graphs::directed_graph</a>.</p>

</div>
</div>
<a id="ab695106a6d1f24fe72eaa6f83483e6ef" name="ab695106a6d1f24fe72eaa6f83483e6ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab695106a6d1f24fe72eaa6f83483e6ef">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1graphs_1_1free__tree.html">free_tree</a> &amp; lal::graphs::free_tree::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">free_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A <a class="el" href="classlal_1_1graphs_1_1free__tree.html" title="Free tree graph class.">lal::graphs::free_tree</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae0b5312915e7119e82bb3319da8b863b" name="ae0b5312915e7119e82bb3319da8b863b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0b5312915e7119e82bb3319da8b863b">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1graphs_1_1free__tree.html">free_tree</a> &amp; lal::graphs::free_tree::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlal_1_1graphs_1_1free__tree.html">free_tree</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A <a class="el" href="classlal_1_1graphs_1_1free__tree.html" title="Free tree graph class.">lal::graphs::free_tree</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac000d0b567b5d842fe8f66a67db73472" name="ac000d0b567b5d842fe8f66a67db73472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac000d0b567b5d842fe8f66a67db73472">&#9670;&#160;</a></span>remove_edge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">undirected_graph</a> &amp; lal::graphs::undirected_graph::remove_edge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacelal.html#abd94045faecfc68a03268dde9c9a13eb">node</a></td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelal.html#abd94045faecfc68a03268dde9c9a13eb">node</a></td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>norm</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>check_norm</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove an edge from this graph. </p>
<p><b>For developers:</b> method <a class="el" href="classlal_1_1graphs_1_1graph.html#a72db97a2f52da5d9b20d5c2c5c80a876">graph::extra_work_per_edge_remove</a> is called after the edge has been removed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Valid node index: \(0 \le s &lt; n\). </td></tr>
    <tr><td class="paramname">t</td><td>Valid node index: \(0 \le t &lt; n\). </td></tr>
    <tr><td class="paramname">norm</td><td>Normalise the graph after the deletion. </td></tr>
    <tr><td class="paramname">check_norm</td><td>If <em>norm</em> is false then, should we check whether the result is normalised or not? This might be useful in case the resulting graph is normalised. If <em>norm</em> is true then <em>check_norm</em> is ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The edge must exist. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>If <em>norm</em> is true the graph is guaranteed to be normalised after the addition of the edge. </dd></dl>

</div>
</div>
<a id="a34a2d08fad8a4ce2498e2101bafcc50b" name="a34a2d08fad8a4ce2498e2101bafcc50b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34a2d08fad8a4ce2498e2101bafcc50b">&#9670;&#160;</a></span>remove_edges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">undirected_graph</a> &amp; lal::graphs::undirected_graph::remove_edges </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacelal.html#a5969ec7ecc85697ebb9ec0ace78fbcab">edge</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>edges</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>norm</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>check_norm</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove an edge from this graph. </p>
<p>This operation is faster than removing edges one by one with <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html#ac000d0b567b5d842fe8f66a67db73472">remove_edge(node,node,bool,bool)</a> since the edges are removed in bulk.</p>
<p><b>For developers:</b> method <a class="el" href="classlal_1_1graphs_1_1graph.html#a72db97a2f52da5d9b20d5c2c5c80a876">graph::extra_work_per_edge_remove</a> is called after each edge has been removed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edges</td><td>The edges to be deleted. </td></tr>
    <tr><td class="paramname">norm</td><td>Normalise the graph after the deletion. </td></tr>
    <tr><td class="paramname">check_norm</td><td>If <em>norm</em> is false then, should we check whether the result is normalised or not? This might be useful in case the resulting graph is normalised. If <em>norm</em> is true then <em>check_norm</em> is ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>All the edges in <em>edges</em> must meet the precondition of method <a class="el" href="#a09753d6e59c2ec951c2820803cd1907e">add_edge(node,node,bool,bool)</a>. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>If <em>norm</em> is true the graph is guaranteed to be normalised after the addition of the edge. </dd></dl>

</div>
</div>
<a id="a5b6b4482407f28f0dd6bab48a0e75e8f" name="a5b6b4482407f28f0dd6bab48a0e75e8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b6b4482407f28f0dd6bab48a0e75e8f">&#9670;&#160;</a></span>remove_edges_incident_to()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classlal_1_1graphs_1_1free__tree.html">free_tree</a> &amp; lal::graphs::free_tree::remove_edges_incident_to </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacelal.html#abd94045faecfc68a03268dde9c9a13eb">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>norm</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>check_norm</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove all edges incident to a given vertex. </p>
<p>This operation is faster than removing edges one by one with <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html#ac000d0b567b5d842fe8f66a67db73472">remove_edge(node,node,bool,bool)</a> since the edges are removed in bulk.</p>
<p><b>For developers:</b> method <a class="el" href="classlal_1_1graphs_1_1graph.html#a72db97a2f52da5d9b20d5c2c5c80a876">lal::graphs::graph::extra_work_per_edge_remove</a> is called after each edge has been removed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>The node whose incident vertices are to be removed. </td></tr>
    <tr><td class="paramname">norm</td><td>Normalise the graph after the deletion. </td></tr>
    <tr><td class="paramname">check_norm</td><td>If <em>norm</em> is false then, should we check whether the result is normalised or not? This might be useful in case the resulting graph is normalised. If <em>norm</em> is true then <em>check_norm</em> is ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>If <em>norm</em> is true the graph is guaranteed to be normalised after the addition of the edge. </dd></dl>

<p>Reimplemented from <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html#a7e2894aca89d57e281c2f4b8dd17e6f7">lal::graphs::undirected_graph</a>.</p>

</div>
</div>
<a id="a9358e59dc7c717b29f746985e0428fae" name="a9358e59dc7c717b29f746985e0428fae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9358e59dc7c717b29f746985e0428fae">&#9670;&#160;</a></span>remove_single_edge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::undirected_graph::remove_single_edge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacelal.html#abd94045faecfc68a03268dde9c9a13eb">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelal.html#abd94045faecfc68a03268dde9c9a13eb">node</a></td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelal.html#aef91d923414879a998619e9c65181d1f">neighbourhood</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>out_u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelal.html#aef91d923414879a998619e9c65181d1f">neighbourhood</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>in_v</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a single edge. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>First node of edge. </td></tr>
    <tr><td class="paramname">v</td><td>Second node of edge. </td></tr>
    <tr><td class="paramname">out_u</td><td>Out-neighbourhood of node <em>u</em>. </td></tr>
    <tr><td class="paramname">in_v</td><td>In-neighbourhood of node <em>v</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5c46a4bb10d19dff5ae1a9f5121638d8" name="a5c46a4bb10d19dff5ae1a9f5121638d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c46a4bb10d19dff5ae1a9f5121638d8">&#9670;&#160;</a></span>set_edges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1graphs_1_1free__tree.html">free_tree</a> &amp; lal::graphs::free_tree::set_edges </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacelal.html#a5969ec7ecc85697ebb9ec0ace78fbcab">edge</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>edges</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>norm</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>check_norm</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the edges to the graph. </p>
<p>Sets the edges of this graph assuming that the nodes indexed in the list are, at most, the number of nodes of this graph.</p>
<p>This list of edges is assumed to be all the edges that are going to be added to this graph. This means that the internal data structures are constructed more efficiently than when adding edges one by one (see <a class="el" href="#a09753d6e59c2ec951c2820803cd1907e">add_edge</a>) or in several chunks (see <a class="el" href="#a3567112a1772f34ba748a23fabc37955">add_edges</a>). For a more controlled addition of the edges, see <a class="el" href="classlal_1_1graphs_1_1tree.html#ace1349eb9e5c32c61f98022a73f8e870">can_add_edges</a>.</p>
<p>Moreover, the current structure of the graph is cleared before setting the new edges. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edges</td><td>The edges to be added. </td></tr>
    <tr><td class="paramname">norm</td><td>Normalise the graph after the insertions. </td></tr>
    <tr><td class="paramname">check_norm</td><td>If <em>norm</em> is false then, should we check whether the result is normalised or not? This might be useful in case the resulting graph is normalised. If <em>norm</em> is true then <em>check_norm</em> is ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The graph has been initialized with as many nodes as vertices in the list of edges. </dd>
<dd>
There are no repeated edges in the list. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>If <em>norm</em> is true the graph is guaranteed to be normalised after the addition of the edge. </dd></dl>

<p>Reimplemented from <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html#a3c22e698293ce9e770529d66ba717394">lal::graphs::undirected_graph</a>.</p>

</div>
</div>
<a id="adeb1360f7847f2c29f70c68b54a73b18" name="adeb1360f7847f2c29f70c68b54a73b18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adeb1360f7847f2c29f70c68b54a73b18">&#9670;&#160;</a></span>tree_only_extra_work_edges_set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::tree::tree_only_extra_work_edges_set </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Updates the data structures of a tree after the graph structure has had its set of edges set. </p>

</div>
</div>
<a id="aa5336916f0e68fdd2e023db806275ad7" name="aa5336916f0e68fdd2e023db806275ad7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5336916f0e68fdd2e023db806275ad7">&#9670;&#160;</a></span>tree_only_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::tree::tree_only_init </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialises only the memory of class <a class="el" href="classlal_1_1graphs_1_1tree.html">tree</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of vertices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a951a57e760385ce3de285089627b7bbb" name="a951a57e760385ce3de285089627b7bbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a951a57e760385ce3de285089627b7bbb">&#9670;&#160;</a></span>m_is_tree_type_valid</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::graphs::tree::m_is_tree_type_valid = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the type of this tree valid? </p>
<p>This attribute keeps track of whether or not the function <a class="el" href="#a2355fb9491fe13bf32b32dd44d472977">calculate_tree_type</a> should be called before querying the type of this tree via function <a class="el" href="classlal_1_1graphs_1_1tree.html#a06ce8cc7afb074d2fecf70a0842adaaa">is_of_tree_type</a>. </p>

</div>
</div>
<a id="afbd9fef263d20c982a21371e3d1e9307" name="afbd9fef263d20c982a21371e3d1e9307"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbd9fef263d20c982a21371e3d1e9307">&#9670;&#160;</a></span>m_normalised</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::graphs::graph::m_normalised = true</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this graph normalised? </p>
<p>An undirected graph is normalised iff every node's adjacency list is sorted in increasing order.</p>
<p>In directed graphs, however, it is necessary that the adjacency lists of the out-neighbours and in-neighbours of nodes be sorted.</p>
<p>This attribute is set to 'true' in all graph's initialisation and destruction (when <a class="el" href="classlal_1_1graphs_1_1graph.html#af8ba9ec6acf2306c84d9ddbd88fc8474">clear()</a> method is called). </p>

</div>
</div>
<a id="ad6dab82fca5d3606b81228ca8c69654d" name="ad6dab82fca5d3606b81228ca8c69654d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6dab82fca5d3606b81228ca8c69654d">&#9670;&#160;</a></span>m_root_size</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;uint32_t&gt; lal::graphs::tree::m_root_size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The size of the connected component that a <em>root</em> belongs to. </p>
<p>Formally, <em>m_size_of</em>[v] is the size of the connected component of a <em>root</em> vertex <em>v</em>. A vertex <em>u</em> is a root vertex if there exists a vertex <em>w</em> such that <a class="el" href="classlal_1_1graphs_1_1tree.html#a544bb4ac5c61bac5c401b06b46eb629b">m_root_of</a>[w] = u.</p>
<p>In this context, root is within the union-find data structure. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>lal/graphs/<a class="el" href="free__tree_8hpp_source.html">free_tree.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
