<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LAL: Linear Arrangement Library: lal::properties Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">LAL: Linear Arrangement Library<span id="projectnumber">&#160;21.07.01</span>
   </div>
   <div id="projectbrief">A library focused on algorithms on linear arrangements of graphs.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacelal.html">lal</a></li><li class="navelem"><a class="el" href="namespacelal_1_1properties.html">properties</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">lal::properties Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Namespace for all linear-arrangement-independent algorithms.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a18d37074e9152261d8b51822becda3d8" id="r_a18d37074e9152261d8b51822becda3d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a18d37074e9152261d8b51822becda3d8">exp_num_crossings_rational</a> (const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;g) noexcept</td></tr>
<tr class="memdesc:a18d37074e9152261d8b51822becda3d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the the expected number of crossings in unconstrained arrangements, \(\mathbb{E}[C]\).  <br /></td></tr>
<tr class="separator:a18d37074e9152261d8b51822becda3d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8ff16428584d88aba05a4b677444a4b" id="r_ab8ff16428584d88aba05a4b677444a4b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab8ff16428584d88aba05a4b677444a4b">exp_num_crossings</a> (const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;g) noexcept</td></tr>
<tr class="memdesc:ab8ff16428584d88aba05a4b677444a4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the the expected number of crossings in unconstrained arrangements, \(\mathbb{E}[C]\).  <br /></td></tr>
<tr class="separator:ab8ff16428584d88aba05a4b677444a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a726f70a34d6950773beea9cdadf7e5c5" id="r_a726f70a34d6950773beea9cdadf7e5c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a726f70a34d6950773beea9cdadf7e5c5">var_num_crossings_rational</a> (const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;g, bool reuse=true) noexcept</td></tr>
<tr class="memdesc:a726f70a34d6950773beea9cdadf7e5c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the variance of the number of crossings of a graph in unconstrained arrangements, \(\mathbb{V}[C]\).  <br /></td></tr>
<tr class="separator:a726f70a34d6950773beea9cdadf7e5c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad59eec82bbd716aefedc4453d82becd4" id="r_ad59eec82bbd716aefedc4453d82becd4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad59eec82bbd716aefedc4453d82becd4">var_num_crossings</a> (const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;g, bool reuse=true) noexcept</td></tr>
<tr class="memdesc:ad59eec82bbd716aefedc4453d82becd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the variance of the number of crossings of a graph in unconstrained arrangements, \(\mathbb{V}[C]\).  <br /></td></tr>
<tr class="separator:ad59eec82bbd716aefedc4453d82becd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fc49dada4d129f0a9026605e74cfe0a" id="r_a4fc49dada4d129f0a9026605e74cfe0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4fc49dada4d129f0a9026605e74cfe0a">var_num_crossings_forest_rational</a> (const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;g) noexcept</td></tr>
<tr class="memdesc:a4fc49dada4d129f0a9026605e74cfe0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the variance of the number of crossings of a forest in unconstrained arrangements, \(\mathbb{V}[C]\).  <br /></td></tr>
<tr class="separator:a4fc49dada4d129f0a9026605e74cfe0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af404ccea372ee1d555cab3b9c6e67a1d" id="r_af404ccea372ee1d555cab3b9c6e67a1d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af404ccea372ee1d555cab3b9c6e67a1d">var_num_crossings_forest</a> (const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;g) noexcept</td></tr>
<tr class="memdesc:af404ccea372ee1d555cab3b9c6e67a1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the variance of the number of crossings of a forest in unconstrained arrangements, \(\mathbb{V}[C]\).  <br /></td></tr>
<tr class="separator:af404ccea372ee1d555cab3b9c6e67a1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83745d14589b98b918481d83f564f7c0" id="r_a83745d14589b98b918481d83f564f7c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a83745d14589b98b918481d83f564f7c0">var_num_crossings_tree_rational</a> (const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:a83745d14589b98b918481d83f564f7c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the variance of the number of crossings of a tree in unconstrained arrangements, \(\mathbb{V}[C]\).  <br /></td></tr>
<tr class="separator:a83745d14589b98b918481d83f564f7c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c904df78290dd71ec9445ad3908bc5" id="r_a02c904df78290dd71ec9445ad3908bc5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a02c904df78290dd71ec9445ad3908bc5">var_num_crossings_tree</a> (const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:a02c904df78290dd71ec9445ad3908bc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the variance of the number of crossings of a tree in unconstrained arrangements, \(\mathbb{V}[C]\).  <br /></td></tr>
<tr class="separator:a02c904df78290dd71ec9445ad3908bc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad04afab9d98252090df36b307c014de4" id="r_ad04afab9d98252090df36b307c014de4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad04afab9d98252090df36b307c014de4">var_num_crossings_tree_rational</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:ad04afab9d98252090df36b307c014de4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the variance of the number of crossings of a tree in unconstrained arrangements, \(\mathbb{V}[C]\).  <br /></td></tr>
<tr class="separator:ad04afab9d98252090df36b307c014de4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a504fb6143e41360712cdd5b96b93cb6e" id="r_a504fb6143e41360712cdd5b96b93cb6e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a504fb6143e41360712cdd5b96b93cb6e">var_num_crossings_tree</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:a504fb6143e41360712cdd5b96b93cb6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the variance of the number of crossings of a tree in unconstrained arrangements, \(\mathbb{V}[C]\).  <br /></td></tr>
<tr class="separator:a504fb6143e41360712cdd5b96b93cb6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a654ff6deae467b9103c8d6b9235b088a" id="r_a654ff6deae467b9103c8d6b9235b088a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a654ff6deae467b9103c8d6b9235b088a">exp_sum_edge_lengths_rational</a> (const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;g) noexcept</td></tr>
<tr class="memdesc:a654ff6deae467b9103c8d6b9235b088a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expected sum of edge lengths of an undirected graph in unconstrained arrangments, \(\mathbb{E}[D]\).  <br /></td></tr>
<tr class="separator:a654ff6deae467b9103c8d6b9235b088a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80c20fa410c8b9b216afe7f5241209a6" id="r_a80c20fa410c8b9b216afe7f5241209a6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a80c20fa410c8b9b216afe7f5241209a6">exp_sum_edge_lengths</a> (const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;g) noexcept</td></tr>
<tr class="memdesc:a80c20fa410c8b9b216afe7f5241209a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expected sum of edge lengths of an undirected graph in unconstrained arrangments, \(\mathbb{E}[D]\).  <br /></td></tr>
<tr class="separator:a80c20fa410c8b9b216afe7f5241209a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f34ca26ddc18aa06be109d7a25b0821" id="r_a7f34ca26ddc18aa06be109d7a25b0821"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f34ca26ddc18aa06be109d7a25b0821">exp_sum_edge_lengths_rational</a> (const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:a7f34ca26ddc18aa06be109d7a25b0821"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expected sum of edge lengths of a free tree in unconstrained arrangments, \(\mathbb{E}[D]\).  <br /></td></tr>
<tr class="separator:a7f34ca26ddc18aa06be109d7a25b0821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbd8a4120ef6f3ef2d7813442f41a223" id="r_afbd8a4120ef6f3ef2d7813442f41a223"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afbd8a4120ef6f3ef2d7813442f41a223">exp_sum_edge_lengths</a> (const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:afbd8a4120ef6f3ef2d7813442f41a223"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expected sum of edge lengths of a free tree in unconstrained arrangments, \(\mathbb{E}[D]\).  <br /></td></tr>
<tr class="separator:afbd8a4120ef6f3ef2d7813442f41a223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42339b47863289d19a1b103dfda103f1" id="r_a42339b47863289d19a1b103dfda103f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42339b47863289d19a1b103dfda103f1">exp_sum_edge_lengths_rational</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:a42339b47863289d19a1b103dfda103f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expected sum of edge lengths of a rooted tree in unconstrained arrangments, \(\mathbb{E}[D]\).  <br /></td></tr>
<tr class="separator:a42339b47863289d19a1b103dfda103f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e68f49e9379b09814741599d58b91c1" id="r_a9e68f49e9379b09814741599d58b91c1"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9e68f49e9379b09814741599d58b91c1">exp_sum_edge_lengths</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:a9e68f49e9379b09814741599d58b91c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expected sum of edge lengths of a rooted tree in unconstrained arrangments, \(\mathbb{E}[D]\).  <br /></td></tr>
<tr class="separator:a9e68f49e9379b09814741599d58b91c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3c1189ccc59dea31e83c862b0615d08" id="r_ab3c1189ccc59dea31e83c862b0615d08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3c1189ccc59dea31e83c862b0615d08">exp_sum_edge_lengths_projective_rational</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;rt) noexcept</td></tr>
<tr class="memdesc:ab3c1189ccc59dea31e83c862b0615d08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expected sum of edge lengths of a tree constrained to projective arrangments, \(\mathbb{E}_{\mathrm{pr}}[D]\).  <br /></td></tr>
<tr class="separator:ab3c1189ccc59dea31e83c862b0615d08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af19d68977283afd82cae661106bbb0f8" id="r_af19d68977283afd82cae661106bbb0f8"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af19d68977283afd82cae661106bbb0f8">exp_sum_edge_lengths_projective</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;rt) noexcept</td></tr>
<tr class="memdesc:af19d68977283afd82cae661106bbb0f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expected sum of edge lengths of a tree constrained to projective arrangments, \(\mathbb{E}_{\mathrm{pr}}[D]\).  <br /></td></tr>
<tr class="separator:af19d68977283afd82cae661106bbb0f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff56efacd50b8e4db045db0e3c48cf03" id="r_aff56efacd50b8e4db045db0e3c48cf03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff56efacd50b8e4db045db0e3c48cf03">exp_sum_edge_lengths_planar_rational</a> (const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:aff56efacd50b8e4db045db0e3c48cf03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expected sum of edge lengths of a tree constrained to planar arrangments, \(\mathbb{E}_{\mathrm{pl}}[D]\).  <br /></td></tr>
<tr class="separator:aff56efacd50b8e4db045db0e3c48cf03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b01b0e3579b43e886f1b0d675bc0227" id="r_a4b01b0e3579b43e886f1b0d675bc0227"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b01b0e3579b43e886f1b0d675bc0227">exp_sum_edge_lengths_planar_rational</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;rt) noexcept</td></tr>
<tr class="memdesc:a4b01b0e3579b43e886f1b0d675bc0227"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expected sum of edge lengths of a tree constrained to planar arrangments, \(\mathbb{E}_{\mathrm{pl}}[D]\).  <br /></td></tr>
<tr class="separator:a4b01b0e3579b43e886f1b0d675bc0227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac053f8c3c640e10636970e6800b6e661" id="r_ac053f8c3c640e10636970e6800b6e661"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac053f8c3c640e10636970e6800b6e661">exp_sum_edge_lengths_planar</a> (const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:ac053f8c3c640e10636970e6800b6e661"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expected sum of edge lengths of a tree constrained to planar arrangments, \(\mathbb{E}_{\mathrm{pl}}[D]\).  <br /></td></tr>
<tr class="separator:ac053f8c3c640e10636970e6800b6e661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a83b194e6a3d0e977b45778ddf0030e" id="r_a8a83b194e6a3d0e977b45778ddf0030e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8a83b194e6a3d0e977b45778ddf0030e">exp_sum_edge_lengths_planar</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;rt) noexcept</td></tr>
<tr class="memdesc:a8a83b194e6a3d0e977b45778ddf0030e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expected sum of edge lengths of a tree constrained to planar arrangments, \(\mathbb{E}_{\mathrm{pl}}[D]\).  <br /></td></tr>
<tr class="separator:a8a83b194e6a3d0e977b45778ddf0030e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3826e458a5c14aa82c2d5f0679530e7e" id="r_a3826e458a5c14aa82c2d5f0679530e7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3826e458a5c14aa82c2d5f0679530e7e">var_sum_edge_lengths_rational</a> (const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;g) noexcept</td></tr>
<tr class="memdesc:a3826e458a5c14aa82c2d5f0679530e7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the variance of the sum of the length of edges of a graph, \(\mathbb{V}[D]\).  <br /></td></tr>
<tr class="separator:a3826e458a5c14aa82c2d5f0679530e7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade6a3f20263e2a982cfc5dc59facaf40" id="r_ade6a3f20263e2a982cfc5dc59facaf40"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade6a3f20263e2a982cfc5dc59facaf40">var_sum_edge_lengths</a> (const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;g) noexcept</td></tr>
<tr class="memdesc:ade6a3f20263e2a982cfc5dc59facaf40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the variance of the sum of the length of edges of a graph, \(\mathbb{V}[D]\).  <br /></td></tr>
<tr class="separator:ade6a3f20263e2a982cfc5dc59facaf40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8189ffb3e3386ee95dcf7530011dda01" id="r_a8189ffb3e3386ee95dcf7530011dda01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8189ffb3e3386ee95dcf7530011dda01">moment_degree_rational</a> (const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;g, uint32_t p) noexcept</td></tr>
<tr class="memdesc:a8189ffb3e3386ee95dcf7530011dda01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the \(p\)-th moment of degree about zero of a graph as an exact rational value.  <br /></td></tr>
<tr class="separator:a8189ffb3e3386ee95dcf7530011dda01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb06b2d8f62bf9603ef2f5adee87d56b" id="r_afb06b2d8f62bf9603ef2f5adee87d56b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afb06b2d8f62bf9603ef2f5adee87d56b">moment_degree</a> (const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;g, uint32_t p) noexcept</td></tr>
<tr class="memdesc:afb06b2d8f62bf9603ef2f5adee87d56b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the \(p\)-th moment of degree about zero of a directed graph as a floating point value.  <br /></td></tr>
<tr class="separator:afb06b2d8f62bf9603ef2f5adee87d56b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f4554ea43c1374e040d60cd9a53ac84" id="r_a4f4554ea43c1374e040d60cd9a53ac84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4f4554ea43c1374e040d60cd9a53ac84">moment_degree_rational</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;g, uint32_t p) noexcept</td></tr>
<tr class="memdesc:a4f4554ea43c1374e040d60cd9a53ac84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the \(p\)-th moment of degree about zero of a directed graph as an exact rational value.  <br /></td></tr>
<tr class="separator:a4f4554ea43c1374e040d60cd9a53ac84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa92325006267f83f5f683e9f674942db" id="r_aa92325006267f83f5f683e9f674942db"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa92325006267f83f5f683e9f674942db">moment_degree</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;g, uint32_t p) noexcept</td></tr>
<tr class="memdesc:aa92325006267f83f5f683e9f674942db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the \(p\)-th moment of degree about zero of a directed graph as a floating point value.  <br /></td></tr>
<tr class="separator:aa92325006267f83f5f683e9f674942db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dd093274eff2c3755cd54ae5907a04f" id="r_a9dd093274eff2c3755cd54ae5907a04f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9dd093274eff2c3755cd54ae5907a04f">moment_degree_in_rational</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;g, uint32_t p) noexcept</td></tr>
<tr class="memdesc:a9dd093274eff2c3755cd54ae5907a04f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the \(p\)-th moment of in-degree about zero of a directed graph as an exact rational value.  <br /></td></tr>
<tr class="separator:a9dd093274eff2c3755cd54ae5907a04f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d46daa5e371aa95448f8f31a642bede" id="r_a5d46daa5e371aa95448f8f31a642bede"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5d46daa5e371aa95448f8f31a642bede">moment_degree_in</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;g, uint32_t p) noexcept</td></tr>
<tr class="memdesc:a5d46daa5e371aa95448f8f31a642bede"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the \(p\)-th moment of in-degree about zero of a directed graph as a floating point value.  <br /></td></tr>
<tr class="separator:a5d46daa5e371aa95448f8f31a642bede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5efdbc1f5586bca3cdb9b6279051c12b" id="r_a5efdbc1f5586bca3cdb9b6279051c12b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5efdbc1f5586bca3cdb9b6279051c12b">moment_degree_out_rational</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;g, uint32_t p) noexcept</td></tr>
<tr class="memdesc:a5efdbc1f5586bca3cdb9b6279051c12b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the \(p\)-th moment of out-degree about zero of a directed graph as an exact rational value.  <br /></td></tr>
<tr class="separator:a5efdbc1f5586bca3cdb9b6279051c12b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14c1ae06978c36d1da71b62bae32304f" id="r_a14c1ae06978c36d1da71b62bae32304f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a14c1ae06978c36d1da71b62bae32304f">moment_degree_out</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;g, uint32_t p) noexcept</td></tr>
<tr class="memdesc:a14c1ae06978c36d1da71b62bae32304f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the \(p\)-th moment of out-degree about zero of a directed graph as a floating point value.  <br /></td></tr>
<tr class="separator:a14c1ae06978c36d1da71b62bae32304f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23f61ed2204c24dce8049666357b65d5" id="r_a23f61ed2204c24dce8049666357b65d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a23f61ed2204c24dce8049666357b65d5">hubiness_rational</a> (const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:a23f61ed2204c24dce8049666357b65d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hubiness coefficient as an exact rational number.  <br /></td></tr>
<tr class="separator:a23f61ed2204c24dce8049666357b65d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1750ada3673e7deba32658dc3da2cf0c" id="r_a1750ada3673e7deba32658dc3da2cf0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1750ada3673e7deba32658dc3da2cf0c">hubiness_rational</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:a1750ada3673e7deba32658dc3da2cf0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hubiness coefficient as an exact rational number.  <br /></td></tr>
<tr class="separator:a1750ada3673e7deba32658dc3da2cf0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab052d596b426bfa68ca44f046e44e76d" id="r_ab052d596b426bfa68ca44f046e44e76d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab052d596b426bfa68ca44f046e44e76d">hubiness</a> (const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:ab052d596b426bfa68ca44f046e44e76d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hubiness coefficient as a floating point value.  <br /></td></tr>
<tr class="separator:ab052d596b426bfa68ca44f046e44e76d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af13cc3093569223cde0ae3f329f86ded" id="r_af13cc3093569223cde0ae3f329f86ded"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af13cc3093569223cde0ae3f329f86ded">hubiness</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:af13cc3093569223cde0ae3f329f86ded"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hubiness coefficient as a floating point value.  <br /></td></tr>
<tr class="separator:af13cc3093569223cde0ae3f329f86ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eca870365ac786867aeacf3609457a9" id="r_a5eca870365ac786867aeacf3609457a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5eca870365ac786867aeacf3609457a9">mean_hierarchical_distance_rational</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:a5eca870365ac786867aeacf3609457a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mean Hierarchical Distance.  <br /></td></tr>
<tr class="separator:a5eca870365ac786867aeacf3609457a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c70ec4072e1df27592aa7a51876c1a9" id="r_a0c70ec4072e1df27592aa7a51876c1a9"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c70ec4072e1df27592aa7a51876c1a9">mean_hierarchical_distance</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:a0c70ec4072e1df27592aa7a51876c1a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mean Hierarchical Distance.  <br /></td></tr>
<tr class="separator:a0c70ec4072e1df27592aa7a51876c1a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fa7c3d6aee99da7e532a943bdbc2a9e" id="r_a6fa7c3d6aee99da7e532a943bdbc2a9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1numeric_1_1integer.html">numeric::integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6fa7c3d6aee99da7e532a943bdbc2a9e">num_pairs_independent_edges_integer</a> (const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;g) noexcept</td></tr>
<tr class="memdesc:a6fa7c3d6aee99da7e532a943bdbc2a9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the size of \(Q(G)\).  <br /></td></tr>
<tr class="separator:a6fa7c3d6aee99da7e532a943bdbc2a9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a492c71d8503b4681ca40d3b526b0f0" id="r_a0a492c71d8503b4681ca40d3b526b0f0"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0a492c71d8503b4681ca40d3b526b0f0">num_pairs_independent_edges</a> (const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;g) noexcept</td></tr>
<tr class="memdesc:a0a492c71d8503b4681ca40d3b526b0f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the size of \(Q(G)\).  <br /></td></tr>
<tr class="separator:a0a492c71d8503b4681ca40d3b526b0f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa086ffd70ff3d2f2ab2e89108b8544a3" id="r_aa086ffd70ff3d2f2ab2e89108b8544a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1numeric_1_1integer.html">numeric::integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa086ffd70ff3d2f2ab2e89108b8544a3">num_pairs_independent_edges_integer</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;g) noexcept</td></tr>
<tr class="memdesc:aa086ffd70ff3d2f2ab2e89108b8544a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the size of \(Q(G)\).  <br /></td></tr>
<tr class="separator:aa086ffd70ff3d2f2ab2e89108b8544a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d1a9bd03760411d1436925d7c095216" id="r_a0d1a9bd03760411d1436925d7c095216"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0d1a9bd03760411d1436925d7c095216">num_pairs_independent_edges</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;g) noexcept</td></tr>
<tr class="memdesc:a0d1a9bd03760411d1436925d7c095216"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the size of \(Q(G)\).  <br /></td></tr>
<tr class="separator:a0d1a9bd03760411d1436925d7c095216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada5517f223bcb1369b625a840dc9c8fa" id="r_ada5517f223bcb1369b625a840dc9c8fa"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="namespacelal.html#abd94045faecfc68a03268dde9c9a13eb">node</a>, <a class="el" href="namespacelal.html#abd94045faecfc68a03268dde9c9a13eb">node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada5517f223bcb1369b625a840dc9c8fa">tree_centre</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:ada5517f223bcb1369b625a840dc9c8fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the centre of a rooted tree.  <br /></td></tr>
<tr class="separator:ada5517f223bcb1369b625a840dc9c8fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab05c2a8ee4c9e544358b1db18a7b1c13" id="r_ab05c2a8ee4c9e544358b1db18a7b1c13"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="namespacelal.html#abd94045faecfc68a03268dde9c9a13eb">node</a>, <a class="el" href="namespacelal.html#abd94045faecfc68a03268dde9c9a13eb">node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab05c2a8ee4c9e544358b1db18a7b1c13">tree_centre</a> (const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:ab05c2a8ee4c9e544358b1db18a7b1c13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the centre of a free tree.  <br /></td></tr>
<tr class="separator:ab05c2a8ee4c9e544358b1db18a7b1c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adda281d4c9e024ea87844756ffbd945e" id="r_adda281d4c9e024ea87844756ffbd945e"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="namespacelal.html#abd94045faecfc68a03268dde9c9a13eb">node</a>, <a class="el" href="namespacelal.html#abd94045faecfc68a03268dde9c9a13eb">node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adda281d4c9e024ea87844756ffbd945e">tree_centroid</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:adda281d4c9e024ea87844756ffbd945e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the centroid of a rooted tree.  <br /></td></tr>
<tr class="separator:adda281d4c9e024ea87844756ffbd945e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a809427c54bf089fa2596e47b23538a5a" id="r_a809427c54bf089fa2596e47b23538a5a"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="namespacelal.html#abd94045faecfc68a03268dde9c9a13eb">node</a>, <a class="el" href="namespacelal.html#abd94045faecfc68a03268dde9c9a13eb">node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a809427c54bf089fa2596e47b23538a5a">tree_centroid</a> (const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:a809427c54bf089fa2596e47b23538a5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the centroid of a free tree.  <br /></td></tr>
<tr class="separator:a809427c54bf089fa2596e47b23538a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff86e7421571febc7a70af4ba770c23f" id="r_aff86e7421571febc7a70af4ba770c23f"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff86e7421571febc7a70af4ba770c23f">tree_diameter</a> (const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:aff86e7421571febc7a70af4ba770c23f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the diameter of a free tree.  <br /></td></tr>
<tr class="separator:aff86e7421571febc7a70af4ba770c23f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab125c9530b3757c61fe74351c0778a6d" id="r_ab125c9530b3757c61fe74351c0778a6d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab125c9530b3757c61fe74351c0778a6d">tree_diameter</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:ab125c9530b3757c61fe74351c0778a6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the diameter of a free tree.  <br /></td></tr>
<tr class="separator:ab125c9530b3757c61fe74351c0778a6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Namespace for all linear-arrangement-independent algorithms. </p>
<p>This namespace contains functions to calculate properties of graphs that do not depend, whether implicitly or explicitly, on a linear arrangement. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="ab8ff16428584d88aba05a4b677444a4b" name="ab8ff16428584d88aba05a4b677444a4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8ff16428584d88aba05a4b677444a4b">&#9670;&#160;</a></span>exp_num_crossings()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double lal::properties::exp_num_crossings </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the the expected number of crossings in unconstrained arrangements, \(\mathbb{E}[C]\). </p>
<p>See <a class="el" href="#a18d37074e9152261d8b51822becda3d8">lal::properties::exp_num_crossings_rational</a> for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>The input graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The expected value of the number of crossings as a floating point value. </dd></dl>

</div>
</div>
<a id="a18d37074e9152261d8b51822becda3d8" name="a18d37074e9152261d8b51822becda3d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18d37074e9152261d8b51822becda3d8">&#9670;&#160;</a></span>exp_num_crossings_rational()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a> lal::properties::exp_num_crossings_rational </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the the expected number of crossings in unconstrained arrangements, \(\mathbb{E}[C]\). </p>
<p>Returns \(\mathbb{E}[C]\) as a rational value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>The input graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The expected value of the number of crossings as a rational value. </dd></dl>

</div>
</div>
<a id="afbd8a4120ef6f3ef2d7813442f41a223" name="afbd8a4120ef6f3ef2d7813442f41a223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbd8a4120ef6f3ef2d7813442f41a223">&#9670;&#160;</a></span>exp_sum_edge_lengths() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double lal::properties::exp_sum_edge_lengths </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Expected sum of edge lengths of a free tree in unconstrained arrangments, \(\mathbb{E}[D]\). </p>
<p>See <a class="el" href="#a654ff6deae467b9103c8d6b9235b088a">lal::properties::exp_sum_edge_lengths_rational</a> for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The input free tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The expected value of the sum of edge lengths as a floating point value. </dd></dl>

</div>
</div>
<a id="a9e68f49e9379b09814741599d58b91c1" name="a9e68f49e9379b09814741599d58b91c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e68f49e9379b09814741599d58b91c1">&#9670;&#160;</a></span>exp_sum_edge_lengths() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double lal::properties::exp_sum_edge_lengths </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Expected sum of edge lengths of a rooted tree in unconstrained arrangments, \(\mathbb{E}[D]\). </p>
<p>See <a class="el" href="#a654ff6deae467b9103c8d6b9235b088a">lal::properties::exp_sum_edge_lengths_rational</a> for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The input rooted tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The expected value of the sum of edge lengths as a floating point value. </dd></dl>

</div>
</div>
<a id="a80c20fa410c8b9b216afe7f5241209a6" name="a80c20fa410c8b9b216afe7f5241209a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80c20fa410c8b9b216afe7f5241209a6">&#9670;&#160;</a></span>exp_sum_edge_lengths() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double lal::properties::exp_sum_edge_lengths </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Expected sum of edge lengths of an undirected graph in unconstrained arrangments, \(\mathbb{E}[D]\). </p>
<p>See <a class="el" href="#a654ff6deae467b9103c8d6b9235b088a">lal::properties::exp_sum_edge_lengths_rational</a> for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>The input graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The expected value of the sum of edge lengths as a floating point value. </dd></dl>

</div>
</div>
<a id="ac053f8c3c640e10636970e6800b6e661" name="ac053f8c3c640e10636970e6800b6e661"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac053f8c3c640e10636970e6800b6e661">&#9670;&#160;</a></span>exp_sum_edge_lengths_planar() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double lal::properties::exp_sum_edge_lengths_planar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Expected sum of edge lengths of a tree constrained to planar arrangments, \(\mathbb{E}_{\mathrm{pl}}[D]\). </p>
<p>This function uses the formulae derived in <a class="el" href="citelist.html#CITEREF_Alemany2021c">[4]</a>.</p>
<p>Returns the value \(E_{\mathrm{pl}}[D]\) as a rational value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The input free tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The expected value of the sum of edge lengths constrained to planar arrangements as a floating point value. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><em>rt</em> must be a valid free tree (see <a class="el" href="classlal_1_1graphs_1_1tree.html#a25c8d57865fa5f7cb5d101fd5d07fe2d">lal::graphs::free_tree::is_tree</a>). </dd></dl>

</div>
</div>
<a id="a8a83b194e6a3d0e977b45778ddf0030e" name="a8a83b194e6a3d0e977b45778ddf0030e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a83b194e6a3d0e977b45778ddf0030e">&#9670;&#160;</a></span>exp_sum_edge_lengths_planar() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double lal::properties::exp_sum_edge_lengths_planar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rt</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Expected sum of edge lengths of a tree constrained to planar arrangments, \(\mathbb{E}_{\mathrm{pl}}[D]\). </p>
<p>This function uses the formulae derived in <a class="el" href="citelist.html#CITEREF_Alemany2021c">[4]</a>.</p>
<p>Returns the value \(E_{\mathrm{pl}}[D]\) as a rational value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rt</td><td>The input rooted tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The expected value of the sum of edge lengths constrained to planar arrangements as a floating point value. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><em>rt</em> must be a valid rooted tree (see <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#af464d98b1b5dfdbaaacea553d9c89154">lal::graphs::rooted_tree::is_rooted_tree</a>). </dd></dl>

</div>
</div>
<a id="aff56efacd50b8e4db045db0e3c48cf03" name="aff56efacd50b8e4db045db0e3c48cf03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff56efacd50b8e4db045db0e3c48cf03">&#9670;&#160;</a></span>exp_sum_edge_lengths_planar_rational() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a> lal::properties::exp_sum_edge_lengths_planar_rational </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Expected sum of edge lengths of a tree constrained to planar arrangments, \(\mathbb{E}_{\mathrm{pl}}[D]\). </p>
<p>This function uses the formulae derived in <a class="el" href="citelist.html#CITEREF_Alemany2021c">[4]</a>.</p>
<p>Returns the value \(E_{\mathrm{pl}}[D]\) as a rational value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The input free tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The expected value of the sum of edge lengths constrained to planar arrangements as an exact rational value. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><em>rt</em> must be a valid free tree (see <a class="el" href="classlal_1_1graphs_1_1tree.html#a25c8d57865fa5f7cb5d101fd5d07fe2d">lal::graphs::free_tree::is_tree</a>). </dd></dl>

</div>
</div>
<a id="a4b01b0e3579b43e886f1b0d675bc0227" name="a4b01b0e3579b43e886f1b0d675bc0227"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b01b0e3579b43e886f1b0d675bc0227">&#9670;&#160;</a></span>exp_sum_edge_lengths_planar_rational() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a> lal::properties::exp_sum_edge_lengths_planar_rational </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rt</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Expected sum of edge lengths of a tree constrained to planar arrangments, \(\mathbb{E}_{\mathrm{pl}}[D]\). </p>
<p>This function uses the formulae derived in <a class="el" href="citelist.html#CITEREF_Alemany2021c">[4]</a>.</p>
<p>Returns the value \(E_{\mathrm{pl}}[D]\) as a rational value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rt</td><td>The input rooted tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The expected value of the sum of edge lengths constrained to planar arrangements as an exact rational value. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><em>rt</em> must be a valid rooted tree (see <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#af464d98b1b5dfdbaaacea553d9c89154">lal::graphs::rooted_tree::is_rooted_tree</a>). </dd></dl>

</div>
</div>
<a id="af19d68977283afd82cae661106bbb0f8" name="af19d68977283afd82cae661106bbb0f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af19d68977283afd82cae661106bbb0f8">&#9670;&#160;</a></span>exp_sum_edge_lengths_projective()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double lal::properties::exp_sum_edge_lengths_projective </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rt</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Expected sum of edge lengths of a tree constrained to projective arrangments, \(\mathbb{E}_{\mathrm{pr}}[D]\). </p>
<p>See <a class="el" href="#ab3c1189ccc59dea31e83c862b0615d08">lal::properties::exp_sum_edge_lengths_projective_rational</a> for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rt</td><td>The input rooted tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The expected value of the sum of edge lengths constrained to projective arrangements as a floating point value. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><em>rt</em> must be a valid rooted tree (see <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#af464d98b1b5dfdbaaacea553d9c89154">lal::graphs::rooted_tree::is_rooted_tree</a>). </dd></dl>

</div>
</div>
<a id="ab3c1189ccc59dea31e83c862b0615d08" name="ab3c1189ccc59dea31e83c862b0615d08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3c1189ccc59dea31e83c862b0615d08">&#9670;&#160;</a></span>exp_sum_edge_lengths_projective_rational()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a> lal::properties::exp_sum_edge_lengths_projective_rational </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rt</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Expected sum of edge lengths of a tree constrained to projective arrangments, \(\mathbb{E}_{\mathrm{pr}}[D]\). </p>
<p>This function uses the formulae derived in <a class="el" href="citelist.html#CITEREF_Alemany2021b">[5]</a>.</p>
<p>Returns the value \(E_{\mathrm{pr}}[D]\) as a rational value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rt</td><td>The input rooted tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The expected value of the sum of edge lengths constrained to projective arrangements as an exact rational value. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><em>rt</em> must be a valid rooted tree (see <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#af464d98b1b5dfdbaaacea553d9c89154">lal::graphs::rooted_tree::is_rooted_tree</a>). </dd></dl>

</div>
</div>
<a id="a7f34ca26ddc18aa06be109d7a25b0821" name="a7f34ca26ddc18aa06be109d7a25b0821"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f34ca26ddc18aa06be109d7a25b0821">&#9670;&#160;</a></span>exp_sum_edge_lengths_rational() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a> lal::properties::exp_sum_edge_lengths_rational </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Expected sum of edge lengths of a free tree in unconstrained arrangments, \(\mathbb{E}[D]\). </p>
<p>This function uses the formulae derived in <a class="el" href="citelist.html#CITEREF_Ferrer2019a">[21]</a>.</p>
<p>Returns the value \(E[D]\) as a rational value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The input rooted tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The expected value of the sum of edge lengths as a rational value. </dd></dl>

</div>
</div>
<a id="a42339b47863289d19a1b103dfda103f1" name="a42339b47863289d19a1b103dfda103f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42339b47863289d19a1b103dfda103f1">&#9670;&#160;</a></span>exp_sum_edge_lengths_rational() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a> lal::properties::exp_sum_edge_lengths_rational </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Expected sum of edge lengths of a rooted tree in unconstrained arrangments, \(\mathbb{E}[D]\). </p>
<p>This function uses the formulae derived in <a class="el" href="citelist.html#CITEREF_Ferrer2019a">[21]</a>.</p>
<p>Returns the value \(E[D]\) as a rational value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The input rooted tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The expected value of the sum of edge lengths as a rational value. </dd></dl>

</div>
</div>
<a id="a654ff6deae467b9103c8d6b9235b088a" name="a654ff6deae467b9103c8d6b9235b088a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a654ff6deae467b9103c8d6b9235b088a">&#9670;&#160;</a></span>exp_sum_edge_lengths_rational() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a> lal::properties::exp_sum_edge_lengths_rational </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Expected sum of edge lengths of an undirected graph in unconstrained arrangments, \(\mathbb{E}[D]\). </p>
<p>This function uses the formulae derived in <a class="el" href="citelist.html#CITEREF_Ferrer2019a">[21]</a>.</p>
<p>Returns the value \(E[D]\) as a rational value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>The input graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The expected value of the sum of edge lengths as a rational value. </dd></dl>

</div>
</div>
<a id="ab052d596b426bfa68ca44f046e44e76d" name="ab052d596b426bfa68ca44f046e44e76d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab052d596b426bfa68ca44f046e44e76d">&#9670;&#160;</a></span>hubiness() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double lal::properties::hubiness </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the hubiness coefficient as a floating point value. </p>
<p>See <a class="el" href="#a23f61ed2204c24dce8049666357b65d5">lal::properties::hubiness_rational</a> for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input free tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hubiness coefficient as a floating point value. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The tree <em>t</em> is a valid tree. Method <a class="el" href="classlal_1_1graphs_1_1tree.html#a25c8d57865fa5f7cb5d101fd5d07fe2d" title="Is this graph is an actual tree?">graphs::free_tree::is_tree</a> returns true. </dd>
<dd>
\(n &gt; 3\). </dd></dl>

</div>
</div>
<a id="af13cc3093569223cde0ae3f329f86ded" name="af13cc3093569223cde0ae3f329f86ded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af13cc3093569223cde0ae3f329f86ded">&#9670;&#160;</a></span>hubiness() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double lal::properties::hubiness </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the hubiness coefficient as a floating point value. </p>
<p>See <a class="el" href="#a23f61ed2204c24dce8049666357b65d5">lal::properties::hubiness_rational</a> for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input rooted tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hubiness coefficient as a floating point value. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The tree <em>t</em> is a valid rooted tree. Method <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#af464d98b1b5dfdbaaacea553d9c89154" title="Is this tree a valid rooted tree?">graphs::rooted_tree::is_rooted_tree</a> returns true. </dd>
<dd>
\(n &gt; 3\). </dd></dl>

</div>
</div>
<a id="a23f61ed2204c24dce8049666357b65d5" name="a23f61ed2204c24dce8049666357b65d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23f61ed2204c24dce8049666357b65d5">&#9670;&#160;</a></span>hubiness_rational() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a> lal::properties::hubiness_rational </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the hubiness coefficient as an exact rational number. </p>
<p>The hubiness coefficient is defined as.</p>
<p>\(h = \frac{ \langle k^2 \rangle - \langle k^2 \rangle_{linear} }
            { \langle k^2 \rangle_{star} - \langle k^2 \rangle_{linear} }\),</p>
<p>where \(\langle k^2 \rangle_{star}\) and \(\langle k^2 \rangle_{linear}\) are the second moment of degree about 0 (see <a class="el" href="#a8189ffb3e3386ee95dcf7530011dda01">lal::properties::moment_degree_rational</a>) of a star and linear tree respectively.</p>
<p>See <a class="el" href="citelist.html#CITEREF_Ferrer2018a">[12]</a> for further details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input free tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hubiness coefficient as a rational value. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The tree <em>t</em> is a valid tree. Method <a class="el" href="classlal_1_1graphs_1_1tree.html#a25c8d57865fa5f7cb5d101fd5d07fe2d" title="Is this graph is an actual tree?">graphs::free_tree::is_tree</a> returns true. </dd>
<dd>
\(n &gt; 3\). </dd></dl>

</div>
</div>
<a id="a1750ada3673e7deba32658dc3da2cf0c" name="a1750ada3673e7deba32658dc3da2cf0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1750ada3673e7deba32658dc3da2cf0c">&#9670;&#160;</a></span>hubiness_rational() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a> lal::properties::hubiness_rational </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the hubiness coefficient as an exact rational number. </p>
<p>The hubiness coefficient is defined as.</p>
<p>\(h = \frac{ \langle k^2 \rangle - \langle k^2 \rangle_{linear} }
            { \langle k^2 \rangle_{star} - \langle k^2 \rangle_{linear} }\),</p>
<p>where \(\langle k^2 \rangle_{star}\) and \(\langle k^2 \rangle_{linear}\) are the second moment of degree about 0 (see <a class="el" href="#a8189ffb3e3386ee95dcf7530011dda01">lal::properties::moment_degree_rational</a>) of a star and linear tree respectively.</p>
<p>See <a class="el" href="citelist.html#CITEREF_Ferrer2018a">[12]</a> for further details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input rooted tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hubiness coefficient as a rational value. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The tree <em>t</em> is a valid rooted tree. Method <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#af464d98b1b5dfdbaaacea553d9c89154" title="Is this tree a valid rooted tree?">graphs::rooted_tree::is_rooted_tree</a> returns true. </dd>
<dd>
\(n &gt; 3\). </dd></dl>

</div>
</div>
<a id="a0c70ec4072e1df27592aa7a51876c1a9" name="a0c70ec4072e1df27592aa7a51876c1a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c70ec4072e1df27592aa7a51876c1a9">&#9670;&#160;</a></span>mean_hierarchical_distance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double lal::properties::mean_hierarchical_distance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mean Hierarchical Distance. </p>
<p>See <a class="el" href="#a5eca870365ac786867aeacf3609457a9">lal::properties::mean_hierarchical_distance_rational</a> for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input rooted tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Mean Hierarchical Distance of a rooted tree as a floating point value. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The tree <em>t</em> is a valid rooted tree. Method <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#af464d98b1b5dfdbaaacea553d9c89154" title="Is this tree a valid rooted tree?">graphs::rooted_tree::is_rooted_tree</a> returns true. </dd>
<dd>
\(n &gt; 1\) (which is the same as \(m &gt; 0\). </dd></dl>

</div>
</div>
<a id="a5eca870365ac786867aeacf3609457a9" name="a5eca870365ac786867aeacf3609457a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eca870365ac786867aeacf3609457a9">&#9670;&#160;</a></span>mean_hierarchical_distance_rational()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a> lal::properties::mean_hierarchical_distance_rational </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mean Hierarchical Distance. </p>
<p>The mean hierarchical distance is calculated as a mean of the different hierarchical distances between each vertex and the root of the tree. The hierarchical distance \(HD_u\) of vertex \(u\) is calculated as the number of edges between the tree's root and \(u\). The result of this function is the mean of these distances: \(MHD = \frac{1}{n-1} \sum_{u\in V} HD_u\).</p>
<p>For furhter details see <a class="el" href="citelist.html#CITEREF_Jing2015a">[23]</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input rooted tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Mean Hierarchical Distance of a rooted tree as a rational value. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The tree <em>t</em> is a valid rooted tree. Method <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#af464d98b1b5dfdbaaacea553d9c89154" title="Is this tree a valid rooted tree?">graphs::rooted_tree::is_rooted_tree</a> returns true. </dd>
<dd>
\(n &gt; 1\) (which is the same as \(m &gt; 0\). </dd></dl>

</div>
</div>
<a id="aa92325006267f83f5f683e9f674942db" name="aa92325006267f83f5f683e9f674942db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa92325006267f83f5f683e9f674942db">&#9670;&#160;</a></span>moment_degree() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double lal::properties::moment_degree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the \(p\)-th moment of degree about zero of a directed graph as a floating point value. </p>
<p>See <a class="el" href="#a8189ffb3e3386ee95dcf7530011dda01">lal::properties::moment_degree_rational</a> for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">p</td><td>Moment of degree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The \(p\)-th moment of the degree about 0 as a floating point value. </dd></dl>

</div>
</div>
<a id="afb06b2d8f62bf9603ef2f5adee87d56b" name="afb06b2d8f62bf9603ef2f5adee87d56b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb06b2d8f62bf9603ef2f5adee87d56b">&#9670;&#160;</a></span>moment_degree() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double lal::properties::moment_degree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the \(p\)-th moment of degree about zero of a directed graph as a floating point value. </p>
<p>See <a class="el" href="#a8189ffb3e3386ee95dcf7530011dda01">lal::properties::moment_degree_rational</a> for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">p</td><td>Moment of degree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The \(p\)-th moment of the degree about 0 as a floating point value. </dd></dl>

</div>
</div>
<a id="a5d46daa5e371aa95448f8f31a642bede" name="a5d46daa5e371aa95448f8f31a642bede"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d46daa5e371aa95448f8f31a642bede">&#9670;&#160;</a></span>moment_degree_in()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double lal::properties::moment_degree_in </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the \(p\)-th moment of in-degree about zero of a directed graph as a floating point value. </p>
<p>See <a class="el" href="#a9dd093274eff2c3755cd54ae5907a04f">lal::properties::moment_degree_in_rational</a> for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">p</td><td>Moment of degree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The \(p\)-th moment of the in-degree about 0 as a floating point value. </dd></dl>

</div>
</div>
<a id="a9dd093274eff2c3755cd54ae5907a04f" name="a9dd093274eff2c3755cd54ae5907a04f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dd093274eff2c3755cd54ae5907a04f">&#9670;&#160;</a></span>moment_degree_in_rational()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a> lal::properties::moment_degree_in_rational </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the \(p\)-th moment of in-degree about zero of a directed graph as an exact rational value. </p>
<p>Computes the \(p\)-th moment of in-degree about zero, \(\langle k_{in}^p \rangle\), of a directed graph using:</p>
<p>\(\langle k_{in}^p \rangle = \frac{1}{n} \sum_{i=1}^n k_{in, i}^p \).</p>
<p>where \(n\) denotes the number of nodes of the graph. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">p</td><td>Moment of degree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The \(p\)-th moment of the in-degree about 0 as a rational value. </dd></dl>

</div>
</div>
<a id="a14c1ae06978c36d1da71b62bae32304f" name="a14c1ae06978c36d1da71b62bae32304f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14c1ae06978c36d1da71b62bae32304f">&#9670;&#160;</a></span>moment_degree_out()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double lal::properties::moment_degree_out </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the \(p\)-th moment of out-degree about zero of a directed graph as a floating point value. </p>
<p>See <a class="el" href="#a5efdbc1f5586bca3cdb9b6279051c12b">lal::properties::moment_degree_out_rational</a> for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">p</td><td>Moment of degree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The \(p\)-th moment of the out-degree about 0 as a floating point value. </dd></dl>

</div>
</div>
<a id="a5efdbc1f5586bca3cdb9b6279051c12b" name="a5efdbc1f5586bca3cdb9b6279051c12b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5efdbc1f5586bca3cdb9b6279051c12b">&#9670;&#160;</a></span>moment_degree_out_rational()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a> lal::properties::moment_degree_out_rational </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the \(p\)-th moment of out-degree about zero of a directed graph as an exact rational value. </p>
<p>Computes the \(p\)-th moment of out-degree about zero, \(\langle k_{out}^p \rangle\), of a directed graph using:</p>
<p>\(\langle k_{out}^p \rangle = \frac{1}{n} \sum_{i=1}^n k_{out, i}^p \).</p>
<p>where \(n\) denotes the number of nodes of the graph. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">p</td><td>Moment of degree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The \(p\)-th moment of the out-degree about 0 as a rational value. </dd></dl>

</div>
</div>
<a id="a4f4554ea43c1374e040d60cd9a53ac84" name="a4f4554ea43c1374e040d60cd9a53ac84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f4554ea43c1374e040d60cd9a53ac84">&#9670;&#160;</a></span>moment_degree_rational() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a> lal::properties::moment_degree_rational </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the \(p\)-th moment of degree about zero of a directed graph as an exact rational value. </p>
<p>Computes the \(p\)-th moment of degree about zero, \(\langle k^p \rangle\), of a graph using:</p>
<p>\(\langle k^p \rangle = \frac{1}{n} \sum_{i=1}^n k_i^p \).</p>
<p>where \(n\) denotes the number of nodes of the graph and \(k_i\) is the in-degree plus the out-degree of vertex \(i\). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">p</td><td>Moment of degree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The \(p\)-th moment of the in-degree about 0 as a rational value. </dd></dl>

</div>
</div>
<a id="a8189ffb3e3386ee95dcf7530011dda01" name="a8189ffb3e3386ee95dcf7530011dda01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8189ffb3e3386ee95dcf7530011dda01">&#9670;&#160;</a></span>moment_degree_rational() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a> lal::properties::moment_degree_rational </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the \(p\)-th moment of degree about zero of a graph as an exact rational value. </p>
<p>Computes the \(p\)-th moment of degree about zero, \(\langle k^p \rangle\), of a graph using:</p>
<p>\(\langle k^p \rangle = \frac{1}{n} \sum_{i=1}^n k_i^p \).</p>
<p>where \(n\) denotes the number of nodes of the graph and \(k_i\) is the degree of vertex \(i\). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">p</td><td>Moment of degree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The \(p\)-th moment of the in-degree about 0 as a rational value. </dd></dl>

</div>
</div>
<a id="a0d1a9bd03760411d1436925d7c095216" name="a0d1a9bd03760411d1436925d7c095216"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d1a9bd03760411d1436925d7c095216">&#9670;&#160;</a></span>num_pairs_independent_edges() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lal::properties::num_pairs_independent_edges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the size of \(Q(G)\). </p>
<p>See <a class="el" href="#a6fa7c3d6aee99da7e532a943bdbc2a9e">lal::properties::num_pairs_independent_edges_integer</a> for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size of \(Q(G)\) as a 64-bit integer. </dd></dl>

</div>
</div>
<a id="a0a492c71d8503b4681ca40d3b526b0f0" name="a0a492c71d8503b4681ca40d3b526b0f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a492c71d8503b4681ca40d3b526b0f0">&#9670;&#160;</a></span>num_pairs_independent_edges() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lal::properties::num_pairs_independent_edges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the size of \(Q(G)\). </p>
<p>See <a class="el" href="#a6fa7c3d6aee99da7e532a943bdbc2a9e">lal::properties::num_pairs_independent_edges_integer</a> for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size of \(Q(G)\) as a 64-bit integer. </dd></dl>

</div>
</div>
<a id="aa086ffd70ff3d2f2ab2e89108b8544a3" name="aa086ffd70ff3d2f2ab2e89108b8544a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa086ffd70ff3d2f2ab2e89108b8544a3">&#9670;&#160;</a></span>num_pairs_independent_edges_integer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1numeric_1_1integer.html">numeric::integer</a> lal::properties::num_pairs_independent_edges_integer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the size of \(Q(G)\). </p>
<p>The set \(Q(G)\) of a graph \(G\) is the set of pairs of independent edges. Two edges are said to be independent if they do not share vertices. Therefore, this function returns the amount of independent edges of this directed graph. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size of \(Q(G)\) as an integer of arbitrary precision. </dd></dl>

</div>
</div>
<a id="a6fa7c3d6aee99da7e532a943bdbc2a9e" name="a6fa7c3d6aee99da7e532a943bdbc2a9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fa7c3d6aee99da7e532a943bdbc2a9e">&#9670;&#160;</a></span>num_pairs_independent_edges_integer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1numeric_1_1integer.html">numeric::integer</a> lal::properties::num_pairs_independent_edges_integer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the size of \(Q(G)\). </p>
<p>The set \(Q(G)\) of a graph \(G\) is the set of pairs of independent edges. Two edges are said to be independent if they do not share vertices. Therefore, this function returns the amount of independent edges of this undirected graph. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size of \(Q(G)\) as an integer of arbitrary precision. </dd></dl>

</div>
</div>
<a id="ab05c2a8ee4c9e544358b1db18a7b1c13" name="ab05c2a8ee4c9e544358b1db18a7b1c13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab05c2a8ee4c9e544358b1db18a7b1c13">&#9670;&#160;</a></span>tree_centre() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="namespacelal.html#abd94045faecfc68a03268dde9c9a13eb">node</a>, <a class="el" href="namespacelal.html#abd94045faecfc68a03268dde9c9a13eb">node</a> &gt; lal::properties::tree_centre </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the centre of a free tree. </p>
<p>Here, "centre" should not be confused with "centroid". The center is the set of (at most) two vertices that have minimum eccentricity. The centroid is the set of (at most) two vertices that have minimum weight, where the weight is the maximum size of the subtrees rooted at that vertex. See <a class="el" href="citelist.html#CITEREF_Harary1969a">[19]</a> (pages 35-36) for further details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tuple of two values: the nodes in the centre. If the tree has a single central node, only the first node is valid and the second is assigned an invalid vertex index. It is guaranteed that the first vertex has smaller index value than the second. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The tree <em>t</em> is a valid rooted tree. Method <a class="el" href="classlal_1_1graphs_1_1tree.html#a25c8d57865fa5f7cb5d101fd5d07fe2d" title="Is this graph is an actual tree?">graphs::free_tree::is_tree</a> returns true. </dd></dl>

</div>
</div>
<a id="ada5517f223bcb1369b625a840dc9c8fa" name="ada5517f223bcb1369b625a840dc9c8fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada5517f223bcb1369b625a840dc9c8fa">&#9670;&#160;</a></span>tree_centre() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="namespacelal.html#abd94045faecfc68a03268dde9c9a13eb">node</a>, <a class="el" href="namespacelal.html#abd94045faecfc68a03268dde9c9a13eb">node</a> &gt; lal::properties::tree_centre </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the centre of a rooted tree. </p>
<p>Here, "centre" should not be confused with "centroid". The center is the set of (at most) two vertices that have minimum eccentricity. The centroid is the set of (at most) two vertices that have minimum weight, where the weight is the maximum size of the subtrees rooted at that vertex. See <a class="el" href="citelist.html#CITEREF_Harary1969a">[19]</a> (pages 35-36) for further details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tuple of two values: the nodes in the centre. If the tree has a single central node, only the first node is valid and the second is assigned an invalid vertex index. It is guaranteed that the first vertex has smaller index value than the second. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The tree <em>t</em> is a valid rooted tree. Method <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#af464d98b1b5dfdbaaacea553d9c89154" title="Is this tree a valid rooted tree?">graphs::rooted_tree::is_rooted_tree</a> returns true. </dd></dl>

</div>
</div>
<a id="a809427c54bf089fa2596e47b23538a5a" name="a809427c54bf089fa2596e47b23538a5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a809427c54bf089fa2596e47b23538a5a">&#9670;&#160;</a></span>tree_centroid() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="namespacelal.html#abd94045faecfc68a03268dde9c9a13eb">node</a>, <a class="el" href="namespacelal.html#abd94045faecfc68a03268dde9c9a13eb">node</a> &gt; lal::properties::tree_centroid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the centroid of a free tree. </p>
<p>Here, "centre" should not be confused with "centroid". The center is the set of (at most) two vertices that have minimum eccentricity. The centroid is the set of (at most) two vertices that have minimum weight, where the weight is the maximum size of the subtrees rooted at that vertex. See <a class="el" href="citelist.html#CITEREF_Harary1969a">[19]</a> (pages 35-36) for further details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tuple of two values: the nodes in the centre. If the tree has a single central node, only the first node is valid and the second is assigned an invalid vertex index. It is guaranteed that the first vertex has smaller index value than the second. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The tree <em>t</em> is a valid free tree. Method <a class="el" href="classlal_1_1graphs_1_1tree.html#a25c8d57865fa5f7cb5d101fd5d07fe2d" title="Is this graph is an actual tree?">graphs::free_tree::is_tree</a> returns true. </dd></dl>

</div>
</div>
<a id="adda281d4c9e024ea87844756ffbd945e" name="adda281d4c9e024ea87844756ffbd945e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adda281d4c9e024ea87844756ffbd945e">&#9670;&#160;</a></span>tree_centroid() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="namespacelal.html#abd94045faecfc68a03268dde9c9a13eb">node</a>, <a class="el" href="namespacelal.html#abd94045faecfc68a03268dde9c9a13eb">node</a> &gt; lal::properties::tree_centroid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the centroid of a rooted tree. </p>
<p>Here, "centroid" should not be confused with "centre". The centre is the set of (at most) two vertices that have minimum eccentricity. The centroid is the set of (at most) two vertices that have minimum weight, where the weight is the maximum size of the subtrees rooted at that vertex. In both case, if the set has two vertices then they are adjacent in the tree. See <a class="el" href="citelist.html#CITEREF_Harary1969a">[19]</a> (pages 35-36) for further details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tuple of two values: the nodes in the centre. If the tree has a single central node, only the first node is valid and the second is assigned an invalid vertex index. It is guaranteed that the first vertex has smaller index value than the second. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The tree <em>t</em> is a valid rooted tree. Method <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#af464d98b1b5dfdbaaacea553d9c89154" title="Is this tree a valid rooted tree?">graphs::rooted_tree::is_rooted_tree</a> returns true. </dd></dl>

</div>
</div>
<a id="aff86e7421571febc7a70af4ba770c23f" name="aff86e7421571febc7a70af4ba770c23f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff86e7421571febc7a70af4ba770c23f">&#9670;&#160;</a></span>tree_diameter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t lal::properties::tree_diameter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the diameter of a free tree. </p>
<p>The diameter is defined as the longest shortest distance between every pair of vertices. The distance is calculated in number of edges; two adjacent vertices are at a distance 1 from each other. See <a class="el" href="citelist.html#CITEREF_Harary1969a">[19]</a> (pages 24, 35) for further details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The diameter of the input tree. </dd></dl>

</div>
</div>
<a id="ab125c9530b3757c61fe74351c0778a6d" name="ab125c9530b3757c61fe74351c0778a6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab125c9530b3757c61fe74351c0778a6d">&#9670;&#160;</a></span>tree_diameter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t lal::properties::tree_diameter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the diameter of a free tree. </p>
<p>The diameter is defined as the longest shortest distance between every pair of vertices. The distance is calculated in number of edges; two adjacent vertices are at a distance 1 from each other. See <a class="el" href="citelist.html#CITEREF_Harary1969a">[19]</a> (pages 24, 35) for further details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The diameter of the input tree. </dd></dl>

</div>
</div>
<a id="ad59eec82bbd716aefedc4453d82becd4" name="ad59eec82bbd716aefedc4453d82becd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad59eec82bbd716aefedc4453d82becd4">&#9670;&#160;</a></span>var_num_crossings()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double lal::properties::var_num_crossings </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>reuse</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the variance of the number of crossings of a graph in unconstrained arrangements, \(\mathbb{V}[C]\). </p>
<p>See <a class="el" href="#a726f70a34d6950773beea9cdadf7e5c5">lal::properties::var_num_crossings_rational</a> for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">reuse</td><td>The algorithm will reuse computations in order to compute the variance faster. Note: this might be too memory-consuming. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The exact value of \(V_{rla}[C]\) as a rationafloating point value. </dd></dl>

</div>
</div>
<a id="af404ccea372ee1d555cab3b9c6e67a1d" name="af404ccea372ee1d555cab3b9c6e67a1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af404ccea372ee1d555cab3b9c6e67a1d">&#9670;&#160;</a></span>var_num_crossings_forest()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double lal::properties::var_num_crossings_forest </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the variance of the number of crossings of a forest in unconstrained arrangements, \(\mathbb{V}[C]\). </p>
<p>See <a class="el" href="#a4fc49dada4d129f0a9026605e74cfe0a">lal::properties::var_num_crossings_forest_rational</a> for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input forest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The exact value of \(V_{rla}[C]\) as a floating point value. </dd></dl>

</div>
</div>
<a id="a4fc49dada4d129f0a9026605e74cfe0a" name="a4fc49dada4d129f0a9026605e74cfe0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fc49dada4d129f0a9026605e74cfe0a">&#9670;&#160;</a></span>var_num_crossings_forest_rational()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a> lal::properties::var_num_crossings_forest_rational </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the variance of the number of crossings of a forest in unconstrained arrangements, \(\mathbb{V}[C]\). </p>
<p>Computes \(\mathbb{V}[C]\) on the given forest. This function implements the algorithm in <a class="el" href="citelist.html#CITEREF_Alemany2020b">[3]</a> for forests, which stems from the study in <a class="el" href="citelist.html#CITEREF_Alemany2020a">[2]</a>.</p>
<p>Complexity: time \(O(n)\), space \(O(n)\). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input forest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The exact value of \(V_{rla}[C]\) as a rational value. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The input graph <em>g</em> is a forest. </dd></dl>

</div>
</div>
<a id="a726f70a34d6950773beea9cdadf7e5c5" name="a726f70a34d6950773beea9cdadf7e5c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a726f70a34d6950773beea9cdadf7e5c5">&#9670;&#160;</a></span>var_num_crossings_rational()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a> lal::properties::var_num_crossings_rational </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>reuse</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the variance of the number of crossings of a graph in unconstrained arrangements, \(\mathbb{V}[C]\). </p>
<p>Computes \(\mathbb{V}[C]\) on the given graph. This function implements the algorithm in <a class="el" href="citelist.html#CITEREF_Alemany2020b">[3]</a> for general graphs, which stems from the study in <a class="el" href="citelist.html#CITEREF_Alemany2020a">[2]</a>.</p>
<p>Since there are many computations that can be resued, setting <em>reuse</em> to 'true' can help speed up the algorithm. Warning: reusing memory might be too memory-consuming for large graphs (handle with care). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">reuse</td><td>The algorithm will reuse computations in order to compute the variance faster. Note: this might be too memory-consuming. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The exact value of \(V_{rla}[C]\) as a rational value. </dd></dl>

</div>
</div>
<a id="a02c904df78290dd71ec9445ad3908bc5" name="a02c904df78290dd71ec9445ad3908bc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02c904df78290dd71ec9445ad3908bc5">&#9670;&#160;</a></span>var_num_crossings_tree() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double lal::properties::var_num_crossings_tree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the variance of the number of crossings of a tree in unconstrained arrangements, \(\mathbb{V}[C]\). </p>
<p>See <a class="el" href="#a83745d14589b98b918481d83f564f7c0">lal::properties::var_num_crossings_tree_rational</a> for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input free tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return value is a floating point value. </dd></dl>

</div>
</div>
<a id="a504fb6143e41360712cdd5b96b93cb6e" name="a504fb6143e41360712cdd5b96b93cb6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a504fb6143e41360712cdd5b96b93cb6e">&#9670;&#160;</a></span>var_num_crossings_tree() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double lal::properties::var_num_crossings_tree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the variance of the number of crossings of a tree in unconstrained arrangements, \(\mathbb{V}[C]\). </p>
<p>This function converts the input rooted tree into a free tree.</p>
<p>See <a class="el" href="#a83745d14589b98b918481d83f564f7c0">lal::properties::var_num_crossings_tree_rational</a> for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input rooted tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return value is a floating point value. </dd></dl>

</div>
</div>
<a id="a83745d14589b98b918481d83f564f7c0" name="a83745d14589b98b918481d83f564f7c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83745d14589b98b918481d83f564f7c0">&#9670;&#160;</a></span>var_num_crossings_tree_rational() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a> lal::properties::var_num_crossings_tree_rational </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the variance of the number of crossings of a tree in unconstrained arrangements, \(\mathbb{V}[C]\). </p>
<p>Computes \(\mathbb{V}[C]\) on the given tree. This function computes the simplified formula of \(V_{rla}[C]\) on general graphs for the case of trees. Complexity: time \(O(n)\), space \(O(n)\). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input free tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The exact value of \(V_{rla}[C]\) as a rational value. </dd></dl>

</div>
</div>
<a id="ad04afab9d98252090df36b307c014de4" name="ad04afab9d98252090df36b307c014de4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad04afab9d98252090df36b307c014de4">&#9670;&#160;</a></span>var_num_crossings_tree_rational() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a> lal::properties::var_num_crossings_tree_rational </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the variance of the number of crossings of a tree in unconstrained arrangements, \(\mathbb{V}[C]\). </p>
<p>This function converts the input rooted tree into a free tree.</p>
<p>Computes \(\mathbb{V}[C]\) on the given tree. This function computes the simplified formula of \(V_{rla}[C]\) on general graphs for the case of trees. Complexity: time \(O(n)\), space \(O(n)\). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input rooted tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The exact value of \(V_{rla}[C]\) as a rational value. </dd></dl>

</div>
</div>
<a id="ade6a3f20263e2a982cfc5dc59facaf40" name="ade6a3f20263e2a982cfc5dc59facaf40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade6a3f20263e2a982cfc5dc59facaf40">&#9670;&#160;</a></span>var_sum_edge_lengths()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double lal::properties::var_sum_edge_lengths </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the variance of the sum of the length of edges of a graph, \(\mathbb{V}[D]\). </p>
<p>See <a class="el" href="#a3826e458a5c14aa82c2d5f0679530e7e">lal::properties::var_sum_edge_lengths_rational</a> for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>The input graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The exact value of \(V[D]\) as a floating point value. </dd></dl>

</div>
</div>
<a id="a3826e458a5c14aa82c2d5f0679530e7e" name="a3826e458a5c14aa82c2d5f0679530e7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3826e458a5c14aa82c2d5f0679530e7e">&#9670;&#160;</a></span>var_sum_edge_lengths_rational()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a> lal::properties::var_sum_edge_lengths_rational </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the variance of the sum of the length of edges of a graph, \(\mathbb{V}[D]\). </p>
<p>Computes the variance of the sum of edge lengths over all \(n!\) arrangements.</p>
<p>This function uses the formula derived in <a class="el" href="citelist.html#CITEREF_Ferrer2019a">[21]</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The exact value of \(V[D]\) as a rational value. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
