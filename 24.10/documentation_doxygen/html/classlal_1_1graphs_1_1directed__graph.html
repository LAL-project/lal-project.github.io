<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LAL: Linear Arrangement Library: lal::graphs::directed_graph Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">LAL: Linear Arrangement Library<span id="projectnumber">&#160;24.10.00</span>
   </div>
   <div id="projectbrief">A library focused on algorithms on linear arrangements of graphs.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacelal.html">lal</a></li><li class="navelem"><a class="el" href="namespacelal_1_1graphs.html">graphs</a></li><li class="navelem"><a class="el" href="classlal_1_1graphs_1_1directed__graph.html">directed_graph</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="classlal_1_1graphs_1_1directed__graph-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">lal::graphs::directed_graph Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Directed graph class.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="directed__graph_8hpp_source.html">directed_graph.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for lal::graphs::directed_graph:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classlal_1_1graphs_1_1directed__graph.png" usemap="#lal::graphs::directed_5Fgraph_map" alt=""/>
  <map id="lal::graphs::directed_5Fgraph_map" name="lal::graphs::directed_5Fgraph_map">
<area href="classlal_1_1graphs_1_1graph.html" title="Abstract class for graphs." alt="lal::graphs::graph" shape="rect" coords="0,0,162,24"/>
<area href="classlal_1_1graphs_1_1rooted__tree.html" title="Rooted tree graph class." alt="lal::graphs::rooted_tree" shape="rect" coords="0,112,162,136"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1c5e231dd8b30335fd267852211a1b84" id="r_a1c5e231dd8b30335fd267852211a1b84"><td class="memItemLeft" align="right" valign="top"><a id="a1c5e231dd8b30335fd267852211a1b84" name="a1c5e231dd8b30335fd267852211a1b84"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>directed_graph</b> () noexcept</td></tr>
<tr class="memdesc:a1c5e231dd8b30335fd267852211a1b84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty constructor. <br /></td></tr>
<tr class="separator:a1c5e231dd8b30335fd267852211a1b84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6e21e83c3edf8cbb2aa7dc0651d32ab" id="r_ac6e21e83c3edf8cbb2aa7dc0651d32ab"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac6e21e83c3edf8cbb2aa7dc0651d32ab">directed_graph</a> (const uint64_t n) noexcept</td></tr>
<tr class="memdesc:ac6e21e83c3edf8cbb2aa7dc0651d32ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor with number of nodes.  <br /></td></tr>
<tr class="separator:ac6e21e83c3edf8cbb2aa7dc0651d32ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30bac2d9e40d0cbc05d211293f3dcea3" id="r_a30bac2d9e40d0cbc05d211293f3dcea3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a30bac2d9e40d0cbc05d211293f3dcea3">directed_graph</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">directed_graph</a> &amp;g) noexcept</td></tr>
<tr class="memdesc:a30bac2d9e40d0cbc05d211293f3dcea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <br /></td></tr>
<tr class="separator:a30bac2d9e40d0cbc05d211293f3dcea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad17b0a80146cdc740fb075d3801f86aa" id="r_ad17b0a80146cdc740fb075d3801f86aa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad17b0a80146cdc740fb075d3801f86aa">directed_graph</a> (<a class="el" href="classlal_1_1graphs_1_1directed__graph.html">directed_graph</a> &amp;&amp;g) noexcept</td></tr>
<tr class="memdesc:ad17b0a80146cdc740fb075d3801f86aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <br /></td></tr>
<tr class="separator:ad17b0a80146cdc740fb075d3801f86aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3581bb59b68d93af766d1c8161fab1f" id="r_aa3581bb59b68d93af766d1c8161fab1f"><td class="memItemLeft" align="right" valign="top"><a id="aa3581bb59b68d93af766d1c8161fab1f" name="aa3581bb59b68d93af766d1c8161fab1f"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~directed_graph</b> () noexcept</td></tr>
<tr class="memdesc:aa3581bb59b68d93af766d1c8161fab1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:aa3581bb59b68d93af766d1c8161fab1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a888fe135207a80aafe845745d9572a54" id="r_a888fe135207a80aafe845745d9572a54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1graphs_1_1directed__graph.html">directed_graph</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a888fe135207a80aafe845745d9572a54">operator=</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">directed_graph</a> &amp;g) noexcept</td></tr>
<tr class="memdesc:a888fe135207a80aafe845745d9572a54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator.  <br /></td></tr>
<tr class="separator:a888fe135207a80aafe845745d9572a54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a06739e9f21f81528e39bf780efdb43" id="r_a4a06739e9f21f81528e39bf780efdb43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1graphs_1_1directed__graph.html">directed_graph</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a06739e9f21f81528e39bf780efdb43">operator=</a> (<a class="el" href="classlal_1_1graphs_1_1directed__graph.html">directed_graph</a> &amp;&amp;g) noexcept</td></tr>
<tr class="memdesc:a4a06739e9f21f81528e39bf780efdb43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator.  <br /></td></tr>
<tr class="separator:a4a06739e9f21f81528e39bf780efdb43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a97b71616cedb7523b1ee712c30e4c1" id="r_a3a97b71616cedb7523b1ee712c30e4c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a97b71616cedb7523b1ee712c30e4c1">reserve_in_degree</a> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u, const uint64_t d) noexcept</td></tr>
<tr class="memdesc:a3a97b71616cedb7523b1ee712c30e4c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicts that the in-degree of node <em>u</em> is <em>d</em>.  <br /></td></tr>
<tr class="separator:a3a97b71616cedb7523b1ee712c30e4c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5f661e1f74f01757e0fb980aaf77562" id="r_ad5f661e1f74f01757e0fb980aaf77562"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad5f661e1f74f01757e0fb980aaf77562">reserve_out_degree</a> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u, const uint64_t d) noexcept</td></tr>
<tr class="memdesc:ad5f661e1f74f01757e0fb980aaf77562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicts that the out-degree of node <em>u</em> is <em>d</em>.  <br /></td></tr>
<tr class="separator:ad5f661e1f74f01757e0fb980aaf77562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e4a81d38587995cb990e21e28aaf2b4" id="r_a4e4a81d38587995cb990e21e28aaf2b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e4a81d38587995cb990e21e28aaf2b4">normalize</a> () noexcept</td></tr>
<tr class="memdesc:a4e4a81d38587995cb990e21e28aaf2b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalizes the graph.  <br /></td></tr>
<tr class="separator:a4e4a81d38587995cb990e21e28aaf2b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23b10c47032b774696a5ed970b059cdb" id="r_a23b10c47032b774696a5ed970b059cdb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a23b10c47032b774696a5ed970b059cdb">check_normalized</a> () noexcept</td></tr>
<tr class="memdesc:a23b10c47032b774696a5ed970b059cdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the graph is normalized.  <br /></td></tr>
<tr class="separator:a23b10c47032b774696a5ed970b059cdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9de4c26d06c16ca6e4644c35985f7546" id="r_a9de4c26d06c16ca6e4644c35985f7546"><td class="memItemLeft" align="right" valign="top"><a id="a9de4c26d06c16ca6e4644c35985f7546" name="a9de4c26d06c16ca6e4644c35985f7546"></a>
virtual <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">directed_graph</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>add_node</b> () noexcept</td></tr>
<tr class="memdesc:a9de4c26d06c16ca6e4644c35985f7546"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a node to the graph. <br /></td></tr>
<tr class="separator:a9de4c26d06c16ca6e4644c35985f7546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae3aa64a0f37563dbb8b9473eeba7ced" id="r_aae3aa64a0f37563dbb8b9473eeba7ced"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">directed_graph</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae3aa64a0f37563dbb8b9473eeba7ced">remove_node</a> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u, const bool norm=true, const bool check_norm=true) noexcept</td></tr>
<tr class="memdesc:aae3aa64a0f37563dbb8b9473eeba7ced"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a node from this graph.  <br /></td></tr>
<tr class="separator:aae3aa64a0f37563dbb8b9473eeba7ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4fd30bc89da5485d2938ae9809d4dac" id="r_ad4fd30bc89da5485d2938ae9809d4dac"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">directed_graph</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad4fd30bc89da5485d2938ae9809d4dac">add_edge</a> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> s, const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> t, const bool norm=true, const bool check_norm=true) noexcept</td></tr>
<tr class="memdesc:ad4fd30bc89da5485d2938ae9809d4dac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a directed edge to the graph.  <br /></td></tr>
<tr class="separator:ad4fd30bc89da5485d2938ae9809d4dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2867b035b48ab54df5f60e3b065fea66" id="r_a2867b035b48ab54df5f60e3b065fea66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1graphs_1_1directed__graph.html">directed_graph</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2867b035b48ab54df5f60e3b065fea66">add_edge_bulk</a> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> s, const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> t) noexcept</td></tr>
<tr class="memdesc:a2867b035b48ab54df5f60e3b065fea66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an edge to the graph.  <br /></td></tr>
<tr class="separator:a2867b035b48ab54df5f60e3b065fea66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21efb8e78ed211739b6d355bbfd29ad6" id="r_a21efb8e78ed211739b6d355bbfd29ad6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a21efb8e78ed211739b6d355bbfd29ad6">finish_bulk_add</a> (const bool norm=true, const bool check=true) noexcept</td></tr>
<tr class="memdesc:a21efb8e78ed211739b6d355bbfd29ad6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Completes the inner structure of the graph after adding a bulk of edges.  <br /></td></tr>
<tr class="separator:a21efb8e78ed211739b6d355bbfd29ad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a211ff1b1441b0c27b1e1dfed8514eed7" id="r_a211ff1b1441b0c27b1e1dfed8514eed7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">directed_graph</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a211ff1b1441b0c27b1e1dfed8514eed7">add_edges</a> (const std::vector&lt; <a class="el" href="namespacelal.html#a5969ec7ecc85697ebb9ec0ace78fbcab">edge</a> &gt; &amp;edges, const bool norm=true, const bool check_norm=true) noexcept</td></tr>
<tr class="memdesc:a211ff1b1441b0c27b1e1dfed8514eed7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a list of directed edges to the graph.  <br /></td></tr>
<tr class="separator:a211ff1b1441b0c27b1e1dfed8514eed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ede56b5930ab3758ab55a81243743d6" id="r_a5ede56b5930ab3758ab55a81243743d6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">directed_graph</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ede56b5930ab3758ab55a81243743d6">set_edges</a> (const std::vector&lt; <a class="el" href="namespacelal.html#a5969ec7ecc85697ebb9ec0ace78fbcab">edge</a> &gt; &amp;edges, const bool norm=true, const bool check_norm=true) noexcept</td></tr>
<tr class="memdesc:a5ede56b5930ab3758ab55a81243743d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the list of edges to the graph.  <br /></td></tr>
<tr class="separator:a5ede56b5930ab3758ab55a81243743d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a655fbacfd749a62e61933ae19cb647cb" id="r_a655fbacfd749a62e61933ae19cb647cb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">directed_graph</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a655fbacfd749a62e61933ae19cb647cb">remove_edge_bulk</a> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> s, const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> t) noexcept</td></tr>
<tr class="memdesc:a655fbacfd749a62e61933ae19cb647cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an edge from the graph.  <br /></td></tr>
<tr class="separator:a655fbacfd749a62e61933ae19cb647cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a890ef15b90aefcda8c6aba36f48a6f8e" id="r_a890ef15b90aefcda8c6aba36f48a6f8e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a890ef15b90aefcda8c6aba36f48a6f8e">finish_bulk_remove</a> (const bool norm=true, const bool check=true) noexcept</td></tr>
<tr class="memdesc:a890ef15b90aefcda8c6aba36f48a6f8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Completes the inner structure of the graph after removing edges in bulk.  <br /></td></tr>
<tr class="separator:a890ef15b90aefcda8c6aba36f48a6f8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fdfa075c6d181f49640d30530f87dab" id="r_a2fdfa075c6d181f49640d30530f87dab"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">directed_graph</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2fdfa075c6d181f49640d30530f87dab">remove_edge</a> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> s, const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> t, const bool norm=true, const bool check_norm=true) noexcept</td></tr>
<tr class="memdesc:a2fdfa075c6d181f49640d30530f87dab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an edge from this graph.  <br /></td></tr>
<tr class="separator:a2fdfa075c6d181f49640d30530f87dab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a859d69232a66987307b4fb67c9d36885" id="r_a859d69232a66987307b4fb67c9d36885"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">directed_graph</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a859d69232a66987307b4fb67c9d36885">remove_edges</a> (const std::vector&lt; <a class="el" href="namespacelal.html#a5969ec7ecc85697ebb9ec0ace78fbcab">edge</a> &gt; &amp;edges, const bool norm=true, const bool check_norm=true) noexcept</td></tr>
<tr class="memdesc:a859d69232a66987307b4fb67c9d36885"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an edge from this graph.  <br /></td></tr>
<tr class="separator:a859d69232a66987307b4fb67c9d36885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87ac6566448b6aaa20a1ed892c480e35" id="r_a87ac6566448b6aaa20a1ed892c480e35"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">directed_graph</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a87ac6566448b6aaa20a1ed892c480e35">remove_edges_incident_to</a> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u, const bool norm=true, const bool check_norm=true) noexcept</td></tr>
<tr class="memdesc:a87ac6566448b6aaa20a1ed892c480e35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all edges incident to a given vertex.  <br /></td></tr>
<tr class="separator:a87ac6566448b6aaa20a1ed892c480e35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac333b30d221d8c5da985b09247d6e09c" id="r_ac333b30d221d8c5da985b09247d6e09c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1graphs_1_1directed__graph.html">directed_graph</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac333b30d221d8c5da985b09247d6e09c">disjoint_union</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">directed_graph</a> &amp;g) noexcept</td></tr>
<tr class="memdesc:ac333b30d221d8c5da985b09247d6e09c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disjoint union of graphs.  <br /></td></tr>
<tr class="separator:ac333b30d221d8c5da985b09247d6e09c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a116071bf1763e9454e1fc047b6c236d8" id="r_a116071bf1763e9454e1fc047b6c236d8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacelal.html#a235d5351556fbc73aa51767ab7765f5c">edge_pair</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a116071bf1763e9454e1fc047b6c236d8">get_Q</a> () const noexcept</td></tr>
<tr class="memdesc:a116071bf1763e9454e1fc047b6c236d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all independent pairs of edges of this graph.  <br /></td></tr>
<tr class="separator:a116071bf1763e9454e1fc047b6c236d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af914b8032445902d03cc4861a8ae976e" id="r_af914b8032445902d03cc4861a8ae976e"><td class="memItemLeft" align="right" valign="top"><a id="af914b8032445902d03cc4861a8ae976e" name="af914b8032445902d03cc4861a8ae976e"></a>
std::vector&lt; <a class="el" href="namespacelal.html#a5969ec7ecc85697ebb9ec0ace78fbcab">edge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>get_edges</b> () const noexcept</td></tr>
<tr class="memdesc:af914b8032445902d03cc4861a8ae976e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all edges of this graph. <br /></td></tr>
<tr class="separator:af914b8032445902d03cc4861a8ae976e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab40bb57d0670a70df80568cf33ed823d" id="r_ab40bb57d0670a70df80568cf33ed823d"><td class="memItemLeft" align="right" valign="top"><a id="ab40bb57d0670a70df80568cf33ed823d" name="ab40bb57d0670a70df80568cf33ed823d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>has_edge</b> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u, const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> v) const noexcept</td></tr>
<tr class="memdesc:ab40bb57d0670a70df80568cf33ed823d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the edge \((u,v)\) exists in the graph. <br /></td></tr>
<tr class="separator:ab40bb57d0670a70df80568cf33ed823d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94834a6fb04411d06eda59f998d2ff02" id="r_a94834a6fb04411d06eda59f998d2ff02"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacelal.html#aef91d923414879a998619e9c65181d1f">neighbourhood</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a94834a6fb04411d06eda59f998d2ff02">get_out_neighbors</a> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u) const noexcept</td></tr>
<tr class="memdesc:a94834a6fb04411d06eda59f998d2ff02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the out-neighbors of node <em>u</em>.  <br /></td></tr>
<tr class="separator:a94834a6fb04411d06eda59f998d2ff02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bd3b9aaaab43d22af76dea13c4c8371" id="r_a6bd3b9aaaab43d22af76dea13c4c8371"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacelal.html#aef91d923414879a998619e9c65181d1f">neighbourhood</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6bd3b9aaaab43d22af76dea13c4c8371">get_in_neighbors</a> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u) const noexcept</td></tr>
<tr class="memdesc:a6bd3b9aaaab43d22af76dea13c4c8371"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the in-neighbors of node <em>u</em>.  <br /></td></tr>
<tr class="separator:a6bd3b9aaaab43d22af76dea13c4c8371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3153114956055fc2e0a801a9418d2ecd" id="r_a3153114956055fc2e0a801a9418d2ecd"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3153114956055fc2e0a801a9418d2ecd">get_degree</a> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u) const noexcept</td></tr>
<tr class="memdesc:a3153114956055fc2e0a801a9418d2ecd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the in-degree plus the out-degree of this vertex.  <br /></td></tr>
<tr class="separator:a3153114956055fc2e0a801a9418d2ecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24cc0db004249dbb192698454d4ce78f" id="r_a24cc0db004249dbb192698454d4ce78f"><td class="memItemLeft" align="right" valign="top"><a id="a24cc0db004249dbb192698454d4ce78f" name="a24cc0db004249dbb192698454d4ce78f"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>get_out_degree</b> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u) const noexcept</td></tr>
<tr class="memdesc:a24cc0db004249dbb192698454d4ce78f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the out-degree of a node. <br /></td></tr>
<tr class="separator:a24cc0db004249dbb192698454d4ce78f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad08168cf9fd02b362013916bf308210" id="r_aad08168cf9fd02b362013916bf308210"><td class="memItemLeft" align="right" valign="top"><a id="aad08168cf9fd02b362013916bf308210" name="aad08168cf9fd02b362013916bf308210"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>get_in_degree</b> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u) const noexcept</td></tr>
<tr class="memdesc:aad08168cf9fd02b362013916bf308210"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the in-degree of a node. <br /></td></tr>
<tr class="separator:aad08168cf9fd02b362013916bf308210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40812da7f1cd9096226472b46645b3d3" id="r_a40812da7f1cd9096226472b46645b3d3"><td class="memItemLeft" align="right" valign="top"><a id="a40812da7f1cd9096226472b46645b3d3" name="a40812da7f1cd9096226472b46645b3d3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_directed</b> () const noexcept</td></tr>
<tr class="memdesc:a40812da7f1cd9096226472b46645b3d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether this graph is directed or not. <br /></td></tr>
<tr class="separator:a40812da7f1cd9096226472b46645b3d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51dde332648558ee729089cc30e67b6a" id="r_a51dde332648558ee729089cc30e67b6a"><td class="memItemLeft" align="right" valign="top"><a id="a51dde332648558ee729089cc30e67b6a" name="a51dde332648558ee729089cc30e67b6a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_undirected</b> () const noexcept</td></tr>
<tr class="memdesc:a51dde332648558ee729089cc30e67b6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether this graph is undirected or not. <br /></td></tr>
<tr class="separator:a51dde332648558ee729089cc30e67b6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7bfd2d96d5110a7bf0d56c4df1618fd" id="r_ad7bfd2d96d5110a7bf0d56c4df1618fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">undirected_graph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad7bfd2d96d5110a7bf0d56c4df1618fd">to_undirected</a> (const bool norm=true, const bool check=true) const noexcept</td></tr>
<tr class="memdesc:ad7bfd2d96d5110a7bf0d56c4df1618fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts this directed graph into an undirected graph.  <br /></td></tr>
<tr class="separator:ad7bfd2d96d5110a7bf0d56c4df1618fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc67c1ae0083dd89d8ec867e069d5c1a" id="r_adc67c1ae0083dd89d8ec867e069d5c1a"><td class="memItemLeft" align="right" valign="top"><a id="adc67c1ae0083dd89d8ec867e069d5c1a" name="adc67c1ae0083dd89d8ec867e069d5c1a"></a>
std::vector&lt; <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">directed_graph</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>get_connected_components</b> () const noexcept</td></tr>
<tr class="memdesc:adc67c1ae0083dd89d8ec867e069d5c1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all the connected components of this graph as individual graphs. <br /></td></tr>
<tr class="separator:adc67c1ae0083dd89d8ec867e069d5c1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e3529632b38533c4be8b2a306a038c3" id="r_a0e3529632b38533c4be8b2a306a038c3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1graph.html#a0e3529632b38533c4be8b2a306a038c3">init</a> (const uint64_t n) noexcept</td></tr>
<tr class="memdesc:a0e3529632b38533c4be8b2a306a038c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates the necessary memory for this class.  <br /></td></tr>
<tr class="separator:a0e3529632b38533c4be8b2a306a038c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8ba9ec6acf2306c84d9ddbd88fc8474" id="r_af8ba9ec6acf2306c84d9ddbd88fc8474"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1graph.html#af8ba9ec6acf2306c84d9ddbd88fc8474">clear</a> () noexcept</td></tr>
<tr class="memdesc:af8ba9ec6acf2306c84d9ddbd88fc8474"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the memory occupied by this graph.  <br /></td></tr>
<tr class="separator:af8ba9ec6acf2306c84d9ddbd88fc8474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbe53e770688c22a8c1e614d728d11cc" id="r_abbe53e770688c22a8c1e614d728d11cc"><td class="memItemLeft" align="right" valign="top"><a id="abbe53e770688c22a8c1e614d728d11cc" name="abbe53e770688c22a8c1e614d728d11cc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_normalized</b> (const bool v=true) noexcept</td></tr>
<tr class="memdesc:abbe53e770688c22a8c1e614d728d11cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether this graph is normalized or not. <br /></td></tr>
<tr class="separator:abbe53e770688c22a8c1e614d728d11cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad2d7e6a53d8746c66e8af9762c14484" id="r_aad2d7e6a53d8746c66e8af9762c14484"><td class="memItemLeft" align="right" valign="top"><a id="aad2d7e6a53d8746c66e8af9762c14484" name="aad2d7e6a53d8746c66e8af9762c14484"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>has_node</b> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u) const noexcept</td></tr>
<tr class="memdesc:aad2d7e6a53d8746c66e8af9762c14484"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if node <em>u</em> is in this graph. <br /></td></tr>
<tr class="separator:aad2d7e6a53d8746c66e8af9762c14484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58918b2b3fe79dff35003604bdfa19f3" id="r_a58918b2b3fe79dff35003604bdfa19f3"><td class="memItemLeft" align="right" valign="top"><a id="a58918b2b3fe79dff35003604bdfa19f3" name="a58918b2b3fe79dff35003604bdfa19f3"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>get_num_nodes</b> () const noexcept</td></tr>
<tr class="memdesc:a58918b2b3fe79dff35003604bdfa19f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of ndoes. <br /></td></tr>
<tr class="separator:a58918b2b3fe79dff35003604bdfa19f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a351a7e8c6a0ec6c23026b0b0b57efd17" id="r_a351a7e8c6a0ec6c23026b0b0b57efd17"><td class="memItemLeft" align="right" valign="top"><a id="a351a7e8c6a0ec6c23026b0b0b57efd17" name="a351a7e8c6a0ec6c23026b0b0b57efd17"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>get_num_edges</b> () const noexcept</td></tr>
<tr class="memdesc:a351a7e8c6a0ec6c23026b0b0b57efd17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of edges. <br /></td></tr>
<tr class="separator:a351a7e8c6a0ec6c23026b0b0b57efd17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb9238eb8914e145736f1ac914f6b9d6" id="r_abb9238eb8914e145736f1ac914f6b9d6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1graph.html#abb9238eb8914e145736f1ac914f6b9d6">is_normalized</a> () const noexcept</td></tr>
<tr class="memdesc:abb9238eb8914e145736f1ac914f6b9d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether this graph is normalized or not.  <br /></td></tr>
<tr class="separator:abb9238eb8914e145736f1ac914f6b9d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a3d94bc0b0b7d824c714e6980ddc5f6de" id="r_a3d94bc0b0b7d824c714e6980ddc5f6de"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d94bc0b0b7d824c714e6980ddc5f6de">_init</a> (const uint64_t n) noexcept</td></tr>
<tr class="memdesc:a3d94bc0b0b7d824c714e6980ddc5f6de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the memory in the graph hierarchy.  <br /></td></tr>
<tr class="separator:a3d94bc0b0b7d824c714e6980ddc5f6de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59e0515f2b02a576e10289a633ada49d" id="r_a59e0515f2b02a576e10289a633ada49d"><td class="memItemLeft" align="right" valign="top"><a id="a59e0515f2b02a576e10289a633ada49d" name="a59e0515f2b02a576e10289a633ada49d"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>_clear</b> () noexcept</td></tr>
<tr class="memdesc:a59e0515f2b02a576e10289a633ada49d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the memory of <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">directed_graph</a> and <a class="el" href="classlal_1_1graphs_1_1graph.html">graph</a> classes. <br /></td></tr>
<tr class="separator:a59e0515f2b02a576e10289a633ada49d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0cf22c45fc8d6a3c5cd29e00af7b9df" id="r_ac0cf22c45fc8d6a3c5cd29e00af7b9df"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac0cf22c45fc8d6a3c5cd29e00af7b9df">actions_after_add_edge</a> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u, const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> v) noexcept</td></tr>
<tr class="memdesc:ac0cf22c45fc8d6a3c5cd29e00af7b9df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do some extra work after the addition of an edge.  <br /></td></tr>
<tr class="separator:ac0cf22c45fc8d6a3c5cd29e00af7b9df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20e37ab891e53364f706f157695eda33" id="r_a20e37ab891e53364f706f157695eda33"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a20e37ab891e53364f706f157695eda33">actions_after_add_edges</a> (const <a class="el" href="namespacelal.html#ab98936b00d896700a71899dff1ed9248">edge_list</a> &amp;e) noexcept</td></tr>
<tr class="memdesc:a20e37ab891e53364f706f157695eda33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do some extra work after the addition of several edges.  <br /></td></tr>
<tr class="separator:a20e37ab891e53364f706f157695eda33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39ea733e148d29496a6db24189788d1d" id="r_a39ea733e148d29496a6db24189788d1d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a39ea733e148d29496a6db24189788d1d">actions_after_add_edges_bulk</a> () noexcept</td></tr>
<tr class="memdesc:a39ea733e148d29496a6db24189788d1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do some extra work after the addition of several edges in bulk.  <br /></td></tr>
<tr class="separator:a39ea733e148d29496a6db24189788d1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fb2e27dacaed104276a13e7024cffc9" id="r_a2fb2e27dacaed104276a13e7024cffc9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2fb2e27dacaed104276a13e7024cffc9">actions_after_remove_edge</a> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u, const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> v) noexcept</td></tr>
<tr class="memdesc:a2fb2e27dacaed104276a13e7024cffc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do some extra work after the removal of an edge.  <br /></td></tr>
<tr class="separator:a2fb2e27dacaed104276a13e7024cffc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af60a3b6149315d98468c34fc144d93a1" id="r_af60a3b6149315d98468c34fc144d93a1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af60a3b6149315d98468c34fc144d93a1">actions_after_remove_edges</a> (const <a class="el" href="namespacelal.html#ab98936b00d896700a71899dff1ed9248">edge_list</a> &amp;e) noexcept</td></tr>
<tr class="memdesc:af60a3b6149315d98468c34fc144d93a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do some extra work after the removal of several edges.  <br /></td></tr>
<tr class="separator:af60a3b6149315d98468c34fc144d93a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89d0c4e8dff527470d7ea96f75726756" id="r_a89d0c4e8dff527470d7ea96f75726756"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a89d0c4e8dff527470d7ea96f75726756">actions_after_remove_edges_bulk</a> () noexcept</td></tr>
<tr class="memdesc:a89d0c4e8dff527470d7ea96f75726756"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do some extra work after the removal of several edges in bulk.  <br /></td></tr>
<tr class="separator:a89d0c4e8dff527470d7ea96f75726756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc7874bcad8a4ff2c3059b054f2e863b" id="r_afc7874bcad8a4ff2c3059b054f2e863b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afc7874bcad8a4ff2c3059b054f2e863b">actions_before_remove_edges_incident_to</a> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u) noexcept</td></tr>
<tr class="memdesc:afc7874bcad8a4ff2c3059b054f2e863b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do some work before all edges incident to a node is removed.  <br /></td></tr>
<tr class="separator:afc7874bcad8a4ff2c3059b054f2e863b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a703e14070ff7eae72ddc3a4307344605" id="r_a703e14070ff7eae72ddc3a4307344605"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a703e14070ff7eae72ddc3a4307344605">actions_after_remove_node</a> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u) noexcept</td></tr>
<tr class="memdesc:a703e14070ff7eae72ddc3a4307344605"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do some work before the removal of a vertex.  <br /></td></tr>
<tr class="separator:a703e14070ff7eae72ddc3a4307344605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dc067070236fec5b9fe626043732cf0" id="r_a2dc067070236fec5b9fe626043732cf0"><td class="memItemLeft" align="right" valign="top"><a id="a2dc067070236fec5b9fe626043732cf0" name="a2dc067070236fec5b9fe626043732cf0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>copy_full_directed_graph</b> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">directed_graph</a> &amp;d) noexcept</td></tr>
<tr class="memdesc:a2dc067070236fec5b9fe626043732cf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies all members of this class and the parent class. <br /></td></tr>
<tr class="separator:a2dc067070236fec5b9fe626043732cf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1876aab72e9c99dd94ed66b95682db85" id="r_a1876aab72e9c99dd94ed66b95682db85"><td class="memItemLeft" align="right" valign="top"><a id="a1876aab72e9c99dd94ed66b95682db85" name="a1876aab72e9c99dd94ed66b95682db85"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>move_full_directed_graph</b> (<a class="el" href="classlal_1_1graphs_1_1directed__graph.html">directed_graph</a> &amp;&amp;d) noexcept</td></tr>
<tr class="memdesc:a1876aab72e9c99dd94ed66b95682db85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves all members of this class and the parent class. <br /></td></tr>
<tr class="separator:a1876aab72e9c99dd94ed66b95682db85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ea60f01e9535ae965e54b9caa3d08fd" id="r_a0ea60f01e9535ae965e54b9caa3d08fd"><td class="memItemLeft" align="right" valign="top"><a id="a0ea60f01e9535ae965e54b9caa3d08fd" name="a0ea60f01e9535ae965e54b9caa3d08fd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>copy_full_graph</b> (const <a class="el" href="classlal_1_1graphs_1_1graph.html">graph</a> &amp;g) noexcept</td></tr>
<tr class="memdesc:a0ea60f01e9535ae965e54b9caa3d08fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies all members of this class. <br /></td></tr>
<tr class="separator:a0ea60f01e9535ae965e54b9caa3d08fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca19fcaa6d290a97c92ef95df92160ae" id="r_aca19fcaa6d290a97c92ef95df92160ae"><td class="memItemLeft" align="right" valign="top"><a id="aca19fcaa6d290a97c92ef95df92160ae" name="aca19fcaa6d290a97c92ef95df92160ae"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>move_full_graph</b> (<a class="el" href="classlal_1_1graphs_1_1graph.html">graph</a> &amp;&amp;g) noexcept</td></tr>
<tr class="memdesc:aca19fcaa6d290a97c92ef95df92160ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves all members of this class. <br /></td></tr>
<tr class="separator:aca19fcaa6d290a97c92ef95df92160ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb30bc5c7c927a2b32c2db7e0fcfeeee" id="r_aeb30bc5c7c927a2b32c2db7e0fcfeeee"><td class="memItemLeft" align="right" valign="top"><a id="aeb30bc5c7c927a2b32c2db7e0fcfeeee" name="aeb30bc5c7c927a2b32c2db7e0fcfeeee"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>__add_node</b> () noexcept</td></tr>
<tr class="memdesc:aeb30bc5c7c927a2b32c2db7e0fcfeeee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a node to the graph. <br /></td></tr>
<tr class="separator:aeb30bc5c7c927a2b32c2db7e0fcfeeee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2953c51682d770519cac771dc26c77ee" id="r_a2953c51682d770519cac771dc26c77ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1graph.html#a2953c51682d770519cac771dc26c77ee">__disjoint_union</a> (const <a class="el" href="classlal_1_1graphs_1_1graph.html">graph</a> &amp;g) noexcept</td></tr>
<tr class="memdesc:a2953c51682d770519cac771dc26c77ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disjoint union of graphs.  <br /></td></tr>
<tr class="separator:a2953c51682d770519cac771dc26c77ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a697a6199daaf909ae4d4f00ef70768b9" id="r_a697a6199daaf909ae4d4f00ef70768b9"><td class="memItemLeft" align="right" valign="top"><a id="a697a6199daaf909ae4d4f00ef70768b9" name="a697a6199daaf909ae4d4f00ef70768b9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>normalize_after_edge_addition</b> (const bool norm, const bool check) noexcept</td></tr>
<tr class="memdesc:a697a6199daaf909ae4d4f00ef70768b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize the graph after one (or more) edges have been added. <br /></td></tr>
<tr class="separator:a697a6199daaf909ae4d4f00ef70768b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31aee9e64b4839cb154c843c92c52507" id="r_a31aee9e64b4839cb154c843c92c52507"><td class="memItemLeft" align="right" valign="top"><a id="a31aee9e64b4839cb154c843c92c52507" name="a31aee9e64b4839cb154c843c92c52507"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>normalize_after_edge_removal</b> (const bool norm, const bool check) noexcept</td></tr>
<tr class="memdesc:a31aee9e64b4839cb154c843c92c52507"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize the graph after one (or more) edges have been removed. <br /></td></tr>
<tr class="separator:a31aee9e64b4839cb154c843c92c52507"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a0c93720588444d26ed92436bed7fe756" id="r_a0c93720588444d26ed92436bed7fe756"><td class="memItemLeft" align="right" valign="top"><a id="a0c93720588444d26ed92436bed7fe756" name="a0c93720588444d26ed92436bed7fe756"></a>
std::vector&lt; <a class="el" href="namespacelal.html#aef91d923414879a998619e9c65181d1f">neighbourhood</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_in_adjacency_list</b></td></tr>
<tr class="memdesc:a0c93720588444d26ed92436bed7fe756"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-neighbors for every node. <br /></td></tr>
<tr class="separator:a0c93720588444d26ed92436bed7fe756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad87c640988218838def15ea96645bb84" id="r_ad87c640988218838def15ea96645bb84"><td class="memItemLeft" align="right" valign="top"><a id="ad87c640988218838def15ea96645bb84" name="ad87c640988218838def15ea96645bb84"></a>
std::vector&lt; <a class="el" href="namespacelal.html#aef91d923414879a998619e9c65181d1f">neighbourhood</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_adjacency_list</b></td></tr>
<tr class="memdesc:ad87c640988218838def15ea96645bb84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure that implements the graph. <br /></td></tr>
<tr class="separator:ad87c640988218838def15ea96645bb84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a028261ff75ed8e624f4f3fee4e3c5c06" id="r_a028261ff75ed8e624f4f3fee4e3c5c06"><td class="memItemLeft" align="right" valign="top"><a id="a028261ff75ed8e624f4f3fee4e3c5c06" name="a028261ff75ed8e624f4f3fee4e3c5c06"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>m_num_edges</b> = 0</td></tr>
<tr class="memdesc:a028261ff75ed8e624f4f3fee4e3c5c06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Amount of edges of this graph. <br /></td></tr>
<tr class="separator:a028261ff75ed8e624f4f3fee4e3c5c06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a427d63b1bef991f43db8f5d622567bb6" id="r_a427d63b1bef991f43db8f5d622567bb6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1graph.html#a427d63b1bef991f43db8f5d622567bb6">m_is_normalized</a> = true</td></tr>
<tr class="memdesc:a427d63b1bef991f43db8f5d622567bb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this graph normalized?  <br /></td></tr>
<tr class="separator:a427d63b1bef991f43db8f5d622567bb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a49c96337e914f103b8e06d132b42102d" id="r_a49c96337e914f103b8e06d132b42102d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a49c96337e914f103b8e06d132b42102d">remove_single_edge</a> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u, const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> v, <a class="el" href="namespacelal.html#aef91d923414879a998619e9c65181d1f">neighbourhood</a> &amp;out_u, <a class="el" href="namespacelal.html#aef91d923414879a998619e9c65181d1f">neighbourhood</a> &amp;in_v) noexcept</td></tr>
<tr class="memdesc:a49c96337e914f103b8e06d132b42102d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a single edge.  <br /></td></tr>
<tr class="separator:a49c96337e914f103b8e06d132b42102d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Directed graph class. </p>
<p>Class implementing a directed graph, using the adjacency list data structure.</p>
<p>An object of this class must be initialized either with its constructor or with the <a class="el" href="classlal_1_1graphs_1_1graph.html#a0e3529632b38533c4be8b2a306a038c3">init</a> method. Edges can then be added one by one (see <a class="el" href="#ad4fd30bc89da5485d2938ae9809d4dac">add_edge</a>) or all at the same time (see <a class="el" href="#a211ff1b1441b0c27b1e1dfed8514eed7">add_edges</a>). </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac6e21e83c3edf8cbb2aa7dc0651d32ab" name="ac6e21e83c3edf8cbb2aa7dc0651d32ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6e21e83c3edf8cbb2aa7dc0651d32ab">&#9670;&#160;</a></span>directed_graph() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">lal::graphs::directed_graph::directed_graph </td>
          <td>(</td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor with number of nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of nodes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a30bac2d9e40d0cbc05d211293f3dcea3" name="a30bac2d9e40d0cbc05d211293f3dcea3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30bac2d9e40d0cbc05d211293f3dcea3">&#9670;&#160;</a></span>directed_graph() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">lal::graphs::directed_graph::directed_graph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">directed_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Directed graph. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad17b0a80146cdc740fb075d3801f86aa" name="ad17b0a80146cdc740fb075d3801f86aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad17b0a80146cdc740fb075d3801f86aa">&#9670;&#160;</a></span>directed_graph() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">lal::graphs::directed_graph::directed_graph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlal_1_1graphs_1_1directed__graph.html">directed_graph</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Directed graph. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a2953c51682d770519cac771dc26c77ee" name="a2953c51682d770519cac771dc26c77ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2953c51682d770519cac771dc26c77ee">&#9670;&#160;</a></span>__disjoint_union()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::graph::__disjoint_union </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1graph.html">graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disjoint union of graphs. </p>
<p>Given a graph, append it to the current graph.</p>
<p>All the nodes in <em>g</em> are relabelled starting at <em>n</em>, the number of nodes of the current graph. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>This graph and <em>g</em> must be of the same type (both must be either undirected, or both directed). </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The graph is normalized only if it was normalized before the call and <em>g</em> is also normalized. </dd></dl>

</div>
</div>
<a id="a3d94bc0b0b7d824c714e6980ddc5f6de" name="a3d94bc0b0b7d824c714e6980ddc5f6de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d94bc0b0b7d824c714e6980ddc5f6de">&#9670;&#160;</a></span>_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void lal::graphs::directed_graph::_init </td>
          <td>(</td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the memory in the graph hierarchy. </p>
<p>Initializes memory of <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">lal::graphs::directed_graph</a> and <a class="el" href="classlal_1_1graphs_1_1graph.html">lal::graphs::graph</a> classes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of nodes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The graph is cleared. </dd></dl>

<p>Reimplemented from <a class="el" href="classlal_1_1graphs_1_1graph.html#aad95568f8b3a8ac76edfabd8581fa455">lal::graphs::graph</a>.</p>

<p>Reimplemented in <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#ae644f013789ff98bcb57284059f89738">lal::graphs::rooted_tree</a>.</p>

</div>
</div>
<a id="ac0cf22c45fc8d6a3c5cd29e00af7b9df" name="ac0cf22c45fc8d6a3c5cd29e00af7b9df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0cf22c45fc8d6a3c5cd29e00af7b9df">&#9670;&#160;</a></span>actions_after_add_edge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void lal::graphs::directed_graph::actions_after_add_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do some extra work after the addition of an edge. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>Node of the edge </td></tr>
    <tr><td class="paramname">v</td><td>Node of the edge </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classlal_1_1graphs_1_1graph.html#a82d1dd3ec710c4ccf60100298a6cb5a1">lal::graphs::graph</a>.</p>

<p>Reimplemented in <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#a1b6c5b10032d6486657af65fa1efb469">lal::graphs::rooted_tree</a>.</p>

</div>
</div>
<a id="a20e37ab891e53364f706f157695eda33" name="a20e37ab891e53364f706f157695eda33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20e37ab891e53364f706f157695eda33">&#9670;&#160;</a></span>actions_after_add_edges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void lal::graphs::directed_graph::actions_after_add_edges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ab98936b00d896700a71899dff1ed9248">edge_list</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do some extra work after the addition of several edges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>List of edges. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classlal_1_1graphs_1_1graph.html#ac0f77ff1a0513b0d2edd30e443e21a66">lal::graphs::graph</a>.</p>

<p>Reimplemented in <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#a43f819b53ca12050c9afd4f7876706ae">lal::graphs::rooted_tree</a>.</p>

</div>
</div>
<a id="a39ea733e148d29496a6db24189788d1d" name="a39ea733e148d29496a6db24189788d1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39ea733e148d29496a6db24189788d1d">&#9670;&#160;</a></span>actions_after_add_edges_bulk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void lal::graphs::directed_graph::actions_after_add_edges_bulk </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do some extra work after the addition of several edges in bulk. </p>
<p>This method should only be called after several calls to <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html#a3d9454ddfaef55219be3ef00ecac1189">undirected_graph::add_edge_bulk</a> or <a class="el" href="#a2867b035b48ab54df5f60e3b065fea66">directed_graph::add_edge_bulk</a>. </p>

<p>Reimplemented from <a class="el" href="classlal_1_1graphs_1_1graph.html#a90f34e52de222e529126803ee46be312">lal::graphs::graph</a>.</p>

<p>Reimplemented in <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#a1c44f4a3b405b2140a21d221b85ab790">lal::graphs::rooted_tree</a>.</p>

</div>
</div>
<a id="a2fb2e27dacaed104276a13e7024cffc9" name="a2fb2e27dacaed104276a13e7024cffc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fb2e27dacaed104276a13e7024cffc9">&#9670;&#160;</a></span>actions_after_remove_edge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void lal::graphs::directed_graph::actions_after_remove_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do some extra work after the removal of an edge. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>Node of the edge </td></tr>
    <tr><td class="paramname">v</td><td>Node of the edge </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classlal_1_1graphs_1_1graph.html#a98d5b515434333420d3c0383118a40e9">lal::graphs::graph</a>.</p>

<p>Reimplemented in <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#a7a11bc77f5a58f731d76e51f013b8195">lal::graphs::rooted_tree</a>.</p>

</div>
</div>
<a id="af60a3b6149315d98468c34fc144d93a1" name="af60a3b6149315d98468c34fc144d93a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af60a3b6149315d98468c34fc144d93a1">&#9670;&#160;</a></span>actions_after_remove_edges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void lal::graphs::directed_graph::actions_after_remove_edges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ab98936b00d896700a71899dff1ed9248">edge_list</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do some extra work after the removal of several edges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>List of edges. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classlal_1_1graphs_1_1graph.html#a956070ceaa53f3f27782e93ee789b52d">lal::graphs::graph</a>.</p>

<p>Reimplemented in <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#a87f919e3637ce545101bd901ebf71a13">lal::graphs::rooted_tree</a>.</p>

</div>
</div>
<a id="a89d0c4e8dff527470d7ea96f75726756" name="a89d0c4e8dff527470d7ea96f75726756"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89d0c4e8dff527470d7ea96f75726756">&#9670;&#160;</a></span>actions_after_remove_edges_bulk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void lal::graphs::directed_graph::actions_after_remove_edges_bulk </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do some extra work after the removal of several edges in bulk. </p>
<p>This method should only be called after several calls to <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html#a741081cc0646053bcb5fd5809eb19a21">undirected_graph::remove_edge_bulk</a> or <a class="el" href="#a655fbacfd749a62e61933ae19cb647cb">directed_graph::remove_edge_bulk</a>. </p>

<p>Reimplemented from <a class="el" href="classlal_1_1graphs_1_1graph.html#af0652eaa93e528addf994e0a387c89a3">lal::graphs::graph</a>.</p>

<p>Reimplemented in <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#a5948c8e20e5feda6ae81e91a7b57be0e">lal::graphs::rooted_tree</a>.</p>

</div>
</div>
<a id="a703e14070ff7eae72ddc3a4307344605" name="a703e14070ff7eae72ddc3a4307344605"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a703e14070ff7eae72ddc3a4307344605">&#9670;&#160;</a></span>actions_after_remove_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void lal::graphs::directed_graph::actions_after_remove_node </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do some work before the removal of a vertex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>Node to be removed. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classlal_1_1graphs_1_1graph.html#ace7b6a4bfae204ead0ef1a79d4bff84a">lal::graphs::graph</a>.</p>

<p>Reimplemented in <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#a254e29f4c623d83fd3a67738d4ed8068">lal::graphs::rooted_tree</a>.</p>

</div>
</div>
<a id="afc7874bcad8a4ff2c3059b054f2e863b" name="afc7874bcad8a4ff2c3059b054f2e863b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc7874bcad8a4ff2c3059b054f2e863b">&#9670;&#160;</a></span>actions_before_remove_edges_incident_to()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void lal::graphs::directed_graph::actions_before_remove_edges_incident_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do some work before all edges incident to a node is removed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>Node whose incident edges are to be removed. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classlal_1_1graphs_1_1graph.html#a9c27b3db924121cb7c8f739c79de1c81">lal::graphs::graph</a>.</p>

<p>Reimplemented in <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#a02bc84af2dd2eb64d4eac9b21038100d">lal::graphs::rooted_tree</a>.</p>

</div>
</div>
<a id="ad4fd30bc89da5485d2938ae9809d4dac" name="ad4fd30bc89da5485d2938ae9809d4dac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4fd30bc89da5485d2938ae9809d4dac">&#9670;&#160;</a></span>add_edge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">directed_graph</a> &amp; lal::graphs::directed_graph::add_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>norm</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>check_norm</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a directed edge to the graph. </p>
<p>Method <a class="el" href="#ac0cf22c45fc8d6a3c5cd29e00af7b9df">actions_after_add_edge</a> is called after the edge has been added. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Valid node index: \(0 \le s &lt; n\). </td></tr>
    <tr><td class="paramname">t</td><td>Valid node index: \(0 \le t &lt; n\). </td></tr>
    <tr><td class="paramname">norm</td><td>Normalize the graph after the insertion. </td></tr>
    <tr><td class="paramname">check_norm</td><td>If <em>norm</em> is false then, should we check whether the result is normalized or not? This might be useful in case the resulting graph is normalized. If <em>norm</em> is true then <em>check_norm</em> is ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>\(u \neq v\). The directed edge \((s,t)\) is not part of the graph. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>If <em>norm</em> is true the graph is guaranteed to be normalized after the addition of the edge. </dd></dl>

<p>Reimplemented in <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#a49939ad6dffc54cd4d58bc1506f28f6b">lal::graphs::rooted_tree</a>.</p>

</div>
</div>
<a id="a2867b035b48ab54df5f60e3b065fea66" name="a2867b035b48ab54df5f60e3b065fea66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2867b035b48ab54df5f60e3b065fea66">&#9670;&#160;</a></span>add_edge_bulk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1graphs_1_1directed__graph.html">directed_graph</a> &amp; lal::graphs::directed_graph::add_edge_bulk </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an edge to the graph. </p>
<p>This method only adds an edge, and does no other work: normalisation is not checked, and no extra work per edge is done. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Valid node index: \(0 \le s &lt; n\). </td></tr>
    <tr><td class="paramname">t</td><td>Valid node index: \(0 \le t &lt; n\). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>\(u \neq v\). </dd>
<dd>
The edge \(\{s,t\}\) is not part of the graph. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>If <em>norm</em> is true the graph is guaranteed to be normalized after the addition of the edge. </dd></dl>

</div>
</div>
<a id="a211ff1b1441b0c27b1e1dfed8514eed7" name="a211ff1b1441b0c27b1e1dfed8514eed7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a211ff1b1441b0c27b1e1dfed8514eed7">&#9670;&#160;</a></span>add_edges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">directed_graph</a> &amp; lal::graphs::directed_graph::add_edges </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacelal.html#a5969ec7ecc85697ebb9ec0ace78fbcab">edge</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>edges</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>norm</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>check_norm</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a list of directed edges to the graph. </p>
<p>This operation is faster than adding edges one by one with <a class="el" href="#ad4fd30bc89da5485d2938ae9809d4dac">add_edge</a> since the edges are added in bulk. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edges</td><td>The edges to be added. </td></tr>
    <tr><td class="paramname">norm</td><td>Normalize the graph after the insertions. </td></tr>
    <tr><td class="paramname">check_norm</td><td>If <em>norm</em> is false then, should we check whether the result is normalized or not? This might be useful in case the resulting graph is normalized. If <em>norm</em> is true then <em>check_norm</em> is ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>All the edges in <em>edges</em> must meet the precondition of method <a class="el" href="#ad4fd30bc89da5485d2938ae9809d4dac">add_edge(node,node,bool,bool)</a>. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>If <em>norm</em> is true the graph is guaranteed to be normalized after the addition of the edge. </dd></dl>

<p>Reimplemented in <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#a48e3d3f8b72122e829616edeeee05dfb">lal::graphs::rooted_tree</a>.</p>

</div>
</div>
<a id="a23b10c47032b774696a5ed970b059cdb" name="a23b10c47032b774696a5ed970b059cdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23b10c47032b774696a5ed970b059cdb">&#9670;&#160;</a></span>check_normalized()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::graphs::directed_graph::check_normalized </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the graph is normalized. </p>
<p>Checks, whether the graph's adjacency structure is normalized or not. In case it is, attribute <a class="el" href="classlal_1_1graphs_1_1graph.html#a427d63b1bef991f43db8f5d622567bb6">m_is_normalized</a> is set to true, so method <a class="el" href="classlal_1_1graphs_1_1graph.html#abb9238eb8914e145736f1ac914f6b9d6">is_normalized</a> evaluates to true. </p>

<p>Reimplemented from <a class="el" href="classlal_1_1graphs_1_1graph.html#a0beca99dbbaa1a1a27db6c4e2d280ea5">lal::graphs::graph</a>.</p>

</div>
</div>
<a id="af8ba9ec6acf2306c84d9ddbd88fc8474" name="af8ba9ec6acf2306c84d9ddbd88fc8474"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8ba9ec6acf2306c84d9ddbd88fc8474">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void lal::graphs::graph::clear </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Frees the memory occupied by this graph. </p>
<p>See <a class="el" href="#a59e0515f2b02a576e10289a633ada49d">_clear</a> for details. </p><dl class="section post"><dt>Postcondition</dt><dd>The graph is normalized. The number of edges is 0. </dd></dl>

</div>
</div>
<a id="ac333b30d221d8c5da985b09247d6e09c" name="ac333b30d221d8c5da985b09247d6e09c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac333b30d221d8c5da985b09247d6e09c">&#9670;&#160;</a></span>disjoint_union()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1graphs_1_1directed__graph.html">directed_graph</a> &amp; lal::graphs::directed_graph::disjoint_union </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">directed_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disjoint union of graphs. </p>
<p>Given a graph, append it to the current graph.</p>
<p>All the nodes in <em>g</em> are relabelled starting at <em>n</em>, the number of nodes of the current graph. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>The graph is normalized only if it was normalized before the call and <em>g</em> is also normalized. </dd></dl>

</div>
</div>
<a id="a21efb8e78ed211739b6d355bbfd29ad6" name="a21efb8e78ed211739b6d355bbfd29ad6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21efb8e78ed211739b6d355bbfd29ad6">&#9670;&#160;</a></span>finish_bulk_add()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::directed_graph::finish_bulk_add </td>
          <td>(</td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>norm</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>check</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Completes the inner structure of the graph after adding a bulk of edges. </p>
<p>This is meant to be used after several calls to <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html#a3d9454ddfaef55219be3ef00ecac1189">undirected_graph::add_edge_bulk</a>, <a class="el" href="#a2867b035b48ab54df5f60e3b065fea66">directed_graph::add_edge_bulk</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">norm</td><td>Normalize the graph. </td></tr>
    <tr><td class="paramname">check</td><td>Check wether the graph is normalized or not. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classlal_1_1graphs_1_1graph.html#af01a3a104e9b5b62ef385df4cb6a1bff">lal::graphs::graph</a>.</p>

<p>Reimplemented in <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#a01453a5f86572b1d6097cf9a1067e73c">lal::graphs::rooted_tree</a>.</p>

</div>
</div>
<a id="a890ef15b90aefcda8c6aba36f48a6f8e" name="a890ef15b90aefcda8c6aba36f48a6f8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a890ef15b90aefcda8c6aba36f48a6f8e">&#9670;&#160;</a></span>finish_bulk_remove()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::directed_graph::finish_bulk_remove </td>
          <td>(</td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>norm</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>check</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Completes the inner structure of the graph after removing edges in bulk. </p>
<p>This is meant to be used after several calls to <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html#a741081cc0646053bcb5fd5809eb19a21">undirected_graph::remove_edge_bulk</a>, <a class="el" href="#a655fbacfd749a62e61933ae19cb647cb">directed_graph::remove_edge_bulk</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">norm</td><td>Normalize the graph. </td></tr>
    <tr><td class="paramname">check</td><td>Check wether the graph is normalized or not. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classlal_1_1graphs_1_1graph.html#a3887a16f8193383c971bef9c35b6b700">lal::graphs::graph</a>.</p>

<p>Reimplemented in <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#aa6a62c89130506333d5a7edd221ec5fd">lal::graphs::rooted_tree</a>.</p>

</div>
</div>
<a id="a3153114956055fc2e0a801a9418d2ecd" name="a3153114956055fc2e0a801a9418d2ecd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3153114956055fc2e0a801a9418d2ecd">&#9670;&#160;</a></span>get_degree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lal::graphs::directed_graph::get_degree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the in-degree plus the out-degree of this vertex. </p>
<p>Returns the degree of this vertex in its underlying undirected structure. Same as <a class="el" href="#aad08168cf9fd02b362013916bf308210">get_in_degree</a> + <a class="el" href="#a24cc0db004249dbb192698454d4ce78f">get_out_degree</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>Vertex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The (in + out) degree of this vertex. </dd></dl>

</div>
</div>
<a id="a6bd3b9aaaab43d22af76dea13c4c8371" name="a6bd3b9aaaab43d22af76dea13c4c8371"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bd3b9aaaab43d22af76dea13c4c8371">&#9670;&#160;</a></span>get_in_neighbors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacelal.html#aef91d923414879a998619e9c65181d1f">neighbourhood</a> &amp; lal::graphs::directed_graph::get_in_neighbors </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the in-neighbors of node <em>u</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>Node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The list of nodes entering at node <em>u</em>. </dd></dl>

</div>
</div>
<a id="a94834a6fb04411d06eda59f998d2ff02" name="a94834a6fb04411d06eda59f998d2ff02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94834a6fb04411d06eda59f998d2ff02">&#9670;&#160;</a></span>get_out_neighbors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacelal.html#aef91d923414879a998619e9c65181d1f">neighbourhood</a> &amp; lal::graphs::directed_graph::get_out_neighbors </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the out-neighbors of node <em>u</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>Node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The list of nodes leaving node <em>u</em>. </dd></dl>

</div>
</div>
<a id="a116071bf1763e9454e1fc047b6c236d8" name="a116071bf1763e9454e1fc047b6c236d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a116071bf1763e9454e1fc047b6c236d8">&#9670;&#160;</a></span>get_Q()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespacelal.html#a235d5351556fbc73aa51767ab7765f5c">edge_pair</a> &gt; lal::graphs::directed_graph::get_Q </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns all independent pairs of edges of this graph. </p>
<p>The set \(Q(G)\) is defined as the pairs of edges of \(G\), \(E(G) \times E(G)\), that are independent, that is, that share no nodes. </p>

<p>Implements <a class="el" href="classlal_1_1graphs_1_1graph.html#a91155aa7578956540e8811aa896d06c5">lal::graphs::graph</a>.</p>

</div>
</div>
<a id="a0e3529632b38533c4be8b2a306a038c3" name="a0e3529632b38533c4be8b2a306a038c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e3529632b38533c4be8b2a306a038c3">&#9670;&#160;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void lal::graphs::graph::init </td>
          <td>(</td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates the necessary memory for this class. </p>
<p>See <a class="el" href="#a3d94bc0b0b7d824c714e6980ddc5f6de">_init</a> for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of nodes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abb9238eb8914e145736f1ac914f6b9d6" name="abb9238eb8914e145736f1ac914f6b9d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb9238eb8914e145736f1ac914f6b9d6">&#9670;&#160;</a></span>is_normalized()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::graphs::graph::is_normalized </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether this graph is normalized or not. </p>
<p>A graph is normalized if every node's adjacency list is sorted increasingly. For this, use method <a class="el" href="#a4e4a81d38587995cb990e21e28aaf2b4">normalize()</a>. </p><dl class="section return"><dt>Returns</dt><dd>The value of <a class="el" href="classlal_1_1graphs_1_1graph.html#a427d63b1bef991f43db8f5d622567bb6">m_is_normalized</a>. </dd></dl>

</div>
</div>
<a id="a4e4a81d38587995cb990e21e28aaf2b4" name="a4e4a81d38587995cb990e21e28aaf2b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e4a81d38587995cb990e21e28aaf2b4">&#9670;&#160;</a></span>normalize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::directed_graph::normalize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Normalizes the graph. </p>
<p>Sorts this graph's adjacency list structure in increasing order.</p>
<p>Besides expensive, this method may be unnecessary. Method <a class="el" href="#a23b10c47032b774696a5ed970b059cdb">check_normalized()</a> checks whether the graph is normalized or not; in case it is, using this method is completely unnecessary. </p><dl class="section post"><dt>Postcondition</dt><dd>Method <a class="el" href="classlal_1_1graphs_1_1graph.html#abb9238eb8914e145736f1ac914f6b9d6">is_normalized</a> evaluates to true. </dd></dl>

<p>Reimplemented from <a class="el" href="classlal_1_1graphs_1_1graph.html#abe2c7decb104857bd857c769feb75c98">lal::graphs::graph</a>.</p>

</div>
</div>
<a id="a888fe135207a80aafe845745d9572a54" name="a888fe135207a80aafe845745d9572a54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a888fe135207a80aafe845745d9572a54">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1graphs_1_1directed__graph.html">directed_graph</a> &amp; lal::graphs::directed_graph::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">directed_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Directed graph. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a06739e9f21f81528e39bf780efdb43" name="a4a06739e9f21f81528e39bf780efdb43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a06739e9f21f81528e39bf780efdb43">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1graphs_1_1directed__graph.html">directed_graph</a> &amp; lal::graphs::directed_graph::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlal_1_1graphs_1_1directed__graph.html">directed_graph</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Directed graph. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2fdfa075c6d181f49640d30530f87dab" name="a2fdfa075c6d181f49640d30530f87dab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fdfa075c6d181f49640d30530f87dab">&#9670;&#160;</a></span>remove_edge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">directed_graph</a> &amp; lal::graphs::directed_graph::remove_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>norm</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>check_norm</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove an edge from this graph. </p>
<p>Method <a class="el" href="#a2fb2e27dacaed104276a13e7024cffc9">actions_after_remove_edge</a> is called after the edge has been removed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Valid node index: \(0 \le s &lt; n\). </td></tr>
    <tr><td class="paramname">t</td><td>Valid node index: \(0 \le t &lt; n\). </td></tr>
    <tr><td class="paramname">norm</td><td>Normalize the graph after the deletion. </td></tr>
    <tr><td class="paramname">check_norm</td><td>If <em>norm</em> is false then, should we check whether the result is normalized or not? This might be useful in case the resulting graph is normalized. If <em>norm</em> is true then <em>check_norm</em> is ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The edge must exist. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>If <em>norm</em> is true the graph is guaranteed to be normalized after the addition of the edge. </dd></dl>

<p>Reimplemented in <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#ac2b76c9b017ba87d0458b8a3bf89cc77">lal::graphs::rooted_tree</a>.</p>

</div>
</div>
<a id="a655fbacfd749a62e61933ae19cb647cb" name="a655fbacfd749a62e61933ae19cb647cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a655fbacfd749a62e61933ae19cb647cb">&#9670;&#160;</a></span>remove_edge_bulk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">directed_graph</a> &amp; lal::graphs::directed_graph::remove_edge_bulk </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes an edge from the graph. </p>
<p>This method only removes an edge, and does no other work: normalisation is not checked, and no extra work per edge is done. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Valid node index: \(0 \le s &lt; n\). </td></tr>
    <tr><td class="paramname">t</td><td>Valid node index: \(0 \le t &lt; n\). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>\(u \neq v\). </dd>
<dd>
The edge \(\{s,t\}\) is part of the graph. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>If <em>norm</em> is true the graph is guaranteed to be normalized after the removal of the edge. </dd></dl>

<p>Reimplemented in <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#a34fc00e1d6e5e84b480dfaaab9ab69e9">lal::graphs::rooted_tree</a>.</p>

</div>
</div>
<a id="a859d69232a66987307b4fb67c9d36885" name="a859d69232a66987307b4fb67c9d36885"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a859d69232a66987307b4fb67c9d36885">&#9670;&#160;</a></span>remove_edges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">directed_graph</a> &amp; lal::graphs::directed_graph::remove_edges </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacelal.html#a5969ec7ecc85697ebb9ec0ace78fbcab">edge</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>edges</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>norm</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>check_norm</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove an edge from this graph. </p>
<p>This operation is faster than removing edges one by one with <a class="el" href="#a2fdfa075c6d181f49640d30530f87dab">remove_edge</a> since the edges are removed in bulk. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edges</td><td>The edges to be deleted. </td></tr>
    <tr><td class="paramname">norm</td><td>Normalize the graph after the deletion. </td></tr>
    <tr><td class="paramname">check_norm</td><td>If <em>norm</em> is false then, should we check whether the result is normalized or not? This might be useful in case the resulting graph is normalized. If <em>norm</em> is true then <em>check_norm</em> is ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>All the edges in <em>edges</em> must meet the precondition of method <a class="el" href="#ad4fd30bc89da5485d2938ae9809d4dac">add_edge(node,node,bool,bool)</a>. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>If <em>norm</em> is true the graph is guaranteed to be normalized after the addition of the edge. </dd></dl>

<p>Reimplemented in <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#a3fb10a4c13c5c9fc6c082f1513844330">lal::graphs::rooted_tree</a>.</p>

</div>
</div>
<a id="a87ac6566448b6aaa20a1ed892c480e35" name="a87ac6566448b6aaa20a1ed892c480e35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87ac6566448b6aaa20a1ed892c480e35">&#9670;&#160;</a></span>remove_edges_incident_to()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">directed_graph</a> &amp; lal::graphs::directed_graph::remove_edges_incident_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>norm</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>check_norm</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove all edges incident to a given vertex. </p>
<p>This operation is faster than removing edges one by one with <a class="el" href="#a2fdfa075c6d181f49640d30530f87dab">remove_edge</a> since the edges are removed in bulk.</p>
<p>Method <a class="el" href="#a2fb2e27dacaed104276a13e7024cffc9">actions_after_remove_edge</a> is called after each edge has been removed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>The node whose incident vertices are to be removed. </td></tr>
    <tr><td class="paramname">norm</td><td>Normalize the graph after the deletion. </td></tr>
    <tr><td class="paramname">check_norm</td><td>If <em>norm</em> is false then, should we check whether the result is normalized or not? This might be useful in case the resulting graph is normalized. If <em>norm</em> is true then <em>check_norm</em> is ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>If <em>norm</em> is true the graph is guaranteed to be normalized after the addition of the edge. </dd></dl>

<p>Reimplemented in <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#a87fe72ad0fd7894f19cb31883335682c">lal::graphs::rooted_tree</a>.</p>

</div>
</div>
<a id="aae3aa64a0f37563dbb8b9473eeba7ced" name="aae3aa64a0f37563dbb8b9473eeba7ced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae3aa64a0f37563dbb8b9473eeba7ced">&#9670;&#160;</a></span>remove_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">directed_graph</a> &amp; lal::graphs::directed_graph::remove_node </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>norm</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>check_norm</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a node from this graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>Valid node index: \(0 \le u &lt; n\). </td></tr>
    <tr><td class="paramname">norm</td><td>Normalize the graph after the deletion. </td></tr>
    <tr><td class="paramname">check_norm</td><td>If <em>norm</em> is false then, should we check whether the result is normalized or not? This might be useful in case the resulting graph is normalized. If <em>norm</em> is true then <em>check_norm</em> is ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The node must exist. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>If <em>norm</em> is true the graph is guaranteed to be normalized after the addition of the edge. </dd></dl>

<p>Reimplemented in <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#aae3aa64a0f37563dbb8b9473eeba7ced">lal::graphs::rooted_tree</a>.</p>

</div>
</div>
<a id="a49c96337e914f103b8e06d132b42102d" name="a49c96337e914f103b8e06d132b42102d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49c96337e914f103b8e06d132b42102d">&#9670;&#160;</a></span>remove_single_edge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::directed_graph::remove_single_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelal.html#aef91d923414879a998619e9c65181d1f">neighbourhood</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>out_u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelal.html#aef91d923414879a998619e9c65181d1f">neighbourhood</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>in_v</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a single edge. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>First node of edge. </td></tr>
    <tr><td class="paramname">v</td><td>Second node of edge. </td></tr>
    <tr><td class="paramname">out_u</td><td>Out-neighbourhood of node <em>u</em>. </td></tr>
    <tr><td class="paramname">in_v</td><td>In-neighbourhood of node <em>v</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3a97b71616cedb7523b1ee712c30e4c1" name="a3a97b71616cedb7523b1ee712c30e4c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a97b71616cedb7523b1ee712c30e4c1">&#9670;&#160;</a></span>reserve_in_degree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::directed_graph::reserve_in_degree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>d</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Predicts that the in-degree of node <em>u</em> is <em>d</em>. </p>
<p>Memory of size <em>d</em> is reserved so that adding edges is done more efficiently. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>Node to reserve the degree for. </td></tr>
    <tr><td class="paramname">d</td><td>The amount of memory to reserve. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The graph must have been initialized. </dd></dl>

</div>
</div>
<a id="ad5f661e1f74f01757e0fb980aaf77562" name="ad5f661e1f74f01757e0fb980aaf77562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5f661e1f74f01757e0fb980aaf77562">&#9670;&#160;</a></span>reserve_out_degree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::directed_graph::reserve_out_degree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>d</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Predicts that the out-degree of node <em>u</em> is <em>d</em>. </p>
<p>Memory of size <em>d</em> is reserved so that adding edges is done more efficiently. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>Node to reserve the degree for. </td></tr>
    <tr><td class="paramname">d</td><td>The amount of memory to reserve. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The graph must have been initialized. </dd></dl>

</div>
</div>
<a id="a5ede56b5930ab3758ab55a81243743d6" name="a5ede56b5930ab3758ab55a81243743d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ede56b5930ab3758ab55a81243743d6">&#9670;&#160;</a></span>set_edges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">directed_graph</a> &amp; lal::graphs::directed_graph::set_edges </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacelal.html#a5969ec7ecc85697ebb9ec0ace78fbcab">edge</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>edges</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>norm</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>check_norm</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the list of edges to the graph. </p>
<p>Sets the edges of this graph assuming that the nodes indexed in the list are, at most, the number of nodes of this graph.</p>
<p>This list of edges is assumed to be all the edges that are going to be added to this graph. This means that the internal data structures are constructed more efficiently than when adding edges one by one (see <a class="el" href="#ad4fd30bc89da5485d2938ae9809d4dac">add_edge</a>) or in several chunks (see <a class="el" href="#a211ff1b1441b0c27b1e1dfed8514eed7">add_edges</a>).</p>
<p>Moreover, the current structure of the graph is cleared before setting the new edges. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edges</td><td>The edges to be added. </td></tr>
    <tr><td class="paramname">norm</td><td>Normalize the graph after the insertions. </td></tr>
    <tr><td class="paramname">check_norm</td><td>If <em>norm</em> is false then, should we check whether the result is normalized or not? This might be useful in case the resulting graph is normalized. If <em>norm</em> is true then <em>check_norm</em> is ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The graph has been initialized with as many nodes as vertices in the list of edges. </dd>
<dd>
There are no repeated edges in the list. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>If <em>norm</em> is true the graph is guaranteed to be normalized after the addition of the edge. </dd></dl>

<p>Reimplemented in <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#af22c28ef3cc6dec9e2952f7ed943221d">lal::graphs::rooted_tree</a>.</p>

</div>
</div>
<a id="ad7bfd2d96d5110a7bf0d56c4df1618fd" name="ad7bfd2d96d5110a7bf0d56c4df1618fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7bfd2d96d5110a7bf0d56c4df1618fd">&#9670;&#160;</a></span>to_undirected()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">undirected_graph</a> lal::graphs::directed_graph::to_undirected </td>
          <td>(</td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>norm</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>check</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts this directed graph into an undirected graph. </p>
<p>The undirected graph returned connects two vertices \(u,v\) if these two vertices are connected by a directed edge ( \((u,v)\) or \((v,u)\)) in this graph. In other words, if two vertices are connected by a single directed edge, the direction is dropped. If two edges are connected by two directed edges (of opposite directions) then the two are merged into a single undirected edge. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">norm</td><td>Normalize the graph. </td></tr>
    <tr><td class="paramname">check</td><td>Chech whether the resulting graph is normalized or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This graph in which the edges are undirected. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a427d63b1bef991f43db8f5d622567bb6" name="a427d63b1bef991f43db8f5d622567bb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a427d63b1bef991f43db8f5d622567bb6">&#9670;&#160;</a></span>m_is_normalized</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::graphs::graph::m_is_normalized = true</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this graph normalized? </p>
<p>An undirected graph is normalized iff every node's adjacency list is sorted in increasing order.</p>
<p>In directed graphs, however, it is necessary that the adjacency lists of the out-neighbors and in-neighbors of nodes be sorted.</p>
<p>This attribute is set to 'true' in all graph's initialisation and destruction (when <a class="el" href="classlal_1_1graphs_1_1graph.html#af8ba9ec6acf2306c84d9ddbd88fc8474">clear()</a> method is called). </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>lal/graphs/<a class="el" href="directed__graph_8hpp_source.html">directed_graph.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
