<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LAL: Linear Arrangement Library: lal::detail Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">LAL: Linear Arrangement Library<span id="projectnumber">&#160;24.10.00</span>
   </div>
   <div id="projectbrief">A library focused on algorithms on linear arrangements of graphs.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacelal.html">lal</a></li><li class="navelem"><a class="el" href="namespacelal_1_1detail.html">detail</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">lal::detail Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Detail namespace.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail_1_1bipartite__opt__utils.html">bipartite_opt_utils</a></td></tr>
<tr class="memdesc:namespacelal_1_1detail_1_1bipartite__opt__utils"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utilities for the various optimal linear arrangement algorithms. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail_1_1crossings.html">crossings</a></td></tr>
<tr class="memdesc:namespacelal_1_1detail_1_1crossings"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace for the algorithms that compute the number of crossings. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail_1_1DMax.html">DMax</a></td></tr>
<tr class="memdesc:namespacelal_1_1detail_1_1DMax"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace for algorithms to calculate the maximum sum of edge lengths. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail_1_1DMax__utils.html">DMax_utils</a></td></tr>
<tr class="memdesc:namespacelal_1_1detail_1_1DMax__utils"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utilities for the various maximum linear arrangement algorithms. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail_1_1Dmin.html">Dmin</a></td></tr>
<tr class="memdesc:namespacelal_1_1detail_1_1Dmin"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace for algorithms to calculate the minimum sum of edge lengths. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail_1_1Dmin__utils.html">Dmin_utils</a></td></tr>
<tr class="memdesc:namespacelal_1_1detail_1_1Dmin__utils"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utilities for the various minimum linear arrangement algorithms. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail_1_1Dopt__utils.html">Dopt_utils</a></td></tr>
<tr class="memdesc:namespacelal_1_1detail_1_1Dopt__utils"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utilities for the various optimal linear arrangement algorithms. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail_1_1maximum__subtrees.html">maximum_subtrees</a></td></tr>
<tr class="memdesc:namespacelal_1_1detail_1_1maximum__subtrees"><td class="mdescLeft">&#160;</td><td class="mdescRight">Algorithms to find maximum subtrees. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelal_1_1detail_1_1sorting.html">sorting</a></td></tr>
<tr class="memdesc:namespacelal_1_1detail_1_1sorting"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorting algorithms. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1detail_1_1arrangement__wrapper.html">arrangement_wrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper to easily use identity arrangements.  <a href="classlal_1_1detail_1_1arrangement__wrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlal_1_1detail_1_1array.html">array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper of a C array for automatic deallocation of memory.  <a href="structlal_1_1detail_1_1array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1detail_1_1AVL.html">AVL</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple class that implements an <a class="el" href="classlal_1_1detail_1_1AVL.html" title="Simple class that implements an AVL tree.">AVL</a> tree.  <a href="classlal_1_1detail_1_1AVL.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1detail_1_1BFS.html">BFS</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract graph Breadth-First Search traversal.  <a href="classlal_1_1detail_1_1BFS.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlal_1_1detail_1_1bool__sequence.html">bool_sequence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sequence of Boolean values.  <a href="structlal_1_1detail_1_1bool__sequence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1detail_1_1chunks__Anderson.html">chunks_Anderson</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of Anderson's algorithm for chunking.  <a href="classlal_1_1detail_1_1chunks__Anderson.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1detail_1_1chunks__generic.html">chunks_generic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic algorithms existent in every definition of chunking.  <a href="classlal_1_1detail_1_1chunks__generic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1detail_1_1chunks__Macutek.html">chunks_Macutek</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of Mačutek's algorithm for chunking.  <a href="classlal_1_1detail_1_1chunks__Macutek.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlal_1_1detail_1_1conditional__list.html">conditional_list</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generalization of std::conditional_list.  <a href="structlal_1_1detail_1_1conditional__list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlal_1_1detail_1_1edge__size.html">edge_size</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct used in many algorithms to sort edges according to some integer value.  <a href="structlal_1_1detail_1_1edge__size.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlal_1_1detail_1_1first__true.html">first_true</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">From a list of Boolean values, find the first that is set to true.  <a href="structlal_1_1detail_1_1first__true.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlal_1_1detail_1_1is__pointer__iterator.html">is_pointer_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decide if a type is a pointer or iterator to another.  <a href="structlal_1_1detail_1_1is__pointer__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlal_1_1detail_1_1ith__type.html">ith_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selection of the ith type of a list of types.  <a href="structlal_1_1detail_1_1ith__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlal_1_1detail_1_1ith__type_3_01ith__idx_00_01type__sequence_3_01Ts_8_8_8_01_4_01_4.html">ith_type&lt; ith_idx, type_sequence&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial template specialization of <a class="el" href="structlal_1_1detail_1_1ith__type.html">ith_type</a> for <a class="el" href="structlal_1_1detail_1_1type__sequence.html">type_sequence</a>.  <a href="structlal_1_1detail_1_1ith__type_3_01ith__idx_00_01type__sequence_3_01Ts_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1detail_1_1level__signature.html">level_signature</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that implements level signatures of an array.  <a href="classlal_1_1detail_1_1level__signature.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlal_1_1detail_1_1node__size.html">node_size</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct used in many algorithms to sort vertices according to some integer value.  <a href="structlal_1_1detail_1_1node__size.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1detail_1_1queue__array.html">queue_array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple array-like fixed-size queue.  <a href="classlal_1_1detail_1_1queue__array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1detail_1_1set__array.html">set_array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A set-like data structure implemented with an array.  <a href="classlal_1_1detail_1_1set__array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlal_1_1detail_1_1type__sequence.html">type_sequence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sequence of types.  <a href="structlal_1_1detail_1_1type__sequence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ad642701e881e843747d1df0960edf7b9" id="r_ad642701e881e843747d1df0960edf7b9"><td class="memItemLeft" align="right" valign="top"><a id="ad642701e881e843747d1df0960edf7b9" name="ad642701e881e843747d1df0960edf7b9"></a>
typedef <a class="el" href="classlal_1_1detail_1_1level__signature.html">level_signature</a>&lt; <a class="el" href="#a802d6fe98fa1e77f474f63f151e8c215a4663c74ba8d3cf8462c5080eeaf3718c">level_signature_type::per_vertex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>level_signature_per_vertex</b></td></tr>
<tr class="memdesc:ad642701e881e843747d1df0960edf7b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A useful typedef for level signatures per vertex. <br /></td></tr>
<tr class="separator:ad642701e881e843747d1df0960edf7b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08d4abf36593cbd2d2c10e54007d3f03" id="r_a08d4abf36593cbd2d2c10e54007d3f03"><td class="memItemLeft" align="right" valign="top"><a id="a08d4abf36593cbd2d2c10e54007d3f03" name="a08d4abf36593cbd2d2c10e54007d3f03"></a>
typedef <a class="el" href="classlal_1_1detail_1_1level__signature.html">level_signature</a>&lt; <a class="el" href="#a802d6fe98fa1e77f474f63f151e8c215af39c97817de5c7bd3f11541c94cbdacb">level_signature_type::per_position</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>level_signature_per_position</b></td></tr>
<tr class="memdesc:a08d4abf36593cbd2d2c10e54007d3f03"><td class="mdescLeft">&#160;</td><td class="mdescRight">A useful typedef for level signatures per position. <br /></td></tr>
<tr class="separator:a08d4abf36593cbd2d2c10e54007d3f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94b315fff0ef08b701cb06c1e4497bbb" id="r_a94b315fff0ef08b701cb06c1e4497bbb"><td class="memTemplParams" colspan="2"><a id="a94b315fff0ef08b701cb06c1e4497bbb" name="a94b315fff0ef08b701cb06c1e4497bbb"></a>
template&lt;typename bool_seq , typename type_seq &gt; </td></tr>
<tr class="memitem:a94b315fff0ef08b701cb06c1e4497bbb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>conditional_list_t</b> = typename <a class="el" href="structlal_1_1detail_1_1conditional__list.html">conditional_list</a>&lt;bool_seq, type_seq&gt;::type</td></tr>
<tr class="memdesc:a94b315fff0ef08b701cb06c1e4497bbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shorthand for <a class="el" href="structlal_1_1detail_1_1conditional__list.html">conditional_list</a>. <br /></td></tr>
<tr class="separator:a94b315fff0ef08b701cb06c1e4497bbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3b1c3238da69b18d7dbe76068b2be30" id="r_ac3b1c3238da69b18d7dbe76068b2be30"><td class="memTemplParams" colspan="2"><a id="ac3b1c3238da69b18d7dbe76068b2be30" name="ac3b1c3238da69b18d7dbe76068b2be30"></a>
template&lt;std::size_t ith_idx, typename... Ts&gt; </td></tr>
<tr class="memitem:ac3b1c3238da69b18d7dbe76068b2be30"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ith_type_t</b> = typename <a class="el" href="structlal_1_1detail_1_1ith__type.html">ith_type</a>&lt;ith_idx, Ts...&gt;::type</td></tr>
<tr class="memdesc:ac3b1c3238da69b18d7dbe76068b2be30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shorthand for <a class="el" href="structlal_1_1detail_1_1ith__type.html#a86c0b29a28136adb235759f019209f35">ith_type::type</a>. <br /></td></tr>
<tr class="separator:ac3b1c3238da69b18d7dbe76068b2be30"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a2b1b5c673937cf017e8b8435807a3f03" id="r_a2b1b5c673937cf017e8b8435807a3f03"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b1b5c673937cf017e8b8435807a3f03">arrangement_type</a> { <a class="el" href="#a2b1b5c673937cf017e8b8435807a3f03aff483d1ff591898a9942916050d2ca3f">identity</a>
, <a class="el" href="#a2b1b5c673937cf017e8b8435807a3f03ad674c25b71b5fd0c22b56965b7f58b76">nonidentity</a>
 }</td></tr>
<tr class="memdesc:a2b1b5c673937cf017e8b8435807a3f03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of arrangement.  <a href="#a2b1b5c673937cf017e8b8435807a3f03">More...</a><br /></td></tr>
<tr class="separator:a2b1b5c673937cf017e8b8435807a3f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a802d6fe98fa1e77f474f63f151e8c215" id="r_a802d6fe98fa1e77f474f63f151e8c215"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a802d6fe98fa1e77f474f63f151e8c215">level_signature_type</a> { <a class="el" href="#a802d6fe98fa1e77f474f63f151e8c215a4663c74ba8d3cf8462c5080eeaf3718c">per_vertex</a>
, <a class="el" href="#a802d6fe98fa1e77f474f63f151e8c215af39c97817de5c7bd3f11541c94cbdacb">per_position</a>
 }</td></tr>
<tr class="memdesc:a802d6fe98fa1e77f474f63f151e8c215"><td class="mdescLeft">&#160;</td><td class="mdescRight">Types of level signature.  <a href="#a802d6fe98fa1e77f474f63f151e8c215">More...</a><br /></td></tr>
<tr class="separator:a802d6fe98fa1e77f474f63f151e8c215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47195c004957380992b21cdbb2b43cc9" id="r_a47195c004957380992b21cdbb2b43cc9"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a47195c004957380992b21cdbb2b43cc9">centroid_results</a> { <a class="el" href="#a47195c004957380992b21cdbb2b43cc9ab99249477c8f37e1ad46c4983716d39c">only_one_centroidal</a>
, <a class="el" href="#a47195c004957380992b21cdbb2b43cc9a9ef639b9182eadfee611fc58dd23f9d3">full_centroid</a>
, <a class="el" href="#a47195c004957380992b21cdbb2b43cc9ae6e2f4d15b78cfcbb5a70f39f0d9dda8">full_centroid_plus_subtree_sizes</a>
, <a class="el" href="#a47195c004957380992b21cdbb2b43cc9a454774b2983a333885b75c8845707e38">full_centroid_plus_edge_sizes</a>
 }</td></tr>
<tr class="memdesc:a47195c004957380992b21cdbb2b43cc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The different types of results.  <a href="#a47195c004957380992b21cdbb2b43cc9">More...</a><br /></td></tr>
<tr class="separator:a47195c004957380992b21cdbb2b43cc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad94d3517a86571ef548a7c49e27cbc6b" id="r_ad94d3517a86571ef548a7c49e27cbc6b"><td class="memItemLeft" align="right" valign="top"><a id="ad94d3517a86571ef548a7c49e27cbc6b" name="ad94d3517a86571ef548a7c49e27cbc6b"></a>
<a class="el" href="classlal_1_1detail_1_1arrangement__wrapper.html">arrangement_wrapper</a>&lt; <a class="el" href="#a2b1b5c673937cf017e8b8435807a3f03aff483d1ff591898a9942916050d2ca3f">arrangement_type::identity</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>identity_arr</b> (const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;arr) noexcept</td></tr>
<tr class="memdesc:ad94d3517a86571ef548a7c49e27cbc6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shorthand for an identity arrangement. <br /></td></tr>
<tr class="separator:ad94d3517a86571ef548a7c49e27cbc6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25014e648d810d1a72e7a52d90e3e8a0" id="r_a25014e648d810d1a72e7a52d90e3e8a0"><td class="memItemLeft" align="right" valign="top"><a id="a25014e648d810d1a72e7a52d90e3e8a0" name="a25014e648d810d1a72e7a52d90e3e8a0"></a>
<a class="el" href="classlal_1_1detail_1_1arrangement__wrapper.html">arrangement_wrapper</a>&lt; <a class="el" href="#a2b1b5c673937cf017e8b8435807a3f03ad674c25b71b5fd0c22b56965b7f58b76">arrangement_type::nonidentity</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>nonidentity_arr</b> (const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;arr) noexcept</td></tr>
<tr class="memdesc:a25014e648d810d1a72e7a52d90e3e8a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shorthand for a nonidentity arrangement. <br /></td></tr>
<tr class="separator:a25014e648d810d1a72e7a52d90e3e8a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3a4e75c992cd9209d9b9c7085375001" id="r_af3a4e75c992cd9209d9b9c7085375001"><td class="memTemplParams" colspan="2">template&lt;class container &gt; </td></tr>
<tr class="memitem:af3a4e75c992cd9209d9b9c7085375001"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af3a4e75c992cd9209d9b9c7085375001">make_arrangement_permutations</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;T, const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> r, const container &amp;data, <a class="el" href="namespacelal.html#a5c3f34575ec933a44ed7b6d81e8c75f6">position</a> &amp;pos, <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;arr) noexcept</td></tr>
<tr class="memdesc:af3a4e75c992cd9209d9b9c7085375001"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make an arrangement using permutations.  <br /></td></tr>
<tr class="separator:af3a4e75c992cd9209d9b9c7085375001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a50073a5ef6744e0e15a8ccd85b73fd" id="r_a1a50073a5ef6744e0e15a8ccd85b73fd"><td class="memTemplParams" colspan="2">template&lt;class container &gt; </td></tr>
<tr class="memitem:a1a50073a5ef6744e0e15a8ccd85b73fd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1a50073a5ef6744e0e15a8ccd85b73fd">make_arrangement_permutations</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;T, const container &amp;data) noexcept</td></tr>
<tr class="memdesc:a1a50073a5ef6744e0e15a8ccd85b73fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make an arrangement using permutations.  <br /></td></tr>
<tr class="separator:a1a50073a5ef6744e0e15a8ccd85b73fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41b38d88fe84f185d9fd54d431438724" id="r_a41b38d88fe84f185d9fd54d431438724"><td class="memTemplParams" colspan="2">template&lt;class container &gt; </td></tr>
<tr class="memitem:a41b38d88fe84f185d9fd54d431438724"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a41b38d88fe84f185d9fd54d431438724">make_arrangement_permutations</a> (const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;T, <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> parent, <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u, const container &amp;data, <a class="el" href="namespacelal.html#a5c3f34575ec933a44ed7b6d81e8c75f6">position</a> &amp;pos, <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;arr) noexcept</td></tr>
<tr class="memdesc:a41b38d88fe84f185d9fd54d431438724"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make an arrangement using permutations.  <br /></td></tr>
<tr class="separator:a41b38d88fe84f185d9fd54d431438724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e642d379033a5a82b9a26aed5e1ebcf" id="r_a1e642d379033a5a82b9a26aed5e1ebcf"><td class="memTemplParams" colspan="2">template&lt;class container &gt; </td></tr>
<tr class="memitem:a1e642d379033a5a82b9a26aed5e1ebcf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1e642d379033a5a82b9a26aed5e1ebcf">make_arrangement_permutations</a> (const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;T, <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> root, const container &amp;data) noexcept</td></tr>
<tr class="memdesc:a1e642d379033a5a82b9a26aed5e1ebcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make an arrangement using permutations.  <br /></td></tr>
<tr class="separator:a1e642d379033a5a82b9a26aed5e1ebcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a046facc81651e5b2a0cd92f149b06b8b" id="r_a046facc81651e5b2a0cd92f149b06b8b"><td class="memTemplParams" colspan="2">template&lt;class graph_t &gt; </td></tr>
<tr class="memitem:a046facc81651e5b2a0cd92f149b06b8b"><td class="memTemplItemLeft" align="right" valign="top">graph_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a046facc81651e5b2a0cd92f149b06b8b">from_edge_list_to_graph</a> (const <a class="el" href="namespacelal.html#ab98936b00d896700a71899dff1ed9248">edge_list</a> &amp;<a class="el" href="namespacelal.html#ab98936b00d896700a71899dff1ed9248">edge_list</a>, const bool normalize, const bool check) noexcept</td></tr>
<tr class="memdesc:a046facc81651e5b2a0cd92f149b06b8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an edge list into a graph.  <br /></td></tr>
<tr class="separator:a046facc81651e5b2a0cd92f149b06b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7533691dc2da3241c9ca8e3a873d4e87" id="r_a7533691dc2da3241c9ca8e3a873d4e87"><td class="memTemplParams" colspan="2">template&lt;class graph_t &gt; </td></tr>
<tr class="memitem:a7533691dc2da3241c9ca8e3a873d4e87"><td class="memTemplItemLeft" align="right" valign="top">graph_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7533691dc2da3241c9ca8e3a873d4e87">from_head_vector_to_graph</a> (const <a class="el" href="namespacelal.html#a2eb5b7f5b50ff908a7a67889a9ea744d">head_vector</a> &amp;hv, const bool normalize, const bool check) noexcept</td></tr>
<tr class="memdesc:a7533691dc2da3241c9ca8e3a873d4e87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms a head vector in a directed graph.  <br /></td></tr>
<tr class="separator:a7533691dc2da3241c9ca8e3a873d4e87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b7c40280156dd9e798f407e0c6302a5" id="r_a9b7c40280156dd9e798f407e0c6302a5"><td class="memTemplParams" colspan="2">template&lt;typename tree_t , bool ensure_root_is_returned, bool free_tree_plus_root = ensure_root_is_returned and std::is_same_v&lt;tree_t, graphs::free_tree&gt;&gt; </td></tr>
<tr class="memitem:a9b7c40280156dd9e798f407e0c6302a5"><td class="memTemplItemLeft" align="right" valign="top">std::conditional_t&lt; free_tree_plus_root, std::pair&lt; tree_t, <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> &gt;, tree_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9b7c40280156dd9e798f407e0c6302a5">from_head_vector_to_tree</a> (std::stringstream &amp;ss) noexcept</td></tr>
<tr class="memdesc:a9b7c40280156dd9e798f407e0c6302a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms a head vector in a tree.  <br /></td></tr>
<tr class="separator:a9b7c40280156dd9e798f407e0c6302a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0b594a18111636a94387d9ecc54c708" id="r_ae0b594a18111636a94387d9ecc54c708"><td class="memTemplParams" colspan="2">template&lt;class tree_t , bool is_rooted = std::is_base_of_v&lt;graphs::rooted_tree, tree_t&gt;&gt; </td></tr>
<tr class="memitem:ae0b594a18111636a94387d9ecc54c708"><td class="memTemplItemLeft" align="right" valign="top">std::conditional_t&lt; is_rooted, <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a>, std::pair&lt; <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a>, <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae0b594a18111636a94387d9ecc54c708">from_head_vector_to_tree</a> (const <a class="el" href="namespacelal.html#a2eb5b7f5b50ff908a7a67889a9ea744d">head_vector</a> &amp;hv, const bool normalize, const bool check) noexcept</td></tr>
<tr class="memdesc:ae0b594a18111636a94387d9ecc54c708"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a head vector into a tree.  <br /></td></tr>
<tr class="separator:ae0b594a18111636a94387d9ecc54c708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bc2ccfd7fcd3f4b5ac53d54f3dd8eff" id="r_a0bc2ccfd7fcd3f4b5ac53d54f3dd8eff"><td class="memTemplParams" colspan="2">template&lt;class arrangement_t &gt; </td></tr>
<tr class="memitem:a0bc2ccfd7fcd3f4b5ac53d54f3dd8eff"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacelal.html#a2eb5b7f5b50ff908a7a67889a9ea744d">head_vector</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0bc2ccfd7fcd3f4b5ac53d54f3dd8eff">from_tree_to_head_vector</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;t, const arrangement_t &amp;arr) noexcept</td></tr>
<tr class="memdesc:a0bc2ccfd7fcd3f4b5ac53d54f3dd8eff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the head vector representation of a tree.  <br /></td></tr>
<tr class="separator:a0bc2ccfd7fcd3f4b5ac53d54f3dd8eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa63b6ce11a334bd79da7ca62f9fc396f" id="r_aa63b6ce11a334bd79da7ca62f9fc396f"><td class="memTemplParams" colspan="2">template&lt;class arrangement_t &gt; </td></tr>
<tr class="memitem:aa63b6ce11a334bd79da7ca62f9fc396f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacelal.html#a2eb5b7f5b50ff908a7a67889a9ea744d">head_vector</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa63b6ce11a334bd79da7ca62f9fc396f">from_tree_to_head_vector</a> (const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;t, const arrangement_t &amp;arr, const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> r) noexcept</td></tr>
<tr class="memdesc:aa63b6ce11a334bd79da7ca62f9fc396f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the head vector representation of a tree.  <br /></td></tr>
<tr class="separator:aa63b6ce11a334bd79da7ca62f9fc396f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7039e0e698bb3fbb6d0146705634f32b" id="r_a7039e0e698bb3fbb6d0146705634f32b"><td class="memTemplParams" colspan="2">template&lt;class tree_t &gt; </td></tr>
<tr class="memitem:a7039e0e698bb3fbb6d0146705634f32b"><td class="memTemplItemLeft" align="right" valign="top">tree_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7039e0e698bb3fbb6d0146705634f32b">from_level_sequence_to_tree_small</a> (const uint64_t *const L, const uint64_t n, const bool normalize, const bool check) noexcept</td></tr>
<tr class="memdesc:a7039e0e698bb3fbb6d0146705634f32b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the level sequence of a tree into a graph structure.  <br /></td></tr>
<tr class="separator:a7039e0e698bb3fbb6d0146705634f32b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d6f3ade0fe67e9a18b8139eac1a52dd" id="r_a2d6f3ade0fe67e9a18b8139eac1a52dd"><td class="memTemplParams" colspan="2">template&lt;class tree_t &gt; </td></tr>
<tr class="memitem:a2d6f3ade0fe67e9a18b8139eac1a52dd"><td class="memTemplItemLeft" align="right" valign="top">tree_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2d6f3ade0fe67e9a18b8139eac1a52dd">from_level_sequence_to_tree_large</a> (const uint64_t *const L, const uint64_t n, const bool normalize, const bool check) noexcept</td></tr>
<tr class="memdesc:a2d6f3ade0fe67e9a18b8139eac1a52dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the level sequence of a tree into a graph structure.  <br /></td></tr>
<tr class="separator:a2d6f3ade0fe67e9a18b8139eac1a52dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9fa62b2ef3f94d62eebd1c28ba7beaa" id="r_af9fa62b2ef3f94d62eebd1c28ba7beaa"><td class="memTemplParams" colspan="2">template&lt;class tree_t &gt; </td></tr>
<tr class="memitem:af9fa62b2ef3f94d62eebd1c28ba7beaa"><td class="memTemplItemLeft" align="right" valign="top">tree_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af9fa62b2ef3f94d62eebd1c28ba7beaa">from_level_sequence_to_tree</a> (const uint64_t *const L, const uint64_t n, const bool normalize, const bool check) noexcept</td></tr>
<tr class="memdesc:af9fa62b2ef3f94d62eebd1c28ba7beaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the level sequence of a tree into a graph structure.  <br /></td></tr>
<tr class="separator:af9fa62b2ef3f94d62eebd1c28ba7beaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cd5cc9b0bcbaf8fad86dae9a2fea6e7" id="r_a0cd5cc9b0bcbaf8fad86dae9a2fea6e7"><td class="memTemplParams" colspan="2">template&lt;class tree_t &gt; </td></tr>
<tr class="memitem:a0cd5cc9b0bcbaf8fad86dae9a2fea6e7"><td class="memTemplItemLeft" align="right" valign="top">tree_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0cd5cc9b0bcbaf8fad86dae9a2fea6e7">from_level_sequence_to_tree_small</a> (const std::vector&lt; uint64_t &gt; &amp;L, const uint64_t n, const bool normalize, const bool check) noexcept</td></tr>
<tr class="memdesc:a0cd5cc9b0bcbaf8fad86dae9a2fea6e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the level sequence of a tree into a graph structure.  <br /></td></tr>
<tr class="separator:a0cd5cc9b0bcbaf8fad86dae9a2fea6e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd3538b3666c7d23c2a899f834b966a7" id="r_acd3538b3666c7d23c2a899f834b966a7"><td class="memTemplParams" colspan="2">template&lt;class tree_t &gt; </td></tr>
<tr class="memitem:acd3538b3666c7d23c2a899f834b966a7"><td class="memTemplItemLeft" align="right" valign="top">tree_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acd3538b3666c7d23c2a899f834b966a7">from_level_sequence_to_tree_large</a> (const std::vector&lt; uint64_t &gt; &amp;L, const uint64_t n, const bool normalize, const bool check) noexcept</td></tr>
<tr class="memdesc:acd3538b3666c7d23c2a899f834b966a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the level sequence of a tree into a graph structure.  <br /></td></tr>
<tr class="separator:acd3538b3666c7d23c2a899f834b966a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49149914e78f33a8cd74230c92b44968" id="r_a49149914e78f33a8cd74230c92b44968"><td class="memTemplParams" colspan="2">template&lt;class tree_t &gt; </td></tr>
<tr class="memitem:a49149914e78f33a8cd74230c92b44968"><td class="memTemplItemLeft" align="right" valign="top">tree_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a49149914e78f33a8cd74230c92b44968">from_level_sequence_to_tree</a> (const std::vector&lt; uint64_t &gt; &amp;L, const uint64_t n, const bool normalize, const bool check) noexcept</td></tr>
<tr class="memdesc:a49149914e78f33a8cd74230c92b44968"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the level sequence of a tree into a graph structure.  <br /></td></tr>
<tr class="separator:a49149914e78f33a8cd74230c92b44968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97d73b47249d11a23b829735b9926909" id="r_a97d73b47249d11a23b829735b9926909"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a97d73b47249d11a23b829735b9926909">from_Prufer_sequence_to_ftree</a> (const uint64_t *const seq, const uint64_t n, const bool normalize, const bool check) noexcept</td></tr>
<tr class="memdesc:a97d73b47249d11a23b829735b9926909"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the Prüfer sequence of a labelled tree into a tree structure.  <br /></td></tr>
<tr class="separator:a97d73b47249d11a23b829735b9926909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a549b84ec837daa460b45c2eec5696312" id="r_a549b84ec837daa460b45c2eec5696312"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a549b84ec837daa460b45c2eec5696312">from_Prufer_sequence_to_ftree</a> (const std::vector&lt; uint64_t &gt; &amp;seq, const uint64_t n, const bool normalize, const bool check) noexcept</td></tr>
<tr class="memdesc:a549b84ec837daa460b45c2eec5696312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the Prüfer sequence of a labelled tree into a tree structure.  <br /></td></tr>
<tr class="separator:a549b84ec837daa460b45c2eec5696312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad994803ba72e39d4ad86ca2eb608b55d" id="r_ad994803ba72e39d4ad86ca2eb608b55d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad994803ba72e39d4ad86ca2eb608b55d">find_cycle</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;g, const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u, char *const __restrict__ visited, char *const __restrict__ in_stack) noexcept</td></tr>
<tr class="memdesc:ad994803ba72e39d4ad86ca2eb608b55d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if, and only if, the graph has cycles.  <br /></td></tr>
<tr class="separator:ad994803ba72e39d4ad86ca2eb608b55d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa89ef322801fbacd0782763afb9c5f3a" id="r_aa89ef322801fbacd0782763afb9c5f3a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa89ef322801fbacd0782763afb9c5f3a">has_directed_cycles</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;g, char *const __restrict__ vis, char *const __restrict__ in_stack) noexcept</td></tr>
<tr class="memdesc:aa89ef322801fbacd0782763afb9c5f3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if, and only if, the graph has <em>DIRECTED</em> cycles.  <br /></td></tr>
<tr class="separator:aa89ef322801fbacd0782763afb9c5f3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad493ddcc9165c55d4b14b228da5cdc4d" id="r_ad493ddcc9165c55d4b14b228da5cdc4d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad493ddcc9165c55d4b14b228da5cdc4d">has_directed_cycles</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;g) noexcept</td></tr>
<tr class="memdesc:ad493ddcc9165c55d4b14b228da5cdc4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if, and only if, the graph has DIRECTED cycles.  <br /></td></tr>
<tr class="separator:ad493ddcc9165c55d4b14b228da5cdc4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac1d5fb0c4578d6be926acf180d657c4" id="r_aac1d5fb0c4578d6be926acf180d657c4"><td class="memTemplParams" colspan="2">template&lt;class graph_t &gt; </td></tr>
<tr class="memitem:aac1d5fb0c4578d6be926acf180d657c4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aac1d5fb0c4578d6be926acf180d657c4">has_undirected_cycles</a> (const graph_t &amp;g, <a class="el" href="classlal_1_1detail_1_1BFS.html">BFS</a>&lt; graph_t &gt; &amp;bfs) noexcept</td></tr>
<tr class="memdesc:aac1d5fb0c4578d6be926acf180d657c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if, and only if, the graph has UNDIRECTED cycles.  <br /></td></tr>
<tr class="separator:aac1d5fb0c4578d6be926acf180d657c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af38edbbd2619cd3b319c1a54ce0638ed" id="r_af38edbbd2619cd3b319c1a54ce0638ed"><td class="memTemplParams" colspan="2">template&lt;class graph_t &gt; </td></tr>
<tr class="memitem:af38edbbd2619cd3b319c1a54ce0638ed"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af38edbbd2619cd3b319c1a54ce0638ed">has_undirected_cycles</a> (const graph_t &amp;g) noexcept</td></tr>
<tr class="memdesc:af38edbbd2619cd3b319c1a54ce0638ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if, and only if, the graph has UNDIRECTED cycles.  <br /></td></tr>
<tr class="separator:af38edbbd2619cd3b319c1a54ce0638ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bb2c6db85eddc1623aa2e3e4b0cbb29" id="r_a5bb2c6db85eddc1623aa2e3e4b0cbb29"><td class="memTemplParams" colspan="2">template&lt;class graph_t &gt; </td></tr>
<tr class="memitem:a5bb2c6db85eddc1623aa2e3e4b0cbb29"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacelal.html#a5969ec7ecc85697ebb9ec0ace78fbcab">edge</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5bb2c6db85eddc1623aa2e3e4b0cbb29">set_edges</a> (const graph_t &amp;g) noexcept</td></tr>
<tr class="memdesc:a5bb2c6db85eddc1623aa2e3e4b0cbb29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerate the set of edges of the input graph <em>g</em>.  <br /></td></tr>
<tr class="separator:a5bb2c6db85eddc1623aa2e3e4b0cbb29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ef4c2de8e98db0003d828728aea3846" id="r_a0ef4c2de8e98db0003d828728aea3846"><td class="memTemplParams" colspan="2">template&lt;class graph_t &gt; </td></tr>
<tr class="memitem:a0ef4c2de8e98db0003d828728aea3846"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacelal.html#a235d5351556fbc73aa51767ab7765f5c">edge_pair</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0ef4c2de8e98db0003d828728aea3846">set_pairs_independent_edges</a> (const graph_t &amp;g, const uint64_t qs) noexcept</td></tr>
<tr class="memdesc:a0ef4c2de8e98db0003d828728aea3846"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerate the set of pairs of independent edges of the input graph <em>g</em>.  <br /></td></tr>
<tr class="separator:a0ef4c2de8e98db0003d828728aea3846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58af58031ebc33bbfb5dfcd8f798ebf4" id="r_a58af58031ebc33bbfb5dfcd8f798ebf4"><td class="memTemplParams" colspan="2">template&lt;class graph_t &gt; </td></tr>
<tr class="memitem:a58af58031ebc33bbfb5dfcd8f798ebf4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a58af58031ebc33bbfb5dfcd8f798ebf4">is_graph_a_tree</a> (const graph_t &amp;g) noexcept</td></tr>
<tr class="memdesc:a58af58031ebc33bbfb5dfcd8f798ebf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the input graph a tree?  <br /></td></tr>
<tr class="separator:a58af58031ebc33bbfb5dfcd8f798ebf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81e5bdc0c496cec1dc8764ff73d9eff3" id="r_a81e5bdc0c496cec1dc8764ff73d9eff3"><td class="memTemplParams" colspan="2">template&lt;class graph_t &gt; </td></tr>
<tr class="memitem:a81e5bdc0c496cec1dc8764ff73d9eff3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a81e5bdc0c496cec1dc8764ff73d9eff3">is_node_reachable_from</a> (const graph_t &amp;g, const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> source, const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> target) noexcept</td></tr>
<tr class="memdesc:a81e5bdc0c496cec1dc8764ff73d9eff3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is a node reachable from another?  <br /></td></tr>
<tr class="separator:a81e5bdc0c496cec1dc8764ff73d9eff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88e9b008810ccd6204cf0e34778607f4" id="r_a88e9b008810ccd6204cf0e34778607f4"><td class="memTemplParams" colspan="2">template&lt;bool get_subsizes&gt; </td></tr>
<tr class="memitem:a88e9b008810ccd6204cf0e34778607f4"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; <a class="el" href="namespacelal.html#a5969ec7ecc85697ebb9ec0ace78fbcab">edge</a> &gt;, uint64_t * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a88e9b008810ccd6204cf0e34778607f4">get_edges_subtree</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;T, const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u, const bool relabel) noexcept</td></tr>
<tr class="memdesc:a88e9b008810ccd6204cf0e34778607f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the edges of a subtree.  <br /></td></tr>
<tr class="separator:a88e9b008810ccd6204cf0e34778607f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07c5f3a005c23b6fb759e7bef0dc8053" id="r_a07c5f3a005c23b6fb759e7bef0dc8053"><td class="memTemplParams" colspan="2">template&lt;class tree_t , std::enable_if_t&lt; std::is_base_of_v&lt; <a class="el" href="classlal_1_1graphs_1_1tree.html">graphs::tree</a>, tree_t &gt;, bool &gt;  = true&gt; </td></tr>
<tr class="memitem:a07c5f3a005c23b6fb759e7bef0dc8053"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a07c5f3a005c23b6fb759e7bef0dc8053">get_size_subtrees</a> (const tree_t &amp;t, const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u, const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> v, uint64_t *const sizes) noexcept</td></tr>
<tr class="memdesc:a07c5f3a005c23b6fb759e7bef0dc8053"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the size of every subtree of the tree <em>t</em>.  <br /></td></tr>
<tr class="separator:a07c5f3a005c23b6fb759e7bef0dc8053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d699ac4dd239e067d1823ea612daca4" id="r_a5d699ac4dd239e067d1823ea612daca4"><td class="memTemplParams" colspan="2">template&lt;class tree_t , std::enable_if_t&lt; std::is_base_of_v&lt; <a class="el" href="classlal_1_1graphs_1_1tree.html">graphs::tree</a>, tree_t &gt;, bool &gt;  = true&gt; </td></tr>
<tr class="memitem:a5d699ac4dd239e067d1823ea612daca4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5d699ac4dd239e067d1823ea612daca4">get_size_subtrees</a> (const tree_t &amp;t, const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> r, uint64_t *const sizes) noexcept</td></tr>
<tr class="memdesc:a5d699ac4dd239e067d1823ea612daca4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the size of every subtree of tree <em>t</em>.  <br /></td></tr>
<tr class="separator:a5d699ac4dd239e067d1823ea612daca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b8f436879c464b089f1f2a67e507ffb" id="r_a3b8f436879c464b089f1f2a67e507ffb"><td class="memTemplParams" colspan="2">template&lt;class tree_t , typename iterator_t , std::enable_if_t&lt; std::is_base_of_v&lt; <a class="el" href="classlal_1_1graphs_1_1tree.html">graphs::tree</a>, tree_t &gt; and <a class="el" href="#a1acf6acf0c665841481303603b6ddb02">is_pointer_iterator_v</a>&lt; <a class="el" href="structlal_1_1detail_1_1edge__size.html">edge_size</a>, iterator_t &gt;, bool &gt;  = true&gt; </td></tr>
<tr class="memitem:a3b8f436879c464b089f1f2a67e507ffb"><td class="memTemplItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3b8f436879c464b089f1f2a67e507ffb">calculate_bidirectional_sizes</a> (const tree_t &amp;t, const uint64_t n, const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u, const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> v, iterator_t &amp;it) noexcept</td></tr>
<tr class="memdesc:a3b8f436879c464b089f1f2a67e507ffb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the values \(s(u,v)\) for the edges \((s,t)\) reachable from \(v\) in the subtree \(T^u_v\).  <br /></td></tr>
<tr class="separator:a3b8f436879c464b089f1f2a67e507ffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a332f440b66ce4e8dc243706901575023" id="r_a332f440b66ce4e8dc243706901575023"><td class="memTemplParams" colspan="2">template&lt;class tree_t , typename iterator_t , std::enable_if_t&lt; std::is_base_of_v&lt; <a class="el" href="classlal_1_1graphs_1_1tree.html">graphs::tree</a>, tree_t &gt; and <a class="el" href="#a1acf6acf0c665841481303603b6ddb02">is_pointer_iterator_v</a>&lt; <a class="el" href="structlal_1_1detail_1_1edge__size.html">edge_size</a>, iterator_t &gt;, bool &gt;  = true&gt; </td></tr>
<tr class="memitem:a332f440b66ce4e8dc243706901575023"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a332f440b66ce4e8dc243706901575023">calculate_bidirectional_sizes</a> (const tree_t &amp;t, const uint64_t n, const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> x, iterator_t it) noexcept</td></tr>
<tr class="memdesc:a332f440b66ce4e8dc243706901575023"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the values \(s_u(v)\) for the edges \((u,v)\) reachable from vertex <em>x</em>.  <br /></td></tr>
<tr class="separator:a332f440b66ce4e8dc243706901575023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0e84911e7a2503c840836d3dc35ae4e" id="r_ae0e84911e7a2503c840836d3dc35ae4e"><td class="memTemplParams" colspan="2">template&lt;class tree_t , std::enable_if_t&lt; std::is_base_of_v&lt; <a class="el" href="classlal_1_1graphs_1_1tree.html">graphs::tree</a>, tree_t &gt;, bool &gt;  = true&gt; </td></tr>
<tr class="memitem:ae0e84911e7a2503c840836d3dc35ae4e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae0e84911e7a2503c840836d3dc35ae4e">classify_tree</a> (const tree_t &amp;t, std::array&lt; bool, <a class="el" href="namespacelal_1_1graphs.html#a1895a9ed855ad1d85cd9510de714a732">graphs::__tree_type_size</a> &gt; &amp;tree_types) noexcept</td></tr>
<tr class="memdesc:ae0e84911e7a2503c840836d3dc35ae4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Classify a tree into one of the types <a class="el" href="namespacelal_1_1graphs.html#a18d52542088507e2be6241759722835b">graphs::tree_type</a>.  <br /></td></tr>
<tr class="separator:ae0e84911e7a2503c840836d3dc35ae4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15fc99b90e9aef2b53fc9e3e186cdfb8" id="r_a15fc99b90e9aef2b53fc9e3e186cdfb8"><td class="memItemLeft" align="right" valign="top"><a id="a15fc99b90e9aef2b53fc9e3e186cdfb8" name="a15fc99b90e9aef2b53fc9e3e186cdfb8"></a>
constexpr std::string_view&#160;</td><td class="memItemRight" valign="bottom"><b>tree_type_string</b> (const <a class="el" href="namespacelal_1_1graphs.html#a18d52542088507e2be6241759722835b">graphs::tree_type</a> &amp;tt) noexcept</td></tr>
<tr class="memdesc:a15fc99b90e9aef2b53fc9e3e186cdfb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts to a string a value of the enumeration <a class="el" href="namespacelal_1_1graphs.html#a18d52542088507e2be6241759722835b">lal::graphs::tree_type</a>. <br /></td></tr>
<tr class="separator:a15fc99b90e9aef2b53fc9e3e186cdfb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af50760eaee3200e963cc77c4c95470d6" id="r_af50760eaee3200e963cc77c4c95470d6"><td class="memTemplParams" colspan="2">template&lt;class tree_t &gt; </td></tr>
<tr class="memitem:af50760eaee3200e963cc77c4c95470d6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af50760eaee3200e963cc77c4c95470d6">update_unionfind_after_add_edge</a> (const tree_t &amp;t, const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u, const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> v, <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> *const root_of, uint64_t *const root_size) noexcept</td></tr>
<tr class="memdesc:af50760eaee3200e963cc77c4c95470d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the Union-Find data structure after the addition of an edge.  <br /></td></tr>
<tr class="separator:af50760eaee3200e963cc77c4c95470d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cadd0c126ee7d5e745ee5188d67daff" id="r_a5cadd0c126ee7d5e745ee5188d67daff"><td class="memTemplParams" colspan="2">template&lt;class tree_t &gt; </td></tr>
<tr class="memitem:a5cadd0c126ee7d5e745ee5188d67daff"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5cadd0c126ee7d5e745ee5188d67daff">update_unionfind_after_add_edges</a> (const tree_t &amp;t, const <a class="el" href="namespacelal.html#ab98936b00d896700a71899dff1ed9248">edge_list</a> &amp;edges, <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> *const root_of, uint64_t *const root_size) noexcept</td></tr>
<tr class="memdesc:a5cadd0c126ee7d5e745ee5188d67daff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the Union-Find data structure after the addition of several edges.  <br /></td></tr>
<tr class="separator:a5cadd0c126ee7d5e745ee5188d67daff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49b8ff3684b7c460352ee1678541b0d9" id="r_a49b8ff3684b7c460352ee1678541b0d9"><td class="memTemplParams" colspan="2">template&lt;class tree_t &gt; </td></tr>
<tr class="memitem:a49b8ff3684b7c460352ee1678541b0d9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a49b8ff3684b7c460352ee1678541b0d9">update_unionfind_after_add_rem_edges_bulk</a> (const tree_t &amp;t, <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> *const root_of, uint64_t *const root_size) noexcept</td></tr>
<tr class="memdesc:a49b8ff3684b7c460352ee1678541b0d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the Union-Find data structure after several edges have been operated in bulk.  <br /></td></tr>
<tr class="separator:a49b8ff3684b7c460352ee1678541b0d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a773e3f33dbdcf3c44007f621eea0e4de" id="r_a773e3f33dbdcf3c44007f621eea0e4de"><td class="memTemplParams" colspan="2">template&lt;class tree_t &gt; </td></tr>
<tr class="memitem:a773e3f33dbdcf3c44007f621eea0e4de"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a773e3f33dbdcf3c44007f621eea0e4de">update_unionfind_after_remove_edge</a> (const tree_t &amp;t, const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u, const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> v, <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> *const root_of, uint64_t *const root_size) noexcept</td></tr>
<tr class="memdesc:a773e3f33dbdcf3c44007f621eea0e4de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates Union-Find after the removal of an edge.  <br /></td></tr>
<tr class="separator:a773e3f33dbdcf3c44007f621eea0e4de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c633651b077f8fd9417d8593e222dea" id="r_a7c633651b077f8fd9417d8593e222dea"><td class="memTemplParams" colspan="2">template&lt;class tree_t &gt; </td></tr>
<tr class="memitem:a7c633651b077f8fd9417d8593e222dea"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7c633651b077f8fd9417d8593e222dea">update_unionfind_after_remove_edges</a> (const tree_t &amp;t, const <a class="el" href="namespacelal.html#ab98936b00d896700a71899dff1ed9248">edge_list</a> &amp;edges, <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> *const root_of, uint64_t *const root_size) noexcept</td></tr>
<tr class="memdesc:a7c633651b077f8fd9417d8593e222dea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the Union-Find data structure after the addition of several edges.  <br /></td></tr>
<tr class="separator:a7c633651b077f8fd9417d8593e222dea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13f00277c294d1ea536cb0359e2d28fd" id="r_a13f00277c294d1ea536cb0359e2d28fd"><td class="memTemplParams" colspan="2">template&lt;class tree_t &gt; </td></tr>
<tr class="memitem:a13f00277c294d1ea536cb0359e2d28fd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a13f00277c294d1ea536cb0359e2d28fd">update_unionfind_before_remove_edges_incident_to</a> (<a class="el" href="classlal_1_1detail_1_1BFS.html">BFS</a>&lt; tree_t &gt; &amp;bfs, const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> v, <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> *const root_of, uint64_t *const root_size) noexcept</td></tr>
<tr class="memdesc:a13f00277c294d1ea536cb0359e2d28fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update Union-Find after the removal of a vertex.  <br /></td></tr>
<tr class="separator:a13f00277c294d1ea536cb0359e2d28fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7836c77cec7bbc6cc92ac41016514e4d" id="r_a7836c77cec7bbc6cc92ac41016514e4d"><td class="memTemplParams" colspan="2">template&lt;typename tree_t &gt; </td></tr>
<tr class="memitem:a7836c77cec7bbc6cc92ac41016514e4d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7836c77cec7bbc6cc92ac41016514e4d">update_unionfind_before_remove_edges_incident_to</a> (const tree_t &amp;t, const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u, <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> *const root_of, uint64_t *const root_size) noexcept</td></tr>
<tr class="memdesc:a7836c77cec7bbc6cc92ac41016514e4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update Union-Find after a vertex removal.  <br /></td></tr>
<tr class="separator:a7836c77cec7bbc6cc92ac41016514e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10d1e56d764e413a8f35cecc6a219404" id="r_a10d1e56d764e413a8f35cecc6a219404"><td class="memTemplParams" colspan="2">template&lt;class graph_t , typename char_type , std::enable_if_t&lt; std::is_base_of_v&lt; <a class="el" href="classlal_1_1graphs_1_1graph.html">graphs::graph</a>, graph_t &gt; and std::is_integral_v&lt; char_type &gt;, bool &gt;  = true&gt; </td></tr>
<tr class="memitem:a10d1e56d764e413a8f35cecc6a219404"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a10d1e56d764e413a8f35cecc6a219404">get_bool_neighbors</a> (const graph_t &amp;g, const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u, char_type *const neighs) noexcept</td></tr>
<tr class="memdesc:a10d1e56d764e413a8f35cecc6a219404"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the neighbors of a node in an undirected graph as a list of 0-1 values.  <br /></td></tr>
<tr class="separator:a10d1e56d764e413a8f35cecc6a219404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99e564e21a58d5a88f53503f71317136" id="r_a99e564e21a58d5a88f53503f71317136"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a99e564e21a58d5a88f53503f71317136">append_adjacency_lists</a> (std::vector&lt; <a class="el" href="namespacelal.html#aef91d923414879a998619e9c65181d1f">neighbourhood</a> &gt; &amp;target, const std::vector&lt; <a class="el" href="namespacelal.html#aef91d923414879a998619e9c65181d1f">neighbourhood</a> &gt; &amp;source) noexcept</td></tr>
<tr class="memdesc:a99e564e21a58d5a88f53503f71317136"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append adjacency list 'source' to list 'target'.  <br /></td></tr>
<tr class="separator:a99e564e21a58d5a88f53503f71317136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a179acf38e7d9fe41dc7aed7c3129781f" id="r_a179acf38e7d9fe41dc7aed7c3129781f"><td class="memTemplParams" colspan="2">template&lt;bool decide&gt; </td></tr>
<tr class="memitem:a179acf38e7d9fe41dc7aed7c3129781f"><td class="memTemplItemLeft" align="right" valign="top">std::conditional_t&lt; decide, bool, std::vector&lt; <a class="el" href="classlal_1_1io_1_1head__vector__error.html">io::head_vector_error</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a179acf38e7d9fe41dc7aed7c3129781f">find_errors</a> (const <a class="el" href="namespacelal.html#a2eb5b7f5b50ff908a7a67889a9ea744d">head_vector</a> &amp;hv) noexcept</td></tr>
<tr class="memdesc:a179acf38e7d9fe41dc7aed7c3129781f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find errors in a head vector.  <br /></td></tr>
<tr class="separator:a179acf38e7d9fe41dc7aed7c3129781f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a154fd8759fbd3b3f3dbe71cc32c5cebe" id="r_a154fd8759fbd3b3f3dbe71cc32c5cebe"><td class="memTemplParams" colspan="2">template&lt;bool decide&gt; </td></tr>
<tr class="memitem:a154fd8759fbd3b3f3dbe71cc32c5cebe"><td class="memTemplItemLeft" align="right" valign="top">std::conditional_t&lt; decide, bool, std::vector&lt; <a class="el" href="classlal_1_1io_1_1head__vector__error.html">io::head_vector_error</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a154fd8759fbd3b3f3dbe71cc32c5cebe">find_errors</a> (const std::string &amp;current_line) noexcept</td></tr>
<tr class="memdesc:a154fd8759fbd3b3f3dbe71cc32c5cebe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find errors in a line of a treebank.  <br /></td></tr>
<tr class="separator:a154fd8759fbd3b3f3dbe71cc32c5cebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad12b4d7afb7f959490ab04ebc93f751" id="r_aad12b4d7afb7f959490ab04ebc93f751"><td class="memTemplParams" colspan="2">template&lt;bool decide&gt; </td></tr>
<tr class="memitem:aad12b4d7afb7f959490ab04ebc93f751"><td class="memTemplItemLeft" align="right" valign="top">std::conditional_t&lt; decide, bool, <a class="el" href="classlal_1_1io_1_1treebank__file__report.html">io::treebank_file_report</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aad12b4d7afb7f959490ab04ebc93f751">check_correctness_treebank</a> (const std::string &amp;treebank_filename) noexcept</td></tr>
<tr class="memdesc:aad12b4d7afb7f959490ab04ebc93f751"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find errors in a treebank file.  <br /></td></tr>
<tr class="separator:aad12b4d7afb7f959490ab04ebc93f751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1255954e5484e835779ba3c2b4a275be" id="r_a1255954e5484e835779ba3c2b4a275be"><td class="memTemplParams" colspan="2">template&lt;bool decide&gt; </td></tr>
<tr class="memitem:a1255954e5484e835779ba3c2b4a275be"><td class="memTemplItemLeft" align="right" valign="top">std::conditional_t&lt; decide, bool, <a class="el" href="classlal_1_1io_1_1treebank__collection__report.html">io::treebank_collection_report</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1255954e5484e835779ba3c2b4a275be">check_correctness_treebank_collection</a> (const std::string &amp;main_file_name, const std::size_t n_threads) noexcept</td></tr>
<tr class="memdesc:a1255954e5484e835779ba3c2b4a275be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find errors in a treebank collection.  <br /></td></tr>
<tr class="separator:a1255954e5484e835779ba3c2b4a275be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dfcbe004ac9a216754bf3eae410c32b" id="r_a8dfcbe004ac9a216754bf3eae410c32b"><td class="memTemplParams" colspan="2">template&lt;class graph_t &gt; </td></tr>
<tr class="memitem:a8dfcbe004ac9a216754bf3eae410c32b"><td class="memTemplItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8dfcbe004ac9a216754bf3eae410c32b">n_C_brute_force</a> (const graph_t &amp;g, const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;arr) noexcept</td></tr>
<tr class="memdesc:a8dfcbe004ac9a216754bf3eae410c32b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the number of crossings in the linear arrangement less than a constant?  <br /></td></tr>
<tr class="separator:a8dfcbe004ac9a216754bf3eae410c32b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aaadea543154a22dd77ce1179b9ab42" id="r_a9aaadea543154a22dd77ce1179b9ab42"><td class="memTemplParams" colspan="2">template&lt;class graph_t &gt; </td></tr>
<tr class="memitem:a9aaadea543154a22dd77ce1179b9ab42"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; uint64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9aaadea543154a22dd77ce1179b9ab42">n_C_brute_force</a> (const graph_t &amp;g, const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;arrs) noexcept</td></tr>
<tr class="memdesc:a9aaadea543154a22dd77ce1179b9ab42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the number of crossings in the linear arrangement less than a constant?  <br /></td></tr>
<tr class="separator:a9aaadea543154a22dd77ce1179b9ab42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceadae62ffd6542e97b65cd06eb088b8" id="r_aceadae62ffd6542e97b65cd06eb088b8"><td class="memTemplParams" colspan="2">template&lt;class graph_t &gt; </td></tr>
<tr class="memitem:aceadae62ffd6542e97b65cd06eb088b8"><td class="memTemplItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aceadae62ffd6542e97b65cd06eb088b8">is_n_C_brute_force_lesseq_than</a> (const graph_t &amp;g, const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;arr, const uint64_t upper_bound) noexcept</td></tr>
<tr class="memdesc:aceadae62ffd6542e97b65cd06eb088b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the number of crossings is less than a given constant.  <br /></td></tr>
<tr class="separator:aceadae62ffd6542e97b65cd06eb088b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b4c7622b6c721e178419bca90797348" id="r_a6b4c7622b6c721e178419bca90797348"><td class="memTemplParams" colspan="2">template&lt;class graph_t &gt; </td></tr>
<tr class="memitem:a6b4c7622b6c721e178419bca90797348"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; uint64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6b4c7622b6c721e178419bca90797348">is_n_C_brute_force_lesseq_than</a> (const graph_t &amp;g, const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;arrs, const uint64_t upper_bound) noexcept</td></tr>
<tr class="memdesc:a6b4c7622b6c721e178419bca90797348"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the number of crossings is less than a given constant.  <br /></td></tr>
<tr class="separator:a6b4c7622b6c721e178419bca90797348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52af8ab2c0352a408cce9e05de472e88" id="r_a52af8ab2c0352a408cce9e05de472e88"><td class="memTemplParams" colspan="2">template&lt;class graph_t &gt; </td></tr>
<tr class="memitem:a52af8ab2c0352a408cce9e05de472e88"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; uint64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a52af8ab2c0352a408cce9e05de472e88">is_n_C_brute_force_lesseq_than</a> (const graph_t &amp;g, const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;arrs, const std::vector&lt; uint64_t &gt; &amp;upper_bounds) noexcept</td></tr>
<tr class="memdesc:a52af8ab2c0352a408cce9e05de472e88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the number of crossings is less than a given constant.  <br /></td></tr>
<tr class="separator:a52af8ab2c0352a408cce9e05de472e88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace62b8ae72aa81e2f7220ed5ab94d62b" id="r_ace62b8ae72aa81e2f7220ed5ab94d62b"><td class="memTemplParams" colspan="2">template&lt;class graph_t &gt; </td></tr>
<tr class="memitem:ace62b8ae72aa81e2f7220ed5ab94d62b"><td class="memTemplItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ace62b8ae72aa81e2f7220ed5ab94d62b">n_C_dynamic_programming</a> (const graph_t &amp;g, const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;arr) noexcept</td></tr>
<tr class="memdesc:ace62b8ae72aa81e2f7220ed5ab94d62b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the number of crossings in the linear arrangement less than a constant?  <br /></td></tr>
<tr class="separator:ace62b8ae72aa81e2f7220ed5ab94d62b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6fb4a73feef834d6f6083017c77ffad" id="r_ab6fb4a73feef834d6f6083017c77ffad"><td class="memTemplParams" colspan="2">template&lt;class graph_t &gt; </td></tr>
<tr class="memitem:ab6fb4a73feef834d6f6083017c77ffad"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; uint64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab6fb4a73feef834d6f6083017c77ffad">n_C_dynamic_programming</a> (const graph_t &amp;g, const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;arrs) noexcept</td></tr>
<tr class="memdesc:ab6fb4a73feef834d6f6083017c77ffad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the number of crossings in the linear arrangement less than a constant?  <br /></td></tr>
<tr class="separator:ab6fb4a73feef834d6f6083017c77ffad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39b808838c040a76aa1771bd29944463" id="r_a39b808838c040a76aa1771bd29944463"><td class="memTemplParams" colspan="2">template&lt;class graph_t &gt; </td></tr>
<tr class="memitem:a39b808838c040a76aa1771bd29944463"><td class="memTemplItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a39b808838c040a76aa1771bd29944463">is_n_C_dynamic_programming_lesseq_than</a> (const graph_t &amp;g, const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;arr, const uint64_t upper_bound) noexcept</td></tr>
<tr class="memdesc:a39b808838c040a76aa1771bd29944463"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast calculation of \(C\) if it is less than or equal to an upper bound.  <br /></td></tr>
<tr class="separator:a39b808838c040a76aa1771bd29944463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a483eaac7ab510f15e666df819dca2c32" id="r_a483eaac7ab510f15e666df819dca2c32"><td class="memTemplParams" colspan="2">template&lt;class graph_t &gt; </td></tr>
<tr class="memitem:a483eaac7ab510f15e666df819dca2c32"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; uint64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a483eaac7ab510f15e666df819dca2c32">is_n_C_dynamic_programming_lesseq_than</a> (const graph_t &amp;g, const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;arrs, const uint64_t upper_bound) noexcept</td></tr>
<tr class="memdesc:a483eaac7ab510f15e666df819dca2c32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast calculation of \(C\) if it is less than or equal to an upper bound.  <br /></td></tr>
<tr class="separator:a483eaac7ab510f15e666df819dca2c32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa37dcfd68ac36acf6031b605ab75abc" id="r_aaa37dcfd68ac36acf6031b605ab75abc"><td class="memTemplParams" colspan="2">template&lt;class graph_t &gt; </td></tr>
<tr class="memitem:aaa37dcfd68ac36acf6031b605ab75abc"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; uint64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aaa37dcfd68ac36acf6031b605ab75abc">is_n_C_dynamic_programming_lesseq_than</a> (const graph_t &amp;g, const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;arrs, const std::vector&lt; uint64_t &gt; &amp;upper_bounds) noexcept</td></tr>
<tr class="memdesc:aaa37dcfd68ac36acf6031b605ab75abc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast calculation of \(C\) if it is less than or equal to an upper bound.  <br /></td></tr>
<tr class="separator:aaa37dcfd68ac36acf6031b605ab75abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ff3d3faa9937f42252a89c79809d20f" id="r_a0ff3d3faa9937f42252a89c79809d20f"><td class="memTemplParams" colspan="2">template&lt;class graph_t &gt; </td></tr>
<tr class="memitem:a0ff3d3faa9937f42252a89c79809d20f"><td class="memTemplItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0ff3d3faa9937f42252a89c79809d20f">n_C_ladder</a> (const graph_t &amp;g, const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;arr) noexcept</td></tr>
<tr class="memdesc:a0ff3d3faa9937f42252a89c79809d20f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the number of crossings in the linear arrangement less than a constant?  <br /></td></tr>
<tr class="separator:a0ff3d3faa9937f42252a89c79809d20f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5860c3c8273d95209e36bdd689943629" id="r_a5860c3c8273d95209e36bdd689943629"><td class="memTemplParams" colspan="2">template&lt;class graph_t &gt; </td></tr>
<tr class="memitem:a5860c3c8273d95209e36bdd689943629"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; uint64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5860c3c8273d95209e36bdd689943629">n_C_ladder</a> (const graph_t &amp;g, const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;arrs) noexcept</td></tr>
<tr class="memdesc:a5860c3c8273d95209e36bdd689943629"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the number of crossings in the linear arrangement less than a constant?  <br /></td></tr>
<tr class="separator:a5860c3c8273d95209e36bdd689943629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8239c121f8fcf434838cf51bc31dea3" id="r_ac8239c121f8fcf434838cf51bc31dea3"><td class="memTemplParams" colspan="2">template&lt;class graph_t &gt; </td></tr>
<tr class="memitem:ac8239c121f8fcf434838cf51bc31dea3"><td class="memTemplItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac8239c121f8fcf434838cf51bc31dea3">is_n_C_ladder_lesseq_than</a> (const graph_t &amp;g, const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;arr, const uint64_t upper_bound) noexcept</td></tr>
<tr class="memdesc:ac8239c121f8fcf434838cf51bc31dea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast calculation of \(C\) if it is less than or equal to an upper bound.  <br /></td></tr>
<tr class="separator:ac8239c121f8fcf434838cf51bc31dea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c832c8d5da81092f2b520fba976d1d7" id="r_a0c832c8d5da81092f2b520fba976d1d7"><td class="memTemplParams" colspan="2">template&lt;class graph_t &gt; </td></tr>
<tr class="memitem:a0c832c8d5da81092f2b520fba976d1d7"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; uint64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0c832c8d5da81092f2b520fba976d1d7">is_n_C_ladder_lesseq_than</a> (const graph_t &amp;g, const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;arrs, const uint64_t upper_bound) noexcept</td></tr>
<tr class="memdesc:a0c832c8d5da81092f2b520fba976d1d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast calculation of \(C\) if it is less than or equal to an upper bound.  <br /></td></tr>
<tr class="separator:a0c832c8d5da81092f2b520fba976d1d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a313d37b28c1b5efec442077b09c4ab" id="r_a4a313d37b28c1b5efec442077b09c4ab"><td class="memTemplParams" colspan="2">template&lt;class graph_t &gt; </td></tr>
<tr class="memitem:a4a313d37b28c1b5efec442077b09c4ab"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; uint64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4a313d37b28c1b5efec442077b09c4ab">is_n_C_ladder_lesseq_than</a> (const graph_t &amp;g, const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;arrs, const std::vector&lt; uint64_t &gt; &amp;upper_bounds) noexcept</td></tr>
<tr class="memdesc:a4a313d37b28c1b5efec442077b09c4ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast calculation of \(C\) if it is less than or equal to an upper bound.  <br /></td></tr>
<tr class="separator:a4a313d37b28c1b5efec442077b09c4ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d67b4d927bc4ada1816b903f278bcff" id="r_a1d67b4d927bc4ada1816b903f278bcff"><td class="memTemplParams" colspan="2">template&lt;class graph_t &gt; </td></tr>
<tr class="memitem:a1d67b4d927bc4ada1816b903f278bcff"><td class="memTemplItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1d67b4d927bc4ada1816b903f278bcff">n_C_stack_based</a> (const graph_t &amp;g, const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;arr) noexcept</td></tr>
<tr class="memdesc:a1d67b4d927bc4ada1816b903f278bcff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the number of crossings in the linear arrangement less than a constant?  <br /></td></tr>
<tr class="separator:a1d67b4d927bc4ada1816b903f278bcff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dcc673a543201a113c8c6f1d0f3e1ad" id="r_a2dcc673a543201a113c8c6f1d0f3e1ad"><td class="memTemplParams" colspan="2">template&lt;class graph_t &gt; </td></tr>
<tr class="memitem:a2dcc673a543201a113c8c6f1d0f3e1ad"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; uint64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2dcc673a543201a113c8c6f1d0f3e1ad">n_C_stack_based</a> (const graph_t &amp;g, const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;arrs) noexcept</td></tr>
<tr class="memdesc:a2dcc673a543201a113c8c6f1d0f3e1ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the number of crossings in the linear arrangement less than a constant?  <br /></td></tr>
<tr class="separator:a2dcc673a543201a113c8c6f1d0f3e1ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ca8ff399693e91adb12527b7ca4614c" id="r_a0ca8ff399693e91adb12527b7ca4614c"><td class="memTemplParams" colspan="2">template&lt;class graph_t &gt; </td></tr>
<tr class="memitem:a0ca8ff399693e91adb12527b7ca4614c"><td class="memTemplItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0ca8ff399693e91adb12527b7ca4614c">is_n_C_stack_based_lesseq_than</a> (const graph_t &amp;g, const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;arr, const uint64_t upper_bound) noexcept</td></tr>
<tr class="memdesc:a0ca8ff399693e91adb12527b7ca4614c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast calculation of \(C\) if it is less than or equal to an upper bound.  <br /></td></tr>
<tr class="separator:a0ca8ff399693e91adb12527b7ca4614c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50e2cf86c0b37c3a1446fd87b74e3ea7" id="r_a50e2cf86c0b37c3a1446fd87b74e3ea7"><td class="memTemplParams" colspan="2">template&lt;class graph_t &gt; </td></tr>
<tr class="memitem:a50e2cf86c0b37c3a1446fd87b74e3ea7"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; uint64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a50e2cf86c0b37c3a1446fd87b74e3ea7">is_n_C_stack_based_lesseq_than</a> (const graph_t &amp;g, const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;arrs, const uint64_t upper_bound) noexcept</td></tr>
<tr class="memdesc:a50e2cf86c0b37c3a1446fd87b74e3ea7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast calculation of \(C\) if it is less than or equal to an upper bound.  <br /></td></tr>
<tr class="separator:a50e2cf86c0b37c3a1446fd87b74e3ea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac9327821de6e918b01ac58c5e5f8ec2" id="r_aac9327821de6e918b01ac58c5e5f8ec2"><td class="memTemplParams" colspan="2">template&lt;class graph_t &gt; </td></tr>
<tr class="memitem:aac9327821de6e918b01ac58c5e5f8ec2"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; uint64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aac9327821de6e918b01ac58c5e5f8ec2">is_n_C_stack_based_lesseq_than</a> (const graph_t &amp;g, const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;arrs, const std::vector&lt; uint64_t &gt; &amp;upper_bounds) noexcept</td></tr>
<tr class="memdesc:aac9327821de6e918b01ac58c5e5f8ec2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast calculation of \(C\) if it is less than or equal to an upper bound.  <br /></td></tr>
<tr class="separator:aac9327821de6e918b01ac58c5e5f8ec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c3f637b02ebf8c6b82b6098cfbc40ca" id="r_a0c3f637b02ebf8c6b82b6098cfbc40ca"><td class="memItemLeft" align="right" valign="top">constexpr uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c3f637b02ebf8c6b82b6098cfbc40ca">alpha</a> (const int64_t n, const int64_t d1, const int64_t d2) noexcept</td></tr>
<tr class="memdesc:a0c3f637b02ebf8c6b82b6098cfbc40ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Amount of crossings pairs of edges of given lengths.  <br /></td></tr>
<tr class="separator:a0c3f637b02ebf8c6b82b6098cfbc40ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad403e3fe175466a9544301b3d679eb9e" id="r_ad403e3fe175466a9544301b3d679eb9e"><td class="memItemLeft" align="right" valign="top">constexpr uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad403e3fe175466a9544301b3d679eb9e">beta</a> (const int64_t n, const int64_t d1, const int64_t d2) noexcept</td></tr>
<tr class="memdesc:ad403e3fe175466a9544301b3d679eb9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Amount of pairs of edges of given lengths.  <br /></td></tr>
<tr class="separator:ad403e3fe175466a9544301b3d679eb9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8965e5ea6dab322a1bfdd7ee94c7050f" id="r_a8965e5ea6dab322a1bfdd7ee94c7050f"><td class="memTemplParams" colspan="2">template&lt;typename result_t , class graph_t , class arrangement_t &gt; </td></tr>
<tr class="memitem:a8965e5ea6dab322a1bfdd7ee94c7050f"><td class="memTemplItemLeft" align="right" valign="top">result_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8965e5ea6dab322a1bfdd7ee94c7050f">predict_C_using_edge_lengths</a> (const graph_t &amp;g, const arrangement_t &amp;arr) noexcept</td></tr>
<tr class="memdesc:a8965e5ea6dab322a1bfdd7ee94c7050f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicted number of crossings based on the sum of edge lengths.  <br /></td></tr>
<tr class="separator:a8965e5ea6dab322a1bfdd7ee94c7050f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8452716fdc28399856f71906ef872b6c" id="r_a8452716fdc28399856f71906ef872b6c"><td class="memTemplParams" colspan="2">template&lt;class graph_t , class arrangement_t &gt; </td></tr>
<tr class="memitem:a8452716fdc28399856f71906ef872b6c"><td class="memTemplItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8452716fdc28399856f71906ef872b6c">sum_edge_lengths</a> (const graph_t &amp;g, const arrangement_t &amp;arr) noexcept</td></tr>
<tr class="memdesc:a8452716fdc28399856f71906ef872b6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum of edge lengths in a graph.  <br /></td></tr>
<tr class="separator:a8452716fdc28399856f71906ef872b6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f454be47191d83eb42085332877424e" id="r_a4f454be47191d83eb42085332877424e"><td class="memTemplParams" colspan="2">template&lt;class result_t , class graph_t , class arrangement_t &gt; </td></tr>
<tr class="memitem:a4f454be47191d83eb42085332877424e"><td class="memTemplItemLeft" align="right" valign="top">result_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4f454be47191d83eb42085332877424e">mean_sum_edge_lengths</a> (const graph_t &amp;g, const arrangement_t &amp;arr) noexcept</td></tr>
<tr class="memdesc:a4f454be47191d83eb42085332877424e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Average sum of edge lengths in a graph.  <br /></td></tr>
<tr class="separator:a4f454be47191d83eb42085332877424e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15a4c9114b9c800b7fbb2ccad69d94cd" id="r_a15a4c9114b9c800b7fbb2ccad69d94cd"><td class="memTemplParams" colspan="2">template&lt;class graph_t , <a class="el" href="#a802d6fe98fa1e77f474f63f151e8c215">level_signature_type</a> t&gt; </td></tr>
<tr class="memitem:a15a4c9114b9c800b7fbb2ccad69d94cd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a15a4c9114b9c800b7fbb2ccad69d94cd">is_level_signature_nonincreasing</a> (const graph_t &amp;g, const <a class="el" href="classlal_1_1detail_1_1level__signature.html">level_signature</a>&lt; t &gt; &amp;levels, const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;arr) noexcept</td></tr>
<tr class="memdesc:a15a4c9114b9c800b7fbb2ccad69d94cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the level sequence follows that of a maximum arrangement.  <br /></td></tr>
<tr class="separator:a15a4c9114b9c800b7fbb2ccad69d94cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44eb4714934478c361cefbcab8e40319" id="r_a44eb4714934478c361cefbcab8e40319"><td class="memTemplParams" colspan="2">template&lt;class graph_t , <a class="el" href="#a802d6fe98fa1e77f474f63f151e8c215">level_signature_type</a> t&gt; </td></tr>
<tr class="memitem:a44eb4714934478c361cefbcab8e40319"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a44eb4714934478c361cefbcab8e40319">no_two_adjacent_vertices_have_same_level</a> (const graph_t &amp;g, const <a class="el" href="classlal_1_1detail_1_1level__signature.html">level_signature</a>&lt; t &gt; &amp;levels, const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;arr) noexcept</td></tr>
<tr class="memdesc:a44eb4714934478c361cefbcab8e40319"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if no two adjacent vertices (in the graph) have the same level value.  <br /></td></tr>
<tr class="separator:a44eb4714934478c361cefbcab8e40319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1d25f75df270d8b44ea5eae86f5eabc" id="r_ad1d25f75df270d8b44ea5eae86f5eabc"><td class="memTemplParams" colspan="2">template&lt;class graph_t , <a class="el" href="#a802d6fe98fa1e77f474f63f151e8c215">level_signature_type</a> t&gt; </td></tr>
<tr class="memitem:ad1d25f75df270d8b44ea5eae86f5eabc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad1d25f75df270d8b44ea5eae86f5eabc">no_vertex_in_antenna_is_thistle</a> (const graph_t &amp;g, const std::vector&lt; <a class="el" href="classlal_1_1properties_1_1branchless__path.html">properties::branchless_path</a> &gt; &amp;bps, const <a class="el" href="classlal_1_1detail_1_1level__signature.html">level_signature</a>&lt; t &gt; &amp;levels, const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;arr) noexcept</td></tr>
<tr class="memdesc:ad1d25f75df270d8b44ea5eae86f5eabc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if none of the vertices in the antennas of the graph is a thistle.  <br /></td></tr>
<tr class="separator:ad1d25f75df270d8b44ea5eae86f5eabc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90591a2790d19e95e2f44668207a268f" id="r_a90591a2790d19e95e2f44668207a268f"><td class="memTemplParams" colspan="2">template&lt;class graph_t , <a class="el" href="#a802d6fe98fa1e77f474f63f151e8c215">level_signature_type</a> t&gt; </td></tr>
<tr class="memitem:a90591a2790d19e95e2f44668207a268f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a90591a2790d19e95e2f44668207a268f">at_most_one_thistle_in_bridges</a> (const graph_t &amp;g, const std::vector&lt; <a class="el" href="classlal_1_1properties_1_1branchless__path.html">properties::branchless_path</a> &gt; &amp;bps, const <a class="el" href="classlal_1_1detail_1_1level__signature.html">level_signature</a>&lt; t &gt; &amp;levels, const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;arr) noexcept</td></tr>
<tr class="memdesc:a90591a2790d19e95e2f44668207a268f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if none of the vertices in the antennas of the graph is a thistle.  <br /></td></tr>
<tr class="separator:a90591a2790d19e95e2f44668207a268f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7f64293d24dbac73bc23a087aff348a" id="r_aa7f64293d24dbac73bc23a087aff348a"><td class="memTemplParams" colspan="2">template&lt;class depflux , class arrangement_t &gt; </td></tr>
<tr class="memitem:aa7f64293d24dbac73bc23a087aff348a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa7f64293d24dbac73bc23a087aff348a">calculate_dependencies_and_span</a> (const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;t, const arrangement_t &amp;arr, const std::vector&lt; std::pair&lt; <a class="el" href="namespacelal.html#af8e55c3f8923a4ba55e8117a20a75b4a">edge_t</a>, uint64_t &gt; &gt; &amp;edge_with_max_pos_at, const <a class="el" href="namespacelal.html#a5c3f34575ec933a44ed7b6d81e8c75f6">position</a> cur_pos, std::vector&lt; depflux &gt; &amp;flux, std::vector&lt; <a class="el" href="namespacelal.html#a5969ec7ecc85697ebb9ec0ace78fbcab">edge</a> &gt; &amp;cur_deps) noexcept</td></tr>
<tr class="memdesc:aa7f64293d24dbac73bc23a087aff348a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the dependencies and their span.  <br /></td></tr>
<tr class="separator:aa7f64293d24dbac73bc23a087aff348a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38e173ec404e2222f2d4b5a20dcdfe8b" id="r_a38e173ec404e2222f2d4b5a20dcdfe8b"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a38e173ec404e2222f2d4b5a20dcdfe8b">calculate_weight</a> (const std::vector&lt; <a class="el" href="namespacelal.html#a5969ec7ecc85697ebb9ec0ace78fbcab">edge</a> &gt; &amp;dependencies, <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;ug) noexcept</td></tr>
<tr class="memdesc:a38e173ec404e2222f2d4b5a20dcdfe8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the weight of a set of dependencies in a flux.  <br /></td></tr>
<tr class="separator:a38e173ec404e2222f2d4b5a20dcdfe8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f34b48937d167823667155da1b7c6ba" id="r_a1f34b48937d167823667155da1b7c6ba"><td class="memTemplParams" colspan="2">template&lt;class arrangement_t &gt; </td></tr>
<tr class="memitem:a1f34b48937d167823667155da1b7c6ba"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1f34b48937d167823667155da1b7c6ba">is_root_covered</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;rt, const arrangement_t &amp;arr) noexcept</td></tr>
<tr class="memdesc:a1f34b48937d167823667155da1b7c6ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the root of a rooted tree covered in a given arrangement?  <br /></td></tr>
<tr class="separator:a1f34b48937d167823667155da1b7c6ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4328332d0cc3162fa7c89982547bbfd" id="r_ae4328332d0cc3162fa7c89982547bbfd"><td class="memTemplParams" colspan="2">template&lt;class arrangement_t &gt; </td></tr>
<tr class="memitem:ae4328332d0cc3162fa7c89982547bbfd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae4328332d0cc3162fa7c89982547bbfd">is_projective</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;rt, const arrangement_t &amp;arr) noexcept</td></tr>
<tr class="memdesc:ae4328332d0cc3162fa7c89982547bbfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is a given arrangement projective?  <br /></td></tr>
<tr class="separator:ae4328332d0cc3162fa7c89982547bbfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6504a8c3ab02b566cc1c75854caf6e5a" id="r_a6504a8c3ab02b566cc1c75854caf6e5a"><td class="memTemplParams" colspan="2">template&lt;class arrangement_t &gt; </td></tr>
<tr class="memitem:a6504a8c3ab02b566cc1c75854caf6e5a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6504a8c3ab02b566cc1c75854caf6e5a">is_bipartite__connected</a> (const <a class="el" href="classlal_1_1properties_1_1bipartite__graph__coloring.html">properties::bipartite_graph_coloring</a> &amp;c, const arrangement_t &amp;arr) noexcept</td></tr>
<tr class="memdesc:a6504a8c3ab02b566cc1c75854caf6e5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is a given arrangement bipartite?  <br /></td></tr>
<tr class="separator:a6504a8c3ab02b566cc1c75854caf6e5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ab57809f98ba3830d67ca111445a755" id="r_a3ab57809f98ba3830d67ca111445a755"><td class="memTemplParams" colspan="2">template&lt;class graph_t , class arrangement_t &gt; </td></tr>
<tr class="memitem:a3ab57809f98ba3830d67ca111445a755"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3ab57809f98ba3830d67ca111445a755">is_bipartite</a> (const graph_t &amp;g, const arrangement_t &amp;arr) noexcept</td></tr>
<tr class="memdesc:a3ab57809f98ba3830d67ca111445a755"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is a given arrangement bipartite?  <br /></td></tr>
<tr class="separator:a3ab57809f98ba3830d67ca111445a755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5730f2fef2524437fafcbeb1383d9d96" id="r_a5730f2fef2524437fafcbeb1383d9d96"><td class="memTemplParams" colspan="2">template&lt;class arrangement_t &gt; </td></tr>
<tr class="memitem:a5730f2fef2524437fafcbeb1383d9d96"><td class="memTemplItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5730f2fef2524437fafcbeb1383d9d96">right_branching_edges</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;g, const arrangement_t &amp;arr) noexcept</td></tr>
<tr class="memdesc:a5730f2fef2524437fafcbeb1383d9d96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of right branching edges in a directed graph.  <br /></td></tr>
<tr class="separator:a5730f2fef2524437fafcbeb1383d9d96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace97a861f8ce972d844103dd12a2af62" id="r_ace97a861f8ce972d844103dd12a2af62"><td class="memTemplParams" colspan="2">template&lt;typename result_t , class arrangement_t &gt; </td></tr>
<tr class="memitem:ace97a861f8ce972d844103dd12a2af62"><td class="memTemplItemLeft" align="right" valign="top">result_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ace97a861f8ce972d844103dd12a2af62">head_initial</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;g, const arrangement_t &amp;arr) noexcept</td></tr>
<tr class="memdesc:ace97a861f8ce972d844103dd12a2af62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proposition of right branching edges in a directed graph.  <br /></td></tr>
<tr class="separator:ace97a861f8ce972d844103dd12a2af62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab082090dd9afb14ec54d6fd5d65c085e" id="r_ab082090dd9afb14ec54d6fd5d65c085e"><td class="memItemLeft" align="right" valign="top"><a id="ab082090dd9afb14ec54d6fd5d65c085e" name="ab082090dd9afb14ec54d6fd5d65c085e"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_per_vertex</b> (const <a class="el" href="#a802d6fe98fa1e77f474f63f151e8c215">level_signature_type</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:ab082090dd9afb14ec54d6fd5d65c085e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the template parameter is <a class="el" href="#a802d6fe98fa1e77f474f63f151e8c215a4663c74ba8d3cf8462c5080eeaf3718c">lal::detail::level_signature_type::per_vertex</a>. <br /></td></tr>
<tr class="separator:ab082090dd9afb14ec54d6fd5d65c085e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d7bb33694295abc3a1e47c977e020cd" id="r_a3d7bb33694295abc3a1e47c977e020cd"><td class="memItemLeft" align="right" valign="top"><a id="a3d7bb33694295abc3a1e47c977e020cd" name="a3d7bb33694295abc3a1e47c977e020cd"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_per_position</b> (const <a class="el" href="#a802d6fe98fa1e77f474f63f151e8c215">level_signature_type</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:a3d7bb33694295abc3a1e47c977e020cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the template parameter is <a class="el" href="#a802d6fe98fa1e77f474f63f151e8c215af39c97817de5c7bd3f11541c94cbdacb">lal::detail::level_signature_type::per_position</a>. <br /></td></tr>
<tr class="separator:a3d7bb33694295abc3a1e47c977e020cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bc49ef158d5f8f31c387e870a06f330" id="r_a4bc49ef158d5f8f31c387e870a06f330"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#a802d6fe98fa1e77f474f63f151e8c215">level_signature_type</a> t, class graph_t &gt; </td></tr>
<tr class="memitem:a4bc49ef158d5f8f31c387e870a06f330"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4bc49ef158d5f8f31c387e870a06f330">is_thistle_vertex</a> (const graph_t &amp;g, const <a class="el" href="classlal_1_1detail_1_1level__signature.html">level_signature</a>&lt; t &gt; &amp;levels, const <a class="el" href="structlal_1_1node__t.html">node_t</a> u, const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;arr={}) noexcept</td></tr>
<tr class="memdesc:a4bc49ef158d5f8f31c387e870a06f330"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not the input vertex is a thistle vertex.  <br /></td></tr>
<tr class="separator:a4bc49ef158d5f8f31c387e870a06f330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac88652728e1d3ec55cc25b1620f6065f" id="r_ac88652728e1d3ec55cc25b1620f6065f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#a802d6fe98fa1e77f474f63f151e8c215">level_signature_type</a> t, class graph_t &gt; </td></tr>
<tr class="memitem:ac88652728e1d3ec55cc25b1620f6065f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac88652728e1d3ec55cc25b1620f6065f">calculate_level_signature</a> (const graph_t &amp;g, const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;arr, <a class="el" href="classlal_1_1detail_1_1level__signature.html">level_signature</a>&lt; t &gt; &amp;L) noexcept</td></tr>
<tr class="memdesc:ac88652728e1d3ec55cc25b1620f6065f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the level signature of an arrangement of a graph.  <br /></td></tr>
<tr class="separator:ac88652728e1d3ec55cc25b1620f6065f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14367a955376438e65d1c25cd61f0b20" id="r_a14367a955376438e65d1c25cd61f0b20"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#a802d6fe98fa1e77f474f63f151e8c215">level_signature_type</a> t, class graph_t &gt; </td></tr>
<tr class="memitem:a14367a955376438e65d1c25cd61f0b20"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1detail_1_1level__signature.html">level_signature</a>&lt; t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a14367a955376438e65d1c25cd61f0b20">calculate_level_signature</a> (const graph_t &amp;g, const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;arr) noexcept</td></tr>
<tr class="memdesc:a14367a955376438e65d1c25cd61f0b20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the level signature of an arrangement of a graph.  <br /></td></tr>
<tr class="separator:a14367a955376438e65d1c25cd61f0b20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca0f63ffdc99856ed0323879c85bf9f1" id="r_aca0f63ffdc99856ed0323879c85bf9f1"><td class="memTemplParams" colspan="2">template&lt;class level_signature_t &gt; </td></tr>
<tr class="memitem:aca0f63ffdc99856ed0323879c85bf9f1"><td class="memTemplItemLeft" align="right" valign="top">level_signature_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aca0f63ffdc99856ed0323879c85bf9f1">mirror_level_signature</a> (const level_signature_t &amp;L) noexcept</td></tr>
<tr class="memdesc:aca0f63ffdc99856ed0323879c85bf9f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mirrors a level signature.  <br /></td></tr>
<tr class="separator:aca0f63ffdc99856ed0323879c85bf9f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4c9a33cc1468c286ef8f54b0be769ae" id="r_ab4c9a33cc1468c286ef8f54b0be769ae"><td class="memItemLeft" align="right" valign="top">constexpr std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab4c9a33cc1468c286ef8f54b0be769ae">syntactic_dependency_tree_to_string</a> (const <a class="el" href="namespacelal_1_1linarr.html#a682101b23eb6c0db724df82e2aae18dd">linarr::syntactic_dependency_tree_type</a> &amp;tt) noexcept</td></tr>
<tr class="separator:ab4c9a33cc1468c286ef8f54b0be769ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9607b34bcc80c09c694fc694bd6a96a" id="r_ab9607b34bcc80c09c694fc694bd6a96a"><td class="memTemplParams" colspan="2"><a id="ab9607b34bcc80c09c694fc694bd6a96a" name="ab9607b34bcc80c09c694fc694bd6a96a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab9607b34bcc80c09c694fc694bd6a96a"><td class="memTemplItemLeft" align="right" valign="top">constexpr uint64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>to_uint64</b> (const T &amp;t) noexcept</td></tr>
<tr class="memdesc:ab9607b34bcc80c09c694fc694bd6a96a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion to uint64_t. <br /></td></tr>
<tr class="separator:ab9607b34bcc80c09c694fc694bd6a96a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67e72dd22d7c68404254ea092b3e8fa1" id="r_a67e72dd22d7c68404254ea092b3e8fa1"><td class="memTemplParams" colspan="2"><a id="a67e72dd22d7c68404254ea092b3e8fa1" name="a67e72dd22d7c68404254ea092b3e8fa1"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a67e72dd22d7c68404254ea092b3e8fa1"><td class="memTemplItemLeft" align="right" valign="top">constexpr int64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>to_int64</b> (const T &amp;t) noexcept</td></tr>
<tr class="memdesc:a67e72dd22d7c68404254ea092b3e8fa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion to int64_t. <br /></td></tr>
<tr class="separator:a67e72dd22d7c68404254ea092b3e8fa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0892490a9458044a9b1a4c319eb506b9" id="r_a0892490a9458044a9b1a4c319eb506b9"><td class="memTemplParams" colspan="2"><a id="a0892490a9458044a9b1a4c319eb506b9" name="a0892490a9458044a9b1a4c319eb506b9"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0892490a9458044a9b1a4c319eb506b9"><td class="memTemplItemLeft" align="right" valign="top">constexpr uint32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>to_uint32</b> (const T &amp;t) noexcept</td></tr>
<tr class="memdesc:a0892490a9458044a9b1a4c319eb506b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion to uint32_t. <br /></td></tr>
<tr class="separator:a0892490a9458044a9b1a4c319eb506b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c01d58d26367a1a1216a85efd537227" id="r_a7c01d58d26367a1a1216a85efd537227"><td class="memTemplParams" colspan="2"><a id="a7c01d58d26367a1a1216a85efd537227" name="a7c01d58d26367a1a1216a85efd537227"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7c01d58d26367a1a1216a85efd537227"><td class="memTemplItemLeft" align="right" valign="top">constexpr int32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>to_int32</b> (const T &amp;t) noexcept</td></tr>
<tr class="memdesc:a7c01d58d26367a1a1216a85efd537227"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion to int32_t. <br /></td></tr>
<tr class="separator:a7c01d58d26367a1a1216a85efd537227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d2da0aa7652f2dbbf6b7d6dc1e47fcd" id="r_a4d2da0aa7652f2dbbf6b7d6dc1e47fcd"><td class="memTemplParams" colspan="2"><a id="a4d2da0aa7652f2dbbf6b7d6dc1e47fcd" name="a4d2da0aa7652f2dbbf6b7d6dc1e47fcd"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4d2da0aa7652f2dbbf6b7d6dc1e47fcd"><td class="memTemplItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memTemplItemRight" valign="bottom"><b>to_double</b> (const T &amp;t) noexcept</td></tr>
<tr class="memdesc:a4d2da0aa7652f2dbbf6b7d6dc1e47fcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion to double. <br /></td></tr>
<tr class="separator:a4d2da0aa7652f2dbbf6b7d6dc1e47fcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd572e3130f477ef3c5098f1b21b5064" id="r_abd572e3130f477ef3c5098f1b21b5064"><td class="memTemplParams" colspan="2"><a id="abd572e3130f477ef3c5098f1b21b5064" name="abd572e3130f477ef3c5098f1b21b5064"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:abd572e3130f477ef3c5098f1b21b5064"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>abs_diff</b> (const T &amp;t1, const T &amp;t2) noexcept</td></tr>
<tr class="memdesc:abd572e3130f477ef3c5098f1b21b5064"><td class="mdescLeft">&#160;</td><td class="mdescRight">Absolute difference of two values. <br /></td></tr>
<tr class="separator:abd572e3130f477ef3c5098f1b21b5064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1e2965127d78fb7685c8745e2bf5d4b" id="r_ad1e2965127d78fb7685c8745e2bf5d4b"><td class="memTemplParams" colspan="2">template&lt;typename iterator_t , typename value_t &gt; </td></tr>
<tr class="memitem:ad1e2965127d78fb7685c8745e2bf5d4b"><td class="memTemplItemLeft" align="right" valign="top">iterator_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad1e2965127d78fb7685c8745e2bf5d4b">find_sorted</a> (const iterator_t begin, const iterator_t end, const std::size_t size, const value_t &amp;v, const std::size_t min_size=64) noexcept</td></tr>
<tr class="memdesc:ad1e2965127d78fb7685c8745e2bf5d4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an element within the sorted range [<em>begin</em>, <em>end</em>).  <br /></td></tr>
<tr class="separator:ad1e2965127d78fb7685c8745e2bf5d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf320cd3e1777bd4460eaeb9ecdf6986" id="r_acf320cd3e1777bd4460eaeb9ecdf6986"><td class="memTemplParams" colspan="2">template&lt;typename iterator_t , typename value_t &gt; </td></tr>
<tr class="memitem:acf320cd3e1777bd4460eaeb9ecdf6986"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acf320cd3e1777bd4460eaeb9ecdf6986">exists_sorted</a> (const iterator_t begin, const iterator_t end, const std::size_t size, const value_t &amp;v, const std::size_t min_size=64) noexcept</td></tr>
<tr class="memdesc:acf320cd3e1777bd4460eaeb9ecdf6986"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an element within the sorted range [<em>begin</em>, <em>end</em>).  <br /></td></tr>
<tr class="separator:acf320cd3e1777bd4460eaeb9ecdf6986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1c13d4871396a062ae9ce2533867b15" id="r_ab1c13d4871396a062ae9ce2533867b15"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t size, T v, std::size_t... I&gt; </td></tr>
<tr class="memitem:ab1c13d4871396a062ae9ce2533867b15"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::array&lt; T, size &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab1c13d4871396a062ae9ce2533867b15">make_array_with_value_impl</a> (std::index_sequence&lt; I... &gt;) noexcept</td></tr>
<tr class="memdesc:ab1c13d4871396a062ae9ce2533867b15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of <a class="el" href="#adfd794b7d5d1d3b62c7faa1572342dfe">lal::detail::make_array_with_value</a>.  <br /></td></tr>
<tr class="separator:ab1c13d4871396a062ae9ce2533867b15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfd794b7d5d1d3b62c7faa1572342dfe" id="r_adfd794b7d5d1d3b62c7faa1572342dfe"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t array_size, T value_to_fill_with&gt; </td></tr>
<tr class="memitem:adfd794b7d5d1d3b62c7faa1572342dfe"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::array&lt; T, array_size &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adfd794b7d5d1d3b62c7faa1572342dfe">make_array_with_value</a> () noexcept</td></tr>
<tr class="memdesc:adfd794b7d5d1d3b62c7faa1572342dfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an array initialized at a given value.  <br /></td></tr>
<tr class="separator:adfd794b7d5d1d3b62c7faa1572342dfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba881f87432bdfa65bc26d67244de6aa" id="r_aba881f87432bdfa65bc26d67244de6aa"><td class="memTemplParams" colspan="2">template&lt;typename T , T... ARGS&gt; </td></tr>
<tr class="memitem:aba881f87432bdfa65bc26d67244de6aa"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::array&lt; T, sizeof...(ARGS)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aba881f87432bdfa65bc26d67244de6aa">make_array</a> () noexcept</td></tr>
<tr class="memdesc:aba881f87432bdfa65bc26d67244de6aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make an array with the values given as parameters of the template.  <br /></td></tr>
<tr class="separator:aba881f87432bdfa65bc26d67244de6aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadddf96b5de80a3d63d05ec36f9cb672" id="r_aadddf96b5de80a3d63d05ec36f9cb672"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aadddf96b5de80a3d63d05ec36f9cb672">mpz_pow_mpz</a> (mpz_t &amp;r, const mpz_t &amp;b, const mpz_t &amp;e) noexcept</td></tr>
<tr class="memdesc:aadddf96b5de80a3d63d05ec36f9cb672"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the exponentiation of a big integer to another big integer.  <br /></td></tr>
<tr class="separator:aadddf96b5de80a3d63d05ec36f9cb672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52b8428c64f43950e2e231a38e2a730b" id="r_a52b8428c64f43950e2e231a38e2a730b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a52b8428c64f43950e2e231a38e2a730b">mpz_divide_mpq</a> (mpq_t &amp;r, const mpz_t &amp;k) noexcept</td></tr>
<tr class="memdesc:a52b8428c64f43950e2e231a38e2a730b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rational-Integer division.  <br /></td></tr>
<tr class="separator:a52b8428c64f43950e2e231a38e2a730b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a811da8587db802ee4de53fe9c4d26b7c" id="r_a811da8587db802ee4de53fe9c4d26b7c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a811da8587db802ee4de53fe9c4d26b7c">mpq_divide_mpq</a> (mpq_t &amp;num, const mpq_t &amp;den) noexcept</td></tr>
<tr class="memdesc:a811da8587db802ee4de53fe9c4d26b7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rational-Rational division.  <br /></td></tr>
<tr class="separator:a811da8587db802ee4de53fe9c4d26b7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82682656557db49caf9f7f0c0db9137f" id="r_a82682656557db49caf9f7f0c0db9137f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a82682656557db49caf9f7f0c0db9137f">operate_power</a> (mpq_t &amp;r, uint64_t p) noexcept</td></tr>
<tr class="memdesc:a82682656557db49caf9f7f0c0db9137f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Power operation.  <br /></td></tr>
<tr class="separator:a82682656557db49caf9f7f0c0db9137f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac06bbc1aa13b66438da3a404b295ef3f" id="r_ac06bbc1aa13b66438da3a404b295ef3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac06bbc1aa13b66438da3a404b295ef3f">operate_power</a> (mpq_t &amp;r, const mpz_t &amp;p) noexcept</td></tr>
<tr class="memdesc:ac06bbc1aa13b66438da3a404b295ef3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Power operation.  <br /></td></tr>
<tr class="separator:ac06bbc1aa13b66438da3a404b295ef3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74a37d4a4d50e88991a229f5bfd0307a" id="r_a74a37d4a4d50e88991a229f5bfd0307a"><td class="memItemLeft" align="right" valign="top"><a id="a74a37d4a4d50e88991a229f5bfd0307a" name="a74a37d4a4d50e88991a229f5bfd0307a"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>mpz_bytes</b> (const mpz_t &amp;v) noexcept</td></tr>
<tr class="memdesc:a74a37d4a4d50e88991a229f5bfd0307a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the amount of bytes of a gmp's integer value. <br /></td></tr>
<tr class="separator:a74a37d4a4d50e88991a229f5bfd0307a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99d34bc9f576f5e0bf9f30fd7ae1652f" id="r_a99d34bc9f576f5e0bf9f30fd7ae1652f"><td class="memTemplParams" colspan="2">template&lt;class tree_t &gt; </td></tr>
<tr class="memitem:a99d34bc9f576f5e0bf9f30fd7ae1652f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a99d34bc9f576f5e0bf9f30fd7ae1652f">expand_branchless_path</a> (const tree_t &amp;t, const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u, const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> v, <a class="el" href="classlal_1_1detail_1_1BFS.html">BFS</a>&lt; tree_t &gt; &amp;bfs, std::vector&lt; <a class="el" href="classlal_1_1properties_1_1branchless__path.html">properties::branchless_path</a> &gt; &amp;res, <a class="el" href="classlal_1_1properties_1_1branchless__path.html">properties::branchless_path</a> &amp;p) noexcept</td></tr>
<tr class="memdesc:a99d34bc9f576f5e0bf9f30fd7ae1652f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Completes the branchless path.  <br /></td></tr>
<tr class="separator:a99d34bc9f576f5e0bf9f30fd7ae1652f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef88cd07f45867fe4e4ab3511f316e72" id="r_aef88cd07f45867fe4e4ab3511f316e72"><td class="memTemplParams" colspan="2">template&lt;class tree_t &gt; </td></tr>
<tr class="memitem:aef88cd07f45867fe4e4ab3511f316e72"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classlal_1_1properties_1_1branchless__path.html">properties::branchless_path</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aef88cd07f45867fe4e4ab3511f316e72">branchless_paths_compute</a> (const tree_t &amp;t) noexcept</td></tr>
<tr class="memdesc:aef88cd07f45867fe4e4ab3511f316e72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds all branchless paths in a tree.  <br /></td></tr>
<tr class="separator:aef88cd07f45867fe4e4ab3511f316e72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe3b1dd38f2d471670141dfd38a3c5b6" id="r_abe3b1dd38f2d471670141dfd38a3c5b6"><td class="memTemplParams" colspan="2">template&lt;class tree_t , std::enable_if_t&lt; std::is_base_of_v&lt; <a class="el" href="classlal_1_1graphs_1_1tree.html">graphs::tree</a>, tree_t &gt;, bool &gt;  = true&gt; </td></tr>
<tr class="memitem:abe3b1dd38f2d471670141dfd38a3c5b6"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a>, <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abe3b1dd38f2d471670141dfd38a3c5b6">retrieve_centre</a> (const tree_t &amp;t, const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> X) noexcept</td></tr>
<tr class="memdesc:abe3b1dd38f2d471670141dfd38a3c5b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the centre of the connected component that has node <em>x</em>.  <br /></td></tr>
<tr class="separator:abe3b1dd38f2d471670141dfd38a3c5b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c80173f63af5c20df73f39036957579" id="r_a1c80173f63af5c20df73f39036957579"><td class="memItemLeft" align="right" valign="top"><a id="a1c80173f63af5c20df73f39036957579" name="a1c80173f63af5c20df73f39036957579"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_m1</b> (const <a class="el" href="#a47195c004957380992b21cdbb2b43cc9">centroid_results</a> &amp;m) noexcept</td></tr>
<tr class="memdesc:a1c80173f63af5c20df73f39036957579"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is mode <em>m</em> equal to <a class="el" href="#a47195c004957380992b21cdbb2b43cc9ab99249477c8f37e1ad46c4983716d39c">lal::detail::centroid_results::only_one_centroidal</a>. <br /></td></tr>
<tr class="separator:a1c80173f63af5c20df73f39036957579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70f4ca4489d7fed3b9d044b6c33afa35" id="r_a70f4ca4489d7fed3b9d044b6c33afa35"><td class="memItemLeft" align="right" valign="top"><a id="a70f4ca4489d7fed3b9d044b6c33afa35" name="a70f4ca4489d7fed3b9d044b6c33afa35"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_m2</b> (const <a class="el" href="#a47195c004957380992b21cdbb2b43cc9">centroid_results</a> &amp;m) noexcept</td></tr>
<tr class="memdesc:a70f4ca4489d7fed3b9d044b6c33afa35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is mode <em>m</em> equal to <a class="el" href="#a47195c004957380992b21cdbb2b43cc9a9ef639b9182eadfee611fc58dd23f9d3">lal::detail::centroid_results::full_centroid</a>. <br /></td></tr>
<tr class="separator:a70f4ca4489d7fed3b9d044b6c33afa35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38793200c1b18d533c316775524c175c" id="r_a38793200c1b18d533c316775524c175c"><td class="memItemLeft" align="right" valign="top"><a id="a38793200c1b18d533c316775524c175c" name="a38793200c1b18d533c316775524c175c"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_m3</b> (const <a class="el" href="#a47195c004957380992b21cdbb2b43cc9">centroid_results</a> &amp;m) noexcept</td></tr>
<tr class="memdesc:a38793200c1b18d533c316775524c175c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is mode <em>m</em> equal to <a class="el" href="#a47195c004957380992b21cdbb2b43cc9ae6e2f4d15b78cfcbb5a70f39f0d9dda8">lal::detail::centroid_results::full_centroid_plus_subtree_sizes</a>. <br /></td></tr>
<tr class="separator:a38793200c1b18d533c316775524c175c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe028144d25be302a1f85632559ccf5c" id="r_abe028144d25be302a1f85632559ccf5c"><td class="memItemLeft" align="right" valign="top"><a id="abe028144d25be302a1f85632559ccf5c" name="abe028144d25be302a1f85632559ccf5c"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_m4</b> (const <a class="el" href="#a47195c004957380992b21cdbb2b43cc9">centroid_results</a> &amp;m) noexcept</td></tr>
<tr class="memdesc:abe028144d25be302a1f85632559ccf5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is mode <em>m</em> equal to <a class="el" href="#a47195c004957380992b21cdbb2b43cc9a454774b2983a333885b75c8845707e38">lal::detail::centroid_results::full_centroid_plus_edge_sizes</a>. <br /></td></tr>
<tr class="separator:abe028144d25be302a1f85632559ccf5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7660881b12f071a0ad480e4d4ed7725" id="r_ac7660881b12f071a0ad480e4d4ed7725"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#a47195c004957380992b21cdbb2b43cc9">centroid_results</a> mode, class tree_t , std::enable_if_t&lt; std::is_base_of_v&lt; <a class="el" href="classlal_1_1graphs_1_1tree.html">graphs::tree</a>, tree_t &gt;, bool &gt;  = true&gt; </td></tr>
<tr class="memitem:ac7660881b12f071a0ad480e4d4ed7725"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#a94b315fff0ef08b701cb06c1e4497bbb">conditional_list_t</a>&lt; <a class="el" href="structlal_1_1detail_1_1bool__sequence.html">bool_sequence</a>&lt; <a class="el" href="#a1c80173f63af5c20df73f39036957579">is_m1</a>(mode), <a class="el" href="#a70f4ca4489d7fed3b9d044b6c33afa35">is_m2</a>(mode), <a class="el" href="#a38793200c1b18d533c316775524c175c">is_m3</a>(mode), <a class="el" href="#abe028144d25be302a1f85632559ccf5c">is_m4</a>(mode) &gt;, <a class="el" href="structlal_1_1detail_1_1type__sequence.html">type_sequence</a>&lt; <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a>, std::pair&lt; <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a>, <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> &gt;, std::pair&lt; std::pair&lt; <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a>, <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> &gt;, <a class="el" href="structlal_1_1detail_1_1array.html">array</a>&lt; uint64_t &gt; &gt;, std::pair&lt; std::pair&lt; <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a>, <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> &gt;, <a class="el" href="structlal_1_1detail_1_1array.html">array</a>&lt; <a class="el" href="structlal_1_1detail_1_1edge__size.html">edge_size</a> &gt; &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac7660881b12f071a0ad480e4d4ed7725">find_centroidal_vertex</a> (const tree_t &amp;t, const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> x) noexcept</td></tr>
<tr class="memdesc:ac7660881b12f071a0ad480e4d4ed7725"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the centroid of a tree.  <br /></td></tr>
<tr class="separator:ac7660881b12f071a0ad480e4d4ed7725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8def8df0a8d710569d59e3e3a7042a2" id="r_ab8def8df0a8d710569d59e3e3a7042a2"><td class="memTemplParams" colspan="2">template&lt;class tree_t , std::enable_if_t&lt; std::is_base_of_v&lt; <a class="el" href="classlal_1_1graphs_1_1tree.html">graphs::tree</a>, tree_t &gt;, bool &gt;  = true&gt; </td></tr>
<tr class="memitem:ab8def8df0a8d710569d59e3e3a7042a2"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a>, <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab8def8df0a8d710569d59e3e3a7042a2">centroidal_vertex_plus_adjacency_list</a> (const tree_t &amp;t, const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> x, std::vector&lt; std::vector&lt; <a class="el" href="structlal_1_1detail_1_1node__size.html">node_size</a> &gt; &gt; &amp;L) noexcept</td></tr>
<tr class="memdesc:ab8def8df0a8d710569d59e3e3a7042a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the centroid and the corresponding rooted adjacency list.  <br /></td></tr>
<tr class="separator:ab8def8df0a8d710569d59e3e3a7042a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d196fa5a4cf30d46810eb86634da4f0" id="r_a2d196fa5a4cf30d46810eb86634da4f0"><td class="memTemplParams" colspan="2">template&lt;class tree_t , std::enable_if_t&lt; std::is_base_of_v&lt; <a class="el" href="classlal_1_1graphs_1_1tree.html">graphs::tree</a>, tree_t &gt;, bool &gt;  = true&gt; </td></tr>
<tr class="memitem:a2d196fa5a4cf30d46810eb86634da4f0"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a>, <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2d196fa5a4cf30d46810eb86634da4f0">retrieve_centroid</a> (const tree_t &amp;t, const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> x=0) noexcept</td></tr>
<tr class="memdesc:a2d196fa5a4cf30d46810eb86634da4f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the centroid of the connected component that has node <em>x</em>.  <br /></td></tr>
<tr class="separator:a2d196fa5a4cf30d46810eb86634da4f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fe31411ada0a0c45093503fb6f9406f" id="r_a0fe31411ada0a0c45093503fb6f9406f"><td class="memTemplParams" colspan="2">template&lt;class tree_t , std::enable_if_t&lt; std::is_base_of_v&lt; <a class="el" href="classlal_1_1graphs_1_1tree.html">graphs::tree</a>, tree_t &gt;, bool &gt;  = true&gt; </td></tr>
<tr class="memitem:a0fe31411ada0a0c45093503fb6f9406f"><td class="memTemplItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0fe31411ada0a0c45093503fb6f9406f">tree_diameter</a> (const tree_t &amp;t, const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> x) noexcept</td></tr>
<tr class="memdesc:a0fe31411ada0a0c45093503fb6f9406f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the diameter of a tree.  <br /></td></tr>
<tr class="separator:a0fe31411ada0a0c45093503fb6f9406f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2547121a9b242032eb4a4be0d318a7d5" id="r_a2547121a9b242032eb4a4be0d318a7d5"><td class="memTemplParams" colspan="2">template&lt;class tree_t , std::enable_if_t&lt; std::is_base_of_v&lt; <a class="el" href="classlal_1_1graphs_1_1tree.html">graphs::tree</a>, tree_t &gt;, bool &gt;  = true&gt; </td></tr>
<tr class="memitem:a2547121a9b242032eb4a4be0d318a7d5"><td class="memTemplItemLeft" align="right" valign="top">char&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2547121a9b242032eb4a4be0d318a7d5">fast_non_iso</a> (const tree_t &amp;t1, const tree_t &amp;t2) noexcept</td></tr>
<tr class="memdesc:a2547121a9b242032eb4a4be0d318a7d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast tree non-isomorphism test.  <br /></td></tr>
<tr class="separator:a2547121a9b242032eb4a4be0d318a7d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7327a31edd874aff5e7956a9545b8a14" id="r_a7327a31edd874aff5e7956a9545b8a14"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7327a31edd874aff5e7956a9545b8a14">assign_name_and_keep</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;t, const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u, std::size_t idx, <a class="el" href="structlal_1_1detail_1_1array.html">array</a>&lt; std::string &gt; &amp;aux_memory_for_names, <a class="el" href="structlal_1_1detail_1_1array.html">array</a>&lt; std::string &gt; &amp;keep_name_of) noexcept</td></tr>
<tr class="memdesc:a7327a31edd874aff5e7956a9545b8a14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns a name to node 'u', root of the current subtree.  <br /></td></tr>
<tr class="separator:a7327a31edd874aff5e7956a9545b8a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c25fb79483d872d14fdf4fa3ab958b3" id="r_a2c25fb79483d872d14fdf4fa3ab958b3"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c25fb79483d872d14fdf4fa3ab958b3">assign_name</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;t, const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u, <a class="el" href="structlal_1_1detail_1_1array.html">array</a>&lt; std::string &gt; &amp;names, std::size_t idx) noexcept</td></tr>
<tr class="memdesc:a2c25fb79483d872d14fdf4fa3ab958b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns a name to node 'u', root of the current subtree.  <br /></td></tr>
<tr class="separator:a2c25fb79483d872d14fdf4fa3ab958b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f870cfa27819350e84e969a585fcbd9" id="r_a3f870cfa27819350e84e969a585fcbd9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f870cfa27819350e84e969a585fcbd9">are_rooted_trees_isomorphic</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;t1, const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;t2) noexcept</td></tr>
<tr class="memdesc:a3f870cfa27819350e84e969a585fcbd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether two rooted trees are isomorphic or not.  <br /></td></tr>
<tr class="separator:a3f870cfa27819350e84e969a585fcbd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aed9806774914e302211489b1e5e38769" id="r_aed9806774914e302211489b1e5e38769"><td class="memItemLeft" align="right" valign="top"><a id="aed9806774914e302211489b1e5e38769" name="aed9806774914e302211489b1e5e38769"></a>
constexpr std::array&lt; <a class="el" href="namespacelal_1_1graphs.html#a18d52542088507e2be6241759722835b">graphs::tree_type</a>, <a class="el" href="namespacelal_1_1graphs.html#a1895a9ed855ad1d85cd9510de714a732">graphs::__tree_type_size</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>array_of_tree_types</b></td></tr>
<tr class="memdesc:aed9806774914e302211489b1e5e38769"><td class="mdescLeft">&#160;</td><td class="mdescRight">The array of all types of trees. <br /></td></tr>
<tr class="separator:aed9806774914e302211489b1e5e38769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35fb62e1a794e483ab2f5443d5422bfc" id="r_a35fb62e1a794e483ab2f5443d5422bfc"><td class="memItemLeft" align="right" valign="top"><a id="a35fb62e1a794e483ab2f5443d5422bfc" name="a35fb62e1a794e483ab2f5443d5422bfc"></a>
constexpr std::array&lt; <a class="el" href="namespacelal_1_1linarr.html#a682101b23eb6c0db724df82e2aae18dd">linarr::syntactic_dependency_tree_type</a>, <a class="el" href="namespacelal_1_1linarr.html#a7f09036a41db5bf5009bff33658c988e">linarr::__syntactic_dependency_tree_size</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>array_of_syntactic_dependency_trees</b></td></tr>
<tr class="memdesc:a35fb62e1a794e483ab2f5443d5422bfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The array of all types of syntact dependency structures. <br /></td></tr>
<tr class="separator:a35fb62e1a794e483ab2f5443d5422bfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a061ab47fda03ab411321f87a56dd31cc" id="r_a061ab47fda03ab411321f87a56dd31cc"><td class="memTemplParams" colspan="2"><a id="a061ab47fda03ab411321f87a56dd31cc" name="a061ab47fda03ab411321f87a56dd31cc"></a>
template&lt;bool... conds&gt; </td></tr>
<tr class="memitem:a061ab47fda03ab411321f87a56dd31cc"><td class="memTemplItemLeft" align="right" valign="top">static constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>first_true_v</b> = <a class="el" href="structlal_1_1detail_1_1first__true.html">first_true</a>&lt;conds...&gt;::value</td></tr>
<tr class="memdesc:a061ab47fda03ab411321f87a56dd31cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shorthand for <a class="el" href="structlal_1_1detail_1_1first__true.html">first_true</a>. <br /></td></tr>
<tr class="separator:a061ab47fda03ab411321f87a56dd31cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1acf6acf0c665841481303603b6ddb02" id="r_a1acf6acf0c665841481303603b6ddb02"><td class="memTemplParams" colspan="2"><a id="a1acf6acf0c665841481303603b6ddb02" name="a1acf6acf0c665841481303603b6ddb02"></a>
template&lt;typename Iterated_Type , typename Iterator &gt; </td></tr>
<tr class="memitem:a1acf6acf0c665841481303603b6ddb02"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_pointer_iterator_v</b></td></tr>
<tr class="memdesc:a1acf6acf0c665841481303603b6ddb02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shorthand for <a class="el" href="structlal_1_1detail_1_1is__pointer__iterator.html">is_pointer_iterator</a>. <br /></td></tr>
<tr class="separator:a1acf6acf0c665841481303603b6ddb02"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Detail namespace. </p>
<p>Most algorithms are included here. Unless you have a really good reason to use the algorithms in this namespace, please, refrain from doing so. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a2b1b5c673937cf017e8b8435807a3f03" name="a2b1b5c673937cf017e8b8435807a3f03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b1b5c673937cf017e8b8435807a3f03">&#9670;&#160;</a></span>arrangement_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a2b1b5c673937cf017e8b8435807a3f03">lal::detail::arrangement_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Type of arrangement. </p>
<p>Used to call functions that have arrangements as input parameters. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2b1b5c673937cf017e8b8435807a3f03aff483d1ff591898a9942916050d2ca3f" name="a2b1b5c673937cf017e8b8435807a3f03aff483d1ff591898a9942916050d2ca3f"></a>identity&#160;</td><td class="fielddoc"><p>Identity arrangement. \(\pi(i)=i\). </p>
</td></tr>
<tr><td class="fieldname"><a id="a2b1b5c673937cf017e8b8435807a3f03ad674c25b71b5fd0c22b56965b7f58b76" name="a2b1b5c673937cf017e8b8435807a3f03ad674c25b71b5fd0c22b56965b7f58b76"></a>nonidentity&#160;</td><td class="fielddoc"><p>Non-identity arrangement. An arrangement that is not the identity. </p>
</td></tr>
</table>

</div>
</div>
<a id="a47195c004957380992b21cdbb2b43cc9" name="a47195c004957380992b21cdbb2b43cc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47195c004957380992b21cdbb2b43cc9">&#9670;&#160;</a></span>centroid_results</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a47195c004957380992b21cdbb2b43cc9">lal::detail::centroid_results</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The different types of results. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a47195c004957380992b21cdbb2b43cc9ab99249477c8f37e1ad46c4983716d39c" name="a47195c004957380992b21cdbb2b43cc9ab99249477c8f37e1ad46c4983716d39c"></a>only_one_centroidal&#160;</td><td class="fielddoc"><p>Returns only one centroidal vertex. No weights. </p>
</td></tr>
<tr><td class="fieldname"><a id="a47195c004957380992b21cdbb2b43cc9a9ef639b9182eadfee611fc58dd23f9d3" name="a47195c004957380992b21cdbb2b43cc9a9ef639b9182eadfee611fc58dd23f9d3"></a>full_centroid&#160;</td><td class="fielddoc"><p>Returns the full centroid of the tree. No weights. </p>
</td></tr>
<tr><td class="fieldname"><a id="a47195c004957380992b21cdbb2b43cc9ae6e2f4d15b78cfcbb5a70f39f0d9dda8" name="a47195c004957380992b21cdbb2b43cc9ae6e2f4d15b78cfcbb5a70f39f0d9dda8"></a>full_centroid_plus_subtree_sizes&#160;</td><td class="fielddoc"><p>Returns the full centroid of the tree. Also returns the weights. </p>
</td></tr>
<tr><td class="fieldname"><a id="a47195c004957380992b21cdbb2b43cc9a454774b2983a333885b75c8845707e38" name="a47195c004957380992b21cdbb2b43cc9a454774b2983a333885b75c8845707e38"></a>full_centroid_plus_edge_sizes&#160;</td><td class="fielddoc"><p>Returns the full centroid of the tree. Also returns the <a class="el" href="structlal_1_1detail_1_1edge__size.html" title="Struct used in many algorithms to sort edges according to some integer value.">edge_size</a> array. </p>
</td></tr>
</table>

</div>
</div>
<a id="a802d6fe98fa1e77f474f63f151e8c215" name="a802d6fe98fa1e77f474f63f151e8c215"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a802d6fe98fa1e77f474f63f151e8c215">&#9670;&#160;</a></span>level_signature_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a802d6fe98fa1e77f474f63f151e8c215">lal::detail::level_signature_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Types of level signature. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a802d6fe98fa1e77f474f63f151e8c215a4663c74ba8d3cf8462c5080eeaf3718c" name="a802d6fe98fa1e77f474f63f151e8c215a4663c74ba8d3cf8462c5080eeaf3718c"></a>per_vertex&#160;</td><td class="fielddoc"><p>Given per vertex. </p>
<p>The level value is queried via a vertex u, "L[u]". </p>
</td></tr>
<tr><td class="fieldname"><a id="a802d6fe98fa1e77f474f63f151e8c215af39c97817de5c7bd3f11541c94cbdacb" name="a802d6fe98fa1e77f474f63f151e8c215af39c97817de5c7bd3f11541c94cbdacb"></a>per_position&#160;</td><td class="fielddoc"><p>Given per position. </p>
<p>The level value is queried via a position p, "L[p]". </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a0c3f637b02ebf8c6b82b6098cfbc40ca" name="a0c3f637b02ebf8c6b82b6098cfbc40ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c3f637b02ebf8c6b82b6098cfbc40ca">&#9670;&#160;</a></span>alpha()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lal::detail::alpha </td>
          <td>(</td>
          <td class="paramtype">const int64_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t</td>          <td class="paramname"><span class="paramname"><em>d1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t</td>          <td class="paramname"><span class="paramname"><em>d2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Amount of crossings pairs of edges of given lengths. </p>
<p>Complexity: constant time. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of edges in the linear arrangement. </td></tr>
    <tr><td class="paramname">d1</td><td>Length of the first edge. </td></tr>
    <tr><td class="paramname">d2</td><td>Length of the second edge. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The amount of pairs of edges of lengths <em>d1</em> and <em>d2</em> respectively that can cross in a linear arrangement. </dd></dl>

</div>
</div>
<a id="a99e564e21a58d5a88f53503f71317136" name="a99e564e21a58d5a88f53503f71317136"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99e564e21a58d5a88f53503f71317136">&#9670;&#160;</a></span>append_adjacency_lists()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::detail::append_adjacency_lists </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacelal.html#aef91d923414879a998619e9c65181d1f">neighbourhood</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacelal.html#aef91d923414879a998619e9c65181d1f">neighbourhood</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append adjacency list 'source' to list 'target'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>List into which <em>source</em> will be appended to. </td></tr>
    <tr><td class="paramname">source</td><td>List to append to <em>target</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3f870cfa27819350e84e969a585fcbd9" name="a3f870cfa27819350e84e969a585fcbd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f870cfa27819350e84e969a585fcbd9">&#9670;&#160;</a></span>are_rooted_trees_isomorphic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::detail::are_rooted_trees_isomorphic </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test whether two rooted trees are isomorphic or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t1</td><td>First rooted tree. </td></tr>
    <tr><td class="paramname">t2</td><td>Second rooted tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True or false. </dd></dl>

</div>
</div>
<a id="a2c25fb79483d872d14fdf4fa3ab958b3" name="a2c25fb79483d872d14fdf4fa3ab958b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c25fb79483d872d14fdf4fa3ab958b3">&#9670;&#160;</a></span>assign_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string lal::detail::assign_name </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlal_1_1detail_1_1array.html">array</a>&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>names</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns a name to node 'u', root of the current subtree. </p>
<p>For further details on the algorithm, see <a class="el" href="citelist.html#CITEREF_Aho1974a">[1]</a> for further details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input rooted tree </td></tr>
    <tr><td class="paramname">u</td><td>Root of the subtree whose name we want to calculate </td></tr>
    <tr><td class="paramname">names</td><td>An array of strings where the names are stored (as in a dynamic programming algorithm). The size of this array must be at least the number of vertices in the subtree of 't' rooted at 'u'. Actually, less memory suffices, but I don't know how much less: better be safe than sorry. </td></tr>
    <tr><td class="paramname">idx</td><td>A pointer to the position within <em>names</em> that will contain the name of the first child of 'u'. The position <em>names</em>[idx+1] will contain the name of the second child of 'u'. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The code for the subtree rooted at 'u'. </dd></dl>

</div>
</div>
<a id="a7327a31edd874aff5e7956a9545b8a14" name="a7327a31edd874aff5e7956a9545b8a14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7327a31edd874aff5e7956a9545b8a14">&#9670;&#160;</a></span>assign_name_and_keep()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::detail::assign_name_and_keep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlal_1_1detail_1_1array.html">array</a>&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>aux_memory_for_names</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlal_1_1detail_1_1array.html">array</a>&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>keep_name_of</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns a name to node 'u', root of the current subtree. </p>
<p>This function stores the names of every node in the subtree rooted at 'u'. This is useful if we want to make lots of comparisons between subtrees</p>
<p>For further details on the algorithm, see <a class="el" href="citelist.html#CITEREF_Aho1974a">[1]</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input rooted tree </td></tr>
    <tr><td class="paramname">u</td><td>Root of the subtree whose name we want to calculate </td></tr>
    <tr><td class="paramname">idx</td><td>A pointer to the position within <em>names</em> that will contain the name of the first child of 'u'. The position <em>names</em>[idx+1] will contain the name of the second child of 'u'. </td></tr>
    <tr><td class="paramname">aux_memory_for_names</td><td>Auxiliary memory used to sort names of subtrees. </td></tr>
    <tr><td class="paramname">keep_name_of</td><td>An array of strings where the names are stored (as in a dynamic programming algorithm). The size of this array must be at least the number of vertices in the subtree of 't' rooted at 'u'. Actually, less memory suffices, but better be safe than sorry. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a90591a2790d19e95e2f44668207a268f" name="a90591a2790d19e95e2f44668207a268f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90591a2790d19e95e2f44668207a268f">&#9670;&#160;</a></span>at_most_one_thistle_in_bridges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class graph_t , <a class="el" href="#a802d6fe98fa1e77f474f63f151e8c215">level_signature_type</a> t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::detail::at_most_one_thistle_in_bridges </td>
          <td>(</td>
          <td class="paramtype">const graph_t &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classlal_1_1properties_1_1branchless__path.html">properties::branchless_path</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>bps</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1detail_1_1level__signature.html">level_signature</a>&lt; t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>levels</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>arr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if none of the vertices in the antennas of the graph is a thistle. </p>
<p>Checks that no vertex in any antenna of the tree is a thistle vertex in the input arrangement. This is a necessary condition for an arrangement to be maximum (in sum of edge lengths), as shown in <a class="el" href="citelist.html#CITEREF_Alemany2023a">[7]</a>.</p>
<p>When the level signature is defined on a 'per vertex' basis, the arrangement is not needed. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">t</td><td>Level signature type. </td></tr>
    <tr><td class="paramname">graph_t</td><td>Type of graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arr</td><td>Input arrangement. </td></tr>
    <tr><td class="paramname">levels</td><td>signature of the arrangement. </td></tr>
    <tr><td class="paramname">bps</td><td>All Branchless Paths of the tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the level sequence satisfies the condition. </dd></dl>

</div>
</div>
<a id="ad403e3fe175466a9544301b3d679eb9e" name="ad403e3fe175466a9544301b3d679eb9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad403e3fe175466a9544301b3d679eb9e">&#9670;&#160;</a></span>beta()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lal::detail::beta </td>
          <td>(</td>
          <td class="paramtype">const int64_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t</td>          <td class="paramname"><span class="paramname"><em>d1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t</td>          <td class="paramname"><span class="paramname"><em>d2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Amount of pairs of edges of given lengths. </p>
<p>Complexity: constant time. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of edges in the linear arrangement. </td></tr>
    <tr><td class="paramname">d1</td><td>Length of the first edge. </td></tr>
    <tr><td class="paramname">d2</td><td>Length of the second edge. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The amount of pairs of edges of lengths <em>d1</em> and <em>d2</em> respectively that can cross in a linear arrangement. </dd></dl>

</div>
</div>
<a id="aef88cd07f45867fe4e4ab3511f316e72" name="aef88cd07f45867fe4e4ab3511f316e72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef88cd07f45867fe4e4ab3511f316e72">&#9670;&#160;</a></span>branchless_paths_compute()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tree_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classlal_1_1properties_1_1branchless__path.html">properties::branchless_path</a> &gt; lal::detail::branchless_paths_compute </td>
          <td>(</td>
          <td class="paramtype">const tree_t &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds all branchless paths in a tree. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">tree_t</td><td>Type of tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The list of all branchless paths. </dd></dl>

</div>
</div>
<a id="a3b8f436879c464b089f1f2a67e507ffb" name="a3b8f436879c464b089f1f2a67e507ffb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b8f436879c464b089f1f2a67e507ffb">&#9670;&#160;</a></span>calculate_bidirectional_sizes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tree_t , typename iterator_t , std::enable_if_t&lt; std::is_base_of_v&lt; <a class="el" href="classlal_1_1graphs_1_1tree.html">graphs::tree</a>, tree_t &gt; and <a class="el" href="#a1acf6acf0c665841481303603b6ddb02">is_pointer_iterator_v</a>&lt; <a class="el" href="structlal_1_1detail_1_1edge__size.html">edge_size</a>, iterator_t &gt;, bool &gt;  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lal::detail::calculate_bidirectional_sizes </td>
          <td>(</td>
          <td class="paramtype">const tree_t &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterator_t &amp;</td>          <td class="paramname"><span class="paramname"><em>it</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the values \(s(u,v)\) for the edges \((s,t)\) reachable from \(v\) in the subtree \(T^u_v\). </p>
<p>This function calculates the 'map' relating each edge \((u, v)\) with the size of the subtree rooted at \(v\) with respect to the hypothetical root \(u\). This is an implementation of the algorithm described in <a class="el" href="citelist.html#CITEREF_Hochberg2003a">[30]</a> (proof of lemma 8 (page 63), and the beginning of section 6 (page 65)).</p>
<p>Notice that the values are not stored in an actual map (std::map, or similar), but in a vector. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">iterated_t</td><td>The type that stores the sizes. </td></tr>
    <tr><td class="paramname">iterator_t</td><td>The type of the iterator on a container containing values of type iterated_t. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input tree. </td></tr>
    <tr><td class="paramname">n</td><td>Size of the connected component to which edge \((u,v)\) belongs to. </td></tr>
    <tr><td class="paramname">u</td><td>First vertex of the edge. </td></tr>
    <tr><td class="paramname">v</td><td>Second vertex of the edge. </td></tr>
    <tr><td class="paramname">it</td><td>An iterator to the container that holds the size values. Such container must have size equal to twice the number of edges in the connected component of <em>u</em> and <em>v</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Vertices <em>u</em> and <em>v</em> belong to the same connected component. </dd></dl>

</div>
</div>
<a id="a332f440b66ce4e8dc243706901575023" name="a332f440b66ce4e8dc243706901575023"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a332f440b66ce4e8dc243706901575023">&#9670;&#160;</a></span>calculate_bidirectional_sizes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tree_t , typename iterator_t , std::enable_if_t&lt; std::is_base_of_v&lt; <a class="el" href="classlal_1_1graphs_1_1tree.html">graphs::tree</a>, tree_t &gt; and <a class="el" href="#a1acf6acf0c665841481303603b6ddb02">is_pointer_iterator_v</a>&lt; <a class="el" href="structlal_1_1detail_1_1edge__size.html">edge_size</a>, iterator_t &gt;, bool &gt;  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::detail::calculate_bidirectional_sizes </td>
          <td>(</td>
          <td class="paramtype">const tree_t &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterator_t</td>          <td class="paramname"><span class="paramname"><em>it</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the values \(s_u(v)\) for the edges \((u,v)\) reachable from vertex <em>x</em>. </p>
<p>Calculates the values \(s_u(v)\) for all edges \((u,v)\) in linear time. This is an implementation of the algorithm described in <a class="el" href="citelist.html#CITEREF_Hochberg2003a">[30]</a> (proof of lemma 8 (page 63), and the beginning of section 6 (page 65)).</p>
<p>For any edge \((u,v)\) let \(T^u\) be the tree \(T\) rooted at \(u\). The value \(s_u(v)\) is the size of the subtree of \(T^u\) rooted at \(v\), i.e., \(s_u(v)=|V(T^u_v)|\).</p>
<p>Example of usage (mind the vector! its initial size is \(2*m\)).</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classlal_1_1graphs_1_1free__tree.html">lal::graphs::free_tree</a> t = ... ;</div>
<div class="line">std::vector&lt;pair&lt;edge,uint64_t&gt;&gt; sizes_edges(2*t.<a class="code hl_function" href="classlal_1_1graphs_1_1graph.html#a351a7e8c6a0ec6c23026b0b0b57efd17">get_num_edges</a>());</div>
<div class="line"><span class="keyword">auto</span> it = sizes_edges.begin();</div>
<div class="line"><a class="code hl_function" href="#a3b8f436879c464b089f1f2a67e507ffb">lal::detail::calculate_bidirectional_sizes</a>(t, t.<a class="code hl_function" href="classlal_1_1graphs_1_1graph.html#a58918b2b3fe79dff35003604bdfa19f3">get_num_nodes</a>(), 0, it);</div>
<div class="ttc" id="aclasslal_1_1graphs_1_1free__tree_html"><div class="ttname"><a href="classlal_1_1graphs_1_1free__tree.html">lal::graphs::free_tree</a></div><div class="ttdoc">Free tree graph class.</div><div class="ttdef"><b>Definition</b> free_tree.hpp:60</div></div>
<div class="ttc" id="aclasslal_1_1graphs_1_1graph_html_a351a7e8c6a0ec6c23026b0b0b57efd17"><div class="ttname"><a href="classlal_1_1graphs_1_1graph.html#a351a7e8c6a0ec6c23026b0b0b57efd17">lal::graphs::graph::get_num_edges</a></div><div class="ttdeci">uint64_t get_num_edges() const noexcept</div><div class="ttdoc">Returns the number of edges.</div><div class="ttdef"><b>Definition</b> graph.hpp:211</div></div>
<div class="ttc" id="aclasslal_1_1graphs_1_1graph_html_a58918b2b3fe79dff35003604bdfa19f3"><div class="ttname"><a href="classlal_1_1graphs_1_1graph.html#a58918b2b3fe79dff35003604bdfa19f3">lal::graphs::graph::get_num_nodes</a></div><div class="ttdeci">uint64_t get_num_nodes() const noexcept</div><div class="ttdoc">Returns the number of ndoes.</div><div class="ttdef"><b>Definition</b> graph.hpp:207</div></div>
<div class="ttc" id="anamespacelal_1_1detail_html_a3b8f436879c464b089f1f2a67e507ffb"><div class="ttname"><a href="#a3b8f436879c464b089f1f2a67e507ffb">lal::detail::calculate_bidirectional_sizes</a></div><div class="ttdeci">uint64_t calculate_bidirectional_sizes(const tree_t &amp;t, const uint64_t n, const node u, const node v, iterator_t &amp;it) noexcept</div><div class="ttdoc">Calculates the values  for the edges  reachable from  in the subtree .</div><div class="ttdef"><b>Definition</b> size_subtrees.hpp:168</div></div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">tree_t</td><td>Type of the tree. Must be 'rooted_tree' or 'free_tree'. </td></tr>
    <tr><td class="paramname">iterated_t</td><td>The type that stores the sizes. </td></tr>
    <tr><td class="paramname">iterator_t</td><td>The type of the iterator on a container containing values of type iterated_t. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input tree </td></tr>
    <tr><td class="paramname">n</td><td>Number of nodes in the connected component of vertex <em>x</em> </td></tr>
    <tr><td class="paramname">x</td><td>Node of the connected component for which we want to calculate the bidirectional sizes </td></tr>
    <tr><td class="paramname">it</td><td>An iterator to the container that holds the size values. Such container must have size equal to twice the number of edges in the connected component of <em>u</em> and <em>v</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa7f64293d24dbac73bc23a087aff348a" name="aa7f64293d24dbac73bc23a087aff348a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7f64293d24dbac73bc23a087aff348a">&#9670;&#160;</a></span>calculate_dependencies_and_span()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class depflux , class arrangement_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::detail::calculate_dependencies_and_span </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arrangement_t &amp;</td>          <td class="paramname"><span class="paramname"><em>arr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; <a class="el" href="namespacelal.html#af8e55c3f8923a4ba55e8117a20a75b4a">edge_t</a>, uint64_t &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>edge_with_max_pos_at</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#a5c3f34575ec933a44ed7b6d81e8c75f6">position</a></td>          <td class="paramname"><span class="paramname"><em>cur_pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; depflux &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>flux</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacelal.html#a5969ec7ecc85697ebb9ec0ace78fbcab">edge</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>cur_deps</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the dependencies and their span. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">arrangement_t</td><td>Type of arrangement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">t</td><td>Input tree. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">arr</td><td>Input linear arrangement. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">edge_with_max_pos_at</td><td></td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cur_pos</td><td>Current position in the arrangement for which we calculate the dependencies. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">flux</td><td>The flux at this position. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cur_deps</td><td>The dependencies crossing this position. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a14367a955376438e65d1c25cd61f0b20" name="a14367a955376438e65d1c25cd61f0b20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14367a955376438e65d1c25cd61f0b20">&#9670;&#160;</a></span>calculate_level_signature() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#a802d6fe98fa1e77f474f63f151e8c215">level_signature_type</a> t, class graph_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1detail_1_1level__signature.html">level_signature</a>&lt; t &gt; lal::detail::calculate_level_signature </td>
          <td>(</td>
          <td class="paramtype">const graph_t &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>arr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the level signature of an arrangement of a graph. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">t</td><td>Level signature type. </td></tr>
    <tr><td class="paramname">graph_t</td><td>Type of graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arr</td><td>Input arrangement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The level sequence of an arrangement per vertex. </dd></dl>

</div>
</div>
<a id="ac88652728e1d3ec55cc25b1620f6065f" name="ac88652728e1d3ec55cc25b1620f6065f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac88652728e1d3ec55cc25b1620f6065f">&#9670;&#160;</a></span>calculate_level_signature() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#a802d6fe98fa1e77f474f63f151e8c215">level_signature_type</a> t, class graph_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::detail::calculate_level_signature </td>
          <td>(</td>
          <td class="paramtype">const graph_t &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>arr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlal_1_1detail_1_1level__signature.html">level_signature</a>&lt; t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>L</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the level signature of an arrangement of a graph. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">t</td><td>Level signature type. </td></tr>
    <tr><td class="paramname">graph_t</td><td>Type of graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">arr</td><td>Input arrangement. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">L</td><td>Level signature of the arrangement of the input graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Parameter <em>L</em> is initialized at 0. </dd></dl>

</div>
</div>
<a id="a38e173ec404e2222f2d4b5a20dcdfe8b" name="a38e173ec404e2222f2d4b5a20dcdfe8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38e173ec404e2222f2d4b5a20dcdfe8b">&#9670;&#160;</a></span>calculate_weight()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lal::detail::calculate_weight </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacelal.html#a5969ec7ecc85697ebb9ec0ace78fbcab">edge</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>dependencies</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ug</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the weight of a set of dependencies in a flux. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dependencies</td><td>Input dependencies. </td></tr>
    <tr><td class="paramname">ug</td><td>Input undirected graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size of the largest subset of independent dependencies. </dd></dl>

</div>
</div>
<a id="ab8def8df0a8d710569d59e3e3a7042a2" name="ab8def8df0a8d710569d59e3e3a7042a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8def8df0a8d710569d59e3e3a7042a2">&#9670;&#160;</a></span>centroidal_vertex_plus_adjacency_list()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tree_t , std::enable_if_t&lt; std::is_base_of_v&lt; <a class="el" href="classlal_1_1graphs_1_1tree.html">graphs::tree</a>, tree_t &gt;, bool &gt;  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a>, <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> &gt; lal::detail::centroidal_vertex_plus_adjacency_list </td>
          <td>(</td>
          <td class="paramtype">const tree_t &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="structlal_1_1detail_1_1node__size.html">node_size</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>L</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the centroid and the corresponding rooted adjacency list. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">t</td><td>Treer type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">t</td><td>Input tree. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">x</td><td>Node belonging to a connected component whose centroid we want. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">L</td><td>Adjacency list-like data structure. \(L[u]\) is a list of pairs \((v, s_u(v))\) where \(v\) is a neighbour (with respect to a fictional root taken to be a centroidal vertex of the tree) of \(u\) and \(n_u(v)=|V(T^u_v)|\) is the size of the subtree \(T^u_v\) in vertices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aad12b4d7afb7f959490ab04ebc93f751" name="aad12b4d7afb7f959490ab04ebc93f751"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad12b4d7afb7f959490ab04ebc93f751">&#9670;&#160;</a></span>check_correctness_treebank()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool decide&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; decide, bool, <a class="el" href="classlal_1_1io_1_1treebank__file__report.html">io::treebank_file_report</a> &gt; lal::detail::check_correctness_treebank </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>treebank_filename</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find errors in a treebank file. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">decide</td><td>When true, return a value as soon as an error is found. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">treebank_filename</td><td>Name of the treebank file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Boolean if <em>decide</em> is true, a list of errors if otherwise. </dd></dl>

</div>
</div>
<a id="a1255954e5484e835779ba3c2b4a275be" name="a1255954e5484e835779ba3c2b4a275be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1255954e5484e835779ba3c2b4a275be">&#9670;&#160;</a></span>check_correctness_treebank_collection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool decide&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; decide, bool, <a class="el" href="classlal_1_1io_1_1treebank__collection__report.html">io::treebank_collection_report</a> &gt; lal::detail::check_correctness_treebank_collection </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>main_file_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>n_threads</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find errors in a treebank collection. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">decide</td><td>When true, return a value as soon as an error is found. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">main_file_name</td><td>Name of the collection's main file. </td></tr>
    <tr><td class="paramname">n_threads</td><td>Number of threads that this function can use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Boolean if <em>decide</em> is true, a list of errors if otherwise. </dd></dl>

</div>
</div>
<a id="ae0e84911e7a2503c840836d3dc35ae4e" name="ae0e84911e7a2503c840836d3dc35ae4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0e84911e7a2503c840836d3dc35ae4e">&#9670;&#160;</a></span>classify_tree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tree_t , std::enable_if_t&lt; std::is_base_of_v&lt; <a class="el" href="classlal_1_1graphs_1_1tree.html">graphs::tree</a>, tree_t &gt;, bool &gt;  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::detail::classify_tree </td>
          <td>(</td>
          <td class="paramtype">const tree_t &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; bool, <a class="el" href="namespacelal_1_1graphs.html#a1895a9ed855ad1d85cd9510de714a732">graphs::__tree_type_size</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>tree_types</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Classify a tree into one of the types <a class="el" href="namespacelal_1_1graphs.html#a18d52542088507e2be6241759722835b">graphs::tree_type</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">tree_t</td><td>Type of tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">t</td><td>Input tree. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tree_types</td><td>A set of bits (or flags) each indicating whether or not <em>t</em> is of a certain tree type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acf320cd3e1777bd4460eaeb9ecdf6986" name="acf320cd3e1777bd4460eaeb9ecdf6986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf320cd3e1777bd4460eaeb9ecdf6986">&#9670;&#160;</a></span>exists_sorted()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename iterator_t , typename value_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::detail::exists_sorted </td>
          <td>(</td>
          <td class="paramtype">const iterator_t</td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const iterator_t</td>          <td class="paramname"><span class="paramname"><em>end</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_t &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>min_size</em></span><span class="paramdefsep"> = </span><span class="paramdefval">64</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds an element within the sorted range [<em>begin</em>, <em>end</em>). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">iterator_t</td><td>Iterator type. </td></tr>
    <tr><td class="paramname">value_t</td><td>Value type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>Pointer at the first element of the range. </td></tr>
    <tr><td class="paramname">end</td><td>Pointer at the last element of the range. </td></tr>
    <tr><td class="paramname">size</td><td>The number of elements within the range. </td></tr>
    <tr><td class="paramname">v</td><td>The value to search for. </td></tr>
    <tr><td class="paramname">min_size</td><td>The minimum number of elements for the function to choose std::lower_bound over std::find. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether <em>v</em> exists in the range or not. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The range [<em>begin</em>, <em>end</em>) is entirely sorted. </dd></dl>

</div>
</div>
<a id="a99d34bc9f576f5e0bf9f30fd7ae1652f" name="a99d34bc9f576f5e0bf9f30fd7ae1652f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99d34bc9f576f5e0bf9f30fd7ae1652f">&#9670;&#160;</a></span>expand_branchless_path()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tree_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::detail::expand_branchless_path </td>
          <td>(</td>
          <td class="paramtype">const tree_t &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlal_1_1detail_1_1BFS.html">BFS</a>&lt; tree_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>bfs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classlal_1_1properties_1_1branchless__path.html">properties::branchless_path</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>res</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlal_1_1properties_1_1branchless__path.html">properties::branchless_path</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Completes the branchless path. </p>
<p>The first vertex of degree different from 2 is vertex <em>u</em>. And the next vertex in the sequence is vertex <em>v</em>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">tree_t</td><td>Type of tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input tree. </td></tr>
    <tr><td class="paramname">u</td><td>First vertex of the path. </td></tr>
    <tr><td class="paramname">v</td><td>Second vertex of the path. </td></tr>
    <tr><td class="paramname">bfs</td><td>Breadth-First Search traversal object. </td></tr>
    <tr><td class="paramname">res</td><td>Vector containing all branchless paths. </td></tr>
    <tr><td class="paramname">p</td><td>Current branchless path. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2547121a9b242032eb4a4be0d318a7d5" name="a2547121a9b242032eb4a4be0d318a7d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2547121a9b242032eb4a4be0d318a7d5">&#9670;&#160;</a></span>fast_non_iso()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tree_t , std::enable_if_t&lt; std::is_base_of_v&lt; <a class="el" href="classlal_1_1graphs_1_1tree.html">graphs::tree</a>, tree_t &gt;, bool &gt;  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char lal::detail::fast_non_iso </td>
          <td>(</td>
          <td class="paramtype">const tree_t &amp;</td>          <td class="paramname"><span class="paramname"><em>t1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tree_t &amp;</td>          <td class="paramname"><span class="paramname"><em>t2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fast tree non-isomorphism test. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">tree_t</td><td>Tree type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t1</td><td>One tree. </td></tr>
    <tr><td class="paramname">t2</td><td>Another tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the input trees are, might be, or are not isomorphic. </dd>
<dd>
0 if the trees ARE isomorphic </dd>
<dd>
1 if the trees ARE NOT isomorphic:<ul>
<li>number of vertices do not coincide,</li>
<li>number of leaves do not coincide,</li>
<li>second moment of degree do not coincide,</li>
<li>maximum vertex degrees do not coincide, </li>
</ul>
</dd>
<dd>
2 if the trees MIGHT BE isomorphic </dd></dl>

</div>
</div>
<a id="ac7660881b12f071a0ad480e4d4ed7725" name="ac7660881b12f071a0ad480e4d4ed7725"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7660881b12f071a0ad480e4d4ed7725">&#9670;&#160;</a></span>find_centroidal_vertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#a47195c004957380992b21cdbb2b43cc9">centroid_results</a> mode, class tree_t , std::enable_if_t&lt; std::is_base_of_v&lt; <a class="el" href="classlal_1_1graphs_1_1tree.html">graphs::tree</a>, tree_t &gt;, bool &gt;  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a94b315fff0ef08b701cb06c1e4497bbb">conditional_list_t</a>&lt; <a class="el" href="structlal_1_1detail_1_1bool__sequence.html">bool_sequence</a>&lt; <a class="el" href="#a1c80173f63af5c20df73f39036957579">is_m1</a>(mode), <a class="el" href="#a70f4ca4489d7fed3b9d044b6c33afa35">is_m2</a>(mode), <a class="el" href="#a38793200c1b18d533c316775524c175c">is_m3</a>(mode), <a class="el" href="#abe028144d25be302a1f85632559ccf5c">is_m4</a>(mode) &gt;, <a class="el" href="structlal_1_1detail_1_1type__sequence.html">type_sequence</a>&lt; <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a>, std::pair&lt; <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a>, <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> &gt;, std::pair&lt; std::pair&lt; <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a>, <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> &gt;, <a class="el" href="structlal_1_1detail_1_1array.html">array</a>&lt; uint64_t &gt; &gt;, std::pair&lt; std::pair&lt; <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a>, <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> &gt;, <a class="el" href="structlal_1_1detail_1_1array.html">array</a>&lt; <a class="el" href="structlal_1_1detail_1_1edge__size.html">edge_size</a> &gt; &gt; &gt; &gt; lal::detail::find_centroidal_vertex </td>
          <td>(</td>
          <td class="paramtype">const tree_t &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the centroid of a tree. </p>
<p>See <a class="el" href="LAL_concepts.html#LAL_concepts__centre_centroid">Centre and centroid of a tree</a> for details on what the centroid of a tree is.</p>
<p>If subtree sizes are to be returned, they come in an array of size the number of vertices of the tree.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">mode</td><td>Indicates the value to be returned by this function. If:<ul>
<li>mode == <a class="el" href="#a47195c004957380992b21cdbb2b43cc9ab99249477c8f37e1ad46c4983716d39c">lal::detail::centroid_results::only_one_centroidal</a>, the result of the function is a node.</li>
<li>mode == <a class="el" href="#a47195c004957380992b21cdbb2b43cc9a9ef639b9182eadfee611fc58dd23f9d3">lal::detail::centroid_results::full_centroid</a>, the result of the function is a pair of (possibly) two nodes. The second node may have an invalid value, indicating that the tree has only one centroidal vertex.</li>
<li>mode == <a class="el" href="#a47195c004957380992b21cdbb2b43cc9ae6e2f4d15b78cfcbb5a70f39f0d9dda8">lal::detail::centroid_results::full_centroid_plus_subtree_sizes</a>, the result of the function is a pair of (possibly) two nodes and the sizes of all the subtrees with respect to the first centroidal node in the pair.</li>
<li>mode == <a class="el" href="#a47195c004957380992b21cdbb2b43cc9a454774b2983a333885b75c8845707e38">lal::detail::centroid_results::full_centroid_plus_edge_sizes</a>, the result of the function is a pair of (possibly) two nodes and an array of the form \((u,v, s(u,v))\) for all directed edges \((u,v)\) that point away from the first centroidal node in the pair. </li>
</ul>
</td></tr>
    <tr><td class="paramname">tree_t</td><td>Type of tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input tree. </td></tr>
    <tr><td class="paramname">x</td><td>Node belonging to a connected component whose centroid we want. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad994803ba72e39d4ad86ca2eb608b55d" name="ad994803ba72e39d4ad86ca2eb608b55d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad994803ba72e39d4ad86ca2eb608b55d">&#9670;&#160;</a></span>find_cycle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::detail::find_cycle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *const __restrict__</td>          <td class="paramname"><span class="paramname"><em>visited</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *const __restrict__</td>          <td class="paramname"><span class="paramname"><em>in_stack</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if, and only if, the graph has cycles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">u</td><td>Node of the directed graph </td></tr>
    <tr><td class="paramname">visited</td><td>For each node, has it been visited? </td></tr>
    <tr><td class="paramname">in_stack</td><td>For each node, is it in the recursion stack? </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a179acf38e7d9fe41dc7aed7c3129781f" name="a179acf38e7d9fe41dc7aed7c3129781f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a179acf38e7d9fe41dc7aed7c3129781f">&#9670;&#160;</a></span>find_errors() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool decide&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; decide, bool, std::vector&lt; <a class="el" href="classlal_1_1io_1_1head__vector__error.html">io::head_vector_error</a> &gt; &gt; lal::detail::find_errors </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#a2eb5b7f5b50ff908a7a67889a9ea744d">head_vector</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>hv</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find errors in a head vector. </p>
<p>The head vector may correspond to the contents of a line in a treebank file. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">decide</td><td>When true, return a value as soon as an error is found. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hv</td><td>Input head vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Boolean if <em>decide</em> is true, a list of errors if otherwise. </dd></dl>

</div>
</div>
<a id="a154fd8759fbd3b3f3dbe71cc32c5cebe" name="a154fd8759fbd3b3f3dbe71cc32c5cebe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a154fd8759fbd3b3f3dbe71cc32c5cebe">&#9670;&#160;</a></span>find_errors() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool decide&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; decide, bool, std::vector&lt; <a class="el" href="classlal_1_1io_1_1head__vector__error.html">io::head_vector_error</a> &gt; &gt; lal::detail::find_errors </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>current_line</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find errors in a line of a treebank. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">decide</td><td>When true, return a value as soon as an error is found. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">current_line</td><td>The line being analyzed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Boolean if <em>decide</em> is true, a list of errors if otherwise. </dd></dl>

</div>
</div>
<a id="ad1e2965127d78fb7685c8745e2bf5d4b" name="ad1e2965127d78fb7685c8745e2bf5d4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1e2965127d78fb7685c8745e2bf5d4b">&#9670;&#160;</a></span>find_sorted()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename iterator_t , typename value_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator_t lal::detail::find_sorted </td>
          <td>(</td>
          <td class="paramtype">const iterator_t</td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const iterator_t</td>          <td class="paramname"><span class="paramname"><em>end</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_t &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>min_size</em></span><span class="paramdefsep"> = </span><span class="paramdefval">64</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds an element within the sorted range [<em>begin</em>, <em>end</em>). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">iterator_t</td><td>Iterator type. </td></tr>
    <tr><td class="paramname">value_t</td><td>Value type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>Pointer at the first element of the range. </td></tr>
    <tr><td class="paramname">end</td><td>Pointer at the last element of the range. </td></tr>
    <tr><td class="paramname">size</td><td>The number of elements within the range. </td></tr>
    <tr><td class="paramname">v</td><td>The value to search for. </td></tr>
    <tr><td class="paramname">min_size</td><td>The minimum number of elements for the function to choose std::lower_bound over std::find. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the element <em>v</em> within the input range. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The range [<em>begin</em>, <em>end</em>) is entirely sorted. </dd></dl>

</div>
</div>
<a id="a046facc81651e5b2a0cd92f149b06b8b" name="a046facc81651e5b2a0cd92f149b06b8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a046facc81651e5b2a0cd92f149b06b8b">&#9670;&#160;</a></span>from_edge_list_to_graph()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class graph_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">graph_t lal::detail::from_edge_list_to_graph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ab98936b00d896700a71899dff1ed9248">edge_list</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>edge_list</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>normalize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>check</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts an edge list into a graph. </p>
<p>An edge list is a list of pairs of indices, each index in the pair being different and in \([0,n-1]\)., where \(n\) is the number of vertices of the tree.</p>
<p>Methods <a class="el" href="namespacelal_1_1io.html#a5fd63603805a9fb66903e678de24f97a">lal::io::read_edge_list</a> read an edge list from a file in disk. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edge_list</td><td>An edge list. </td></tr>
    <tr><td class="paramname">normalize</td><td>Should the graph be normalized? </td></tr>
    <tr><td class="paramname">check</td><td>In case the graph is not to be normalized, should we check whether it is nor not? </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html" title="Rooted tree graph class.">lal::graphs::rooted_tree</a> obtained from the head vector. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>No edge in the list is repeated. </dd></dl>

</div>
</div>
<a id="a7533691dc2da3241c9ca8e3a873d4e87" name="a7533691dc2da3241c9ca8e3a873d4e87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7533691dc2da3241c9ca8e3a873d4e87">&#9670;&#160;</a></span>from_head_vector_to_graph()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class graph_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">graph_t lal::detail::from_head_vector_to_graph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#a2eb5b7f5b50ff908a7a67889a9ea744d">head_vector</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>hv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>normalize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>check</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transforms a head vector in a directed graph. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">graph_t</td><td>The type of graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hv</td><td>The input head vector. </td></tr>
    <tr><td class="paramname">normalize</td><td>Normalize the grpah or not? </td></tr>
    <tr><td class="paramname">check</td><td>Check whether the graph is normalized or not? </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A graph. </dd></dl>

</div>
</div>
<a id="ae0b594a18111636a94387d9ecc54c708" name="ae0b594a18111636a94387d9ecc54c708"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0b594a18111636a94387d9ecc54c708">&#9670;&#160;</a></span>from_head_vector_to_tree() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tree_t , bool is_rooted = std::is_base_of_v&lt;graphs::rooted_tree, tree_t&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; is_rooted, <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a>, std::pair&lt; <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a>, <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> &gt; &gt; lal::detail::from_head_vector_to_tree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#a2eb5b7f5b50ff908a7a67889a9ea744d">head_vector</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>hv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>normalize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>check</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a head vector into a tree. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">tree_t</td><td>Type of input tree </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hv</td><td>Input head vector. </td></tr>
    <tr><td class="paramname">normalize</td><td>Normalize the resulting tree. </td></tr>
    <tr><td class="paramname">check</td><td>Check whether the constructed tree is normalized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">lal::graphs::rooted_tree</a> or a pair of <a class="el" href="classlal_1_1graphs_1_1free__tree.html">lal::graphs::free_tree</a> and the root encoded in the head vector. </dd></dl>

</div>
</div>
<a id="a9b7c40280156dd9e798f407e0c6302a5" name="a9b7c40280156dd9e798f407e0c6302a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b7c40280156dd9e798f407e0c6302a5">&#9670;&#160;</a></span>from_head_vector_to_tree() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename tree_t , bool ensure_root_is_returned, bool free_tree_plus_root = ensure_root_is_returned and std::is_same_v&lt;tree_t, graphs::free_tree&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; free_tree_plus_root, std::pair&lt; tree_t, <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> &gt;, tree_t &gt; lal::detail::from_head_vector_to_tree </td>
          <td>(</td>
          <td class="paramtype">std::stringstream &amp;</td>          <td class="paramname"><span class="paramname"><em>ss</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transforms a head vector in a tree. </p>
<p>Reads the head vector from a stream object. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">tree_t</td><td>The type of tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ss</td><td>Stream to read the head vector from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Either a pair of free tree and its root, or a rooted tree. </dd></dl>

</div>
</div>
<a id="a49149914e78f33a8cd74230c92b44968" name="a49149914e78f33a8cd74230c92b44968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49149914e78f33a8cd74230c92b44968">&#9670;&#160;</a></span>from_level_sequence_to_tree() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tree_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">tree_t lal::detail::from_level_sequence_to_tree </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint64_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>L</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>normalize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>check</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the level sequence of a tree into a graph structure. </p>
<p>See <a class="el" href="#af9fa62b2ef3f94d62eebd1c28ba7beaa">lal::detail::from_level_sequence_to_tree</a> for further details. </p>

</div>
</div>
<a id="af9fa62b2ef3f94d62eebd1c28ba7beaa" name="af9fa62b2ef3f94d62eebd1c28ba7beaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9fa62b2ef3f94d62eebd1c28ba7beaa">&#9670;&#160;</a></span>from_level_sequence_to_tree() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tree_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">tree_t lal::detail::from_level_sequence_to_tree </td>
          <td>(</td>
          <td class="paramtype">const uint64_t *const</td>          <td class="paramname"><span class="paramname"><em>L</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>normalize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>check</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the level sequence of a tree into a graph structure. </p>
<p>Examples of level sequences:</p><ul>
<li>linear tree of n nodes: <pre class="fragment">    0 1 2 3 4 ... (n-1) n</pre></li>
<li>star tree of n nodes <pre class="fragment">    0 1 2 2 2 .... 2 2
        |------------| &gt; (n-1) two's</pre></li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">tree_t</td><td>The type of tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>The level sequence, in preorder. </td></tr>
    <tr><td class="paramname">n</td><td>Number of nodes of the tree. </td></tr>
    <tr><td class="paramname">normalize</td><td>Should the tree be normalized? </td></tr>
    <tr><td class="paramname">check</td><td>Should it be checked whether the tree is normalized or not? </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The tree built with the sequence level <em>L</em>. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>n &gt;= 2. </dd>
<dd>
The size of L is exactly <em>n</em> + 1. </dd>
<dd>
The first value of a sequence must be a zero. </dd>
<dd>
The second value of a sequence must be a one. </dd></dl>

</div>
</div>
<a id="acd3538b3666c7d23c2a899f834b966a7" name="acd3538b3666c7d23c2a899f834b966a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd3538b3666c7d23c2a899f834b966a7">&#9670;&#160;</a></span>from_level_sequence_to_tree_large() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tree_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">tree_t lal::detail::from_level_sequence_to_tree_large </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint64_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>L</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>normalize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>check</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the level sequence of a tree into a graph structure. </p>
<p>See <a class="el" href="#af9fa62b2ef3f94d62eebd1c28ba7beaa">lal::detail::from_level_sequence_to_tree</a> for further details. </p>

</div>
</div>
<a id="a2d6f3ade0fe67e9a18b8139eac1a52dd" name="a2d6f3ade0fe67e9a18b8139eac1a52dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d6f3ade0fe67e9a18b8139eac1a52dd">&#9670;&#160;</a></span>from_level_sequence_to_tree_large() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tree_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">tree_t lal::detail::from_level_sequence_to_tree_large </td>
          <td>(</td>
          <td class="paramtype">const uint64_t *const</td>          <td class="paramname"><span class="paramname"><em>L</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>normalize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>check</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the level sequence of a tree into a graph structure. </p>
<p>Examples of level sequences:</p><ul>
<li>linear tree of n nodes: <pre class="fragment">    0 1 2 3 4 ... (n-1) n</pre></li>
<li>star tree of n nodes <pre class="fragment">    0 1 2 2 2 .... 2 2
       |------------| &gt; (n-1) two's</pre></li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">tree_t</td><td>The type of tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>The level sequence, in preorder. </td></tr>
    <tr><td class="paramname">n</td><td>Number of nodes of the tree. </td></tr>
    <tr><td class="paramname">normalize</td><td>Should the tree be normalized? </td></tr>
    <tr><td class="paramname">check</td><td>Should it be checked whether the tree is normalized or not? </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The tree built with the sequence level <em>L</em>. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>n &gt;= 2. </dd>
<dd>
The size of L is exactly <em>n</em> + 1. </dd>
<dd>
The first value of a sequence must be a zero. </dd>
<dd>
The second value of a sequence must be a one. </dd></dl>

</div>
</div>
<a id="a0cd5cc9b0bcbaf8fad86dae9a2fea6e7" name="a0cd5cc9b0bcbaf8fad86dae9a2fea6e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cd5cc9b0bcbaf8fad86dae9a2fea6e7">&#9670;&#160;</a></span>from_level_sequence_to_tree_small() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tree_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">tree_t lal::detail::from_level_sequence_to_tree_small </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint64_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>L</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>normalize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>check</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the level sequence of a tree into a graph structure. </p>
<p>See <a class="el" href="#af9fa62b2ef3f94d62eebd1c28ba7beaa">lal::detail::from_level_sequence_to_tree</a> for further details. </p>

</div>
</div>
<a id="a7039e0e698bb3fbb6d0146705634f32b" name="a7039e0e698bb3fbb6d0146705634f32b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7039e0e698bb3fbb6d0146705634f32b">&#9670;&#160;</a></span>from_level_sequence_to_tree_small() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tree_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">tree_t lal::detail::from_level_sequence_to_tree_small </td>
          <td>(</td>
          <td class="paramtype">const uint64_t *const</td>          <td class="paramname"><span class="paramname"><em>L</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>normalize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>check</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the level sequence of a tree into a graph structure. </p>
<p>Examples of level sequences:</p><ul>
<li>linear tree of n nodes: <pre class="fragment">    0 1 2 3 4 ... (n-1) n</pre></li>
<li>star tree of n nodes <pre class="fragment">    0 1 2 2 2 .... 2 2
       |------------| &gt; (n-1) two's</pre></li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">tree_t</td><td>The type of tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>The level sequence, in preorder. </td></tr>
    <tr><td class="paramname">n</td><td>Number of nodes of the tree. </td></tr>
    <tr><td class="paramname">normalize</td><td>Should the tree be normalized? </td></tr>
    <tr><td class="paramname">check</td><td>Should it be checked whether the tree is normalized or not? </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The tree built with the sequence level <em>L</em>. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>n &gt;= 2. </dd>
<dd>
The size of L is exactly <em>n</em> + 1. </dd>
<dd>
The first value of a sequence must be a zero. </dd>
<dd>
The second value of a sequence must be a one. </dd></dl>

</div>
</div>
<a id="a549b84ec837daa460b45c2eec5696312" name="a549b84ec837daa460b45c2eec5696312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a549b84ec837daa460b45c2eec5696312">&#9670;&#160;</a></span>from_Prufer_sequence_to_ftree() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> lal::detail::from_Prufer_sequence_to_ftree </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint64_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>seq</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>normalize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>check</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the Prüfer sequence of a labelled tree into a tree structure. </p>
<p>For details on Prüfer sequences, see <a class="el" href="citelist.html#CITEREF_Pruefer1918a">[41]</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seq</td><td>The Prufer sequence sequence. </td></tr>
    <tr><td class="paramname">n</td><td>Number of nodes of the tree. </td></tr>
    <tr><td class="paramname">normalize</td><td>Should the tree be normalized? </td></tr>
    <tr><td class="paramname">check</td><td>Should it be checked whether the tree is normalized or not? </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The tree built with <em>seq</em>. </dd></dl>

</div>
</div>
<a id="a97d73b47249d11a23b829735b9926909" name="a97d73b47249d11a23b829735b9926909"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97d73b47249d11a23b829735b9926909">&#9670;&#160;</a></span>from_Prufer_sequence_to_ftree() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> lal::detail::from_Prufer_sequence_to_ftree </td>
          <td>(</td>
          <td class="paramtype">const uint64_t *const</td>          <td class="paramname"><span class="paramname"><em>seq</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>normalize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>check</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the Prüfer sequence of a labelled tree into a tree structure. </p>
<p>For details on Prüfer sequences, see <a class="el" href="citelist.html#CITEREF_Pruefer1918a">[41]</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seq</td><td>The Prufer sequence sequence. </td></tr>
    <tr><td class="paramname">n</td><td>Number of nodes of the tree. </td></tr>
    <tr><td class="paramname">normalize</td><td>Should the tree be normalized? </td></tr>
    <tr><td class="paramname">check</td><td>Should it be checked whether the tree is normalized or not? </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The tree built with <em>seq</em>. </dd></dl>

</div>
</div>
<a id="aa63b6ce11a334bd79da7ca62f9fc396f" name="aa63b6ce11a334bd79da7ca62f9fc396f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa63b6ce11a334bd79da7ca62f9fc396f">&#9670;&#160;</a></span>from_tree_to_head_vector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class arrangement_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacelal.html#a2eb5b7f5b50ff908a7a67889a9ea744d">head_vector</a> lal::detail::from_tree_to_head_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arrangement_t &amp;</td>          <td class="paramname"><span class="paramname"><em>arr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>r</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the head vector representation of a tree. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">arrangement_t</td><td>Type of arrangement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input free tree. </td></tr>
    <tr><td class="paramname">r</td><td>Root of the tree. </td></tr>
    <tr><td class="paramname">arr</td><td>Linear arrangement of the vertices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A head vector </dd></dl>

</div>
</div>
<a id="a0bc2ccfd7fcd3f4b5ac53d54f3dd8eff" name="a0bc2ccfd7fcd3f4b5ac53d54f3dd8eff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bc2ccfd7fcd3f4b5ac53d54f3dd8eff">&#9670;&#160;</a></span>from_tree_to_head_vector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class arrangement_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacelal.html#a2eb5b7f5b50ff908a7a67889a9ea744d">head_vector</a> lal::detail::from_tree_to_head_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arrangement_t &amp;</td>          <td class="paramname"><span class="paramname"><em>arr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the head vector representation of a tree. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">arrangement_t</td><td>Type of arrangement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input rooted tree. </td></tr>
    <tr><td class="paramname">arr</td><td>Linear arrangement of the vertices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A head vector encoding the tree. </dd></dl>

</div>
</div>
<a id="a10d1e56d764e413a8f35cecc6a219404" name="a10d1e56d764e413a8f35cecc6a219404"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10d1e56d764e413a8f35cecc6a219404">&#9670;&#160;</a></span>get_bool_neighbors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class graph_t , typename char_type , std::enable_if_t&lt; std::is_base_of_v&lt; <a class="el" href="classlal_1_1graphs_1_1graph.html">graphs::graph</a>, graph_t &gt; and std::is_integral_v&lt; char_type &gt;, bool &gt;  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::detail::get_bool_neighbors </td>
          <td>(</td>
          <td class="paramtype">const graph_t &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char_type *const</td>          <td class="paramname"><span class="paramname"><em>neighs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the neighbors of a node in an undirected graph as a list of 0-1 values. </p>
<p>Sets to 1 the positions in <em>neighs</em> that correspond to the nodes neighours of <em>u</em>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">u</td><td>Input node. </td></tr>
    <tr><td class="paramname">neighs</td><td>0-1 list of neighbors of <em>u</em> in <em>g</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The contents of <em>neighs</em> must be all 0 (or false). </dd></dl>

</div>
</div>
<a id="a88e9b008810ccd6204cf0e34778607f4" name="a88e9b008810ccd6204cf0e34778607f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88e9b008810ccd6204cf0e34778607f4">&#9670;&#160;</a></span>get_edges_subtree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool get_subsizes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; <a class="el" href="namespacelal.html#a5969ec7ecc85697ebb9ec0ace78fbcab">edge</a> &gt;, uint64_t * &gt; lal::detail::get_edges_subtree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>T</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>relabel</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the edges of a subtree. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">get_subsizes</td><td>Should the result also keep the sizes of the subtrees? </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>Input rooted tree. </td></tr>
    <tr><td class="paramname">u</td><td>Root of the subtree. </td></tr>
    <tr><td class="paramname">relabel</td><td>Relabel the vertices? If so, vertex 'u' is relabelled to 0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair consisting of the list of edges and, optionally, a raw pointer to memory containing the sizes of the subtrees. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The tree is a valid rooted tree. </dd>
<dd>
The tree has vertex 'u'. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The function has NO ownership of the raw pointer returned in the pair. </dd>
<dd>
The pointer returned is not nullptr only when T.size_subtrees_valid() AND the boolean parameter sizes are BOTH true. </dd></dl>

</div>
</div>
<a id="a5d699ac4dd239e067d1823ea612daca4" name="a5d699ac4dd239e067d1823ea612daca4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d699ac4dd239e067d1823ea612daca4">&#9670;&#160;</a></span>get_size_subtrees() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tree_t , std::enable_if_t&lt; std::is_base_of_v&lt; <a class="el" href="classlal_1_1graphs_1_1tree.html">graphs::tree</a>, tree_t &gt;, bool &gt;  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::detail::get_size_subtrees </td>
          <td>(</td>
          <td class="paramtype">const tree_t &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *const</td>          <td class="paramname"><span class="paramname"><em>sizes</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the size of every subtree of tree <em>t</em>. </p>
<p>The method starts calculating the sizes at node <em>r</em>. Since rooted trees have directed edges, starting at a node different from the tree's root may not calculate every subtree's size. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input rooted tree. </td></tr>
    <tr><td class="paramname">r</td><td>Start calculating sizes of subtrees at this node. </td></tr>
    <tr><td class="paramname">sizes</td><td>The size of the subtree rooted at every reachable node from <em>r</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Parameter <em>sizes</em> has size the number of vertices. </dd></dl>

</div>
</div>
<a id="a07c5f3a005c23b6fb759e7bef0dc8053" name="a07c5f3a005c23b6fb759e7bef0dc8053"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07c5f3a005c23b6fb759e7bef0dc8053">&#9670;&#160;</a></span>get_size_subtrees() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tree_t , std::enable_if_t&lt; std::is_base_of_v&lt; <a class="el" href="classlal_1_1graphs_1_1tree.html">graphs::tree</a>, tree_t &gt;, bool &gt;  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::detail::get_size_subtrees </td>
          <td>(</td>
          <td class="paramtype">const tree_t &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *const</td>          <td class="paramname"><span class="paramname"><em>sizes</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the size of every subtree of the tree <em>t</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input tree. </td></tr>
    <tr><td class="paramname">u</td><td>Parent node (the first call should be an invalid value (e.g., n+1)). </td></tr>
    <tr><td class="paramname">v</td><td>Next node in the exploration of the tree. </td></tr>
    <tr><td class="paramname">sizes</td><td>The size of the subtree rooted at every reachable node from <em>r</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Parameter <em>sizes</em> has size the number of vertices. </dd></dl>

</div>
</div>
<a id="ad493ddcc9165c55d4b14b228da5cdc4d" name="ad493ddcc9165c55d4b14b228da5cdc4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad493ddcc9165c55d4b14b228da5cdc4d">&#9670;&#160;</a></span>has_directed_cycles() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::detail::has_directed_cycles </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if, and only if, the graph has DIRECTED cycles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the graph has cycles or not. </dd></dl>

</div>
</div>
<a id="aa89ef322801fbacd0782763afb9c5f3a" name="aa89ef322801fbacd0782763afb9c5f3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa89ef322801fbacd0782763afb9c5f3a">&#9670;&#160;</a></span>has_directed_cycles() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::detail::has_directed_cycles </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *const __restrict__</td>          <td class="paramname"><span class="paramname"><em>vis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *const __restrict__</td>          <td class="paramname"><span class="paramname"><em>in_stack</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if, and only if, the graph has <em>DIRECTED</em> cycles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">vis</td><td>Array of size 'n', where 'n' is the number of vertices of 'g'. </td></tr>
    <tr><td class="paramname">in_stack</td><td>Array of size 'n', where 'n' is the number of vertices of 'g'. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the graph has cycles or not. </dd></dl>

</div>
</div>
<a id="af38edbbd2619cd3b319c1a54ce0638ed" name="af38edbbd2619cd3b319c1a54ce0638ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af38edbbd2619cd3b319c1a54ce0638ed">&#9670;&#160;</a></span>has_undirected_cycles() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class graph_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::detail::has_undirected_cycles </td>
          <td>(</td>
          <td class="paramtype">const graph_t &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if, and only if, the graph has UNDIRECTED cycles. </p>
<p>In case the input graph is a directed graph, reverse edges are considered. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">graph_t</td><td>Type of graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the graph has cycles or not. </dd></dl>

</div>
</div>
<a id="aac1d5fb0c4578d6be926acf180d657c4" name="aac1d5fb0c4578d6be926acf180d657c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac1d5fb0c4578d6be926acf180d657c4">&#9670;&#160;</a></span>has_undirected_cycles() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class graph_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::detail::has_undirected_cycles </td>
          <td>(</td>
          <td class="paramtype">const graph_t &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlal_1_1detail_1_1BFS.html">BFS</a>&lt; graph_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>bfs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if, and only if, the graph has UNDIRECTED cycles. </p>
<p>In case the input graph is a directed graph, reverse edges are considered. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">graph_t</td><td>Type of graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">bfs</td><td>Breadth-First Search object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the graph has cycles or not. </dd></dl>

</div>
</div>
<a id="ace97a861f8ce972d844103dd12a2af62" name="ace97a861f8ce972d844103dd12a2af62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace97a861f8ce972d844103dd12a2af62">&#9670;&#160;</a></span>head_initial()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename result_t , class arrangement_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">result_t lal::detail::head_initial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arrangement_t &amp;</td>          <td class="paramname"><span class="paramname"><em>arr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Proposition of right branching edges in a directed graph. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">result_t</td><td>Type of return value. </td></tr>
    <tr><td class="paramname">arrangement_t</td><td>Type of arrangement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input directed graph. </td></tr>
    <tr><td class="paramname">arr</td><td>Input linear arrangement. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3ab57809f98ba3830d67ca111445a755" name="a3ab57809f98ba3830d67ca111445a755"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ab57809f98ba3830d67ca111445a755">&#9670;&#160;</a></span>is_bipartite()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class graph_t , class arrangement_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::detail::is_bipartite </td>
          <td>(</td>
          <td class="paramtype">const graph_t &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arrangement_t &amp;</td>          <td class="paramname"><span class="paramname"><em>arr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is a given arrangement bipartite? </p>
<p>See <a class="el" href="LAL_concepts.html#LAL_concepts__linear_arrangement__types">Types of arrangements</a> for details on bipartite arrangements.</p>
<p>If the input arrangement is empty then the identity arrangement \(\pi_I\) is used. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">arrangement_t</td><td>Type of arrangement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arr</td><td>Input linear arrangement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the input arrangement is bipartite. </dd></dl>

</div>
</div>
<a id="a6504a8c3ab02b566cc1c75854caf6e5a" name="a6504a8c3ab02b566cc1c75854caf6e5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6504a8c3ab02b566cc1c75854caf6e5a">&#9670;&#160;</a></span>is_bipartite__connected()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class arrangement_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::detail::is_bipartite__connected </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1properties_1_1bipartite__graph__coloring.html">properties::bipartite_graph_coloring</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arrangement_t &amp;</td>          <td class="paramname"><span class="paramname"><em>arr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is a given arrangement bipartite? </p>
<p>See <a class="el" href="LAL_concepts.html#LAL_concepts__linear_arrangement__types">Types of arrangements</a> for details on bipartite arrangements.</p>
<p>If the input arrangement is empty then the identity arrangement \(\pi_I\) is used. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">arrangement_t</td><td>Type of arrangement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Coloring of a bipartite graph. </td></tr>
    <tr><td class="paramname">arr</td><td>Input linear arrangement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the input arrangement is bipartite. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Input <em>arr</em> is an arrangement of a connected bipartite graph. </dd></dl>

</div>
</div>
<a id="a58af58031ebc33bbfb5dfcd8f798ebf4" name="a58af58031ebc33bbfb5dfcd8f798ebf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58af58031ebc33bbfb5dfcd8f798ebf4">&#9670;&#160;</a></span>is_graph_a_tree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class graph_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::detail::is_graph_a_tree </td>
          <td>(</td>
          <td class="paramtype">const graph_t &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the input graph a tree? </p>
<p>By definition, an undirected graph is a tree if it does not contain cycles and has one single connected component. Note that isloated nodes count as single connected components. Directed graphs are allowed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if, and only if, the graph is a tree. </dd></dl>

</div>
</div>
<a id="a15a4c9114b9c800b7fbb2ccad69d94cd" name="a15a4c9114b9c800b7fbb2ccad69d94cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15a4c9114b9c800b7fbb2ccad69d94cd">&#9670;&#160;</a></span>is_level_signature_nonincreasing()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class graph_t , <a class="el" href="#a802d6fe98fa1e77f474f63f151e8c215">level_signature_type</a> t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::detail::is_level_signature_nonincreasing </td>
          <td>(</td>
          <td class="paramtype">const graph_t &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1detail_1_1level__signature.html">level_signature</a>&lt; t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>levels</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>arr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the level sequence follows that of a maximum arrangement. </p>
<p>Checks whether or not the level signature is non-increasing, that is, whether the sequence of level values (in a per position distribution) is non-increasing.</p>
<p>This is a necessary condition for an arrangement to be maximum, as shown in <a class="el" href="citelist.html#CITEREF_Nurse2018a">[18]</a> <a class="el" href="citelist.html#CITEREF_Nurse2019a">[39]</a> and <a class="el" href="citelist.html#CITEREF_Alemany2023a">[7]</a>.</p>
<p>When the level signature is defined on a 'per position' basis, the arrangement is not needed. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">t</td><td>Level signature type. </td></tr>
    <tr><td class="paramname">graph_t</td><td>Type of graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arr</td><td>Input arrangement. </td></tr>
    <tr><td class="paramname">levels</td><td>signature of the arrangement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the level sequence satisfies the condition. </dd></dl>

</div>
</div>
<a id="aceadae62ffd6542e97b65cd06eb088b8" name="aceadae62ffd6542e97b65cd06eb088b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceadae62ffd6542e97b65cd06eb088b8">&#9670;&#160;</a></span>is_n_C_brute_force_lesseq_than() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class graph_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lal::detail::is_n_C_brute_force_lesseq_than </td>
          <td>(</td>
          <td class="paramtype">const graph_t &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>arr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>upper_bound</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the number of crossings is less than a given constant. </p>
<p>Given a graph \(G\) and a linear arrangements \(\pi\) of its nodes, returns the number of edge crossings \(C_{\pi}(G)\) if it is less than or equal to the given upper bound constant \(u\). In case the number of crossings is greater, returns a value strictly larger than the upper bound. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">graph_t</td><td>Type of graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arr</td><td>Linear arrangement of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
    <tr><td class="paramname">upper_bound</td><td>Constant (upper bound). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of crossings \(C\) if said number is less than or equal to the upper bound. The function returns a value strictly larger than the upper bound if otherwise. </dd></dl>

</div>
</div>
<a id="a52af8ab2c0352a408cce9e05de472e88" name="a52af8ab2c0352a408cce9e05de472e88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52af8ab2c0352a408cce9e05de472e88">&#9670;&#160;</a></span>is_n_C_brute_force_lesseq_than() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class graph_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; uint64_t &gt; lal::detail::is_n_C_brute_force_lesseq_than </td>
          <td>(</td>
          <td class="paramtype">const graph_t &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>arrs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint64_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>upper_bounds</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the number of crossings is less than a given constant. </p>
<p>Given a graph \(G\) and a linear arrangements \(\pi\) of its nodes, returns the number of edge crossings \(C_{\pi}(G)\) if it is less than or equal to the given upper bound constant \(u\). In case the number of crossings is greater, returns a value strictly larger than the upper bound.</p>
<p>This is applied to every linear arrangement in <em>pi</em>. To each arrangement corresponds only one upper bound. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">graph_t</td><td>Type of graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arrs</td><td>List of \(k\) linear arrangements of the nodes \(\Pi = \{\pi_i\}_{i=1}^k\). When one is omitted, \(\pi_I\) is used. </td></tr>
    <tr><td class="paramname">upper_bounds</td><td>List of constants (each an upper bound). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of crossings \(C\) if said number is less than or equal to the upper bound. The function returns a value strictly larger than the upper bound if otherwise. </dd></dl>

</div>
</div>
<a id="a6b4c7622b6c721e178419bca90797348" name="a6b4c7622b6c721e178419bca90797348"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b4c7622b6c721e178419bca90797348">&#9670;&#160;</a></span>is_n_C_brute_force_lesseq_than() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class graph_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; uint64_t &gt; lal::detail::is_n_C_brute_force_lesseq_than </td>
          <td>(</td>
          <td class="paramtype">const graph_t &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>arrs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>upper_bound</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the number of crossings is less than a given constant. </p>
<p>Given a graph \(G\) and a linear arrangements \(\pi\) of its nodes, returns the number of edge crossings \(C_{\pi}(G)\) if it is less than or equal to the given upper bound constant \(u\). In case the number of crossings is greater, returns a value strictly larger than the upper bound.</p>
<p>This is applied to every linear arrangement in <em>pi</em>. The upper bound <em>upper_bound</em> is applied to all linear arrangements. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">graph_t</td><td>Type of graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arrs</td><td>Linear arrangement of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
    <tr><td class="paramname">upper_bound</td><td>Constant (upper bound). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of crossings \(C\) if said number is less than or equal to the upper bound. The function returns a value strictly larger than the upper bound if otherwise. </dd></dl>

</div>
</div>
<a id="a39b808838c040a76aa1771bd29944463" name="a39b808838c040a76aa1771bd29944463"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39b808838c040a76aa1771bd29944463">&#9670;&#160;</a></span>is_n_C_dynamic_programming_lesseq_than() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class graph_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lal::detail::is_n_C_dynamic_programming_lesseq_than </td>
          <td>(</td>
          <td class="paramtype">const graph_t &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>arr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>upper_bound</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fast calculation of \(C\) if it is less than or equal to an upper bound. </p>
<p>Given a graph \(G\) and a linear arrangements \(\pi\) of its nodes, returns the number of edge crossings \(C_{\pi}(G)\) if it is less than or equal to the given upper bound constant \(u\). In case the number of crossings is greater, returns a value strictly larger than the upper bound.</p>
<p>This is applied to every linear arrangement in <em>pi</em>. The upper bound <em>upper_bound</em> is applied to all linear arrangements. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">graph_t</td><td>Type of graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arr</td><td>Linear arrangement of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
    <tr><td class="paramname">upper_bound</td><td>Constant (upper bound). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of crossings \(C\) if said number is less than or equal to the upper bound. The function returns a value strictly larger than the upper bound if otherwise. </dd></dl>

</div>
</div>
<a id="aaa37dcfd68ac36acf6031b605ab75abc" name="aaa37dcfd68ac36acf6031b605ab75abc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa37dcfd68ac36acf6031b605ab75abc">&#9670;&#160;</a></span>is_n_C_dynamic_programming_lesseq_than() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class graph_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; uint64_t &gt; lal::detail::is_n_C_dynamic_programming_lesseq_than </td>
          <td>(</td>
          <td class="paramtype">const graph_t &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>arrs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint64_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>upper_bounds</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fast calculation of \(C\) if it is less than or equal to an upper bound. </p>
<p>Given a graph \(G\) and a linear arrangements \(\pi\) of its nodes, returns the number of edge crossings \(C_{\pi}(G)\) if it is less than or equal to the given upper bound constant \(u\). In case the number of crossings is greater, returns a value strictly larger than the upper bound.</p>
<p>This is applied to every linear arrangement in <em>pi</em>. To each arrangement corresponds only one upper bound. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">graph_t</td><td>Type of graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arrs</td><td>List of \(k\) linear arrangements of the nodes \(\Pi = \{\pi_i\}_{i=1}^k\). When one is omitted, \(\pi_I\) is used. </td></tr>
    <tr><td class="paramname">upper_bounds</td><td>List of constants (each an upper bound). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of crossings \(C\) if said number is less than or equal to the upper bound. The function returns a value strictly larger than the upper bound if otherwise. </dd></dl>

</div>
</div>
<a id="a483eaac7ab510f15e666df819dca2c32" name="a483eaac7ab510f15e666df819dca2c32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a483eaac7ab510f15e666df819dca2c32">&#9670;&#160;</a></span>is_n_C_dynamic_programming_lesseq_than() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class graph_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; uint64_t &gt; lal::detail::is_n_C_dynamic_programming_lesseq_than </td>
          <td>(</td>
          <td class="paramtype">const graph_t &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>arrs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>upper_bound</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fast calculation of \(C\) if it is less than or equal to an upper bound. </p>
<p>Given a graph \(G\) and a linear arrangements \(\pi\) of its nodes, returns the number of edge crossings \(C_{\pi}(G)\) if it is less than or equal to the given upper bound constant \(u\). In case the number of crossings is greater, returns a value strictly larger than the upper bound.</p>
<p>This is applied to every linear arrangement in <em>pi</em>. To each arrangement corresponds only one upper bound. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">graph_t</td><td>Type of graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arrs</td><td>List of \(k\) linear arrangements of the nodes \(\Pi = \{\pi_i\}_{i=1}^k\). When one is omitted, \(\pi_I\) is used. </td></tr>
    <tr><td class="paramname">upper_bound</td><td>Constant (upper bound). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of crossings \(C\) if said number is less than or equal to the upper bound. The function returns a value strictly larger than the upper bound if otherwise. </dd></dl>

</div>
</div>
<a id="ac8239c121f8fcf434838cf51bc31dea3" name="ac8239c121f8fcf434838cf51bc31dea3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8239c121f8fcf434838cf51bc31dea3">&#9670;&#160;</a></span>is_n_C_ladder_lesseq_than() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class graph_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lal::detail::is_n_C_ladder_lesseq_than </td>
          <td>(</td>
          <td class="paramtype">const graph_t &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>arr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>upper_bound</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fast calculation of \(C\) if it is less than or equal to an upper bound. </p>
<p>Given a graph \(G\) and a linear arrangements \(\pi\) of its nodes, returns the number of edge crossings \(C_{\pi}(G)\) if it is less than or equal to the given upper bound constant \(u\). In case the number of crossings is greater, returns a value strictly larger than the upper bound. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">graph_t</td><td>Type of graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arr</td><td>Linear arrangement of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
    <tr><td class="paramname">upper_bound</td><td>Constant (upper bound). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of crossings \(C\) if said number is less than or equal to the upper bound. The function returns a value strictly larger than the upper bound if otherwise. </dd></dl>

</div>
</div>
<a id="a4a313d37b28c1b5efec442077b09c4ab" name="a4a313d37b28c1b5efec442077b09c4ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a313d37b28c1b5efec442077b09c4ab">&#9670;&#160;</a></span>is_n_C_ladder_lesseq_than() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class graph_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; uint64_t &gt; lal::detail::is_n_C_ladder_lesseq_than </td>
          <td>(</td>
          <td class="paramtype">const graph_t &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>arrs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint64_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>upper_bounds</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fast calculation of \(C\) if it is less than or equal to an upper bound. </p>
<p>Given a graph \(G\) and a linear arrangements \(\pi\) of its nodes, returns the number of edge crossings \(C_{\pi}(G)\) if it is less than or equal to the given upper bound constant \(u\). In case the number of crossings is greater, returns a value strictly larger than the upper bound.</p>
<p>This is applied to every linear arrangement in <em>pi</em>. To each arrangement corresponds only one upper bound. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">graph_t</td><td>Type of graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arrs</td><td>List of \(k\) linear arrangements of the nodes \(\Pi = \{\pi_i\}_{i=1}^k\). When one is omitted, \(\pi_I\) is used. </td></tr>
    <tr><td class="paramname">upper_bounds</td><td>List of constants (each an upper bound). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of crossings \(C\) if said number is less than or equal to the upper bound. The function returns a value strictly larger than the upper bound if otherwise. </dd></dl>

</div>
</div>
<a id="a0c832c8d5da81092f2b520fba976d1d7" name="a0c832c8d5da81092f2b520fba976d1d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c832c8d5da81092f2b520fba976d1d7">&#9670;&#160;</a></span>is_n_C_ladder_lesseq_than() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class graph_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; uint64_t &gt; lal::detail::is_n_C_ladder_lesseq_than </td>
          <td>(</td>
          <td class="paramtype">const graph_t &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>arrs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>upper_bound</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fast calculation of \(C\) if it is less than or equal to an upper bound. </p>
<p>Given a graph \(G\) and a linear arrangements \(\pi\) of its nodes, returns the number of edge crossings \(C_{\pi}(G)\) if it is less than or equal to the given upper bound constant \(u\). In case the number of crossings is greater, returns a value strictly larger than the upper bound.</p>
<p>This is applied to every linear arrangement in <em>pi</em>. The upper bound <em>upper_bound</em> is applied to all linear arrangements. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">graph_t</td><td>Type of graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arrs</td><td>List of \(k\) linear arrangements of the nodes \(\Pi = \{\pi_i\}_{i=1}^k\). When one is omitted, \(\pi_I\) is used. </td></tr>
    <tr><td class="paramname">upper_bound</td><td>Constant (upper bound). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of crossings \(C\) if said number is less than or equal to the upper bound. The function returns a value strictly larger than the upper bound if otherwise. </dd></dl>

</div>
</div>
<a id="a0ca8ff399693e91adb12527b7ca4614c" name="a0ca8ff399693e91adb12527b7ca4614c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ca8ff399693e91adb12527b7ca4614c">&#9670;&#160;</a></span>is_n_C_stack_based_lesseq_than() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class graph_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lal::detail::is_n_C_stack_based_lesseq_than </td>
          <td>(</td>
          <td class="paramtype">const graph_t &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>arr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>upper_bound</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fast calculation of \(C\) if it is less than or equal to an upper bound. </p>
<p>Given a graph \(G\) and a linear arrangements \(\pi\) of its nodes, returns the number of edge crossings \(C_{\pi}(G)\) if it is less than or equal to the given upper bound constant \(u\). In case the number of crossings is greater, returns a value strictly larger than the upper bound. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">graph_t</td><td>Type of graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arr</td><td>Linear arrangement of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
    <tr><td class="paramname">upper_bound</td><td>Constant (upper bound). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of crossings \(C\) if said number is less than or equal to the upper bound. The function returns a value strictly larger than the upper bound if otherwise. </dd></dl>

</div>
</div>
<a id="aac9327821de6e918b01ac58c5e5f8ec2" name="aac9327821de6e918b01ac58c5e5f8ec2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac9327821de6e918b01ac58c5e5f8ec2">&#9670;&#160;</a></span>is_n_C_stack_based_lesseq_than() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class graph_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; uint64_t &gt; lal::detail::is_n_C_stack_based_lesseq_than </td>
          <td>(</td>
          <td class="paramtype">const graph_t &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>arrs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint64_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>upper_bounds</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fast calculation of \(C\) if it is less than or equal to an upper bound. </p>
<p>Given a graph \(G\) and a linear arrangements \(\pi\) of its nodes, returns the number of edge crossings \(C_{\pi}(G)\) if it is less than or equal to the given upper bound constant \(u\). In case the number of crossings is greater, returns a value strictly larger than the upper bound.</p>
<p>This is applied to every linear arrangement in <em>pi</em>. To each arrangement corresponds only one upper bound. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">graph_t</td><td>Type of graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arrs</td><td>List of \(k\) linear arrangements of the nodes \(\Pi = \{\pi_i\}_{i=1}^k\). When one is omitted, \(\pi_I\) is used. </td></tr>
    <tr><td class="paramname">upper_bounds</td><td>List of constants (each an upper bound). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of crossings \(C\) if said number is less than or equal to the upper bound. The function returns a value strictly larger than the upper bound if otherwise. </dd></dl>

</div>
</div>
<a id="a50e2cf86c0b37c3a1446fd87b74e3ea7" name="a50e2cf86c0b37c3a1446fd87b74e3ea7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50e2cf86c0b37c3a1446fd87b74e3ea7">&#9670;&#160;</a></span>is_n_C_stack_based_lesseq_than() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class graph_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; uint64_t &gt; lal::detail::is_n_C_stack_based_lesseq_than </td>
          <td>(</td>
          <td class="paramtype">const graph_t &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>arrs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>upper_bound</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fast calculation of \(C\) if it is less than or equal to an upper bound. </p>
<p>Given a graph \(G\) and a linear arrangements \(\pi\) of its nodes, returns the number of edge crossings \(C_{\pi}(G)\) if it is less than or equal to the given upper bound constant \(u\). In case the number of crossings is greater, returns a value strictly larger than the upper bound.</p>
<p>This is applied to every linear arrangement in <em>pi</em>. The upper bound <em>upper_bound</em> is applied to all linear arrangements. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">graph_t</td><td>Type of graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arrs</td><td>List of \(k\) linear arrangements of the nodes \(\Pi = \{\pi_i\}_{i=1}^k\). When one is omitted, \(\pi_I\) is used. </td></tr>
    <tr><td class="paramname">upper_bound</td><td>Constant (upper bound). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of crossings \(C\) if said number is less than or equal to the upper bound. The function returns a value strictly larger than the upper bound if otherwise. </dd></dl>

</div>
</div>
<a id="a81e5bdc0c496cec1dc8764ff73d9eff3" name="a81e5bdc0c496cec1dc8764ff73d9eff3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81e5bdc0c496cec1dc8764ff73d9eff3">&#9670;&#160;</a></span>is_node_reachable_from()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class graph_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::detail::is_node_reachable_from </td>
          <td>(</td>
          <td class="paramtype">const graph_t &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>target</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is a node reachable from another? </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">source</td><td>Node where the search starts at. </td></tr>
    <tr><td class="paramname">target</td><td>The node we want to know whether it is reachable from <em>source</em> or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if, and only if, node target is reachable from node source. </dd></dl>

</div>
</div>
<a id="ae4328332d0cc3162fa7c89982547bbfd" name="ae4328332d0cc3162fa7c89982547bbfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4328332d0cc3162fa7c89982547bbfd">&#9670;&#160;</a></span>is_projective()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class arrangement_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::detail::is_projective </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arrangement_t &amp;</td>          <td class="paramname"><span class="paramname"><em>arr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is a given arrangement projective? </p>
<p>See <a class="el" href="LAL_concepts.html#LAL_concepts__linear_arrangement__types">Types of arrangements</a> for details on projective arrangements.</p>
<p>If the input arrangement is empty then the identity arrangement \(\pi_I\) is used. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">arrangement_t</td><td>Type of arrangement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rt</td><td>Input rooted tree </td></tr>
    <tr><td class="paramname">arr</td><td>Input linear arrangement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the input rooted tree arranged with the input arrangement is projective. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The input rooted tree must be a valid rooted tree (see <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#af464d98b1b5dfdbaaacea553d9c89154">lal::graphs::rooted_tree::is_rooted_tree</a>). </dd></dl>

</div>
</div>
<a id="a1f34b48937d167823667155da1b7c6ba" name="a1f34b48937d167823667155da1b7c6ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f34b48937d167823667155da1b7c6ba">&#9670;&#160;</a></span>is_root_covered()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class arrangement_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::detail::is_root_covered </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arrangement_t &amp;</td>          <td class="paramname"><span class="paramname"><em>arr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the root of a rooted tree covered in a given arrangement? </p>
<p>See <a class="el" href="LAL_concepts.html#LAL_concepts__linear_arrangement__properties">Properties that can be defined in linear arrangements</a> for details on vertex covering in an arrangement.</p>
<p>If the input arrangement is empty then the identity arrangement \(\pi_I\) is used. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">arrangement_t</td><td>Type of arrangement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rt</td><td>Input rooted tree </td></tr>
    <tr><td class="paramname">arr</td><td>Input linear arrangement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the root is covered in the given arrangement. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The input rooted tree must be a valid rooted tree (see <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#af464d98b1b5dfdbaaacea553d9c89154">lal::graphs::rooted_tree::is_rooted_tree</a>). </dd></dl>

</div>
</div>
<a id="a4bc49ef158d5f8f31c387e870a06f330" name="a4bc49ef158d5f8f31c387e870a06f330"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bc49ef158d5f8f31c387e870a06f330">&#9670;&#160;</a></span>is_thistle_vertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#a802d6fe98fa1e77f474f63f151e8c215">level_signature_type</a> t, class graph_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::detail::is_thistle_vertex </td>
          <td>(</td>
          <td class="paramtype">const graph_t &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1detail_1_1level__signature.html">level_signature</a>&lt; t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>levels</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlal_1_1node__t.html">node_t</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>arr</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether or not the input vertex is a thistle vertex. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">t</td><td>Level signature type </td></tr>
    <tr><td class="paramname">graph_t</td><td>Type of graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arr</td><td>Input arrangement. </td></tr>
    <tr><td class="paramname">levels</td><td>Level signature of the arrangement. </td></tr>
    <tr><td class="paramname">u</td><td>Vertex to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the input vertex is a thistle. </dd></dl>

</div>
</div>
<a id="a41b38d88fe84f185d9fd54d431438724" name="a41b38d88fe84f185d9fd54d431438724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41b38d88fe84f185d9fd54d431438724">&#9670;&#160;</a></span>make_arrangement_permutations() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::detail::make_arrangement_permutations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>T</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>parent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelal.html#a5c3f34575ec933a44ed7b6d81e8c75f6">position</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>arr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make an arrangement using permutations. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">container</td><td>Object containing the permutations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">T</td><td>Input rooted tree. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">parent</td><td>Parent of node <em>u</em>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">u</td><td>Root of the current subtree. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">data</td><td>The permutations used to construct the arrangement. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pos</td><td>Current position in the arrangement. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">arr</td><td>Arrangement constructed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1e642d379033a5a82b9a26aed5e1ebcf" name="a1e642d379033a5a82b9a26aed5e1ebcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e642d379033a5a82b9a26aed5e1ebcf">&#9670;&#160;</a></span>make_arrangement_permutations() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> lal::detail::make_arrangement_permutations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>T</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>root</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make an arrangement using permutations. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">container</td><td>Object containing the permutations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>Input rooted tree. </td></tr>
    <tr><td class="paramname">root</td><td>Node used as root. </td></tr>
    <tr><td class="paramname">data</td><td>The permutations to construct the arrangement from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The arrangement constructed with the permutations. </dd></dl>

</div>
</div>
<a id="a1a50073a5ef6744e0e15a8ccd85b73fd" name="a1a50073a5ef6744e0e15a8ccd85b73fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a50073a5ef6744e0e15a8ccd85b73fd">&#9670;&#160;</a></span>make_arrangement_permutations() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> lal::detail::make_arrangement_permutations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>T</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make an arrangement using permutations. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">container</td><td>Object containing the permutations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>Input rooted tree. </td></tr>
    <tr><td class="paramname">data</td><td>The permutations to construct the arrangement from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The arrangement constructed with the permutations. </dd></dl>

</div>
</div>
<a id="af3a4e75c992cd9209d9b9c7085375001" name="af3a4e75c992cd9209d9b9c7085375001"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3a4e75c992cd9209d9b9c7085375001">&#9670;&#160;</a></span>make_arrangement_permutations() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::detail::make_arrangement_permutations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>T</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelal.html#a5c3f34575ec933a44ed7b6d81e8c75f6">position</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>arr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make an arrangement using permutations. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">container</td><td>Object containing the permutations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">T</td><td>Input rooted tree. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">r</td><td>Root of the current subtree. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">data</td><td>The permutations used to construct the arrangement. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pos</td><td>Current position in the arrangement. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">arr</td><td>Arrangement constructed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aba881f87432bdfa65bc26d67244de6aa" name="aba881f87432bdfa65bc26d67244de6aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba881f87432bdfa65bc26d67244de6aa">&#9670;&#160;</a></span>make_array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , T... ARGS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, sizeof...(ARGS)&gt; lal::detail::make_array </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make an array with the values given as parameters of the template. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the array </td></tr>
    <tr><td class="paramname">ARGS</td><td>List of values to be stored in the array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adfd794b7d5d1d3b62c7faa1572342dfe" name="adfd794b7d5d1d3b62c7faa1572342dfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfd794b7d5d1d3b62c7faa1572342dfe">&#9670;&#160;</a></span>make_array_with_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t array_size, T value_to_fill_with&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, array_size &gt; lal::detail::make_array_with_value </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an array initialized at a given value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the array's elements. </td></tr>
    <tr><td class="paramname">array_size</td><td>Size of the array. </td></tr>
    <tr><td class="paramname">value_to_fill_with</td><td>The value to fill the array with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab1c13d4871396a062ae9ce2533867b15" name="ab1c13d4871396a062ae9ce2533867b15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1c13d4871396a062ae9ce2533867b15">&#9670;&#160;</a></span>make_array_with_value_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t size, T v, std::size_t... I&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, size &gt; lal::detail::make_array_with_value_impl </td>
          <td>(</td>
          <td class="paramtype">std::index_sequence&lt; I... &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of <a class="el" href="#adfd794b7d5d1d3b62c7faa1572342dfe">lal::detail::make_array_with_value</a>. </p>
<p>Function used by <a class="el" href="#adfd794b7d5d1d3b62c7faa1572342dfe">lal::detail::make_array_with_value()</a>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the value. </td></tr>
    <tr><td class="paramname">size</td><td>Size of the array. </td></tr>
    <tr><td class="paramname">v</td><td>Value to use. </td></tr>
    <tr><td class="paramname">I</td><td>Index sequence. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An array of the given size where all elements are equal to <em>v</em>. </dd></dl>

</div>
</div>
<a id="a4f454be47191d83eb42085332877424e" name="a4f454be47191d83eb42085332877424e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f454be47191d83eb42085332877424e">&#9670;&#160;</a></span>mean_sum_edge_lengths()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class result_t , class graph_t , class arrangement_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">result_t lal::detail::mean_sum_edge_lengths </td>
          <td>(</td>
          <td class="paramtype">const graph_t &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arrangement_t &amp;</td>          <td class="paramname"><span class="paramname"><em>arr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Average sum of edge lengths in a graph. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">result_t</td><td>Type of return value. </td></tr>
    <tr><td class="paramname">graph_t</td><td>Type of graph. </td></tr>
    <tr><td class="paramname">arrangement_t</td><td>Type of arrangement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input directed graph. </td></tr>
    <tr><td class="paramname">arr</td><td>Input linear arrangement. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aca0f63ffdc99856ed0323879c85bf9f1" name="aca0f63ffdc99856ed0323879c85bf9f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca0f63ffdc99856ed0323879c85bf9f1">&#9670;&#160;</a></span>mirror_level_signature()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class level_signature_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">level_signature_t lal::detail::mirror_level_signature </td>
          <td>(</td>
          <td class="paramtype">const level_signature_t &amp;</td>          <td class="paramname"><span class="paramname"><em>L</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mirrors a level signature. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">level_signature_t</td><td>Level signature type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>Input level signature. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A mirrored copy of the input level signature. </dd></dl>

</div>
</div>
<a id="a811da8587db802ee4de53fe9c4d26b7c" name="a811da8587db802ee4de53fe9c4d26b7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a811da8587db802ee4de53fe9c4d26b7c">&#9670;&#160;</a></span>mpq_divide_mpq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::detail::mpq_divide_mpq </td>
          <td>(</td>
          <td class="paramtype">mpq_t &amp;</td>          <td class="paramname"><span class="paramname"><em>num</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mpq_t &amp;</td>          <td class="paramname"><span class="paramname"><em>den</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rational-Rational division. </p>
<p>Divide a rational \(r_1\) by another rational \(r_2\). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">num</td><td>The rational to be divided by \(k\). Result is \(r_1 := r_1/r_2\). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">den</td><td>The rational that divides the rational. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a52b8428c64f43950e2e231a38e2a730b" name="a52b8428c64f43950e2e231a38e2a730b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52b8428c64f43950e2e231a38e2a730b">&#9670;&#160;</a></span>mpz_divide_mpq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::detail::mpz_divide_mpq </td>
          <td>(</td>
          <td class="paramtype">mpq_t &amp;</td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mpz_t &amp;</td>          <td class="paramname"><span class="paramname"><em>k</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rational-Integer division. </p>
<p>Divide a rational \(r\) by an integer \(k\). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">r</td><td>The rational to be divided by \(k\). Result is \(r := r/k\). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>The integer that divides the rational. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aadddf96b5de80a3d63d05ec36f9cb672" name="aadddf96b5de80a3d63d05ec36f9cb672"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadddf96b5de80a3d63d05ec36f9cb672">&#9670;&#160;</a></span>mpz_pow_mpz()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::detail::mpz_pow_mpz </td>
          <td>(</td>
          <td class="paramtype">mpz_t &amp;</td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mpz_t &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mpz_t &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the exponentiation of a big integer to another big integer. </p>
<p>Fast exponentiation algorithm.</p>
<p>This function has, as an exception, its output parameter as its first parameter. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">r</td><td>Result. \(r = b^e\). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Base. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>Exponent. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8dfcbe004ac9a216754bf3eae410c32b" name="a8dfcbe004ac9a216754bf3eae410c32b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dfcbe004ac9a216754bf3eae410c32b">&#9670;&#160;</a></span>n_C_brute_force() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class graph_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lal::detail::n_C_brute_force </td>
          <td>(</td>
          <td class="paramtype">const graph_t &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>arr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the number of crossings in the linear arrangement less than a constant? </p>
<p>Given a graph, and a linear arrangement of its nodes, computes by brute force the number of edges that cross in such linear arrangement. If the arrangement is not specified, the identity arrangement is used. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">graph_t</td><td>Type of graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arr</td><td>Linear arrangement of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of crossings \(C\). </dd></dl>

</div>
</div>
<a id="a9aaadea543154a22dd77ce1179b9ab42" name="a9aaadea543154a22dd77ce1179b9ab42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aaadea543154a22dd77ce1179b9ab42">&#9670;&#160;</a></span>n_C_brute_force() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class graph_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; uint64_t &gt; lal::detail::n_C_brute_force </td>
          <td>(</td>
          <td class="paramtype">const graph_t &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>arrs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the number of crossings in the linear arrangement less than a constant? </p>
<p>Given a graph, and a linear arrangement of its nodes, computes by brute force the number of edges that cross in such linear arrangement. If the arrangement is not specified, the identity arrangement is used. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">graph_t</td><td>Type of graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arrs</td><td>List of \(k\) linear arrangements of the nodes \(\Pi = \{\pi_i\}_{i=1}^k\). When one is omitted, \(\pi_I\) is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list \(L\) where \(L_i = C_{\pi_i}(g)\). </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>None of the arrangements is empty. </dd></dl>

</div>
</div>
<a id="ace62b8ae72aa81e2f7220ed5ab94d62b" name="ace62b8ae72aa81e2f7220ed5ab94d62b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace62b8ae72aa81e2f7220ed5ab94d62b">&#9670;&#160;</a></span>n_C_dynamic_programming() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class graph_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lal::detail::n_C_dynamic_programming </td>
          <td>(</td>
          <td class="paramtype">const graph_t &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>arr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the number of crossings in the linear arrangement less than a constant? </p>
<p>Given a graph, and a linear arrangement of its nodes, computes by brute force the number of edges that cross in such linear arrangement. If the arrangement is not specified, the identity arrangement is used. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">graph_t</td><td>Type of graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arr</td><td>Linear arrangement of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of crossings \(C\). </dd></dl>

</div>
</div>
<a id="ab6fb4a73feef834d6f6083017c77ffad" name="ab6fb4a73feef834d6f6083017c77ffad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6fb4a73feef834d6f6083017c77ffad">&#9670;&#160;</a></span>n_C_dynamic_programming() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class graph_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; uint64_t &gt; lal::detail::n_C_dynamic_programming </td>
          <td>(</td>
          <td class="paramtype">const graph_t &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>arrs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the number of crossings in the linear arrangement less than a constant? </p>
<p>Given a graph, and a linear arrangement of its nodes, computes by brute force the number of edges that cross in such linear arrangement. If the arrangement is not specified, the identity arrangement is used. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">graph_t</td><td>Type of graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arrs</td><td>List of \(k\) linear arrangements of the nodes \(\Pi = \{\pi_i\}_{i=1}^k\). When one is omitted, \(\pi_I\) is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list \(L\) where \(L_i = C_{\pi_i}(g)\). </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>None of the arrangements is empty. </dd></dl>

</div>
</div>
<a id="a0ff3d3faa9937f42252a89c79809d20f" name="a0ff3d3faa9937f42252a89c79809d20f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ff3d3faa9937f42252a89c79809d20f">&#9670;&#160;</a></span>n_C_ladder() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class graph_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lal::detail::n_C_ladder </td>
          <td>(</td>
          <td class="paramtype">const graph_t &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>arr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the number of crossings in the linear arrangement less than a constant? </p>
<p>Given a graph, and a linear arrangement of its nodes, computes by brute force the number of edges that cross in such linear arrangement. If the arrangement is not specified, the identity arrangement is used. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">graph_t</td><td>Type of graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arr</td><td>Linear arrangement of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of crossings \(C\). </dd></dl>

</div>
</div>
<a id="a5860c3c8273d95209e36bdd689943629" name="a5860c3c8273d95209e36bdd689943629"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5860c3c8273d95209e36bdd689943629">&#9670;&#160;</a></span>n_C_ladder() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class graph_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; uint64_t &gt; lal::detail::n_C_ladder </td>
          <td>(</td>
          <td class="paramtype">const graph_t &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>arrs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the number of crossings in the linear arrangement less than a constant? </p>
<p>Given a graph, and a linear arrangement of its nodes, computes by brute force the number of edges that cross in such linear arrangement. If the arrangement is not specified, the identity arrangement is used. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">graph_t</td><td>Type of graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arrs</td><td>List of \(k\) linear arrangements of the nodes \(\Pi = \{\pi_i\}_{i=1}^k\). When one is omitted, \(\pi_I\) is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list \(L\) where \(L_i = C_{\pi_i}(g)\). </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>None of the arrangements is empty. </dd></dl>

</div>
</div>
<a id="a1d67b4d927bc4ada1816b903f278bcff" name="a1d67b4d927bc4ada1816b903f278bcff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d67b4d927bc4ada1816b903f278bcff">&#9670;&#160;</a></span>n_C_stack_based() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class graph_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lal::detail::n_C_stack_based </td>
          <td>(</td>
          <td class="paramtype">const graph_t &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>arr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the number of crossings in the linear arrangement less than a constant? </p>
<p>Given a graph, and a linear arrangement of its nodes, computes by brute force the number of edges that cross in such linear arrangement. If the arrangement is not specified, the identity arrangement is used. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">graph_t</td><td>Type of graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arr</td><td>A linear arrangement of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of crossings \(C\). </dd></dl>

</div>
</div>
<a id="a2dcc673a543201a113c8c6f1d0f3e1ad" name="a2dcc673a543201a113c8c6f1d0f3e1ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dcc673a543201a113c8c6f1d0f3e1ad">&#9670;&#160;</a></span>n_C_stack_based() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class graph_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; uint64_t &gt; lal::detail::n_C_stack_based </td>
          <td>(</td>
          <td class="paramtype">const graph_t &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>arrs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the number of crossings in the linear arrangement less than a constant? </p>
<p>Given a graph, and a linear arrangement of its nodes, computes by brute force the number of edges that cross in such linear arrangement. If the arrangement is not specified, the identity arrangement is used. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">graph_t</td><td>Type of graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arrs</td><td>List of \(k\) linear arrangements of the nodes \(\Pi = \{\pi_i\}_{i=1}^k\). When one is omitted, \(\pi_I\) is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list \(L\) where \(L_i = C_{\pi_i}(g)\). </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>None of the arrangements is empty. </dd></dl>

</div>
</div>
<a id="a44eb4714934478c361cefbcab8e40319" name="a44eb4714934478c361cefbcab8e40319"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44eb4714934478c361cefbcab8e40319">&#9670;&#160;</a></span>no_two_adjacent_vertices_have_same_level()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class graph_t , <a class="el" href="#a802d6fe98fa1e77f474f63f151e8c215">level_signature_type</a> t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::detail::no_two_adjacent_vertices_have_same_level </td>
          <td>(</td>
          <td class="paramtype">const graph_t &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1detail_1_1level__signature.html">level_signature</a>&lt; t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>levels</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>arr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if no two adjacent vertices (in the graph) have the same level value. </p>
<p>Checks that no edge \(uv\in E(G)\) is such that \(l_{\pi}(u) = l_{\pi}(v)\). This is a necessary condition for an arrangement to be maximum (in sum of edge lengths), as shown in <a class="el" href="citelist.html#CITEREF_Nurse2018a">[18]</a> <a class="el" href="citelist.html#CITEREF_Nurse2019a">[39]</a> and <a class="el" href="citelist.html#CITEREF_Alemany2023a">[7]</a>.</p>
<p>When the level signature is defined on a 'per vertex' basis, the arrangement is not needed. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">t</td><td>Level signature type. </td></tr>
    <tr><td class="paramname">graph_t</td><td>Type of graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arr</td><td>Input arrangement. </td></tr>
    <tr><td class="paramname">levels</td><td>signature of the arrangement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the level sequence satisfies the condition. </dd></dl>

</div>
</div>
<a id="ad1d25f75df270d8b44ea5eae86f5eabc" name="ad1d25f75df270d8b44ea5eae86f5eabc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1d25f75df270d8b44ea5eae86f5eabc">&#9670;&#160;</a></span>no_vertex_in_antenna_is_thistle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class graph_t , <a class="el" href="#a802d6fe98fa1e77f474f63f151e8c215">level_signature_type</a> t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::detail::no_vertex_in_antenna_is_thistle </td>
          <td>(</td>
          <td class="paramtype">const graph_t &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classlal_1_1properties_1_1branchless__path.html">properties::branchless_path</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>bps</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1detail_1_1level__signature.html">level_signature</a>&lt; t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>levels</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>arr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if none of the vertices in the antennas of the graph is a thistle. </p>
<p>Checks that no vertex in any antenna of the tree is a thistle vertex in the input arrangement. This is a necessary condition for an arrangement to be maximum (in sum of edge lengths), as shown in <a class="el" href="citelist.html#CITEREF_Alemany2023a">[7]</a>.</p>
<p>When the level signature is defined on a 'per vertex' basis, the arrangement is not needed. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">t</td><td>Level signature type. </td></tr>
    <tr><td class="paramname">graph_t</td><td>Type of graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arr</td><td>Input arrangement. </td></tr>
    <tr><td class="paramname">levels</td><td>signature of the arrangement. </td></tr>
    <tr><td class="paramname">bps</td><td>All Branchless Paths of the tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the level sequence satisfies the condition. </dd></dl>

</div>
</div>
<a id="ac06bbc1aa13b66438da3a404b295ef3f" name="ac06bbc1aa13b66438da3a404b295ef3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac06bbc1aa13b66438da3a404b295ef3f">&#9670;&#160;</a></span>operate_power() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::detail::operate_power </td>
          <td>(</td>
          <td class="paramtype">mpq_t &amp;</td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mpz_t &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Power operation. </p>
<p>Raise a rational value \(r\) to a certain power \(p\). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">r</td><td>Rational value. Result is \(r = r^p\). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Exponent. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a82682656557db49caf9f7f0c0db9137f" name="a82682656557db49caf9f7f0c0db9137f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82682656557db49caf9f7f0c0db9137f">&#9670;&#160;</a></span>operate_power() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::detail::operate_power </td>
          <td>(</td>
          <td class="paramtype">mpq_t &amp;</td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Power operation. </p>
<p>Raise a rational value \(r\) to a certain power \(p\). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">r</td><td>Rational value. Result is \(r = r^p\). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Exponent. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8965e5ea6dab322a1bfdd7ee94c7050f" name="a8965e5ea6dab322a1bfdd7ee94c7050f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8965e5ea6dab322a1bfdd7ee94c7050f">&#9670;&#160;</a></span>predict_C_using_edge_lengths()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename result_t , class graph_t , class arrangement_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">result_t lal::detail::predict_C_using_edge_lengths </td>
          <td>(</td>
          <td class="paramtype">const graph_t &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arrangement_t &amp;</td>          <td class="paramname"><span class="paramname"><em>arr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Predicted number of crossings based on the sum of edge lengths. </p>
<p>See <a class="el" href="citelist.html#CITEREF_Ferrer2014a">[22]</a> for further details. This functions implements \(E_2[C]\). </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">result_t</td><td>Type of the return value. </td></tr>
    <tr><td class="paramname">graph_t</td><td>Type of graph. </td></tr>
    <tr><td class="paramname">arrangement_t</td><td>Type of arrangement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arr</td><td>Input arrangement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of \(E_2[C]\). </dd></dl>

</div>
</div>
<a id="abe3b1dd38f2d471670141dfd38a3c5b6" name="abe3b1dd38f2d471670141dfd38a3c5b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe3b1dd38f2d471670141dfd38a3c5b6">&#9670;&#160;</a></span>retrieve_centre()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tree_t , std::enable_if_t&lt; std::is_base_of_v&lt; <a class="el" href="classlal_1_1graphs_1_1tree.html">graphs::tree</a>, tree_t &gt;, bool &gt;  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a>, <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> &gt; lal::detail::retrieve_centre </td>
          <td>(</td>
          <td class="paramtype">const tree_t &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>X</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the centre of the connected component that has node <em>x</em>. </p>
<p>See <a class="el" href="LAL_concepts.html#LAL_concepts__centre_centroid">Centre and centroid of a tree</a> for details on what the centre of a tree is.</p>
<p>A graph of type <a class="el" href="classlal_1_1graphs_1_1tree.html">lal::graphs::tree</a> may lack some edges tree so it has several connected components. Vertex <em>x</em> belongs to one of these connected components.</p>
<p>This method finds the central nodes of the connected components node 'x' belongs to.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">tree_t</td><td>type of tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input tree. </td></tr>
    <tr><td class="paramname">X</td><td>Input node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Input tree <em>t</em> may be a forest. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A tuple of the two nodes in the centre. If the tree has a single central node, only the first node is valid and the second is assigned an invalid vertex index. It is guaranteed that the first vertex has smaller index value than the second. </dd></dl>

</div>
</div>
<a id="a2d196fa5a4cf30d46810eb86634da4f0" name="a2d196fa5a4cf30d46810eb86634da4f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d196fa5a4cf30d46810eb86634da4f0">&#9670;&#160;</a></span>retrieve_centroid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tree_t , std::enable_if_t&lt; std::is_base_of_v&lt; <a class="el" href="classlal_1_1graphs_1_1tree.html">graphs::tree</a>, tree_t &gt;, bool &gt;  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a>, <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> &gt; lal::detail::retrieve_centroid </td>
          <td>(</td>
          <td class="paramtype">const tree_t &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the centroid of the connected component that has node <em>x</em>. </p>
<p>For details on the parameters and return value see documentation of the function above. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">tree_t</td><td>Type of tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input tree </td></tr>
    <tr><td class="paramname">x</td><td>Node belonging to a connected component whose centroid we want. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tuple of two values: the nodes in the centroid. If the tree has a single centroidal node, only the first node is valid and the second is assigned an invalid vertex index. It is guaranteed that the first vertex has smaller index value than the second. </dd></dl>

</div>
</div>
<a id="a5730f2fef2524437fafcbeb1383d9d96" name="a5730f2fef2524437fafcbeb1383d9d96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5730f2fef2524437fafcbeb1383d9d96">&#9670;&#160;</a></span>right_branching_edges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class arrangement_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lal::detail::right_branching_edges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arrangement_t &amp;</td>          <td class="paramname"><span class="paramname"><em>arr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of right branching edges in a directed graph. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">arrangement_t</td><td>Type of arrangement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input directed graph. </td></tr>
    <tr><td class="paramname">arr</td><td>Input linear arrangement. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5bb2c6db85eddc1623aa2e3e4b0cbb29" name="a5bb2c6db85eddc1623aa2e3e4b0cbb29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bb2c6db85eddc1623aa2e3e4b0cbb29">&#9670;&#160;</a></span>set_edges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class graph_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespacelal.html#a5969ec7ecc85697ebb9ec0ace78fbcab">edge</a> &gt; lal::detail::set_edges </td>
          <td>(</td>
          <td class="paramtype">const graph_t &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumerate the set of edges of the input graph <em>g</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector with all <em>g's</em> edges. </dd></dl>

</div>
</div>
<a id="a0ef4c2de8e98db0003d828728aea3846" name="a0ef4c2de8e98db0003d828728aea3846"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ef4c2de8e98db0003d828728aea3846">&#9670;&#160;</a></span>set_pairs_independent_edges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class graph_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespacelal.html#a235d5351556fbc73aa51767ab7765f5c">edge_pair</a> &gt; lal::detail::set_pairs_independent_edges </td>
          <td>(</td>
          <td class="paramtype">const graph_t &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>qs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumerate the set of pairs of independent edges of the input graph <em>g</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">qs</td><td>Total amount of pairs of independent edges. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector with all <em>g's</em> pairs of independent edges. </dd></dl>

</div>
</div>
<a id="a8452716fdc28399856f71906ef872b6c" name="a8452716fdc28399856f71906ef872b6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8452716fdc28399856f71906ef872b6c">&#9670;&#160;</a></span>sum_edge_lengths()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class graph_t , class arrangement_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lal::detail::sum_edge_lengths </td>
          <td>(</td>
          <td class="paramtype">const graph_t &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arrangement_t &amp;</td>          <td class="paramname"><span class="paramname"><em>arr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sum of edge lengths in a graph. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">graph_t</td><td>Type of graph. </td></tr>
    <tr><td class="paramname">arrangement_t</td><td>Type of arrangement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input directed graph. </td></tr>
    <tr><td class="paramname">arr</td><td>Input linear arrangement. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab4c9a33cc1468c286ef8f54b0be769ae" name="ab4c9a33cc1468c286ef8f54b0be769ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4c9a33cc1468c286ef8f54b0be769ae">&#9670;&#160;</a></span>syntactic_dependency_tree_to_string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string_view lal::detail::syntactic_dependency_tree_to_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal_1_1linarr.html#a682101b23eb6c0db724df82e2aae18dd">linarr::syntactic_dependency_tree_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>tt</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts a value of the enumeration <a class="el" href="namespacelal_1_1linarr.html#a682101b23eb6c0db724df82e2aae18dd">lal::linarr::syntactic_dependency_tree_type</a> into a string. </p>

</div>
</div>
<a id="a0fe31411ada0a0c45093503fb6f9406f" name="a0fe31411ada0a0c45093503fb6f9406f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fe31411ada0a0c45093503fb6f9406f">&#9670;&#160;</a></span>tree_diameter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tree_t , std::enable_if_t&lt; std::is_base_of_v&lt; <a class="el" href="classlal_1_1graphs_1_1tree.html">graphs::tree</a>, tree_t &gt;, bool &gt;  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lal::detail::tree_diameter </td>
          <td>(</td>
          <td class="paramtype">const tree_t &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the diameter of a tree. </p>
<p>See <a class="el" href="LAL_concepts.html#LAL_concepts__tree_diameter">Diameter of a tree</a> for details on the definition of the diameter of a tree.</p>
<p>The diameter of the connected component to which node <em>x</em> belongs to. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">tree_t</td><td>Type of tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input tree. </td></tr>
    <tr><td class="paramname">x</td><td>Input node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The diameter of the tree. </dd></dl>

</div>
</div>
<a id="af50760eaee3200e963cc77c4c95470d6" name="af50760eaee3200e963cc77c4c95470d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af50760eaee3200e963cc77c4c95470d6">&#9670;&#160;</a></span>update_unionfind_after_add_edge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tree_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::detail::update_unionfind_after_add_edge </td>
          <td>(</td>
          <td class="paramtype">const tree_t &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> *const</td>          <td class="paramname"><span class="paramname"><em>root_of</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *const</td>          <td class="paramname"><span class="paramname"><em>root_size</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the Union-Find data structure after the addition of an edge. </p>
<p>This function updates the Union-Find data structure of a tree after the addition of an edge between vertices <em>u</em> and <em>v</em>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">tree_t</td><td>Type of input tree. A derived class of <a class="el" href="classlal_1_1graphs_1_1free__tree.html">lal::graphs::free_tree</a> or a derived class of <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">lal::graphs::rooted_tree</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input tree </td></tr>
    <tr><td class="paramname">u</td><td>Node </td></tr>
    <tr><td class="paramname">v</td><td>Node </td></tr>
    <tr><td class="paramname">root_of</td><td>Pointer to an array where <em>root_of</em>[<em>s</em>] = <em>t</em> if the root of the connected component of <em>s</em> is <em>t</em> </td></tr>
    <tr><td class="paramname">root_size</td><td>Sizes of each connected component. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The edge \(\{u,v\}\) must exist. </dd></dl>

</div>
</div>
<a id="a5cadd0c126ee7d5e745ee5188d67daff" name="a5cadd0c126ee7d5e745ee5188d67daff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cadd0c126ee7d5e745ee5188d67daff">&#9670;&#160;</a></span>update_unionfind_after_add_edges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tree_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::detail::update_unionfind_after_add_edges </td>
          <td>(</td>
          <td class="paramtype">const tree_t &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ab98936b00d896700a71899dff1ed9248">edge_list</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>edges</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> *const</td>          <td class="paramname"><span class="paramname"><em>root_of</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *const</td>          <td class="paramname"><span class="paramname"><em>root_size</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the Union-Find data structure after the addition of several edges. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">tree_t</td><td>Type of tree </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input tree </td></tr>
    <tr><td class="paramname">edges</td><td>Edges added to the tree </td></tr>
    <tr><td class="paramname">root_of</td><td>Pointer to an array where <em>root_of</em>[<em>s</em>] = <em>t</em> if the root of the connected component of <em>s</em> is <em>t</em> </td></tr>
    <tr><td class="paramname">root_size</td><td>Sizes of each connected component. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The edge \(\{u,v\}\) must exist. </dd></dl>

</div>
</div>
<a id="a49b8ff3684b7c460352ee1678541b0d9" name="a49b8ff3684b7c460352ee1678541b0d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49b8ff3684b7c460352ee1678541b0d9">&#9670;&#160;</a></span>update_unionfind_after_add_rem_edges_bulk()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tree_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::detail::update_unionfind_after_add_rem_edges_bulk </td>
          <td>(</td>
          <td class="paramtype">const tree_t &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> *const</td>          <td class="paramname"><span class="paramname"><em>root_of</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *const</td>          <td class="paramname"><span class="paramname"><em>root_size</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the Union-Find data structure after several edges have been operated in bulk. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">tree_t</td><td>Type of tree </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input tree </td></tr>
    <tr><td class="paramname">root_of</td><td>Pointer to an array where <em>root_of</em>[<em>s</em>] = <em>t</em> if the root of the connected component of <em>s</em> is <em>t</em> </td></tr>
    <tr><td class="paramname">root_size</td><td>Sizes of each connected component. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The edge \(\{u,v\}\) must exist. </dd></dl>

</div>
</div>
<a id="a773e3f33dbdcf3c44007f621eea0e4de" name="a773e3f33dbdcf3c44007f621eea0e4de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a773e3f33dbdcf3c44007f621eea0e4de">&#9670;&#160;</a></span>update_unionfind_after_remove_edge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tree_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::detail::update_unionfind_after_remove_edge </td>
          <td>(</td>
          <td class="paramtype">const tree_t &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> *const</td>          <td class="paramname"><span class="paramname"><em>root_of</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *const</td>          <td class="paramname"><span class="paramname"><em>root_size</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates Union-Find after the removal of an edge. </p>
<p>This function updates the Union-Find data structure of a tree after the removal of the edge between vertices <em>u</em> and <em>v</em>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">tree_t</td><td>Type of input tree. A derived class of <a class="el" href="classlal_1_1graphs_1_1free__tree.html">lal::graphs::free_tree</a> or a derived class of <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">lal::graphs::rooted_tree</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input tree </td></tr>
    <tr><td class="paramname">u</td><td>Node </td></tr>
    <tr><td class="paramname">v</td><td>Node </td></tr>
    <tr><td class="paramname">root_of</td><td>Pointer to an array where <em>root_of</em>[<em>s</em>] = <em>t</em> if the root of the connected component of <em>s</em> is <em>t</em> </td></tr>
    <tr><td class="paramname">root_size</td><td>Sizes of each connected component. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The edge \(\{u,v\}\) must exist. </dd></dl>

</div>
</div>
<a id="a7c633651b077f8fd9417d8593e222dea" name="a7c633651b077f8fd9417d8593e222dea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c633651b077f8fd9417d8593e222dea">&#9670;&#160;</a></span>update_unionfind_after_remove_edges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tree_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::detail::update_unionfind_after_remove_edges </td>
          <td>(</td>
          <td class="paramtype">const tree_t &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ab98936b00d896700a71899dff1ed9248">edge_list</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>edges</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> *const</td>          <td class="paramname"><span class="paramname"><em>root_of</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *const</td>          <td class="paramname"><span class="paramname"><em>root_size</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the Union-Find data structure after the addition of several edges. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">tree_t</td><td>Type of input tree. A derived class of <a class="el" href="classlal_1_1graphs_1_1free__tree.html">lal::graphs::free_tree</a> or a derived class of <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">lal::graphs::rooted_tree</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input tree </td></tr>
    <tr><td class="paramname">edges</td><td>Edges added to the tree </td></tr>
    <tr><td class="paramname">root_of</td><td>Pointer to an array where <em>root_of</em>[<em>s</em>] = <em>t</em> if the root of the connected component of <em>s</em> is <em>t</em> </td></tr>
    <tr><td class="paramname">root_size</td><td>Sizes of each connected component. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The edge \(\{u,v\}\) must exist. </dd></dl>

</div>
</div>
<a id="a13f00277c294d1ea536cb0359e2d28fd" name="a13f00277c294d1ea536cb0359e2d28fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13f00277c294d1ea536cb0359e2d28fd">&#9670;&#160;</a></span>update_unionfind_before_remove_edges_incident_to() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class tree_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::detail::update_unionfind_before_remove_edges_incident_to </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlal_1_1detail_1_1BFS.html">BFS</a>&lt; tree_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>bfs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> *const</td>          <td class="paramname"><span class="paramname"><em>root_of</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *const</td>          <td class="paramname"><span class="paramname"><em>root_size</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update Union-Find after the removal of a vertex. </p>
<p>This function updates the Union-Find data structure of a tree prior to the removal of the edge (u,v).</p>
<p>In particular, it updates the information associated to the vertices found in the direction (u,v). </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">tree_t</td><td>Type of input tree. A derived class of <a class="el" href="classlal_1_1graphs_1_1free__tree.html">lal::graphs::free_tree</a> or a derived class of <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">lal::graphs::rooted_tree</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bfs</td><td>Breadth-First Search object. </td></tr>
    <tr><td class="paramname">v</td><td>Node to be removed. </td></tr>
    <tr><td class="paramname">root_of</td><td>Pointer to an array where <em>root_of</em>[<em>s</em>] = <em>t</em> if the root of the connected component of <em>s</em> is <em>t</em> </td></tr>
    <tr><td class="paramname">root_size</td><td>Sizes of each connected component. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7836c77cec7bbc6cc92ac41016514e4d" name="a7836c77cec7bbc6cc92ac41016514e4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7836c77cec7bbc6cc92ac41016514e4d">&#9670;&#160;</a></span>update_unionfind_before_remove_edges_incident_to() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename tree_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::detail::update_unionfind_before_remove_edges_incident_to </td>
          <td>(</td>
          <td class="paramtype">const tree_t &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> *const</td>          <td class="paramname"><span class="paramname"><em>root_of</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *const</td>          <td class="paramname"><span class="paramname"><em>root_size</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update Union-Find after a vertex removal. </p>
<p>This function updates the Union-Find data structure of a tree prior to the removal of the edge (u,v).</p>
<p>In particular, it updates the information associated to the vertices found in the direction (u,v). </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">tree_t</td><td>Type of input tree. A derived class of <a class="el" href="classlal_1_1graphs_1_1free__tree.html">lal::graphs::free_tree</a> or a derived class of <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">lal::graphs::rooted_tree</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input tree. </td></tr>
    <tr><td class="paramname">u</td><td>Node to be removed. </td></tr>
    <tr><td class="paramname">root_of</td><td>Pointer to an array where <em>root_of</em>[<em>s</em>] = <em>t</em> if the root of the connected component of <em>s</em> is <em>t</em> </td></tr>
    <tr><td class="paramname">root_size</td><td>Sizes of each connected component. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
