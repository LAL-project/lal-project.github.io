<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LAL: Linear Arrangement Library: lal::properties Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">LAL: Linear Arrangement Library<span id="projectnumber">&#160;24.10.00</span>
   </div>
   <div id="projectbrief">A library focused on algorithms on linear arrangements of graphs.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacelal.html">lal</a></li><li class="navelem"><a class="el" href="namespacelal_1_1properties.html">properties</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">lal::properties Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Namespace for all linear-arrangement-independent algorithms.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1properties_1_1bipartite__graph__coloring.html">bipartite_graph_coloring</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class to represent a coloring of the vertices of a bipartite graph.  <a href="classlal_1_1properties_1_1bipartite__graph__coloring.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1properties_1_1branchless__path.html">branchless_path</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Branchless paths in trees.  <a href="classlal_1_1properties_1_1branchless__path.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1properties_1_1connected__components.html">connected_components</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The connected components of a graph.  <a href="classlal_1_1properties_1_1connected__components.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad53eefcef533555560adccb4226ab376" id="r_ad53eefcef533555560adccb4226ab376"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1properties_1_1bipartite__graph__coloring.html">bipartite_graph_coloring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad53eefcef533555560adccb4226ab376">bipartite_coloring</a> (const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;g) noexcept</td></tr>
<tr class="memdesc:ad53eefcef533555560adccb4226ab376"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the coloring of a bipartite graph.  <br /></td></tr>
<tr class="separator:ad53eefcef533555560adccb4226ab376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e00464be532ce6f496b5e70a9fa2082" id="r_a9e00464be532ce6f496b5e70a9fa2082"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1properties_1_1bipartite__graph__coloring.html">bipartite_graph_coloring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9e00464be532ce6f496b5e70a9fa2082">bipartite_coloring</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;g) noexcept</td></tr>
<tr class="memdesc:a9e00464be532ce6f496b5e70a9fa2082"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the coloring of a bipartite graph.  <br /></td></tr>
<tr class="separator:a9e00464be532ce6f496b5e70a9fa2082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aebad83947a7a88f73a996ef1db8fb0" id="r_a1aebad83947a7a88f73a996ef1db8fb0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1aebad83947a7a88f73a996ef1db8fb0">is_graph_bipartite</a> (const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;g, const <a class="el" href="classlal_1_1properties_1_1bipartite__graph__coloring.html">bipartite_graph_coloring</a> &amp;c) noexcept</td></tr>
<tr class="memdesc:a1aebad83947a7a88f73a996ef1db8fb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is a graph bipartite?  <br /></td></tr>
<tr class="separator:a1aebad83947a7a88f73a996ef1db8fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afae64cf7fe3106dbc368690f6fe9c1c5" id="r_afae64cf7fe3106dbc368690f6fe9c1c5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afae64cf7fe3106dbc368690f6fe9c1c5">is_graph_bipartite</a> (const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;g) noexcept</td></tr>
<tr class="memdesc:afae64cf7fe3106dbc368690f6fe9c1c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is a graph bipartite?  <br /></td></tr>
<tr class="separator:afae64cf7fe3106dbc368690f6fe9c1c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07b9c42ed6a90f262a17502a75b4be58" id="r_a07b9c42ed6a90f262a17502a75b4be58"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07b9c42ed6a90f262a17502a75b4be58">is_graph_bipartite</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;g, const <a class="el" href="classlal_1_1properties_1_1bipartite__graph__coloring.html">bipartite_graph_coloring</a> &amp;c) noexcept</td></tr>
<tr class="memdesc:a07b9c42ed6a90f262a17502a75b4be58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is a graph bipartite?  <br /></td></tr>
<tr class="separator:a07b9c42ed6a90f262a17502a75b4be58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0543824abc7e98a65b0ec698ec44788" id="r_ac0543824abc7e98a65b0ec698ec44788"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac0543824abc7e98a65b0ec698ec44788">is_graph_bipartite</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;g) noexcept</td></tr>
<tr class="memdesc:ac0543824abc7e98a65b0ec698ec44788"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is a graph bipartite?  <br /></td></tr>
<tr class="separator:ac0543824abc7e98a65b0ec698ec44788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac468e7956d7ef0d9ae2cb277cc5da951" id="r_ac468e7956d7ef0d9ae2cb277cc5da951"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classlal_1_1properties_1_1branchless__path.html">branchless_path</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac468e7956d7ef0d9ae2cb277cc5da951">branchless_paths_compute</a> (const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:ac468e7956d7ef0d9ae2cb277cc5da951"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds all branchless paths in a tree.  <br /></td></tr>
<tr class="separator:ac468e7956d7ef0d9ae2cb277cc5da951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a081d46a9bdccaef038b1b89f9b9fc9a9" id="r_a081d46a9bdccaef038b1b89f9b9fc9a9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classlal_1_1properties_1_1branchless__path.html">branchless_path</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a081d46a9bdccaef038b1b89f9b9fc9a9">branchless_paths_compute</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:a081d46a9bdccaef038b1b89f9b9fc9a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds all branchless paths in a tree.  <br /></td></tr>
<tr class="separator:a081d46a9bdccaef038b1b89f9b9fc9a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18d37074e9152261d8b51822becda3d8" id="r_a18d37074e9152261d8b51822becda3d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a18d37074e9152261d8b51822becda3d8">exp_num_crossings_rational</a> (const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;g) noexcept</td></tr>
<tr class="memdesc:a18d37074e9152261d8b51822becda3d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the the expected number of crossings in unconstrained arrangements, \(\mathbb{E}[C]\).  <br /></td></tr>
<tr class="separator:a18d37074e9152261d8b51822becda3d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8ff16428584d88aba05a4b677444a4b" id="r_ab8ff16428584d88aba05a4b677444a4b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab8ff16428584d88aba05a4b677444a4b">exp_num_crossings</a> (const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;g) noexcept</td></tr>
<tr class="memdesc:ab8ff16428584d88aba05a4b677444a4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the the expected number of crossings in unconstrained arrangements, \(\mathbb{E}[C]\).  <br /></td></tr>
<tr class="separator:ab8ff16428584d88aba05a4b677444a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad80fca59dc093300ae576c379a768452" id="r_ad80fca59dc093300ae576c379a768452"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad80fca59dc093300ae576c379a768452">var_num_crossings_rational</a> (const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;g, const bool reuse=true) noexcept</td></tr>
<tr class="memdesc:ad80fca59dc093300ae576c379a768452"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the variance of the number of crossings of a graph in unconstrained arrangements, \(\mathbb{V}[C]\).  <br /></td></tr>
<tr class="separator:ad80fca59dc093300ae576c379a768452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa58446707ce2f604cf693edbb8f122db" id="r_aa58446707ce2f604cf693edbb8f122db"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa58446707ce2f604cf693edbb8f122db">var_num_crossings</a> (const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;g, const bool reuse=true) noexcept</td></tr>
<tr class="memdesc:aa58446707ce2f604cf693edbb8f122db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the variance of the number of crossings of a graph in unconstrained arrangements, \(\mathbb{V}[C]\).  <br /></td></tr>
<tr class="separator:aa58446707ce2f604cf693edbb8f122db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fc49dada4d129f0a9026605e74cfe0a" id="r_a4fc49dada4d129f0a9026605e74cfe0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4fc49dada4d129f0a9026605e74cfe0a">var_num_crossings_forest_rational</a> (const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;g) noexcept</td></tr>
<tr class="memdesc:a4fc49dada4d129f0a9026605e74cfe0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the variance of the number of crossings of a forest in unconstrained arrangements, \(\mathbb{V}[C]\).  <br /></td></tr>
<tr class="separator:a4fc49dada4d129f0a9026605e74cfe0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af404ccea372ee1d555cab3b9c6e67a1d" id="r_af404ccea372ee1d555cab3b9c6e67a1d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af404ccea372ee1d555cab3b9c6e67a1d">var_num_crossings_forest</a> (const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;g) noexcept</td></tr>
<tr class="memdesc:af404ccea372ee1d555cab3b9c6e67a1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the variance of the number of crossings of a forest in unconstrained arrangements, \(\mathbb{V}[C]\).  <br /></td></tr>
<tr class="separator:af404ccea372ee1d555cab3b9c6e67a1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83745d14589b98b918481d83f564f7c0" id="r_a83745d14589b98b918481d83f564f7c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a83745d14589b98b918481d83f564f7c0">var_num_crossings_tree_rational</a> (const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:a83745d14589b98b918481d83f564f7c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the variance of the number of crossings of a tree in unconstrained arrangements, \(\mathbb{V}[C]\).  <br /></td></tr>
<tr class="separator:a83745d14589b98b918481d83f564f7c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c904df78290dd71ec9445ad3908bc5" id="r_a02c904df78290dd71ec9445ad3908bc5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a02c904df78290dd71ec9445ad3908bc5">var_num_crossings_tree</a> (const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:a02c904df78290dd71ec9445ad3908bc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the variance of the number of crossings of a tree in unconstrained arrangements, \(\mathbb{V}[C]\).  <br /></td></tr>
<tr class="separator:a02c904df78290dd71ec9445ad3908bc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad04afab9d98252090df36b307c014de4" id="r_ad04afab9d98252090df36b307c014de4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad04afab9d98252090df36b307c014de4">var_num_crossings_tree_rational</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:ad04afab9d98252090df36b307c014de4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the variance of the number of crossings of a tree in unconstrained arrangements, \(\mathbb{V}[C]\).  <br /></td></tr>
<tr class="separator:ad04afab9d98252090df36b307c014de4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a504fb6143e41360712cdd5b96b93cb6e" id="r_a504fb6143e41360712cdd5b96b93cb6e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a504fb6143e41360712cdd5b96b93cb6e">var_num_crossings_tree</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:a504fb6143e41360712cdd5b96b93cb6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the variance of the number of crossings of a tree in unconstrained arrangements, \(\mathbb{V}[C]\).  <br /></td></tr>
<tr class="separator:a504fb6143e41360712cdd5b96b93cb6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ad32788fcae58379fc9fda3913ebfff" id="r_a8ad32788fcae58379fc9fda3913ebfff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1properties_1_1connected__components.html">connected_components</a>&lt; <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ad32788fcae58379fc9fda3913ebfff">connected_components_compute</a> (const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;g) noexcept</td></tr>
<tr class="memdesc:a8ad32788fcae58379fc9fda3913ebfff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the connected components of an undirected graph.  <br /></td></tr>
<tr class="separator:a8ad32788fcae58379fc9fda3913ebfff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeaea3dee0d6b1a7c8d413bec50cadea" id="r_afeaea3dee0d6b1a7c8d413bec50cadea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1properties_1_1connected__components.html">connected_components</a>&lt; <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afeaea3dee0d6b1a7c8d413bec50cadea">connected_components_compute</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;g) noexcept</td></tr>
<tr class="memdesc:afeaea3dee0d6b1a7c8d413bec50cadea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the connected components of a directed graph.  <br /></td></tr>
<tr class="separator:afeaea3dee0d6b1a7c8d413bec50cadea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a654ff6deae467b9103c8d6b9235b088a" id="r_a654ff6deae467b9103c8d6b9235b088a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a654ff6deae467b9103c8d6b9235b088a">exp_sum_edge_lengths_rational</a> (const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;g) noexcept</td></tr>
<tr class="memdesc:a654ff6deae467b9103c8d6b9235b088a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expected sum of edge lengths of an undirected graph in unconstrained arrangments, \(\mathbb{E}[D]\).  <br /></td></tr>
<tr class="separator:a654ff6deae467b9103c8d6b9235b088a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80c20fa410c8b9b216afe7f5241209a6" id="r_a80c20fa410c8b9b216afe7f5241209a6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a80c20fa410c8b9b216afe7f5241209a6">exp_sum_edge_lengths</a> (const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;g) noexcept</td></tr>
<tr class="memdesc:a80c20fa410c8b9b216afe7f5241209a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expected sum of edge lengths of an undirected graph in unconstrained arrangments, \(\mathbb{E}[D]\).  <br /></td></tr>
<tr class="separator:a80c20fa410c8b9b216afe7f5241209a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f34ca26ddc18aa06be109d7a25b0821" id="r_a7f34ca26ddc18aa06be109d7a25b0821"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f34ca26ddc18aa06be109d7a25b0821">exp_sum_edge_lengths_rational</a> (const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:a7f34ca26ddc18aa06be109d7a25b0821"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expected sum of edge lengths of a free tree in unconstrained arrangments, \(\mathbb{E}[D]\).  <br /></td></tr>
<tr class="separator:a7f34ca26ddc18aa06be109d7a25b0821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbd8a4120ef6f3ef2d7813442f41a223" id="r_afbd8a4120ef6f3ef2d7813442f41a223"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afbd8a4120ef6f3ef2d7813442f41a223">exp_sum_edge_lengths</a> (const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:afbd8a4120ef6f3ef2d7813442f41a223"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expected sum of edge lengths of a free tree in unconstrained arrangments, \(\mathbb{E}[D]\).  <br /></td></tr>
<tr class="separator:afbd8a4120ef6f3ef2d7813442f41a223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42339b47863289d19a1b103dfda103f1" id="r_a42339b47863289d19a1b103dfda103f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42339b47863289d19a1b103dfda103f1">exp_sum_edge_lengths_rational</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:a42339b47863289d19a1b103dfda103f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expected sum of edge lengths of a rooted tree in unconstrained arrangments, \(\mathbb{E}[D]\).  <br /></td></tr>
<tr class="separator:a42339b47863289d19a1b103dfda103f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e68f49e9379b09814741599d58b91c1" id="r_a9e68f49e9379b09814741599d58b91c1"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9e68f49e9379b09814741599d58b91c1">exp_sum_edge_lengths</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:a9e68f49e9379b09814741599d58b91c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expected sum of edge lengths of a rooted tree in unconstrained arrangments, \(\mathbb{E}[D]\).  <br /></td></tr>
<tr class="separator:a9e68f49e9379b09814741599d58b91c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d4a1bef8645e5a1dda9c69224dd9555" id="r_a0d4a1bef8645e5a1dda9c69224dd9555"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0d4a1bef8645e5a1dda9c69224dd9555">exp_sum_edge_lengths_bipartite_rational</a> (const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;g) noexcept</td></tr>
<tr class="memdesc:a0d4a1bef8645e5a1dda9c69224dd9555"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expected sum of edge lengths of a bipartite graph in bipartite arrangments, \(\mathbb{E}_{\mathrm{bip}}[D]\).  <br /></td></tr>
<tr class="separator:a0d4a1bef8645e5a1dda9c69224dd9555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada47cac794ac356fffa07e54ac0c58cb" id="r_ada47cac794ac356fffa07e54ac0c58cb"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada47cac794ac356fffa07e54ac0c58cb">exp_sum_edge_lengths_bipartite</a> (const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;g) noexcept</td></tr>
<tr class="memdesc:ada47cac794ac356fffa07e54ac0c58cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expected sum of edge lengths of a bipartite graph in bipartite arrangments, \(\mathbb{E}_{\mathrm{bip}}[D]\).  <br /></td></tr>
<tr class="separator:ada47cac794ac356fffa07e54ac0c58cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3c1189ccc59dea31e83c862b0615d08" id="r_ab3c1189ccc59dea31e83c862b0615d08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3c1189ccc59dea31e83c862b0615d08">exp_sum_edge_lengths_projective_rational</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;rt) noexcept</td></tr>
<tr class="memdesc:ab3c1189ccc59dea31e83c862b0615d08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expected sum of edge lengths of a tree constrained to projective arrangments, \(\mathbb{E}_{\mathrm{pr}}[D]\).  <br /></td></tr>
<tr class="separator:ab3c1189ccc59dea31e83c862b0615d08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af19d68977283afd82cae661106bbb0f8" id="r_af19d68977283afd82cae661106bbb0f8"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af19d68977283afd82cae661106bbb0f8">exp_sum_edge_lengths_projective</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;rt) noexcept</td></tr>
<tr class="memdesc:af19d68977283afd82cae661106bbb0f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expected sum of edge lengths of a tree constrained to projective arrangments, \(\mathbb{E}_{\mathrm{pr}}[D]\).  <br /></td></tr>
<tr class="separator:af19d68977283afd82cae661106bbb0f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff56efacd50b8e4db045db0e3c48cf03" id="r_aff56efacd50b8e4db045db0e3c48cf03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff56efacd50b8e4db045db0e3c48cf03">exp_sum_edge_lengths_planar_rational</a> (const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:aff56efacd50b8e4db045db0e3c48cf03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expected sum of edge lengths of a tree constrained to planar arrangments, \(\mathbb{E}_{\mathrm{pl}}[D]\).  <br /></td></tr>
<tr class="separator:aff56efacd50b8e4db045db0e3c48cf03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b01b0e3579b43e886f1b0d675bc0227" id="r_a4b01b0e3579b43e886f1b0d675bc0227"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b01b0e3579b43e886f1b0d675bc0227">exp_sum_edge_lengths_planar_rational</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;rt) noexcept</td></tr>
<tr class="memdesc:a4b01b0e3579b43e886f1b0d675bc0227"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expected sum of edge lengths of a tree constrained to planar arrangments, \(\mathbb{E}_{\mathrm{pl}}[D]\).  <br /></td></tr>
<tr class="separator:a4b01b0e3579b43e886f1b0d675bc0227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac053f8c3c640e10636970e6800b6e661" id="r_ac053f8c3c640e10636970e6800b6e661"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac053f8c3c640e10636970e6800b6e661">exp_sum_edge_lengths_planar</a> (const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:ac053f8c3c640e10636970e6800b6e661"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expected sum of edge lengths of a tree constrained to planar arrangments, \(\mathbb{E}_{\mathrm{pl}}[D]\).  <br /></td></tr>
<tr class="separator:ac053f8c3c640e10636970e6800b6e661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a83b194e6a3d0e977b45778ddf0030e" id="r_a8a83b194e6a3d0e977b45778ddf0030e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8a83b194e6a3d0e977b45778ddf0030e">exp_sum_edge_lengths_planar</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;rt) noexcept</td></tr>
<tr class="memdesc:a8a83b194e6a3d0e977b45778ddf0030e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expected sum of edge lengths of a tree constrained to planar arrangments, \(\mathbb{E}_{\mathrm{pl}}[D]\).  <br /></td></tr>
<tr class="separator:a8a83b194e6a3d0e977b45778ddf0030e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3826e458a5c14aa82c2d5f0679530e7e" id="r_a3826e458a5c14aa82c2d5f0679530e7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3826e458a5c14aa82c2d5f0679530e7e">var_sum_edge_lengths_rational</a> (const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;g) noexcept</td></tr>
<tr class="memdesc:a3826e458a5c14aa82c2d5f0679530e7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the variance of the sum of the length of edges of a graph, \(\mathbb{V}[D]\).  <br /></td></tr>
<tr class="separator:a3826e458a5c14aa82c2d5f0679530e7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade6a3f20263e2a982cfc5dc59facaf40" id="r_ade6a3f20263e2a982cfc5dc59facaf40"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade6a3f20263e2a982cfc5dc59facaf40">var_sum_edge_lengths</a> (const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;g) noexcept</td></tr>
<tr class="memdesc:ade6a3f20263e2a982cfc5dc59facaf40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the variance of the sum of the length of edges of a graph, \(\mathbb{V}[D]\).  <br /></td></tr>
<tr class="separator:ade6a3f20263e2a982cfc5dc59facaf40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bdd8c7fb6995c5b519d477af45fca7b" id="r_a1bdd8c7fb6995c5b519d477af45fca7b"><td class="memTemplParams" colspan="2">template&lt;class graph_t , class return_type &gt; </td></tr>
<tr class="memitem:a1bdd8c7fb6995c5b519d477af45fca7b"><td class="memTemplItemLeft" align="right" valign="top">return_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1bdd8c7fb6995c5b519d477af45fca7b">sum_powers_degrees</a> (const graph_t &amp;g, const uint64_t p, uint64_t(graph_t::*degree_function)(<a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a>) const noexcept) noexcept</td></tr>
<tr class="memdesc:a1bdd8c7fb6995c5b519d477af45fca7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic template function for the sum of degrees.  <br /></td></tr>
<tr class="separator:a1bdd8c7fb6995c5b519d477af45fca7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab219655c784e1537677e0b6ec6d51b1f" id="r_ab219655c784e1537677e0b6ec6d51b1f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1numeric_1_1integer.html">numeric::integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab219655c784e1537677e0b6ec6d51b1f">sum_powers_degrees_integer</a> (const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;g, const uint64_t p) noexcept</td></tr>
<tr class="memdesc:ab219655c784e1537677e0b6ec6d51b1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sum of degrees raised to the \(p\)-th power.  <br /></td></tr>
<tr class="separator:ab219655c784e1537677e0b6ec6d51b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb1126afe99609fb9f5565b65dd32a88" id="r_abb1126afe99609fb9f5565b65dd32a88"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb1126afe99609fb9f5565b65dd32a88">sum_powers_degrees</a> (const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;g, const uint64_t p) noexcept</td></tr>
<tr class="memdesc:abb1126afe99609fb9f5565b65dd32a88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sum of degrees raised to the \(p\)-th power.  <br /></td></tr>
<tr class="separator:abb1126afe99609fb9f5565b65dd32a88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0979fcc3a285cab4228fbac54cc266d" id="r_ad0979fcc3a285cab4228fbac54cc266d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1numeric_1_1integer.html">numeric::integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad0979fcc3a285cab4228fbac54cc266d">sum_powers_degrees_integer</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;g, const uint64_t p) noexcept</td></tr>
<tr class="memdesc:ad0979fcc3a285cab4228fbac54cc266d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sum of degrees raised to the \(p\)-th power.  <br /></td></tr>
<tr class="separator:ad0979fcc3a285cab4228fbac54cc266d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab30fba5a78c5dab2da0bf3fc67e25db2" id="r_ab30fba5a78c5dab2da0bf3fc67e25db2"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab30fba5a78c5dab2da0bf3fc67e25db2">sum_powers_degrees</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;g, const uint64_t p) noexcept</td></tr>
<tr class="memdesc:ab30fba5a78c5dab2da0bf3fc67e25db2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sum of degrees raised to the \(p\)-th power.  <br /></td></tr>
<tr class="separator:ab30fba5a78c5dab2da0bf3fc67e25db2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfd173768090fa6ab1b06bfd86875dbd" id="r_adfd173768090fa6ab1b06bfd86875dbd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1numeric_1_1integer.html">numeric::integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adfd173768090fa6ab1b06bfd86875dbd">sum_powers_in_degrees_integer</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;g, const uint64_t p) noexcept</td></tr>
<tr class="memdesc:adfd173768090fa6ab1b06bfd86875dbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sum of in-degrees raised to the \(p\)-th power.  <br /></td></tr>
<tr class="separator:adfd173768090fa6ab1b06bfd86875dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae53cd84193757ec7d8c9acf8186eb7cb" id="r_ae53cd84193757ec7d8c9acf8186eb7cb"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae53cd84193757ec7d8c9acf8186eb7cb">sum_powers_in_degrees</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;g, const uint64_t p) noexcept</td></tr>
<tr class="memdesc:ae53cd84193757ec7d8c9acf8186eb7cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sum of in-degrees raised to the \(p\)-th power.  <br /></td></tr>
<tr class="separator:ae53cd84193757ec7d8c9acf8186eb7cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9645c192bfd54213d3a3a51381d518e4" id="r_a9645c192bfd54213d3a3a51381d518e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1numeric_1_1integer.html">numeric::integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9645c192bfd54213d3a3a51381d518e4">sum_powers_in_degrees_integer</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;t, const uint64_t p) noexcept</td></tr>
<tr class="memdesc:a9645c192bfd54213d3a3a51381d518e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sum of in-degrees raised to the \(p\)-th power.  <br /></td></tr>
<tr class="separator:a9645c192bfd54213d3a3a51381d518e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49181ee2f17212bf26efd435526c0815" id="r_a49181ee2f17212bf26efd435526c0815"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a49181ee2f17212bf26efd435526c0815">sum_powers_in_degrees</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;t, const uint64_t p) noexcept</td></tr>
<tr class="memdesc:a49181ee2f17212bf26efd435526c0815"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sum of in-degrees raised to the \(p\)-th power.  <br /></td></tr>
<tr class="separator:a49181ee2f17212bf26efd435526c0815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c393af1ac9ab3d02440428ff11585f3" id="r_a5c393af1ac9ab3d02440428ff11585f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1numeric_1_1integer.html">numeric::integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c393af1ac9ab3d02440428ff11585f3">sum_powers_out_degrees_integer</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;g, const uint64_t p) noexcept</td></tr>
<tr class="memdesc:a5c393af1ac9ab3d02440428ff11585f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sum of out-degrees raised to the \(p\)-th power.  <br /></td></tr>
<tr class="separator:a5c393af1ac9ab3d02440428ff11585f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98dfd6732945f3db02be807a6d286290" id="r_a98dfd6732945f3db02be807a6d286290"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a98dfd6732945f3db02be807a6d286290">sum_powers_out_degrees</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;g, const uint64_t p) noexcept</td></tr>
<tr class="memdesc:a98dfd6732945f3db02be807a6d286290"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sum of out-degrees raised to the \(p\)-th power.  <br /></td></tr>
<tr class="separator:a98dfd6732945f3db02be807a6d286290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a317c023347f5c68745d207d1fba0a3f3" id="r_a317c023347f5c68745d207d1fba0a3f3"><td class="memTemplParams" colspan="2">template&lt;class graph_t , class return_type &gt; </td></tr>
<tr class="memitem:a317c023347f5c68745d207d1fba0a3f3"><td class="memTemplItemLeft" align="right" valign="top">return_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a317c023347f5c68745d207d1fba0a3f3">moment_degree</a> (const graph_t &amp;g, const uint64_t p, uint64_t(graph_t::*degree_function)(<a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a>) const noexcept) noexcept</td></tr>
<tr class="memdesc:a317c023347f5c68745d207d1fba0a3f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic template function for the moment of degree about 0.  <br /></td></tr>
<tr class="separator:a317c023347f5c68745d207d1fba0a3f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a093509b229fae64111c3144665773ea4" id="r_a093509b229fae64111c3144665773ea4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a093509b229fae64111c3144665773ea4">moment_degree_rational</a> (const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;g, const uint64_t p) noexcept</td></tr>
<tr class="memdesc:a093509b229fae64111c3144665773ea4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the \(p\)-th moment of degree about zero of a graph as an exact rational value.  <br /></td></tr>
<tr class="separator:a093509b229fae64111c3144665773ea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0c60f8f535c5ec9749f76d6c4f50792" id="r_ae0c60f8f535c5ec9749f76d6c4f50792"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae0c60f8f535c5ec9749f76d6c4f50792">moment_degree</a> (const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;g, const uint64_t p) noexcept</td></tr>
<tr class="memdesc:ae0c60f8f535c5ec9749f76d6c4f50792"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the \(p\)-th moment of degree about zero of a directed graph as a floating point value.  <br /></td></tr>
<tr class="separator:ae0c60f8f535c5ec9749f76d6c4f50792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab291c021d50c14df2be5beb384521006" id="r_ab291c021d50c14df2be5beb384521006"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab291c021d50c14df2be5beb384521006">moment_degree_rational</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;g, const uint64_t p) noexcept</td></tr>
<tr class="memdesc:ab291c021d50c14df2be5beb384521006"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the \(p\)-th moment of degree about zero of a directed graph as an exact rational value.  <br /></td></tr>
<tr class="separator:ab291c021d50c14df2be5beb384521006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28a5dd4f44b02d1b6ffdf717149a8f88" id="r_a28a5dd4f44b02d1b6ffdf717149a8f88"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a28a5dd4f44b02d1b6ffdf717149a8f88">moment_degree</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;g, const uint64_t p) noexcept</td></tr>
<tr class="memdesc:a28a5dd4f44b02d1b6ffdf717149a8f88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the \(p\)-th moment of degree about zero of a directed graph as a floating point value.  <br /></td></tr>
<tr class="separator:a28a5dd4f44b02d1b6ffdf717149a8f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7f3ff91179f596873097cdc288025f3" id="r_ae7f3ff91179f596873097cdc288025f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae7f3ff91179f596873097cdc288025f3">moment_in_degree_rational</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;g, const uint64_t p) noexcept</td></tr>
<tr class="memdesc:ae7f3ff91179f596873097cdc288025f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the \(p\)-th moment of in-degree about zero of a directed graph as an exact rational value.  <br /></td></tr>
<tr class="separator:ae7f3ff91179f596873097cdc288025f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef514f5efa0917d7d5e796dd6155586a" id="r_aef514f5efa0917d7d5e796dd6155586a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aef514f5efa0917d7d5e796dd6155586a">moment_in_degree</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;g, const uint64_t p) noexcept</td></tr>
<tr class="memdesc:aef514f5efa0917d7d5e796dd6155586a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the \(p\)-th moment of in-degree about zero of a directed graph as a floating point value.  <br /></td></tr>
<tr class="separator:aef514f5efa0917d7d5e796dd6155586a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad386d7dd295a3874997499c533c08e2e" id="r_ad386d7dd295a3874997499c533c08e2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad386d7dd295a3874997499c533c08e2e">moment_in_degree_rational</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;t, const uint64_t p) noexcept</td></tr>
<tr class="memdesc:ad386d7dd295a3874997499c533c08e2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the \(p\)-th moment of in-degree about zero of a rooted tree as an exact rational value.  <br /></td></tr>
<tr class="separator:ad386d7dd295a3874997499c533c08e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08453cba2f3f911ce3354703e01490f9" id="r_a08453cba2f3f911ce3354703e01490f9"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a08453cba2f3f911ce3354703e01490f9">moment_in_degree</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;t, const uint64_t p) noexcept</td></tr>
<tr class="memdesc:a08453cba2f3f911ce3354703e01490f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the \(p\)-th moment of in-degree about zero of a directed graph as a floating point value.  <br /></td></tr>
<tr class="separator:a08453cba2f3f911ce3354703e01490f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9d3ce43ec6e32ce27e139cb655871db" id="r_ae9d3ce43ec6e32ce27e139cb655871db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9d3ce43ec6e32ce27e139cb655871db">moment_out_degree_rational</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;g, const uint64_t p) noexcept</td></tr>
<tr class="memdesc:ae9d3ce43ec6e32ce27e139cb655871db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the \(p\)-th moment of out-degree about zero of a directed graph as an exact rational value.  <br /></td></tr>
<tr class="separator:ae9d3ce43ec6e32ce27e139cb655871db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90be129d2973fa452b75a5ac86872fc1" id="r_a90be129d2973fa452b75a5ac86872fc1"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a90be129d2973fa452b75a5ac86872fc1">moment_out_degree</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;g, const uint64_t p) noexcept</td></tr>
<tr class="memdesc:a90be129d2973fa452b75a5ac86872fc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the \(p\)-th moment of out-degree about zero of a directed graph as a floating point value.  <br /></td></tr>
<tr class="separator:a90be129d2973fa452b75a5ac86872fc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23f61ed2204c24dce8049666357b65d5" id="r_a23f61ed2204c24dce8049666357b65d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a23f61ed2204c24dce8049666357b65d5">hubiness_rational</a> (const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:a23f61ed2204c24dce8049666357b65d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hubiness coefficient as an exact rational number.  <br /></td></tr>
<tr class="separator:a23f61ed2204c24dce8049666357b65d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1750ada3673e7deba32658dc3da2cf0c" id="r_a1750ada3673e7deba32658dc3da2cf0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1750ada3673e7deba32658dc3da2cf0c">hubiness_rational</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:a1750ada3673e7deba32658dc3da2cf0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hubiness coefficient as an exact rational number.  <br /></td></tr>
<tr class="separator:a1750ada3673e7deba32658dc3da2cf0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab052d596b426bfa68ca44f046e44e76d" id="r_ab052d596b426bfa68ca44f046e44e76d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab052d596b426bfa68ca44f046e44e76d">hubiness</a> (const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:ab052d596b426bfa68ca44f046e44e76d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hubiness coefficient as a floating point value.  <br /></td></tr>
<tr class="separator:ab052d596b426bfa68ca44f046e44e76d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af13cc3093569223cde0ae3f329f86ded" id="r_af13cc3093569223cde0ae3f329f86ded"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af13cc3093569223cde0ae3f329f86ded">hubiness</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:af13cc3093569223cde0ae3f329f86ded"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hubiness coefficient as a floating point value.  <br /></td></tr>
<tr class="separator:af13cc3093569223cde0ae3f329f86ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba97ff50d077ea9a8ddbf86a0aa33453" id="r_aba97ff50d077ea9a8ddbf86a0aa33453"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba97ff50d077ea9a8ddbf86a0aa33453">sum_hierarchical_distances</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:aba97ff50d077ea9a8ddbf86a0aa33453"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum of hierarchical distances (SHD).  <br /></td></tr>
<tr class="separator:aba97ff50d077ea9a8ddbf86a0aa33453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eca870365ac786867aeacf3609457a9" id="r_a5eca870365ac786867aeacf3609457a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5eca870365ac786867aeacf3609457a9">mean_hierarchical_distance_rational</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:a5eca870365ac786867aeacf3609457a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mean Hierarchical Distance (MHD).  <br /></td></tr>
<tr class="separator:a5eca870365ac786867aeacf3609457a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c70ec4072e1df27592aa7a51876c1a9" id="r_a0c70ec4072e1df27592aa7a51876c1a9"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c70ec4072e1df27592aa7a51876c1a9">mean_hierarchical_distance</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:a0c70ec4072e1df27592aa7a51876c1a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mean Hierarchical Distance (MHD).  <br /></td></tr>
<tr class="separator:a0c70ec4072e1df27592aa7a51876c1a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa25aeecc00b06f4bbc0840b0b82a09e1" id="r_aa25aeecc00b06f4bbc0840b0b82a09e1"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa25aeecc00b06f4bbc0840b0b82a09e1">tree_caterpillar_distance</a> (const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:aa25aeecc00b06f4bbc0840b0b82a09e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Caterpillar distance of a tree.  <br /></td></tr>
<tr class="separator:aa25aeecc00b06f4bbc0840b0b82a09e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b0f0a6bd4d70e33ffec833c215ca755" id="r_a9b0f0a6bd4d70e33ffec833c215ca755"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b0f0a6bd4d70e33ffec833c215ca755">tree_caterpillar_distance</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:a9b0f0a6bd4d70e33ffec833c215ca755"><td class="mdescLeft">&#160;</td><td class="mdescRight">Caterpillar distance of a tree.  <br /></td></tr>
<tr class="separator:a9b0f0a6bd4d70e33ffec833c215ca755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fa7c3d6aee99da7e532a943bdbc2a9e" id="r_a6fa7c3d6aee99da7e532a943bdbc2a9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1numeric_1_1integer.html">numeric::integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6fa7c3d6aee99da7e532a943bdbc2a9e">num_pairs_independent_edges_integer</a> (const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;g) noexcept</td></tr>
<tr class="memdesc:a6fa7c3d6aee99da7e532a943bdbc2a9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the size of \(Q(G)\).  <br /></td></tr>
<tr class="separator:a6fa7c3d6aee99da7e532a943bdbc2a9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a492c71d8503b4681ca40d3b526b0f0" id="r_a0a492c71d8503b4681ca40d3b526b0f0"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0a492c71d8503b4681ca40d3b526b0f0">num_pairs_independent_edges</a> (const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;g) noexcept</td></tr>
<tr class="memdesc:a0a492c71d8503b4681ca40d3b526b0f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the size of \(Q(G)\).  <br /></td></tr>
<tr class="separator:a0a492c71d8503b4681ca40d3b526b0f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa086ffd70ff3d2f2ab2e89108b8544a3" id="r_aa086ffd70ff3d2f2ab2e89108b8544a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1numeric_1_1integer.html">numeric::integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa086ffd70ff3d2f2ab2e89108b8544a3">num_pairs_independent_edges_integer</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;g) noexcept</td></tr>
<tr class="memdesc:aa086ffd70ff3d2f2ab2e89108b8544a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the size of \(Q(G)\).  <br /></td></tr>
<tr class="separator:aa086ffd70ff3d2f2ab2e89108b8544a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d1a9bd03760411d1436925d7c095216" id="r_a0d1a9bd03760411d1436925d7c095216"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0d1a9bd03760411d1436925d7c095216">num_pairs_independent_edges</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;g) noexcept</td></tr>
<tr class="memdesc:a0d1a9bd03760411d1436925d7c095216"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the size of \(Q(G)\).  <br /></td></tr>
<tr class="separator:a0d1a9bd03760411d1436925d7c095216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada5517f223bcb1369b625a840dc9c8fa" id="r_ada5517f223bcb1369b625a840dc9c8fa"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a>, <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada5517f223bcb1369b625a840dc9c8fa">tree_centre</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:ada5517f223bcb1369b625a840dc9c8fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the centre of a rooted tree.  <br /></td></tr>
<tr class="separator:ada5517f223bcb1369b625a840dc9c8fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab05c2a8ee4c9e544358b1db18a7b1c13" id="r_ab05c2a8ee4c9e544358b1db18a7b1c13"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a>, <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab05c2a8ee4c9e544358b1db18a7b1c13">tree_centre</a> (const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:ab05c2a8ee4c9e544358b1db18a7b1c13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the centre of a free tree.  <br /></td></tr>
<tr class="separator:ab05c2a8ee4c9e544358b1db18a7b1c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adda281d4c9e024ea87844756ffbd945e" id="r_adda281d4c9e024ea87844756ffbd945e"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a>, <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adda281d4c9e024ea87844756ffbd945e">tree_centroid</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:adda281d4c9e024ea87844756ffbd945e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the centroid of a rooted tree.  <br /></td></tr>
<tr class="separator:adda281d4c9e024ea87844756ffbd945e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a809427c54bf089fa2596e47b23538a5a" id="r_a809427c54bf089fa2596e47b23538a5a"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a>, <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a809427c54bf089fa2596e47b23538a5a">tree_centroid</a> (const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:a809427c54bf089fa2596e47b23538a5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the centroid of a free tree.  <br /></td></tr>
<tr class="separator:a809427c54bf089fa2596e47b23538a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b40731d0c6eb1115f4ca7c655841078" id="r_a3b40731d0c6eb1115f4ca7c655841078"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b40731d0c6eb1115f4ca7c655841078">tree_diameter</a> (const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:a3b40731d0c6eb1115f4ca7c655841078"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the diameter of a free tree.  <br /></td></tr>
<tr class="separator:a3b40731d0c6eb1115f4ca7c655841078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa51ed4f552db20a0000f85a86326efd8" id="r_aa51ed4f552db20a0000f85a86326efd8"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa51ed4f552db20a0000f85a86326efd8">tree_diameter</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:aa51ed4f552db20a0000f85a86326efd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the diameter of a free tree.  <br /></td></tr>
<tr class="separator:aa51ed4f552db20a0000f85a86326efd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aead22cd81b7f901d34a7ada4fa356cb5" id="r_aead22cd81b7f901d34a7ada4fa356cb5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aead22cd81b7f901d34a7ada4fa356cb5">vertex_orbits_compute</a> (const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:aead22cd81b7f901d34a7ada4fa356cb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the set of vertex orbits of a tree.  <br /></td></tr>
<tr class="separator:aead22cd81b7f901d34a7ada4fa356cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Namespace for all linear-arrangement-independent algorithms. </p>
<p>This namespace contains functions to calculate properties of graphs that do not depend, whether implicitly or explicitly, on a linear arrangement. To read more about the concept of linear arrangement see the <a class="el" href="LAL_concepts.html#LAL_concepts__linear_arrangement">Linear Arrangement</a> page. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a9e00464be532ce6f496b5e70a9fa2082" name="a9e00464be532ce6f496b5e70a9fa2082"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e00464be532ce6f496b5e70a9fa2082">&#9670;&#160;</a></span>bipartite_coloring() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1properties_1_1bipartite__graph__coloring.html">bipartite_graph_coloring</a> lal::properties::bipartite_coloring </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the coloring of a bipartite graph. </p>
<p>This function converts the input directed graph into an undirected graph (see <a class="el" href="classlal_1_1graphs_1_1directed__graph.html#ad7bfd2d96d5110a7bf0d56c4df1618fd">lal::graphs::directed_graph::to_undirected()</a>). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input directed graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An object of type <a class="el" href="classlal_1_1properties_1_1bipartite__graph__coloring.html">lal::properties::bipartite_graph_coloring</a>. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The underlying undirected graph must be bipartite. </dd></dl>

</div>
</div>
<a id="ad53eefcef533555560adccb4226ab376" name="ad53eefcef533555560adccb4226ab376"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad53eefcef533555560adccb4226ab376">&#9670;&#160;</a></span>bipartite_coloring() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1properties_1_1bipartite__graph__coloring.html">bipartite_graph_coloring</a> lal::properties::bipartite_coloring </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the coloring of a bipartite graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input undirected graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An object of type <a class="el" href="classlal_1_1properties_1_1bipartite__graph__coloring.html">lal::properties::bipartite_graph_coloring</a>. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The graph must be bipartite. </dd></dl>

</div>
</div>
<a id="ac468e7956d7ef0d9ae2cb277cc5da951" name="ac468e7956d7ef0d9ae2cb277cc5da951"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac468e7956d7ef0d9ae2cb277cc5da951">&#9670;&#160;</a></span>branchless_paths_compute() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classlal_1_1properties_1_1branchless__path.html">branchless_path</a> &gt; lal::properties::branchless_paths_compute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds all branchless paths in a tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The list of branchless paths. </dd></dl>

</div>
</div>
<a id="a081d46a9bdccaef038b1b89f9b9fc9a9" name="a081d46a9bdccaef038b1b89f9b9fc9a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a081d46a9bdccaef038b1b89f9b9fc9a9">&#9670;&#160;</a></span>branchless_paths_compute() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classlal_1_1properties_1_1branchless__path.html">branchless_path</a> &gt; lal::properties::branchless_paths_compute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds all branchless paths in a tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The list of branchless paths. </dd></dl>

</div>
</div>
<a id="afeaea3dee0d6b1a7c8d413bec50cadea" name="afeaea3dee0d6b1a7c8d413bec50cadea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeaea3dee0d6b1a7c8d413bec50cadea">&#9670;&#160;</a></span>connected_components_compute() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1properties_1_1connected__components.html">connected_components</a>&lt; <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &gt; lal::properties::connected_components_compute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the connected components of a directed graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input directed graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An object containing all connected components. </dd></dl>

</div>
</div>
<a id="a8ad32788fcae58379fc9fda3913ebfff" name="a8ad32788fcae58379fc9fda3913ebfff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ad32788fcae58379fc9fda3913ebfff">&#9670;&#160;</a></span>connected_components_compute() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1properties_1_1connected__components.html">connected_components</a>&lt; <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &gt; lal::properties::connected_components_compute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the connected components of an undirected graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input undirected graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An object containing all connected components. </dd></dl>

</div>
</div>
<a id="ab8ff16428584d88aba05a4b677444a4b" name="ab8ff16428584d88aba05a4b677444a4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8ff16428584d88aba05a4b677444a4b">&#9670;&#160;</a></span>exp_num_crossings()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double lal::properties::exp_num_crossings </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the the expected number of crossings in unconstrained arrangements, \(\mathbb{E}[C]\). </p>
<p>See <a class="el" href="#a18d37074e9152261d8b51822becda3d8">lal::properties::exp_num_crossings_rational</a> for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>The input graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The expected value of the number of crossings as a floating point value. </dd></dl>

</div>
</div>
<a id="a18d37074e9152261d8b51822becda3d8" name="a18d37074e9152261d8b51822becda3d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18d37074e9152261d8b51822becda3d8">&#9670;&#160;</a></span>exp_num_crossings_rational()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a> lal::properties::exp_num_crossings_rational </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the the expected number of crossings in unconstrained arrangements, \(\mathbb{E}[C]\). </p>
<p>Returns \(\mathbb{E}[C]\) as a rational value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>The input graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The expected value of the number of crossings as a rational value. </dd></dl>

</div>
</div>
<a id="afbd8a4120ef6f3ef2d7813442f41a223" name="afbd8a4120ef6f3ef2d7813442f41a223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbd8a4120ef6f3ef2d7813442f41a223">&#9670;&#160;</a></span>exp_sum_edge_lengths() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double lal::properties::exp_sum_edge_lengths </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Expected sum of edge lengths of a free tree in unconstrained arrangments, \(\mathbb{E}[D]\). </p>
<p>See <a class="el" href="#a654ff6deae467b9103c8d6b9235b088a">lal::properties::exp_sum_edge_lengths_rational</a> for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The input free tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The expected value of the sum of edge lengths as a floating point value. </dd></dl>

</div>
</div>
<a id="a9e68f49e9379b09814741599d58b91c1" name="a9e68f49e9379b09814741599d58b91c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e68f49e9379b09814741599d58b91c1">&#9670;&#160;</a></span>exp_sum_edge_lengths() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double lal::properties::exp_sum_edge_lengths </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Expected sum of edge lengths of a rooted tree in unconstrained arrangments, \(\mathbb{E}[D]\). </p>
<p>See <a class="el" href="#a654ff6deae467b9103c8d6b9235b088a">lal::properties::exp_sum_edge_lengths_rational</a> for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The input rooted tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The expected value of the sum of edge lengths as a floating point value. </dd></dl>

</div>
</div>
<a id="a80c20fa410c8b9b216afe7f5241209a6" name="a80c20fa410c8b9b216afe7f5241209a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80c20fa410c8b9b216afe7f5241209a6">&#9670;&#160;</a></span>exp_sum_edge_lengths() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double lal::properties::exp_sum_edge_lengths </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Expected sum of edge lengths of an undirected graph in unconstrained arrangments, \(\mathbb{E}[D]\). </p>
<p>See <a class="el" href="#a654ff6deae467b9103c8d6b9235b088a">lal::properties::exp_sum_edge_lengths_rational</a> for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>The input graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The expected value of the sum of edge lengths as a floating point value. </dd></dl>

</div>
</div>
<a id="ada47cac794ac356fffa07e54ac0c58cb" name="ada47cac794ac356fffa07e54ac0c58cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada47cac794ac356fffa07e54ac0c58cb">&#9670;&#160;</a></span>exp_sum_edge_lengths_bipartite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double lal::properties::exp_sum_edge_lengths_bipartite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Expected sum of edge lengths of a bipartite graph in bipartite arrangments, \(\mathbb{E}_{\mathrm{bip}}[D]\). </p>
<p>See <a class="el" href="LAL_concepts.html#LAL_concepts__linear_arrangement__types">Types of arrangements</a> for the definition of bipartite arrangement.</p>
<p>This function uses the formula in <a class="el" href="citelist.html#CITEREF_Alemany2024b">[10]</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>The input bipartite graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The expected value of the sum of edge lengths as a floating point value. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Input graph <em>g</em> is a bipartite arrangement. </dd></dl>

</div>
</div>
<a id="a0d4a1bef8645e5a1dda9c69224dd9555" name="a0d4a1bef8645e5a1dda9c69224dd9555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d4a1bef8645e5a1dda9c69224dd9555">&#9670;&#160;</a></span>exp_sum_edge_lengths_bipartite_rational()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a> lal::properties::exp_sum_edge_lengths_bipartite_rational </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Expected sum of edge lengths of a bipartite graph in bipartite arrangments, \(\mathbb{E}_{\mathrm{bip}}[D]\). </p>
<p>See <a class="el" href="LAL_concepts.html#LAL_concepts__linear_arrangement__types">Types of arrangements</a> for the definition of bipartite arrangement.</p>
<p>This function uses the formula in <a class="el" href="citelist.html#CITEREF_Alemany2024b">[10]</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>The input bipartite graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The expected value of the sum of edge lengths as a rational value. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Input graph <em>g</em> is a bipartite arrangement. </dd></dl>

</div>
</div>
<a id="ac053f8c3c640e10636970e6800b6e661" name="ac053f8c3c640e10636970e6800b6e661"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac053f8c3c640e10636970e6800b6e661">&#9670;&#160;</a></span>exp_sum_edge_lengths_planar() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double lal::properties::exp_sum_edge_lengths_planar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Expected sum of edge lengths of a tree constrained to planar arrangments, \(\mathbb{E}_{\mathrm{pl}}[D]\). </p>
<p>See <a class="el" href="#aff56efacd50b8e4db045db0e3c48cf03">lal::properties::exp_sum_edge_lengths_planar_rational</a> for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The input free tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The expected value of the sum of edge lengths constrained to planar arrangements as a floating point value. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><em>rt</em> must be a valid free tree (see <a class="el" href="classlal_1_1graphs_1_1tree.html#a25c8d57865fa5f7cb5d101fd5d07fe2d">lal::graphs::free_tree::is_tree</a>). </dd></dl>

</div>
</div>
<a id="a8a83b194e6a3d0e977b45778ddf0030e" name="a8a83b194e6a3d0e977b45778ddf0030e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a83b194e6a3d0e977b45778ddf0030e">&#9670;&#160;</a></span>exp_sum_edge_lengths_planar() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double lal::properties::exp_sum_edge_lengths_planar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rt</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Expected sum of edge lengths of a tree constrained to planar arrangments, \(\mathbb{E}_{\mathrm{pl}}[D]\). </p>
<p>See <a class="el" href="#aff56efacd50b8e4db045db0e3c48cf03">lal::properties::exp_sum_edge_lengths_planar_rational</a> for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rt</td><td>The input rooted tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The expected value of the sum of edge lengths constrained to planar arrangements as a floating point value. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><em>rt</em> must be a valid rooted tree (see <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#af464d98b1b5dfdbaaacea553d9c89154">lal::graphs::rooted_tree::is_rooted_tree</a>). </dd></dl>

</div>
</div>
<a id="aff56efacd50b8e4db045db0e3c48cf03" name="aff56efacd50b8e4db045db0e3c48cf03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff56efacd50b8e4db045db0e3c48cf03">&#9670;&#160;</a></span>exp_sum_edge_lengths_planar_rational() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a> lal::properties::exp_sum_edge_lengths_planar_rational </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Expected sum of edge lengths of a tree constrained to planar arrangments, \(\mathbb{E}_{\mathrm{pl}}[D]\). </p>
<p>This function uses the formulae derived in <a class="el" href="citelist.html#CITEREF_Alemany2022c">[4]</a>.</p>
<p>Returns the value \(E_{\mathrm{pl}}[D]\) as a rational value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The input free tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The expected value of the sum of edge lengths constrained to planar arrangements as an exact rational value. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><em>rt</em> must be a valid free tree (see <a class="el" href="classlal_1_1graphs_1_1tree.html#a25c8d57865fa5f7cb5d101fd5d07fe2d">lal::graphs::free_tree::is_tree</a>). </dd></dl>

</div>
</div>
<a id="a4b01b0e3579b43e886f1b0d675bc0227" name="a4b01b0e3579b43e886f1b0d675bc0227"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b01b0e3579b43e886f1b0d675bc0227">&#9670;&#160;</a></span>exp_sum_edge_lengths_planar_rational() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a> lal::properties::exp_sum_edge_lengths_planar_rational </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rt</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Expected sum of edge lengths of a tree constrained to planar arrangments, \(\mathbb{E}_{\mathrm{pl}}[D]\). </p>
<p>Returns the value \(E_{\mathrm{pl}}[D]\) as a rational value.</p>
<p>This function uses the formulae derived in <a class="el" href="citelist.html#CITEREF_Alemany2022c">[4]</a>.</p>
<p>This function transforms the input rooted tree into a free tree. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rt</td><td>The input rooted tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The expected value of the sum of edge lengths constrained to planar arrangements as an exact rational value. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><em>rt</em> must be a valid rooted tree (see <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#af464d98b1b5dfdbaaacea553d9c89154">lal::graphs::rooted_tree::is_rooted_tree</a>). </dd></dl>

</div>
</div>
<a id="af19d68977283afd82cae661106bbb0f8" name="af19d68977283afd82cae661106bbb0f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af19d68977283afd82cae661106bbb0f8">&#9670;&#160;</a></span>exp_sum_edge_lengths_projective()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double lal::properties::exp_sum_edge_lengths_projective </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rt</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Expected sum of edge lengths of a tree constrained to projective arrangments, \(\mathbb{E}_{\mathrm{pr}}[D]\). </p>
<p>See <a class="el" href="#ab3c1189ccc59dea31e83c862b0615d08">lal::properties::exp_sum_edge_lengths_projective_rational</a> for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rt</td><td>The input rooted tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The expected value of the sum of edge lengths constrained to projective arrangements as a floating point value. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><em>rt</em> must be a valid rooted tree (see <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#af464d98b1b5dfdbaaacea553d9c89154">lal::graphs::rooted_tree::is_rooted_tree</a>). </dd></dl>

</div>
</div>
<a id="ab3c1189ccc59dea31e83c862b0615d08" name="ab3c1189ccc59dea31e83c862b0615d08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3c1189ccc59dea31e83c862b0615d08">&#9670;&#160;</a></span>exp_sum_edge_lengths_projective_rational()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a> lal::properties::exp_sum_edge_lengths_projective_rational </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rt</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Expected sum of edge lengths of a tree constrained to projective arrangments, \(\mathbb{E}_{\mathrm{pr}}[D]\). </p>
<p>This function uses the formulae derived in <a class="el" href="citelist.html#CITEREF_Alemany2022b">[5]</a>.</p>
<p>Returns the value \(E_{\mathrm{pr}}[D]\) as a rational value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rt</td><td>The input rooted tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The expected value of the sum of edge lengths constrained to projective arrangements as an exact rational value. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><em>rt</em> must be a valid rooted tree (see <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#af464d98b1b5dfdbaaacea553d9c89154">lal::graphs::rooted_tree::is_rooted_tree</a>). </dd></dl>

</div>
</div>
<a id="a7f34ca26ddc18aa06be109d7a25b0821" name="a7f34ca26ddc18aa06be109d7a25b0821"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f34ca26ddc18aa06be109d7a25b0821">&#9670;&#160;</a></span>exp_sum_edge_lengths_rational() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a> lal::properties::exp_sum_edge_lengths_rational </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Expected sum of edge lengths of a free tree in unconstrained arrangments, \(\mathbb{E}[D]\). </p>
<p>This function uses the formulae derived in <a class="el" href="citelist.html#CITEREF_Ferrer2019a">[23]</a>.</p>
<p>Returns the value \(E[D]\) as a rational value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The input rooted tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The expected value of the sum of edge lengths as a rational value. </dd></dl>

</div>
</div>
<a id="a42339b47863289d19a1b103dfda103f1" name="a42339b47863289d19a1b103dfda103f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42339b47863289d19a1b103dfda103f1">&#9670;&#160;</a></span>exp_sum_edge_lengths_rational() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a> lal::properties::exp_sum_edge_lengths_rational </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Expected sum of edge lengths of a rooted tree in unconstrained arrangments, \(\mathbb{E}[D]\). </p>
<p>This function uses the formulae derived in <a class="el" href="citelist.html#CITEREF_Ferrer2019a">[23]</a>.</p>
<p>Returns the value \(E[D]\) as a rational value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The input rooted tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The expected value of the sum of edge lengths as a rational value. </dd></dl>

</div>
</div>
<a id="a654ff6deae467b9103c8d6b9235b088a" name="a654ff6deae467b9103c8d6b9235b088a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a654ff6deae467b9103c8d6b9235b088a">&#9670;&#160;</a></span>exp_sum_edge_lengths_rational() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a> lal::properties::exp_sum_edge_lengths_rational </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Expected sum of edge lengths of an undirected graph in unconstrained arrangments, \(\mathbb{E}[D]\). </p>
<p>This function uses the formulae derived in <a class="el" href="citelist.html#CITEREF_Ferrer2004a">[21]</a>, <a class="el" href="citelist.html#CITEREF_Ferrer2019a">[23]</a>.</p>
<p>Returns the value \(E[D]\) as a rational value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>The input graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The expected value of the sum of edge lengths as a rational value. </dd></dl>

</div>
</div>
<a id="ab052d596b426bfa68ca44f046e44e76d" name="ab052d596b426bfa68ca44f046e44e76d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab052d596b426bfa68ca44f046e44e76d">&#9670;&#160;</a></span>hubiness() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double lal::properties::hubiness </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the hubiness coefficient as a floating point value. </p>
<p>See <a class="el" href="#a23f61ed2204c24dce8049666357b65d5">lal::properties::hubiness_rational</a> for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input free tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hubiness coefficient as a floating point value. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The tree <em>t</em> is a valid tree. Method <a class="el" href="classlal_1_1graphs_1_1tree.html#a25c8d57865fa5f7cb5d101fd5d07fe2d" title="Is this graph an actual tree?">graphs::free_tree::is_tree</a> returns true. </dd>
<dd>
\(n &gt; 3\). </dd></dl>

</div>
</div>
<a id="af13cc3093569223cde0ae3f329f86ded" name="af13cc3093569223cde0ae3f329f86ded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af13cc3093569223cde0ae3f329f86ded">&#9670;&#160;</a></span>hubiness() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double lal::properties::hubiness </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the hubiness coefficient as a floating point value. </p>
<p>See <a class="el" href="#a23f61ed2204c24dce8049666357b65d5">lal::properties::hubiness_rational</a> for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input rooted tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hubiness coefficient as a floating point value. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The tree <em>t</em> is a valid rooted tree. Method <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#af464d98b1b5dfdbaaacea553d9c89154" title="Is this tree a valid rooted tree?">graphs::rooted_tree::is_rooted_tree</a> returns true. </dd>
<dd>
\(n &gt; 3\). </dd></dl>

</div>
</div>
<a id="a23f61ed2204c24dce8049666357b65d5" name="a23f61ed2204c24dce8049666357b65d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23f61ed2204c24dce8049666357b65d5">&#9670;&#160;</a></span>hubiness_rational() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a> lal::properties::hubiness_rational </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the hubiness coefficient as an exact rational number. </p>
<p>The hubiness coefficient is defined as.</p>
<p>\(h = \frac{ \langle k^2 \rangle - \langle k^2 \rangle_{linear} }
            { \langle k^2 \rangle_{star} - \langle k^2 \rangle_{linear} }\),</p>
<p>where \(\langle k^2 \rangle_{star}\) and \(\langle k^2 \rangle_{linear}\) are the second moment of degree about 0 (see <a class="el" href="#a093509b229fae64111c3144665773ea4">lal::properties::moment_degree_rational</a>) of a star and linear tree respectively.</p>
<p>See <a class="el" href="citelist.html#CITEREF_Ferrer2018a">[20]</a> for further details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input free tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hubiness coefficient as a rational value. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The tree <em>t</em> is a valid tree. Method <a class="el" href="classlal_1_1graphs_1_1tree.html#a25c8d57865fa5f7cb5d101fd5d07fe2d" title="Is this graph an actual tree?">graphs::free_tree::is_tree</a> returns true. </dd>
<dd>
\(n &gt; 3\). </dd></dl>

</div>
</div>
<a id="a1750ada3673e7deba32658dc3da2cf0c" name="a1750ada3673e7deba32658dc3da2cf0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1750ada3673e7deba32658dc3da2cf0c">&#9670;&#160;</a></span>hubiness_rational() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a> lal::properties::hubiness_rational </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the hubiness coefficient as an exact rational number. </p>
<p>The hubiness coefficient is defined as.</p>
<p>\(h = \frac{ \langle k^2 \rangle - \langle k^2 \rangle_{linear} }
            { \langle k^2 \rangle_{star} - \langle k^2 \rangle_{linear} }\),</p>
<p>where \(\langle k^2 \rangle_{star}\) and \(\langle k^2 \rangle_{linear}\) are the second moment of degree about 0 (see <a class="el" href="#a093509b229fae64111c3144665773ea4">lal::properties::moment_degree_rational</a>) of a star and linear tree respectively.</p>
<p>See <a class="el" href="citelist.html#CITEREF_Ferrer2018a">[20]</a> for further details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input rooted tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hubiness coefficient as a rational value. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The tree <em>t</em> is a valid rooted tree. Method <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#af464d98b1b5dfdbaaacea553d9c89154" title="Is this tree a valid rooted tree?">graphs::rooted_tree::is_rooted_tree</a> returns true. </dd>
<dd>
\(n &gt; 3\). </dd></dl>

</div>
</div>
<a id="ac0543824abc7e98a65b0ec698ec44788" name="ac0543824abc7e98a65b0ec698ec44788"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0543824abc7e98a65b0ec698ec44788">&#9670;&#160;</a></span>is_graph_bipartite() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::properties::is_graph_bipartite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is a graph bipartite? </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input directed graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the input graph is bipartite. </dd></dl>

</div>
</div>
<a id="a07b9c42ed6a90f262a17502a75b4be58" name="a07b9c42ed6a90f262a17502a75b4be58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07b9c42ed6a90f262a17502a75b4be58">&#9670;&#160;</a></span>is_graph_bipartite() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::properties::is_graph_bipartite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1properties_1_1bipartite__graph__coloring.html">bipartite_graph_coloring</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is a graph bipartite? </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input directed graph. </td></tr>
    <tr><td class="paramname">c</td><td>Coloring of the input graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the input graph is bipartite. </dd></dl>

</div>
</div>
<a id="afae64cf7fe3106dbc368690f6fe9c1c5" name="afae64cf7fe3106dbc368690f6fe9c1c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afae64cf7fe3106dbc368690f6fe9c1c5">&#9670;&#160;</a></span>is_graph_bipartite() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::properties::is_graph_bipartite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is a graph bipartite? </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input undirected graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the input graph is bipartite. </dd></dl>

</div>
</div>
<a id="a1aebad83947a7a88f73a996ef1db8fb0" name="a1aebad83947a7a88f73a996ef1db8fb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1aebad83947a7a88f73a996ef1db8fb0">&#9670;&#160;</a></span>is_graph_bipartite() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::properties::is_graph_bipartite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1properties_1_1bipartite__graph__coloring.html">bipartite_graph_coloring</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is a graph bipartite? </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input undirected graph. </td></tr>
    <tr><td class="paramname">c</td><td>Coloring of the input graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the input graph is bipartite. </dd></dl>

</div>
</div>
<a id="a0c70ec4072e1df27592aa7a51876c1a9" name="a0c70ec4072e1df27592aa7a51876c1a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c70ec4072e1df27592aa7a51876c1a9">&#9670;&#160;</a></span>mean_hierarchical_distance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double lal::properties::mean_hierarchical_distance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mean Hierarchical Distance (MHD). </p>
<p>See <a class="el" href="#a5eca870365ac786867aeacf3609457a9">lal::properties::mean_hierarchical_distance_rational</a> for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input rooted tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Mean Hierarchical Distance of a rooted tree as a floating point value. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The tree <em>t</em> is a valid rooted tree. Method <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#af464d98b1b5dfdbaaacea553d9c89154" title="Is this tree a valid rooted tree?">graphs::rooted_tree::is_rooted_tree</a> returns true. </dd>
<dd>
\(n &gt; 1\) (which is the same as \(m &gt; 0\). </dd></dl>

</div>
</div>
<a id="a5eca870365ac786867aeacf3609457a9" name="a5eca870365ac786867aeacf3609457a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eca870365ac786867aeacf3609457a9">&#9670;&#160;</a></span>mean_hierarchical_distance_rational()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a> lal::properties::mean_hierarchical_distance_rational </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mean Hierarchical Distance (MHD). </p>
<p>The hierarchical distance \(HD_u\) of a vertex \(u\) to the root of the tree is calculated as the number of edges between these two vertices. Therefore, the hierarchical distance from a root's child and the root is exactly 1.</p>
<p>The result of this function is the average of such distances: \(MHD = \frac{1}{n-1} \sum_{u\in V} HD_u\).</p>
<p>For furhter details see <a class="el" href="citelist.html#CITEREF_Jing2015a">[31]</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input rooted tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Mean Hierarchical Distance of a rooted tree as a rational value. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The tree <em>t</em> is a valid rooted tree. Method <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#af464d98b1b5dfdbaaacea553d9c89154" title="Is this tree a valid rooted tree?">graphs::rooted_tree::is_rooted_tree</a> returns true. </dd>
<dd>
\(n &gt; 1\) (which is the same as \(m &gt; 0\). </dd></dl>

</div>
</div>
<a id="a317c023347f5c68745d207d1fba0a3f3" name="a317c023347f5c68745d207d1fba0a3f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a317c023347f5c68745d207d1fba0a3f3">&#9670;&#160;</a></span>moment_degree() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class graph_t , class return_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">return_type lal::properties::moment_degree </td>
          <td>(</td>
          <td class="paramtype">const graph_t &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t(graph_t::*</td>          <td class="paramname"><span class="paramname"><em>degree_function&#160;</em></span>)(<a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a>) const noexcept&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generic template function for the moment of degree about 0. </p>
<p>Calculates the \(p\)-th moment of degree about 0, where the degree is given by some function.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">graph_t</td><td>Type of graph </td></tr>
    <tr><td class="paramname">return_type</td><td>Type of function's result (double, <a class="el" href="classlal_1_1numeric_1_1rational.html">lal::numeric::rational</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph </td></tr>
    <tr><td class="paramname">p</td><td>Power to which degrees must be raised </td></tr>
    <tr><td class="paramname">degree_function</td><td>The function that returns the specific degree (full, out, in, or other). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The \(p\)-th moment of degree about 0. </dd></dl>

</div>
</div>
<a id="a28a5dd4f44b02d1b6ffdf717149a8f88" name="a28a5dd4f44b02d1b6ffdf717149a8f88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28a5dd4f44b02d1b6ffdf717149a8f88">&#9670;&#160;</a></span>moment_degree() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double lal::properties::moment_degree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the \(p\)-th moment of degree about zero of a directed graph as a floating point value. </p>
<p>See <a class="el" href="#a093509b229fae64111c3144665773ea4">lal::properties::moment_degree_rational</a> for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">p</td><td>Moment of degree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The \(p\)-th moment of the degree about 0 as a floating point value. </dd></dl>

</div>
</div>
<a id="ae0c60f8f535c5ec9749f76d6c4f50792" name="ae0c60f8f535c5ec9749f76d6c4f50792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0c60f8f535c5ec9749f76d6c4f50792">&#9670;&#160;</a></span>moment_degree() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double lal::properties::moment_degree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the \(p\)-th moment of degree about zero of a directed graph as a floating point value. </p>
<p>See <a class="el" href="#a093509b229fae64111c3144665773ea4">lal::properties::moment_degree_rational</a> for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">p</td><td>Moment of degree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The \(p\)-th moment of the degree about 0 as a floating point value. </dd></dl>

</div>
</div>
<a id="ab291c021d50c14df2be5beb384521006" name="ab291c021d50c14df2be5beb384521006"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab291c021d50c14df2be5beb384521006">&#9670;&#160;</a></span>moment_degree_rational() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a> lal::properties::moment_degree_rational </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the \(p\)-th moment of degree about zero of a directed graph as an exact rational value. </p>
<p>Computes the \(p\)-th moment of degree about zero, \(\langle k^p \rangle\), of a graph using:</p>
<p>\(\langle k^p \rangle = \frac{1}{n} \sum_{i=1}^n k_i^p \).</p>
<p>where \(n\) denotes the number of nodes of the graph and \(k_i\) is the in-degree plus the out-degree of vertex \(i\). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">p</td><td>Moment of degree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The \(p\)-th moment of the in-degree about 0 as a rational value. </dd></dl>

</div>
</div>
<a id="a093509b229fae64111c3144665773ea4" name="a093509b229fae64111c3144665773ea4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a093509b229fae64111c3144665773ea4">&#9670;&#160;</a></span>moment_degree_rational() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a> lal::properties::moment_degree_rational </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the \(p\)-th moment of degree about zero of a graph as an exact rational value. </p>
<p>Computes the \(p\)-th moment of degree about zero, \(\langle k^p \rangle\), of a graph using:</p>
<p>\(\langle k^p \rangle = \frac{1}{n} \sum_{i=1}^n k_i^p \).</p>
<p>where \(n\) denotes the number of nodes of the graph and \(k_i\) is the degree of vertex \(i\). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">p</td><td>Moment of degree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The \(p\)-th moment of the in-degree about 0 as a rational value. </dd></dl>

</div>
</div>
<a id="aef514f5efa0917d7d5e796dd6155586a" name="aef514f5efa0917d7d5e796dd6155586a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef514f5efa0917d7d5e796dd6155586a">&#9670;&#160;</a></span>moment_in_degree() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double lal::properties::moment_in_degree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the \(p\)-th moment of in-degree about zero of a directed graph as a floating point value. </p>
<p>See <a class="el" href="#ae7f3ff91179f596873097cdc288025f3">lal::properties::moment_in_degree_rational</a> for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">p</td><td>Moment of degree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The \(p\)-th moment of the in-degree about 0 as a floating point value. </dd></dl>

</div>
</div>
<a id="a08453cba2f3f911ce3354703e01490f9" name="a08453cba2f3f911ce3354703e01490f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08453cba2f3f911ce3354703e01490f9">&#9670;&#160;</a></span>moment_in_degree() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double lal::properties::moment_in_degree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the \(p\)-th moment of in-degree about zero of a directed graph as a floating point value. </p>
<p>See <a class="el" href="#ae7f3ff91179f596873097cdc288025f3">lal::properties::moment_in_degree_rational</a> for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input rooted tree. </td></tr>
    <tr><td class="paramname">p</td><td>Moment of degree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The \(p\)-th moment of the in-degree about 0 as a floating point value. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Tree <em>t</em> is a valid rooted tree. </dd></dl>

</div>
</div>
<a id="ae7f3ff91179f596873097cdc288025f3" name="ae7f3ff91179f596873097cdc288025f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7f3ff91179f596873097cdc288025f3">&#9670;&#160;</a></span>moment_in_degree_rational() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a> lal::properties::moment_in_degree_rational </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the \(p\)-th moment of in-degree about zero of a directed graph as an exact rational value. </p>
<p>Computes the \(p\)-th moment of in-degree about zero, \(\langle k_{in}^p \rangle\), of a directed graph using:</p>
<p>\(\langle k_{in}^p \rangle = \frac{1}{n} \sum_{i=1}^n k_{in, i}^p \).</p>
<p>where \(n\) denotes the number of nodes of the graph and \(k_{in, i}\) is the in-degree of vertex \(i\). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">p</td><td>Moment of degree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The \(p\)-th moment of the in-degree about 0 as a rational value. </dd></dl>

</div>
</div>
<a id="ad386d7dd295a3874997499c533c08e2e" name="ad386d7dd295a3874997499c533c08e2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad386d7dd295a3874997499c533c08e2e">&#9670;&#160;</a></span>moment_in_degree_rational() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a> lal::properties::moment_in_degree_rational </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the \(p\)-th moment of in-degree about zero of a rooted tree as an exact rational value. </p>
<p>Computes the \(p\)-th moment of in-degree about zero, \(\langle k_{in}^p \rangle\), of a rooted tree using:</p>
<p>\(\langle k_{in}^p \rangle = \frac{1}{n} \sum_{i=1}^n k_{in, i}^p \).</p>
<p>where \(n\) denotes the number of nodes of the tree. In this case, this value is trivially independent of the moment \(p\),</p>
<p>\(\langle k_{in}^p \rangle = \frac{n - 1}{n}\). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input rooted tree. </td></tr>
    <tr><td class="paramname">p</td><td>Moment of degree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The \(p\)-th moment of the in-degree about 0 as a rational value. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Tree <em>t</em> is a valid rooted tree. </dd></dl>

</div>
</div>
<a id="a90be129d2973fa452b75a5ac86872fc1" name="a90be129d2973fa452b75a5ac86872fc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90be129d2973fa452b75a5ac86872fc1">&#9670;&#160;</a></span>moment_out_degree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double lal::properties::moment_out_degree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the \(p\)-th moment of out-degree about zero of a directed graph as a floating point value. </p>
<p>See <a class="el" href="#ae9d3ce43ec6e32ce27e139cb655871db">lal::properties::moment_out_degree_rational</a> for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">p</td><td>Moment of degree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The \(p\)-th moment of the out-degree about 0 as a floating point value. </dd></dl>

</div>
</div>
<a id="ae9d3ce43ec6e32ce27e139cb655871db" name="ae9d3ce43ec6e32ce27e139cb655871db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9d3ce43ec6e32ce27e139cb655871db">&#9670;&#160;</a></span>moment_out_degree_rational()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a> lal::properties::moment_out_degree_rational </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the \(p\)-th moment of out-degree about zero of a directed graph as an exact rational value. </p>
<p>Computes the \(p\)-th moment of out-degree about zero, \(\langle k_{out}^p \rangle\), of a directed graph using:</p>
<p>\(\langle k_{out}^p \rangle = \frac{1}{n} \sum_{i=1}^n k_{out, i}^p \).</p>
<p>where \(n\) denotes the number of nodes of the graph and \(k_{out, i}\) is the out-degree of vertex \(i\). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">p</td><td>Moment of degree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The \(p\)-th moment of the out-degree about 0 as a rational value. </dd></dl>

</div>
</div>
<a id="a0d1a9bd03760411d1436925d7c095216" name="a0d1a9bd03760411d1436925d7c095216"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d1a9bd03760411d1436925d7c095216">&#9670;&#160;</a></span>num_pairs_independent_edges() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lal::properties::num_pairs_independent_edges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the size of \(Q(G)\). </p>
<p>See <a class="el" href="#a6fa7c3d6aee99da7e532a943bdbc2a9e">lal::properties::num_pairs_independent_edges_integer</a> for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size of \(Q(G)\) as a 64-bit integer. </dd></dl>

</div>
</div>
<a id="a0a492c71d8503b4681ca40d3b526b0f0" name="a0a492c71d8503b4681ca40d3b526b0f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a492c71d8503b4681ca40d3b526b0f0">&#9670;&#160;</a></span>num_pairs_independent_edges() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lal::properties::num_pairs_independent_edges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the size of \(Q(G)\). </p>
<p>See <a class="el" href="#a6fa7c3d6aee99da7e532a943bdbc2a9e">lal::properties::num_pairs_independent_edges_integer</a> for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size of \(Q(G)\) as a 64-bit integer. </dd></dl>

</div>
</div>
<a id="aa086ffd70ff3d2f2ab2e89108b8544a3" name="aa086ffd70ff3d2f2ab2e89108b8544a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa086ffd70ff3d2f2ab2e89108b8544a3">&#9670;&#160;</a></span>num_pairs_independent_edges_integer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1numeric_1_1integer.html">numeric::integer</a> lal::properties::num_pairs_independent_edges_integer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the size of \(Q(G)\). </p>
<p>The set \(Q(G)\) of a graph \(G\) is the set of pairs of independent edges. Two edges are said to be independent if they do not share vertices. Therefore, this function returns the amount of independent edges of this directed graph. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size of \(Q(G)\) as an integer of arbitrary precision. </dd></dl>

</div>
</div>
<a id="a6fa7c3d6aee99da7e532a943bdbc2a9e" name="a6fa7c3d6aee99da7e532a943bdbc2a9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fa7c3d6aee99da7e532a943bdbc2a9e">&#9670;&#160;</a></span>num_pairs_independent_edges_integer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1numeric_1_1integer.html">numeric::integer</a> lal::properties::num_pairs_independent_edges_integer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the size of \(Q(G)\). </p>
<p>The set \(Q(G)\) of a graph \(G\) is the set of pairs of independent edges. Two edges are said to be independent if they do not share vertices. Therefore, this function returns the amount of independent edges of this undirected graph. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size of \(Q(G)\) as an integer of arbitrary precision. </dd></dl>

</div>
</div>
<a id="aba97ff50d077ea9a8ddbf86a0aa33453" name="aba97ff50d077ea9a8ddbf86a0aa33453"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba97ff50d077ea9a8ddbf86a0aa33453">&#9670;&#160;</a></span>sum_hierarchical_distances()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lal::properties::sum_hierarchical_distances </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sum of hierarchical distances (SHD). </p>
<p>The hierarchical distance \(HD_u\) of a vertex \(u\) to the root of the tree is calculated as the number of edges between these two vertices. Therefore, the hierarchical distance from a root's child and the root is exactly 1.</p>
<p>The result of this function is the sum of such distances: \(SHD = \sum_{u\in V} HD_u\).</p>
<p>For furhter details see <a class="el" href="citelist.html#CITEREF_Jing2015a">[31]</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input rooted tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of hierarchical distances of a rooted tree. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The tree <em>t</em> is a valid rooted tree. Method <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#af464d98b1b5dfdbaaacea553d9c89154" title="Is this tree a valid rooted tree?">graphs::rooted_tree::is_rooted_tree</a> returns true. </dd></dl>

</div>
</div>
<a id="a1bdd8c7fb6995c5b519d477af45fca7b" name="a1bdd8c7fb6995c5b519d477af45fca7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bdd8c7fb6995c5b519d477af45fca7b">&#9670;&#160;</a></span>sum_powers_degrees() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class graph_t , class return_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">return_type lal::properties::sum_powers_degrees </td>
          <td>(</td>
          <td class="paramtype">const graph_t &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t(graph_t::*</td>          <td class="paramname"><span class="paramname"><em>degree_function&#160;</em></span>)(<a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a>) const noexcept&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generic template function for the sum of degrees. </p>
<p>Each degree is raised to a certain power according to the parameter.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">graph_t</td><td>Type of graph. </td></tr>
    <tr><td class="paramname">return_type</td><td>Type of function's result (uint64_t, <a class="el" href="classlal_1_1numeric_1_1integer.html">lal::numeric::integer</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph </td></tr>
    <tr><td class="paramname">p</td><td>Power to which degrees must be raised </td></tr>
    <tr><td class="paramname">degree_function</td><td>The function that returns the specific degree (in+out, out, in, or other). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of degrees raised to the input power <em>p</em>. </dd></dl>

</div>
</div>
<a id="ab30fba5a78c5dab2da0bf3fc67e25db2" name="ab30fba5a78c5dab2da0bf3fc67e25db2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab30fba5a78c5dab2da0bf3fc67e25db2">&#9670;&#160;</a></span>sum_powers_degrees() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lal::properties::sum_powers_degrees </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the sum of degrees raised to the \(p\)-th power. </p>
<p>Computes the sum of degrees raised to the \(p\)-th power using</p>
<p>\(K^p = \sum_{i=1}^n k_i^p\).</p>
<p>where \(n\) denotes the number of nodes of the graph and \(k_i\) is the degree of vertex \(i\). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">p</td><td>Power of degree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of in-degrees raised to the \(p\)-th power. </dd></dl>

</div>
</div>
<a id="abb1126afe99609fb9f5565b65dd32a88" name="abb1126afe99609fb9f5565b65dd32a88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb1126afe99609fb9f5565b65dd32a88">&#9670;&#160;</a></span>sum_powers_degrees() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lal::properties::sum_powers_degrees </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the sum of degrees raised to the \(p\)-th power. </p>
<p>Computes the sum of degrees raised to the \(p\)-th power using</p>
<p>\(K^p = \sum_{i=1}^n k_i^p\).</p>
<p>where \(n\) denotes the number of nodes of the graph and \(k_i\) is the degree of vertex \(i\). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">p</td><td>Power of degree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of degrees raised to the \(p\)-th power. </dd></dl>

</div>
</div>
<a id="ad0979fcc3a285cab4228fbac54cc266d" name="ad0979fcc3a285cab4228fbac54cc266d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0979fcc3a285cab4228fbac54cc266d">&#9670;&#160;</a></span>sum_powers_degrees_integer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1numeric_1_1integer.html">numeric::integer</a> lal::properties::sum_powers_degrees_integer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the sum of degrees raised to the \(p\)-th power. </p>
<p>Computes the sum of degrees raised to the \(p\)-th power using</p>
<p>\(K^p = \sum_{i=1}^n k_i^p\).</p>
<p>where \(n\) denotes the number of nodes of the graph and \(k_i\) is the degree of vertex \(i\). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">p</td><td>Power of degree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of degrees raised to the \(p\)-th power. </dd></dl>

</div>
</div>
<a id="ab219655c784e1537677e0b6ec6d51b1f" name="ab219655c784e1537677e0b6ec6d51b1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab219655c784e1537677e0b6ec6d51b1f">&#9670;&#160;</a></span>sum_powers_degrees_integer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1numeric_1_1integer.html">numeric::integer</a> lal::properties::sum_powers_degrees_integer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the sum of degrees raised to the \(p\)-th power. </p>
<p>Computes the sum of degrees raised to the \(p\)-th power using</p>
<p>\(K^p = \sum_{i=1}^n k_i^p\).</p>
<p>where \(n\) denotes the number of nodes of the graph and \(k_i\) is the degree of vertex \(i\). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">p</td><td>Power of degree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of degrees raised to the \(p\)-th power. </dd></dl>

</div>
</div>
<a id="ae53cd84193757ec7d8c9acf8186eb7cb" name="ae53cd84193757ec7d8c9acf8186eb7cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae53cd84193757ec7d8c9acf8186eb7cb">&#9670;&#160;</a></span>sum_powers_in_degrees() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lal::properties::sum_powers_in_degrees </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the sum of in-degrees raised to the \(p\)-th power. </p>
<p>Computes the sum of in-degrees raised to the \(p\)-th power using</p>
<p>\(K^p = \sum_{i=1}^n k_{in, i}^p\).</p>
<p>where \(n\) denotes the number of nodes of the graph and \(k_{in, i}\) is the in-degree of vertex \(i\). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">p</td><td>Power of degree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of in-degrees raised to the \(p\)-th power. </dd></dl>

</div>
</div>
<a id="a49181ee2f17212bf26efd435526c0815" name="a49181ee2f17212bf26efd435526c0815"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49181ee2f17212bf26efd435526c0815">&#9670;&#160;</a></span>sum_powers_in_degrees() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lal::properties::sum_powers_in_degrees </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the sum of in-degrees raised to the \(p\)-th power. </p>
<p>Computes the sum of in-degrees raised to the \(p\)-th power using</p>
<p>\(K^p = \sum_{i=1}^n k_{in, i}^p\).</p>
<p>where \(n\) denotes the number of nodes of the graph and \(k_{in, i}\) is the in-degree of vertex \(i\). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input tree. </td></tr>
    <tr><td class="paramname">p</td><td>Power of degree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of in-degrees raised to the \(p\)-th power. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Tree <em>t</em> is a valid rooted tree. </dd></dl>

</div>
</div>
<a id="adfd173768090fa6ab1b06bfd86875dbd" name="adfd173768090fa6ab1b06bfd86875dbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfd173768090fa6ab1b06bfd86875dbd">&#9670;&#160;</a></span>sum_powers_in_degrees_integer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1numeric_1_1integer.html">numeric::integer</a> lal::properties::sum_powers_in_degrees_integer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the sum of in-degrees raised to the \(p\)-th power. </p>
<p>Computes the sum of in-degrees raised to the \(p\)-th power using</p>
<p>\(K^p = \sum_{i=1}^n k_{in, i}^p\).</p>
<p>where \(n\) denotes the number of nodes of the graph and \(k_{in, i}\) is the in-degree of vertex \(i\). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">p</td><td>Power of degree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of in-degrees raised to the \(p\)-th power. </dd></dl>

</div>
</div>
<a id="a9645c192bfd54213d3a3a51381d518e4" name="a9645c192bfd54213d3a3a51381d518e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9645c192bfd54213d3a3a51381d518e4">&#9670;&#160;</a></span>sum_powers_in_degrees_integer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1numeric_1_1integer.html">numeric::integer</a> lal::properties::sum_powers_in_degrees_integer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the sum of in-degrees raised to the \(p\)-th power. </p>
<p>Computes the sum of in-degrees raised to the \(p\)-th power using</p>
<p>\(K^p = \sum_{i=1}^n k_{in, i}^p\).</p>
<p>where \(n\) denotes the number of nodes of the graph and \(k_{in, i}\) is the in-degree of vertex \(i\). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input tree. </td></tr>
    <tr><td class="paramname">p</td><td>Power of degree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of in-degrees raised to the \(p\)-th power. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Tree <em>t</em> is a valid rooted tree. </dd></dl>

</div>
</div>
<a id="a98dfd6732945f3db02be807a6d286290" name="a98dfd6732945f3db02be807a6d286290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98dfd6732945f3db02be807a6d286290">&#9670;&#160;</a></span>sum_powers_out_degrees()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lal::properties::sum_powers_out_degrees </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the sum of out-degrees raised to the \(p\)-th power. </p>
<p>Computes the sum of out-degrees raised to the \(p\)-th power using</p>
<p>\(K^p = \sum_{i=1}^n k_{out, i}^p\).</p>
<p>where \(n\) denotes the number of nodes of the graph and \(k_{out, i}\) is the out-degree of vertex \(i\). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">p</td><td>Power of degree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of in-degrees raised to the \(p\)-th power. </dd></dl>

</div>
</div>
<a id="a5c393af1ac9ab3d02440428ff11585f3" name="a5c393af1ac9ab3d02440428ff11585f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c393af1ac9ab3d02440428ff11585f3">&#9670;&#160;</a></span>sum_powers_out_degrees_integer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1numeric_1_1integer.html">numeric::integer</a> lal::properties::sum_powers_out_degrees_integer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the sum of out-degrees raised to the \(p\)-th power. </p>
<p>Computes the sum of out-degrees raised to the \(p\)-th power using</p>
<p>\(K^p = \sum_{i=1}^n k_{out, i}^p\).</p>
<p>where \(n\) denotes the number of nodes of the graph and \(k_{out, i}\) is the out-degree of vertex \(i\). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">p</td><td>Power of degree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of out-degrees raised to the \(p\)-th power. </dd></dl>

</div>
</div>
<a id="aa25aeecc00b06f4bbc0840b0b82a09e1" name="aa25aeecc00b06f4bbc0840b0b82a09e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa25aeecc00b06f4bbc0840b0b82a09e1">&#9670;&#160;</a></span>tree_caterpillar_distance() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lal::properties::tree_caterpillar_distance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Caterpillar distance of a tree. </p>
<p>The caterpillar distance of a given tree is defined as the minimum amount of vertices to be removed from the tree so that the result is a caterpillar tree. See page <a class="el" href="LAL_concepts.html#LAL_concepts__tree_types">The different types of trees</a> for a definition of caterpillar tree. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input free tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A positive integer value, the caterpillar distance of the input tree. </dd></dl>

</div>
</div>
<a id="a9b0f0a6bd4d70e33ffec833c215ca755" name="a9b0f0a6bd4d70e33ffec833c215ca755"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b0f0a6bd4d70e33ffec833c215ca755">&#9670;&#160;</a></span>tree_caterpillar_distance() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lal::properties::tree_caterpillar_distance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Caterpillar distance of a tree. </p>
<p>The caterpillar distance of a given tree is defined as the minimum amount of vertices to be removed from the tree so that the result is a caterpillar tree. See page <a class="el" href="LAL_concepts.html#LAL_concepts__tree_types">The different types of trees</a> for a definition of caterpillar tree. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input free tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A positive integer value, the caterpillar distance of the input tree. </dd></dl>

</div>
</div>
<a id="ab05c2a8ee4c9e544358b1db18a7b1c13" name="ab05c2a8ee4c9e544358b1db18a7b1c13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab05c2a8ee4c9e544358b1db18a7b1c13">&#9670;&#160;</a></span>tree_centre() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a>, <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> &gt; lal::properties::tree_centre </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the centre of a free tree. </p>
<p>See <a class="el" href="LAL_concepts.html#LAL_concepts__centre_centroid">Centre and centroid of a tree</a> for details on the centre and centroid of a tree. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tuple of the two nodes in the centre. If the tree has a single central node, only the first node is valid and the second is assigned an invalid vertex index. It is guaranteed that the first vertex has smaller index value than the second. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The tree <em>t</em> is a valid rooted tree. Method <a class="el" href="classlal_1_1graphs_1_1tree.html#a25c8d57865fa5f7cb5d101fd5d07fe2d" title="Is this graph an actual tree?">graphs::free_tree::is_tree</a> returns true. </dd></dl>

</div>
</div>
<a id="ada5517f223bcb1369b625a840dc9c8fa" name="ada5517f223bcb1369b625a840dc9c8fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada5517f223bcb1369b625a840dc9c8fa">&#9670;&#160;</a></span>tree_centre() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a>, <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> &gt; lal::properties::tree_centre </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the centre of a rooted tree. </p>
<p>See <a class="el" href="LAL_concepts.html#LAL_concepts__centre_centroid">Centre and centroid of a tree</a> for details on the centre and centroid of a tree. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tuple of the two nodes in the centre. If the tree has a single central node, only the first node is valid and the second is assigned an invalid vertex index. It is guaranteed that the first vertex has smaller index value than the second. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The tree <em>t</em> is a valid rooted tree. Method <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#af464d98b1b5dfdbaaacea553d9c89154" title="Is this tree a valid rooted tree?">graphs::rooted_tree::is_rooted_tree</a> returns true. </dd></dl>

</div>
</div>
<a id="a809427c54bf089fa2596e47b23538a5a" name="a809427c54bf089fa2596e47b23538a5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a809427c54bf089fa2596e47b23538a5a">&#9670;&#160;</a></span>tree_centroid() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a>, <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> &gt; lal::properties::tree_centroid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the centroid of a free tree. </p>
<p>See <a class="el" href="LAL_concepts.html#LAL_concepts__centre_centroid">Centre and centroid of a tree</a> for details on what the centroid of a tree is. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tuple of two values: the nodes in the centre. If the tree has a single central node, only the first node is valid and the second is assigned an invalid vertex index. It is guaranteed that the first vertex has smaller index value than the second. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The tree <em>t</em> is a valid free tree. Method <a class="el" href="classlal_1_1graphs_1_1tree.html#a25c8d57865fa5f7cb5d101fd5d07fe2d" title="Is this graph an actual tree?">lal::graphs::free_tree::is_tree</a> returns true. </dd></dl>

</div>
</div>
<a id="adda281d4c9e024ea87844756ffbd945e" name="adda281d4c9e024ea87844756ffbd945e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adda281d4c9e024ea87844756ffbd945e">&#9670;&#160;</a></span>tree_centroid() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a>, <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> &gt; lal::properties::tree_centroid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the centroid of a rooted tree. </p>
<p>See <a class="el" href="LAL_concepts.html#LAL_concepts__centre_centroid">Centre and centroid of a tree</a> for details on what the centroid of a tree is. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tuple of two values: the nodes in the centre. If the tree has a single central node, only the first node is valid and the second is assigned an invalid vertex index. It is guaranteed that the first vertex has smaller index value than the second. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The tree <em>t</em> is a valid rooted tree. Method <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#af464d98b1b5dfdbaaacea553d9c89154" title="Is this tree a valid rooted tree?">lal::graphs::rooted_tree::is_rooted_tree</a> returns true. </dd></dl>

</div>
</div>
<a id="a3b40731d0c6eb1115f4ca7c655841078" name="a3b40731d0c6eb1115f4ca7c655841078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b40731d0c6eb1115f4ca7c655841078">&#9670;&#160;</a></span>tree_diameter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lal::properties::tree_diameter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the diameter of a free tree. </p>
<p>See <a class="el" href="LAL_concepts.html#LAL_concepts__tree_diameter">Diameter of a tree</a> for details on the definition of the diameter of a tree. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The diameter of the input tree. </dd></dl>

</div>
</div>
<a id="aa51ed4f552db20a0000f85a86326efd8" name="aa51ed4f552db20a0000f85a86326efd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa51ed4f552db20a0000f85a86326efd8">&#9670;&#160;</a></span>tree_diameter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lal::properties::tree_diameter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the diameter of a free tree. </p>
<p>See <a class="el" href="LAL_concepts.html#LAL_concepts__tree_diameter">Diameter of a tree</a> for details on the definition of the diameter of a tree. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The diameter of the input tree. </dd></dl>

</div>
</div>
<a id="aa58446707ce2f604cf693edbb8f122db" name="aa58446707ce2f604cf693edbb8f122db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa58446707ce2f604cf693edbb8f122db">&#9670;&#160;</a></span>var_num_crossings()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double lal::properties::var_num_crossings </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>reuse</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the variance of the number of crossings of a graph in unconstrained arrangements, \(\mathbb{V}[C]\). </p>
<p>See <a class="el" href="#ad80fca59dc093300ae576c379a768452">lal::properties::var_num_crossings_rational</a> for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">reuse</td><td>The algorithm will reuse computations in order to compute the variance faster. Note: this might be too memory-consuming. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The exact value of \(V_{rla}[C]\) as a rationafloating point value. </dd></dl>

</div>
</div>
<a id="af404ccea372ee1d555cab3b9c6e67a1d" name="af404ccea372ee1d555cab3b9c6e67a1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af404ccea372ee1d555cab3b9c6e67a1d">&#9670;&#160;</a></span>var_num_crossings_forest()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double lal::properties::var_num_crossings_forest </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the variance of the number of crossings of a forest in unconstrained arrangements, \(\mathbb{V}[C]\). </p>
<p>See <a class="el" href="#a4fc49dada4d129f0a9026605e74cfe0a">lal::properties::var_num_crossings_forest_rational</a> for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input forest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The exact value of \(V_{rla}[C]\) as a floating point value. </dd></dl>

</div>
</div>
<a id="a4fc49dada4d129f0a9026605e74cfe0a" name="a4fc49dada4d129f0a9026605e74cfe0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fc49dada4d129f0a9026605e74cfe0a">&#9670;&#160;</a></span>var_num_crossings_forest_rational()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a> lal::properties::var_num_crossings_forest_rational </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the variance of the number of crossings of a forest in unconstrained arrangements, \(\mathbb{V}[C]\). </p>
<p>Computes \(\mathbb{V}[C]\) on the given forest. This function implements the algorithm in <a class="el" href="citelist.html#CITEREF_Alemany2020b">[3]</a> for forests, which stems from the study in <a class="el" href="citelist.html#CITEREF_Alemany2020a">[2]</a>.</p>
<p>Complexity: time \(O(n)\), space \(O(n)\). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input forest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The exact value of \(V_{rla}[C]\) as a rational value. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The input graph <em>g</em> is a forest. </dd></dl>

</div>
</div>
<a id="ad80fca59dc093300ae576c379a768452" name="ad80fca59dc093300ae576c379a768452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad80fca59dc093300ae576c379a768452">&#9670;&#160;</a></span>var_num_crossings_rational()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a> lal::properties::var_num_crossings_rational </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>reuse</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the variance of the number of crossings of a graph in unconstrained arrangements, \(\mathbb{V}[C]\). </p>
<p>Computes \(\mathbb{V}[C]\) on the given graph. This function implements the algorithm in <a class="el" href="citelist.html#CITEREF_Alemany2020b">[3]</a> for general graphs, which stems from the study in <a class="el" href="citelist.html#CITEREF_Alemany2020a">[2]</a>.</p>
<p>Since there are many computations that can be resued, setting <em>reuse</em> to 'true' can help speed up the algorithm. Warning: reusing memory might be too memory-consuming for large graphs (handle with care). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">reuse</td><td>The algorithm will reuse computations in order to compute the variance faster. Note: this might be too memory-consuming. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The exact value of \(V_{rla}[C]\) as a rational value. </dd></dl>

</div>
</div>
<a id="a02c904df78290dd71ec9445ad3908bc5" name="a02c904df78290dd71ec9445ad3908bc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02c904df78290dd71ec9445ad3908bc5">&#9670;&#160;</a></span>var_num_crossings_tree() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double lal::properties::var_num_crossings_tree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the variance of the number of crossings of a tree in unconstrained arrangements, \(\mathbb{V}[C]\). </p>
<p>See <a class="el" href="#a83745d14589b98b918481d83f564f7c0">lal::properties::var_num_crossings_tree_rational</a> for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input free tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return value is a floating point value. </dd></dl>

</div>
</div>
<a id="a504fb6143e41360712cdd5b96b93cb6e" name="a504fb6143e41360712cdd5b96b93cb6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a504fb6143e41360712cdd5b96b93cb6e">&#9670;&#160;</a></span>var_num_crossings_tree() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double lal::properties::var_num_crossings_tree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the variance of the number of crossings of a tree in unconstrained arrangements, \(\mathbb{V}[C]\). </p>
<p>This function converts the input rooted tree into a free tree.</p>
<p>See <a class="el" href="#a83745d14589b98b918481d83f564f7c0">lal::properties::var_num_crossings_tree_rational</a> for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input rooted tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return value is a floating point value. </dd></dl>

</div>
</div>
<a id="a83745d14589b98b918481d83f564f7c0" name="a83745d14589b98b918481d83f564f7c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83745d14589b98b918481d83f564f7c0">&#9670;&#160;</a></span>var_num_crossings_tree_rational() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a> lal::properties::var_num_crossings_tree_rational </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the variance of the number of crossings of a tree in unconstrained arrangements, \(\mathbb{V}[C]\). </p>
<p>Computes \(\mathbb{V}[C]\) on the given tree. This function computes the simplified formula of \(V_{rla}[C]\) on general graphs for the case of trees. Complexity: time \(O(n)\), space \(O(n)\). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input free tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The exact value of \(V_{rla}[C]\) as a rational value. </dd></dl>

</div>
</div>
<a id="ad04afab9d98252090df36b307c014de4" name="ad04afab9d98252090df36b307c014de4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad04afab9d98252090df36b307c014de4">&#9670;&#160;</a></span>var_num_crossings_tree_rational() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a> lal::properties::var_num_crossings_tree_rational </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the variance of the number of crossings of a tree in unconstrained arrangements, \(\mathbb{V}[C]\). </p>
<p>This function converts the input rooted tree into a free tree.</p>
<p>Computes \(\mathbb{V}[C]\) on the given tree. This function computes the simplified formula of \(V_{rla}[C]\) on general graphs for the case of trees. Complexity: time \(O(n)\), space \(O(n)\). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input rooted tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The exact value of \(V_{rla}[C]\) as a rational value. </dd></dl>

</div>
</div>
<a id="ade6a3f20263e2a982cfc5dc59facaf40" name="ade6a3f20263e2a982cfc5dc59facaf40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade6a3f20263e2a982cfc5dc59facaf40">&#9670;&#160;</a></span>var_sum_edge_lengths()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double lal::properties::var_sum_edge_lengths </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the variance of the sum of the length of edges of a graph, \(\mathbb{V}[D]\). </p>
<p>See <a class="el" href="#a3826e458a5c14aa82c2d5f0679530e7e">lal::properties::var_sum_edge_lengths_rational</a> for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>The input graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The exact value of \(V[D]\) as a floating point value. </dd></dl>

</div>
</div>
<a id="a3826e458a5c14aa82c2d5f0679530e7e" name="a3826e458a5c14aa82c2d5f0679530e7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3826e458a5c14aa82c2d5f0679530e7e">&#9670;&#160;</a></span>var_sum_edge_lengths_rational()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a> lal::properties::var_sum_edge_lengths_rational </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the variance of the sum of the length of edges of a graph, \(\mathbb{V}[D]\). </p>
<p>Computes the variance of the sum of edge lengths over all \(n!\) arrangements.</p>
<p>This function uses the formula derived in <a class="el" href="citelist.html#CITEREF_Ferrer2019a">[23]</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The exact value of \(V[D]\) as a rational value. </dd></dl>

</div>
</div>
<a id="aead22cd81b7f901d34a7ada4fa356cb5" name="aead22cd81b7f901d34a7ada4fa356cb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aead22cd81b7f901d34a7ada4fa356cb5">&#9670;&#160;</a></span>vertex_orbits_compute()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> &gt; &gt; lal::properties::vertex_orbits_compute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct the set of vertex orbits of a tree. </p>
<p>This function implements an algorithm of time complexity \(O(n^2)\), where \(n\) is the number of vertices of the tree. In the future, the linear-time algorithm in <a class="el" href="citelist.html#CITEREF_Colbourn1981a">[16]</a> may be implemented. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The input free tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector, each with a list of vertices that belong to the same orbit. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
