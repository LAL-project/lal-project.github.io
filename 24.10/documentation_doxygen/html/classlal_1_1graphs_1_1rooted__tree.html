<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LAL: Linear Arrangement Library: lal::graphs::rooted_tree Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">LAL: Linear Arrangement Library<span id="projectnumber">&#160;24.10.00</span>
   </div>
   <div id="projectbrief">A library focused on algorithms on linear arrangements of graphs.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacelal.html">lal</a></li><li class="navelem"><a class="el" href="namespacelal_1_1graphs.html">graphs</a></li><li class="navelem"><a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">rooted_tree</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="classlal_1_1graphs_1_1rooted__tree-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">lal::graphs::rooted_tree Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Rooted tree graph class.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="rooted__tree_8hpp_source.html">rooted_tree.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for lal::graphs::rooted_tree:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classlal_1_1graphs_1_1rooted__tree.png" usemap="#lal::graphs::rooted_5Ftree_map" alt=""/>
  <map id="lal::graphs::rooted_5Ftree_map" name="lal::graphs::rooted_5Ftree_map">
<area href="classlal_1_1graphs_1_1directed__graph.html" title="Directed graph class." alt="lal::graphs::directed_graph" shape="rect" coords="0,56,162,80"/>
<area href="classlal_1_1graphs_1_1tree.html" title="Tree graph class." alt="lal::graphs::tree" shape="rect" coords="172,56,334,80"/>
<area href="classlal_1_1graphs_1_1graph.html" title="Abstract class for graphs." alt="lal::graphs::graph" shape="rect" coords="0,0,162,24"/>
<area href="classlal_1_1graphs_1_1graph.html" title="Abstract class for graphs." alt="lal::graphs::graph" shape="rect" coords="172,0,334,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abdd0796c80d7ec1fc37f0f359cd78b6c" id="r_abdd0796c80d7ec1fc37f0f359cd78b6c"><td class="memItemLeft" align="right" valign="top"><a id="abdd0796c80d7ec1fc37f0f359cd78b6c" name="abdd0796c80d7ec1fc37f0f359cd78b6c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>rooted_tree</b> () noexcept</td></tr>
<tr class="memdesc:abdd0796c80d7ec1fc37f0f359cd78b6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty constructor. <br /></td></tr>
<tr class="separator:abdd0796c80d7ec1fc37f0f359cd78b6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6fa8f965afc59d4c0250ef118fa30da" id="r_af6fa8f965afc59d4c0250ef118fa30da"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af6fa8f965afc59d4c0250ef118fa30da">rooted_tree</a> (const uint64_t n) noexcept</td></tr>
<tr class="memdesc:af6fa8f965afc59d4c0250ef118fa30da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor with number of nodes and root node.  <br /></td></tr>
<tr class="separator:af6fa8f965afc59d4c0250ef118fa30da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a947af40c3256a42866b92fc20f61ec19" id="r_a947af40c3256a42866b92fc20f61ec19"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a947af40c3256a42866b92fc20f61ec19">rooted_tree</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">directed_graph</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:a947af40c3256a42866b92fc20f61ec19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor with directed graph.  <br /></td></tr>
<tr class="separator:a947af40c3256a42866b92fc20f61ec19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac311b00ac5f2baa34353c37cd5be5d7b" id="r_ac311b00ac5f2baa34353c37cd5be5d7b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac311b00ac5f2baa34353c37cd5be5d7b">rooted_tree</a> (<a class="el" href="classlal_1_1graphs_1_1directed__graph.html">directed_graph</a> &amp;&amp;t) noexcept</td></tr>
<tr class="memdesc:ac311b00ac5f2baa34353c37cd5be5d7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor with directed graph.  <br /></td></tr>
<tr class="separator:ac311b00ac5f2baa34353c37cd5be5d7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a976ef24f6dabb3d250f325e943e9b1c8" id="r_a976ef24f6dabb3d250f325e943e9b1c8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a976ef24f6dabb3d250f325e943e9b1c8">rooted_tree</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">rooted_tree</a> &amp;r) noexcept</td></tr>
<tr class="memdesc:a976ef24f6dabb3d250f325e943e9b1c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <br /></td></tr>
<tr class="separator:a976ef24f6dabb3d250f325e943e9b1c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02a2243d59de6bdb05d973956388005d" id="r_a02a2243d59de6bdb05d973956388005d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a02a2243d59de6bdb05d973956388005d">rooted_tree</a> (<a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">rooted_tree</a> &amp;&amp;r) noexcept</td></tr>
<tr class="memdesc:a02a2243d59de6bdb05d973956388005d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <br /></td></tr>
<tr class="separator:a02a2243d59de6bdb05d973956388005d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab42eb737eebdee2e8602f8c02a5a57f7" id="r_ab42eb737eebdee2e8602f8c02a5a57f7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab42eb737eebdee2e8602f8c02a5a57f7">rooted_tree</a> (const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">free_tree</a> &amp;t, const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> r, const bool norm=true, const bool check_norm=true) noexcept</td></tr>
<tr class="memdesc:ab42eb737eebdee2e8602f8c02a5a57f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor with free tree and root node.  <br /></td></tr>
<tr class="separator:ab42eb737eebdee2e8602f8c02a5a57f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89c6d30586506028567a3ef5e5c85e4b" id="r_a89c6d30586506028567a3ef5e5c85e4b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a89c6d30586506028567a3ef5e5c85e4b">rooted_tree</a> (<a class="el" href="classlal_1_1graphs_1_1free__tree.html">free_tree</a> &amp;&amp;t, const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> r, const bool norm=true, const bool check_norm=true) noexcept</td></tr>
<tr class="memdesc:a89c6d30586506028567a3ef5e5c85e4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor with tree and root node.  <br /></td></tr>
<tr class="separator:a89c6d30586506028567a3ef5e5c85e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a419a78b7489222b13927c50cb3a1f423" id="r_a419a78b7489222b13927c50cb3a1f423"><td class="memItemLeft" align="right" valign="top"><a id="a419a78b7489222b13927c50cb3a1f423" name="a419a78b7489222b13927c50cb3a1f423"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~rooted_tree</b> () noexcept</td></tr>
<tr class="memdesc:a419a78b7489222b13927c50cb3a1f423"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a419a78b7489222b13927c50cb3a1f423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ea3a2ecbda50de43e57564855f7b61f" id="r_a3ea3a2ecbda50de43e57564855f7b61f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">rooted_tree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3ea3a2ecbda50de43e57564855f7b61f">operator=</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">rooted_tree</a> &amp;r) noexcept</td></tr>
<tr class="memdesc:a3ea3a2ecbda50de43e57564855f7b61f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator.  <br /></td></tr>
<tr class="separator:a3ea3a2ecbda50de43e57564855f7b61f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae19c29613069729e0bc0683a676a34ef" id="r_ae19c29613069729e0bc0683a676a34ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">rooted_tree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae19c29613069729e0bc0683a676a34ef">operator=</a> (<a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">rooted_tree</a> &amp;&amp;r) noexcept</td></tr>
<tr class="memdesc:ae19c29613069729e0bc0683a676a34ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator.  <br /></td></tr>
<tr class="separator:ae19c29613069729e0bc0683a676a34ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad35cda8a4fa8de6fcc9c92b8a132f21b" id="r_ad35cda8a4fa8de6fcc9c92b8a132f21b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad35cda8a4fa8de6fcc9c92b8a132f21b">init_rooted</a> (const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">free_tree</a> &amp;t, const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> r, const bool norm=true, const bool check_norm=true) noexcept</td></tr>
<tr class="memdesc:ad35cda8a4fa8de6fcc9c92b8a132f21b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer with tree and root node.  <br /></td></tr>
<tr class="separator:ad35cda8a4fa8de6fcc9c92b8a132f21b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5062b5f398247b196495ab811b7f59ad" id="r_a5062b5f398247b196495ab811b7f59ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5062b5f398247b196495ab811b7f59ad">init_rooted</a> (<a class="el" href="classlal_1_1graphs_1_1free__tree.html">free_tree</a> &amp;&amp;t, const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> r, const bool norm=true, const bool check_norm=true) noexcept</td></tr>
<tr class="memdesc:a5062b5f398247b196495ab811b7f59ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer with tree and root node.  <br /></td></tr>
<tr class="separator:a5062b5f398247b196495ab811b7f59ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29e10f053a90b751d9d67890e2b0eb16" id="r_a29e10f053a90b751d9d67890e2b0eb16"><td class="memItemLeft" align="right" valign="top"><a id="a29e10f053a90b751d9d67890e2b0eb16" name="a29e10f053a90b751d9d67890e2b0eb16"></a>
<a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">rooted_tree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>add_node</b> () noexcept</td></tr>
<tr class="memdesc:a29e10f053a90b751d9d67890e2b0eb16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a node to the graph. <br /></td></tr>
<tr class="separator:a29e10f053a90b751d9d67890e2b0eb16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfd2e63ab74fbbc367216f2c256f33c2" id="r_abfd2e63ab74fbbc367216f2c256f33c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">rooted_tree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abfd2e63ab74fbbc367216f2c256f33c2">remove_node</a> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u, const bool connect=false, const bool norm=true, const bool check_norm=true) noexcept</td></tr>
<tr class="memdesc:abfd2e63ab74fbbc367216f2c256f33c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a node from this tree.  <br /></td></tr>
<tr class="separator:abfd2e63ab74fbbc367216f2c256f33c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49939ad6dffc54cd4d58bc1506f28f6b" id="r_a49939ad6dffc54cd4d58bc1506f28f6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">rooted_tree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a49939ad6dffc54cd4d58bc1506f28f6b">add_edge</a> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> s, const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> t, const bool norm=true, const bool check_norm=true) noexcept</td></tr>
<tr class="memdesc:a49939ad6dffc54cd4d58bc1506f28f6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an edge to the tree.  <br /></td></tr>
<tr class="separator:a49939ad6dffc54cd4d58bc1506f28f6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71bb1763d7603eacd42a5e8ed91defba" id="r_a71bb1763d7603eacd42a5e8ed91defba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">rooted_tree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a71bb1763d7603eacd42a5e8ed91defba">add_edge_bulk</a> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> s, const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> t) noexcept</td></tr>
<tr class="memdesc:a71bb1763d7603eacd42a5e8ed91defba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an edge to the graph.  <br /></td></tr>
<tr class="separator:a71bb1763d7603eacd42a5e8ed91defba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01453a5f86572b1d6097cf9a1067e73c" id="r_a01453a5f86572b1d6097cf9a1067e73c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a01453a5f86572b1d6097cf9a1067e73c">finish_bulk_add</a> (const bool norm=true, const bool check=true) noexcept</td></tr>
<tr class="memdesc:a01453a5f86572b1d6097cf9a1067e73c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes adding edges in bulk.  <br /></td></tr>
<tr class="separator:a01453a5f86572b1d6097cf9a1067e73c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57459861c9e1917d66b11f1515acdcaa" id="r_a57459861c9e1917d66b11f1515acdcaa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a57459861c9e1917d66b11f1515acdcaa">finish_bulk_add_complete</a> (const bool norm=true, const bool check=true) noexcept</td></tr>
<tr class="memdesc:a57459861c9e1917d66b11f1515acdcaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Completes the inner structure of the tree after adding edges in bulk.  <br /></td></tr>
<tr class="separator:a57459861c9e1917d66b11f1515acdcaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48e3d3f8b72122e829616edeeee05dfb" id="r_a48e3d3f8b72122e829616edeeee05dfb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">rooted_tree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a48e3d3f8b72122e829616edeeee05dfb">add_edges</a> (const std::vector&lt; <a class="el" href="namespacelal.html#a5969ec7ecc85697ebb9ec0ace78fbcab">edge</a> &gt; &amp;edges, const bool norm=true, const bool check_norm=true) noexcept</td></tr>
<tr class="memdesc:a48e3d3f8b72122e829616edeeee05dfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a list of edges to the graph.  <br /></td></tr>
<tr class="separator:a48e3d3f8b72122e829616edeeee05dfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af22c28ef3cc6dec9e2952f7ed943221d" id="r_af22c28ef3cc6dec9e2952f7ed943221d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">rooted_tree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af22c28ef3cc6dec9e2952f7ed943221d">set_edges</a> (const std::vector&lt; <a class="el" href="namespacelal.html#a5969ec7ecc85697ebb9ec0ace78fbcab">edge</a> &gt; &amp;edges, const bool norm=true, const bool check_norm=true) noexcept</td></tr>
<tr class="memdesc:af22c28ef3cc6dec9e2952f7ed943221d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the edges to the graph.  <br /></td></tr>
<tr class="separator:af22c28ef3cc6dec9e2952f7ed943221d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2b76c9b017ba87d0458b8a3bf89cc77" id="r_ac2b76c9b017ba87d0458b8a3bf89cc77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">rooted_tree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac2b76c9b017ba87d0458b8a3bf89cc77">remove_edge</a> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> s, const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> t, const bool norm=false, const bool check_norm=true) noexcept</td></tr>
<tr class="memdesc:ac2b76c9b017ba87d0458b8a3bf89cc77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an edge from this graph.  <br /></td></tr>
<tr class="separator:ac2b76c9b017ba87d0458b8a3bf89cc77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34fc00e1d6e5e84b480dfaaab9ab69e9" id="r_a34fc00e1d6e5e84b480dfaaab9ab69e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">rooted_tree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a34fc00e1d6e5e84b480dfaaab9ab69e9">remove_edge_bulk</a> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> s, const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> t) noexcept</td></tr>
<tr class="memdesc:a34fc00e1d6e5e84b480dfaaab9ab69e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an edge from the tree.  <br /></td></tr>
<tr class="separator:a34fc00e1d6e5e84b480dfaaab9ab69e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6a62c89130506333d5a7edd221ec5fd" id="r_aa6a62c89130506333d5a7edd221ec5fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa6a62c89130506333d5a7edd221ec5fd">finish_bulk_remove</a> (const bool norm=true, const bool check=true) noexcept</td></tr>
<tr class="memdesc:aa6a62c89130506333d5a7edd221ec5fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes removing edges in bulk.  <br /></td></tr>
<tr class="separator:aa6a62c89130506333d5a7edd221ec5fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68010a9d89ab810721e4abf3ea5008e2" id="r_a68010a9d89ab810721e4abf3ea5008e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a68010a9d89ab810721e4abf3ea5008e2">finish_bulk_remove_complete</a> (const bool norm=true, const bool check=true) noexcept</td></tr>
<tr class="memdesc:a68010a9d89ab810721e4abf3ea5008e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Completes the inner structure of the tree after removing edges in bulk.  <br /></td></tr>
<tr class="separator:a68010a9d89ab810721e4abf3ea5008e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fb10a4c13c5c9fc6c082f1513844330" id="r_a3fb10a4c13c5c9fc6c082f1513844330"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">rooted_tree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3fb10a4c13c5c9fc6c082f1513844330">remove_edges</a> (const std::vector&lt; <a class="el" href="namespacelal.html#a5969ec7ecc85697ebb9ec0ace78fbcab">edge</a> &gt; &amp;edges, const bool norm=true, const bool check_norm=true) noexcept</td></tr>
<tr class="memdesc:a3fb10a4c13c5c9fc6c082f1513844330"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an edge from this graph.  <br /></td></tr>
<tr class="separator:a3fb10a4c13c5c9fc6c082f1513844330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87fe72ad0fd7894f19cb31883335682c" id="r_a87fe72ad0fd7894f19cb31883335682c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">rooted_tree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a87fe72ad0fd7894f19cb31883335682c">remove_edges_incident_to</a> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u, const bool norm=true, const bool check_norm=true) noexcept</td></tr>
<tr class="memdesc:a87fe72ad0fd7894f19cb31883335682c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all edges incident to a given vertex.  <br /></td></tr>
<tr class="separator:a87fe72ad0fd7894f19cb31883335682c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adec23a6b7b6c10c80a9cdc595cdf91f2" id="r_adec23a6b7b6c10c80a9cdc595cdf91f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">rooted_tree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adec23a6b7b6c10c80a9cdc595cdf91f2">disjoint_union</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">rooted_tree</a> &amp;t, const bool connect_roots=true) noexcept</td></tr>
<tr class="memdesc:adec23a6b7b6c10c80a9cdc595cdf91f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disjoint union of trees.  <br /></td></tr>
<tr class="separator:adec23a6b7b6c10c80a9cdc595cdf91f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5682b09580f720e6931f811d8b13659f" id="r_a5682b09580f720e6931f811d8b13659f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5682b09580f720e6931f811d8b13659f">calculate_size_subtrees</a> () noexcept</td></tr>
<tr class="memdesc:a5682b09580f720e6931f811d8b13659f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the number of nodes at every rooted subtree.  <br /></td></tr>
<tr class="separator:a5682b09580f720e6931f811d8b13659f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaa55acc91cddcd44f95419b83706ae9" id="r_aaaa55acc91cddcd44f95419b83706ae9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaaa55acc91cddcd44f95419b83706ae9">calculate_tree_type</a> () noexcept</td></tr>
<tr class="memdesc:aaaa55acc91cddcd44f95419b83706ae9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the type of tree.  <br /></td></tr>
<tr class="separator:aaaa55acc91cddcd44f95419b83706ae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a315021f4b8de00b99996d45c5bbb9c4a" id="r_a315021f4b8de00b99996d45c5bbb9c4a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a315021f4b8de00b99996d45c5bbb9c4a">set_root</a> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> r) noexcept</td></tr>
<tr class="memdesc:a315021f4b8de00b99996d45c5bbb9c4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the root of this tree.  <br /></td></tr>
<tr class="separator:a315021f4b8de00b99996d45c5bbb9c4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e9cff34e745fb4b9388f73f91f43729" id="r_a6e9cff34e745fb4b9388f73f91f43729"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e9cff34e745fb4b9388f73f91f43729">is_root_valid</a> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> r) const noexcept</td></tr>
<tr class="memdesc:a6e9cff34e745fb4b9388f73f91f43729"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the root valid?  <br /></td></tr>
<tr class="separator:a6e9cff34e745fb4b9388f73f91f43729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a273d4cd55ab0ed2b35891f00b74a5e92" id="r_a273d4cd55ab0ed2b35891f00b74a5e92"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a273d4cd55ab0ed2b35891f00b74a5e92">can_add_edge</a> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> s, const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> t) const noexcept</td></tr>
<tr class="memdesc:a273d4cd55ab0ed2b35891f00b74a5e92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can this edge be added?  <br /></td></tr>
<tr class="separator:a273d4cd55ab0ed2b35891f00b74a5e92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac66708cc747974506d27201655fa78bb" id="r_ac66708cc747974506d27201655fa78bb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac66708cc747974506d27201655fa78bb">can_add_edges</a> (const std::vector&lt; <a class="el" href="namespacelal.html#a5969ec7ecc85697ebb9ec0ace78fbcab">edge</a> &gt; &amp;edges) const noexcept</td></tr>
<tr class="memdesc:ac66708cc747974506d27201655fa78bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can these edges be added?  <br /></td></tr>
<tr class="separator:ac66708cc747974506d27201655fa78bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9176a47f0fdf3a3782cb6e940f8c5e52" id="r_a9176a47f0fdf3a3782cb6e940f8c5e52"><td class="memItemLeft" align="right" valign="top"><a id="a9176a47f0fdf3a3782cb6e940f8c5e52" name="a9176a47f0fdf3a3782cb6e940f8c5e52"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_rooted</b> () const noexcept</td></tr>
<tr class="memdesc:a9176a47f0fdf3a3782cb6e940f8c5e52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether this tree is a rooted tree. <br /></td></tr>
<tr class="separator:a9176a47f0fdf3a3782cb6e940f8c5e52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af464d98b1b5dfdbaaacea553d9c89154" id="r_af464d98b1b5dfdbaaacea553d9c89154"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af464d98b1b5dfdbaaacea553d9c89154">is_rooted_tree</a> () const noexcept</td></tr>
<tr class="memdesc:af464d98b1b5dfdbaaacea553d9c89154"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this tree a valid rooted tree?  <br /></td></tr>
<tr class="separator:af464d98b1b5dfdbaaacea553d9c89154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c188e4dc4a372c356e68ced5d80d5f6" id="r_a8c188e4dc4a372c356e68ced5d80d5f6"><td class="memItemLeft" align="right" valign="top"><a id="a8c188e4dc4a372c356e68ced5d80d5f6" name="a8c188e4dc4a372c356e68ced5d80d5f6"></a>
<a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_root</b> () const noexcept</td></tr>
<tr class="memdesc:a8c188e4dc4a372c356e68ced5d80d5f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the root of this tree. <br /></td></tr>
<tr class="separator:a8c188e4dc4a372c356e68ced5d80d5f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bd08e2ff59bf1037d70db8199543b2a" id="r_a8bd08e2ff59bf1037d70db8199543b2a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8bd08e2ff59bf1037d70db8199543b2a">has_root</a> () const noexcept</td></tr>
<tr class="separator:a8bd08e2ff59bf1037d70db8199543b2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6be97ab69d1c8bf6f085bef3cebbdfb" id="r_ae6be97ab69d1c8bf6f085bef3cebbdfb"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae6be97ab69d1c8bf6f085bef3cebbdfb">get_num_nodes_subtree</a> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u) const noexcept</td></tr>
<tr class="memdesc:ae6be97ab69d1c8bf6f085bef3cebbdfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of a subtree rooted at a given node.  <br /></td></tr>
<tr class="separator:ae6be97ab69d1c8bf6f085bef3cebbdfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae92039a5723afd79aec1934f2b145dda" id="r_ae92039a5723afd79aec1934f2b145dda"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae92039a5723afd79aec1934f2b145dda">are_size_subtrees_valid</a> () const noexcept</td></tr>
<tr class="memdesc:ae92039a5723afd79aec1934f2b145dda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is a recalculation of the subtree's sizes needed?  <br /></td></tr>
<tr class="separator:ae92039a5723afd79aec1934f2b145dda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d47b0d4f67a1b214eb120e5cb6c18ed" id="r_a8d47b0d4f67a1b214eb120e5cb6c18ed"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacelal.html#a5969ec7ecc85697ebb9ec0ace78fbcab">edge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d47b0d4f67a1b214eb120e5cb6c18ed">get_edges_subtree</a> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u, const bool relab=false) const noexcept</td></tr>
<tr class="memdesc:a8d47b0d4f67a1b214eb120e5cb6c18ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the edges of the subtree rooted at <em>u</em>.  <br /></td></tr>
<tr class="separator:a8d47b0d4f67a1b214eb120e5cb6c18ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecd3d53ae80a7aeb705bc5a3c543e901" id="r_aecd3d53ae80a7aeb705bc5a3c543e901"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">rooted_tree</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aecd3d53ae80a7aeb705bc5a3c543e901">get_subtree</a> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u) const noexcept</td></tr>
<tr class="memdesc:aecd3d53ae80a7aeb705bc5a3c543e901"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the subtree rooted at node <em>u</em>.  <br /></td></tr>
<tr class="separator:aecd3d53ae80a7aeb705bc5a3c543e901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0600daeeb3542446c6c8d8299d7fffa6" id="r_a0600daeeb3542446c6c8d8299d7fffa6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1graphs_1_1free__tree.html">free_tree</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0600daeeb3542446c6c8d8299d7fffa6">to_free_tree</a> (const bool norm=true, const bool check=true) const noexcept</td></tr>
<tr class="memdesc:a0600daeeb3542446c6c8d8299d7fffa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts this rooted tree into a free tree (see <a class="el" href="classlal_1_1graphs_1_1free__tree.html">free_tree</a>).  <br /></td></tr>
<tr class="separator:a0600daeeb3542446c6c8d8299d7fffa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39fe1b8076010e6bdcb0620436e3a399" id="r_a39fe1b8076010e6bdcb0620436e3a399"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacelal.html#a2eb5b7f5b50ff908a7a67889a9ea744d">head_vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a39fe1b8076010e6bdcb0620436e3a399">get_head_vector</a> (const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;arr={}) const noexcept</td></tr>
<tr class="memdesc:a39fe1b8076010e6bdcb0620436e3a399"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a rooted tree into a head vector.  <br /></td></tr>
<tr class="separator:a39fe1b8076010e6bdcb0620436e3a399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad96a414d470e9fbc8694601503da4ad" id="r_aad96a414d470e9fbc8694601503da4ad"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad96a414d470e9fbc8694601503da4ad">subtree_contains_node</a> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> r, const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u) const noexcept</td></tr>
<tr class="memdesc:aad96a414d470e9fbc8694601503da4ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the subtree rooted at <em>r</em> contain node <em>u</em>?  <br /></td></tr>
<tr class="separator:aad96a414d470e9fbc8694601503da4ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8922eeacf0937020d3008b94516a448c" id="r_a8922eeacf0937020d3008b94516a448c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8922eeacf0937020d3008b94516a448c">are_nodes_siblings</a> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u, const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> v) const noexcept</td></tr>
<tr class="memdesc:a8922eeacf0937020d3008b94516a448c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Are two nodes siblings?  <br /></td></tr>
<tr class="separator:a8922eeacf0937020d3008b94516a448c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea9359d7279ddd5c247da7483e888175" id="r_aea9359d7279ddd5c247da7483e888175"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aea9359d7279ddd5c247da7483e888175">node_has_parent</a> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u) const noexcept</td></tr>
<tr class="memdesc:aea9359d7279ddd5c247da7483e888175"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does a node have a parent vertex?  <br /></td></tr>
<tr class="separator:aea9359d7279ddd5c247da7483e888175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade2f568db839f6ec8a6cdda5c49d86d8" id="r_ade2f568db839f6ec8a6cdda5c49d86d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade2f568db839f6ec8a6cdda5c49d86d8">get_parent_node</a> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u) const noexcept</td></tr>
<tr class="memdesc:ade2f568db839f6ec8a6cdda5c49d86d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parent vertex of a node.  <br /></td></tr>
<tr class="separator:ade2f568db839f6ec8a6cdda5c49d86d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a97b71616cedb7523b1ee712c30e4c1" id="r_a3a97b71616cedb7523b1ee712c30e4c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1directed__graph.html#a3a97b71616cedb7523b1ee712c30e4c1">reserve_in_degree</a> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u, const uint64_t d) noexcept</td></tr>
<tr class="memdesc:a3a97b71616cedb7523b1ee712c30e4c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicts that the in-degree of node <em>u</em> is <em>d</em>.  <br /></td></tr>
<tr class="separator:a3a97b71616cedb7523b1ee712c30e4c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5f661e1f74f01757e0fb980aaf77562" id="r_ad5f661e1f74f01757e0fb980aaf77562"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1directed__graph.html#ad5f661e1f74f01757e0fb980aaf77562">reserve_out_degree</a> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u, const uint64_t d) noexcept</td></tr>
<tr class="memdesc:ad5f661e1f74f01757e0fb980aaf77562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicts that the out-degree of node <em>u</em> is <em>d</em>.  <br /></td></tr>
<tr class="separator:ad5f661e1f74f01757e0fb980aaf77562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e4a81d38587995cb990e21e28aaf2b4" id="r_a4e4a81d38587995cb990e21e28aaf2b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1directed__graph.html#a4e4a81d38587995cb990e21e28aaf2b4">normalize</a> () noexcept</td></tr>
<tr class="memdesc:a4e4a81d38587995cb990e21e28aaf2b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalizes the graph.  <br /></td></tr>
<tr class="separator:a4e4a81d38587995cb990e21e28aaf2b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23b10c47032b774696a5ed970b059cdb" id="r_a23b10c47032b774696a5ed970b059cdb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1directed__graph.html#a23b10c47032b774696a5ed970b059cdb">check_normalized</a> () noexcept</td></tr>
<tr class="memdesc:a23b10c47032b774696a5ed970b059cdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the graph is normalized.  <br /></td></tr>
<tr class="separator:a23b10c47032b774696a5ed970b059cdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a116071bf1763e9454e1fc047b6c236d8" id="r_a116071bf1763e9454e1fc047b6c236d8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacelal.html#a235d5351556fbc73aa51767ab7765f5c">edge_pair</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1directed__graph.html#a116071bf1763e9454e1fc047b6c236d8">get_Q</a> () const noexcept</td></tr>
<tr class="memdesc:a116071bf1763e9454e1fc047b6c236d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all independent pairs of edges of this graph.  <br /></td></tr>
<tr class="separator:a116071bf1763e9454e1fc047b6c236d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af914b8032445902d03cc4861a8ae976e" id="r_af914b8032445902d03cc4861a8ae976e"><td class="memItemLeft" align="right" valign="top"><a id="af914b8032445902d03cc4861a8ae976e" name="af914b8032445902d03cc4861a8ae976e"></a>
std::vector&lt; <a class="el" href="namespacelal.html#a5969ec7ecc85697ebb9ec0ace78fbcab">edge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>get_edges</b> () const noexcept</td></tr>
<tr class="memdesc:af914b8032445902d03cc4861a8ae976e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all edges of this graph. <br /></td></tr>
<tr class="separator:af914b8032445902d03cc4861a8ae976e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab40bb57d0670a70df80568cf33ed823d" id="r_ab40bb57d0670a70df80568cf33ed823d"><td class="memItemLeft" align="right" valign="top"><a id="ab40bb57d0670a70df80568cf33ed823d" name="ab40bb57d0670a70df80568cf33ed823d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>has_edge</b> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u, const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> v) const noexcept</td></tr>
<tr class="memdesc:ab40bb57d0670a70df80568cf33ed823d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the edge \((u,v)\) exists in the graph. <br /></td></tr>
<tr class="separator:ab40bb57d0670a70df80568cf33ed823d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94834a6fb04411d06eda59f998d2ff02" id="r_a94834a6fb04411d06eda59f998d2ff02"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacelal.html#aef91d923414879a998619e9c65181d1f">neighbourhood</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1directed__graph.html#a94834a6fb04411d06eda59f998d2ff02">get_out_neighbors</a> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u) const noexcept</td></tr>
<tr class="memdesc:a94834a6fb04411d06eda59f998d2ff02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the out-neighbors of node <em>u</em>.  <br /></td></tr>
<tr class="separator:a94834a6fb04411d06eda59f998d2ff02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bd3b9aaaab43d22af76dea13c4c8371" id="r_a6bd3b9aaaab43d22af76dea13c4c8371"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacelal.html#aef91d923414879a998619e9c65181d1f">neighbourhood</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1directed__graph.html#a6bd3b9aaaab43d22af76dea13c4c8371">get_in_neighbors</a> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u) const noexcept</td></tr>
<tr class="memdesc:a6bd3b9aaaab43d22af76dea13c4c8371"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the in-neighbors of node <em>u</em>.  <br /></td></tr>
<tr class="separator:a6bd3b9aaaab43d22af76dea13c4c8371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3153114956055fc2e0a801a9418d2ecd" id="r_a3153114956055fc2e0a801a9418d2ecd"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1directed__graph.html#a3153114956055fc2e0a801a9418d2ecd">get_degree</a> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u) const noexcept</td></tr>
<tr class="memdesc:a3153114956055fc2e0a801a9418d2ecd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the in-degree plus the out-degree of this vertex.  <br /></td></tr>
<tr class="separator:a3153114956055fc2e0a801a9418d2ecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24cc0db004249dbb192698454d4ce78f" id="r_a24cc0db004249dbb192698454d4ce78f"><td class="memItemLeft" align="right" valign="top"><a id="a24cc0db004249dbb192698454d4ce78f" name="a24cc0db004249dbb192698454d4ce78f"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>get_out_degree</b> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u) const noexcept</td></tr>
<tr class="memdesc:a24cc0db004249dbb192698454d4ce78f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the out-degree of a node. <br /></td></tr>
<tr class="separator:a24cc0db004249dbb192698454d4ce78f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad08168cf9fd02b362013916bf308210" id="r_aad08168cf9fd02b362013916bf308210"><td class="memItemLeft" align="right" valign="top"><a id="aad08168cf9fd02b362013916bf308210" name="aad08168cf9fd02b362013916bf308210"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>get_in_degree</b> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u) const noexcept</td></tr>
<tr class="memdesc:aad08168cf9fd02b362013916bf308210"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the in-degree of a node. <br /></td></tr>
<tr class="separator:aad08168cf9fd02b362013916bf308210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40812da7f1cd9096226472b46645b3d3" id="r_a40812da7f1cd9096226472b46645b3d3"><td class="memItemLeft" align="right" valign="top"><a id="a40812da7f1cd9096226472b46645b3d3" name="a40812da7f1cd9096226472b46645b3d3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_directed</b> () const noexcept</td></tr>
<tr class="memdesc:a40812da7f1cd9096226472b46645b3d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether this graph is directed or not. <br /></td></tr>
<tr class="separator:a40812da7f1cd9096226472b46645b3d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51dde332648558ee729089cc30e67b6a" id="r_a51dde332648558ee729089cc30e67b6a"><td class="memItemLeft" align="right" valign="top"><a id="a51dde332648558ee729089cc30e67b6a" name="a51dde332648558ee729089cc30e67b6a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_undirected</b> () const noexcept</td></tr>
<tr class="memdesc:a51dde332648558ee729089cc30e67b6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether this graph is undirected or not. <br /></td></tr>
<tr class="separator:a51dde332648558ee729089cc30e67b6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7bfd2d96d5110a7bf0d56c4df1618fd" id="r_ad7bfd2d96d5110a7bf0d56c4df1618fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">undirected_graph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1directed__graph.html#ad7bfd2d96d5110a7bf0d56c4df1618fd">to_undirected</a> (const bool norm=true, const bool check=true) const noexcept</td></tr>
<tr class="memdesc:ad7bfd2d96d5110a7bf0d56c4df1618fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts this directed graph into an undirected graph.  <br /></td></tr>
<tr class="separator:ad7bfd2d96d5110a7bf0d56c4df1618fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc67c1ae0083dd89d8ec867e069d5c1a" id="r_adc67c1ae0083dd89d8ec867e069d5c1a"><td class="memItemLeft" align="right" valign="top"><a id="adc67c1ae0083dd89d8ec867e069d5c1a" name="adc67c1ae0083dd89d8ec867e069d5c1a"></a>
std::vector&lt; <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">directed_graph</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>get_connected_components</b> () const noexcept</td></tr>
<tr class="memdesc:adc67c1ae0083dd89d8ec867e069d5c1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all the connected components of this graph as individual graphs. <br /></td></tr>
<tr class="separator:adc67c1ae0083dd89d8ec867e069d5c1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25c8d57865fa5f7cb5d101fd5d07fe2d" id="r_a25c8d57865fa5f7cb5d101fd5d07fe2d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1tree.html#a25c8d57865fa5f7cb5d101fd5d07fe2d">is_tree</a> () const noexcept</td></tr>
<tr class="memdesc:a25c8d57865fa5f7cb5d101fd5d07fe2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this graph an actual tree?  <br /></td></tr>
<tr class="separator:a25c8d57865fa5f7cb5d101fd5d07fe2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19e1904c2b9fe5c62237517c618ce71b" id="r_a19e1904c2b9fe5c62237517c618ce71b"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1tree.html#a19e1904c2b9fe5c62237517c618ce71b">get_component_representative</a> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u) const noexcept</td></tr>
<tr class="memdesc:a19e1904c2b9fe5c62237517c618ce71b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representative node of the connected component in which <em>u</em> belongs.  <br /></td></tr>
<tr class="separator:a19e1904c2b9fe5c62237517c618ce71b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a680f3d15750907dfd5183ec76b5fa7f8" id="r_a680f3d15750907dfd5183ec76b5fa7f8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1tree.html#a680f3d15750907dfd5183ec76b5fa7f8">are_nodes_in_same_component</a> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u, const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> v) const noexcept</td></tr>
<tr class="memdesc:a680f3d15750907dfd5183ec76b5fa7f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two nodes are in the same connected component.  <br /></td></tr>
<tr class="separator:a680f3d15750907dfd5183ec76b5fa7f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54061e1790d0424cac8960a0a3277a99" id="r_a54061e1790d0424cac8960a0a3277a99"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1tree.html#a54061e1790d0424cac8960a0a3277a99">get_num_nodes_component</a> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u) const noexcept</td></tr>
<tr class="memdesc:a54061e1790d0424cac8960a0a3277a99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Amount of nodes in a connected component of the tree.  <br /></td></tr>
<tr class="separator:a54061e1790d0424cac8960a0a3277a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06ce8cc7afb074d2fecf70a0842adaaa" id="r_a06ce8cc7afb074d2fecf70a0842adaaa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1tree.html#a06ce8cc7afb074d2fecf70a0842adaaa">is_of_tree_type</a> (const <a class="el" href="namespacelal_1_1graphs.html#a18d52542088507e2be6241759722835b">tree_type</a> &amp;tt) const noexcept</td></tr>
<tr class="memdesc:a06ce8cc7afb074d2fecf70a0842adaaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether this tree is of type <em>tt</em>.  <br /></td></tr>
<tr class="separator:a06ce8cc7afb074d2fecf70a0842adaaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fc7f9e08db601f10982da6a01315cb3" id="r_a9fc7f9e08db601f10982da6a01315cb3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1tree.html#a9fc7f9e08db601f10982da6a01315cb3">is_tree_type_valid</a> () const noexcept</td></tr>
<tr class="memdesc:a9fc7f9e08db601f10982da6a01315cb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the type of this tree valid?  <br /></td></tr>
<tr class="separator:a9fc7f9e08db601f10982da6a01315cb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae51ce9ddffc9287f375545e2b2fec3e3" id="r_ae51ce9ddffc9287f375545e2b2fec3e3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1tree.html#ae51ce9ddffc9287f375545e2b2fec3e3">get_tree_type_list</a> () const noexcept</td></tr>
<tr class="memdesc:ae51ce9ddffc9287f375545e2b2fec3e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the list of types as a list of strings.  <br /></td></tr>
<tr class="separator:ae51ce9ddffc9287f375545e2b2fec3e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e3529632b38533c4be8b2a306a038c3" id="r_a0e3529632b38533c4be8b2a306a038c3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1graph.html#a0e3529632b38533c4be8b2a306a038c3">init</a> (const uint64_t n) noexcept</td></tr>
<tr class="memdesc:a0e3529632b38533c4be8b2a306a038c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates the necessary memory for this class.  <br /></td></tr>
<tr class="separator:a0e3529632b38533c4be8b2a306a038c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8ba9ec6acf2306c84d9ddbd88fc8474" id="r_af8ba9ec6acf2306c84d9ddbd88fc8474"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1graph.html#af8ba9ec6acf2306c84d9ddbd88fc8474">clear</a> () noexcept</td></tr>
<tr class="memdesc:af8ba9ec6acf2306c84d9ddbd88fc8474"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the memory occupied by this graph.  <br /></td></tr>
<tr class="separator:af8ba9ec6acf2306c84d9ddbd88fc8474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbe53e770688c22a8c1e614d728d11cc" id="r_abbe53e770688c22a8c1e614d728d11cc"><td class="memItemLeft" align="right" valign="top"><a id="abbe53e770688c22a8c1e614d728d11cc" name="abbe53e770688c22a8c1e614d728d11cc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_normalized</b> (const bool v=true) noexcept</td></tr>
<tr class="memdesc:abbe53e770688c22a8c1e614d728d11cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether this graph is normalized or not. <br /></td></tr>
<tr class="separator:abbe53e770688c22a8c1e614d728d11cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad2d7e6a53d8746c66e8af9762c14484" id="r_aad2d7e6a53d8746c66e8af9762c14484"><td class="memItemLeft" align="right" valign="top"><a id="aad2d7e6a53d8746c66e8af9762c14484" name="aad2d7e6a53d8746c66e8af9762c14484"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>has_node</b> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u) const noexcept</td></tr>
<tr class="memdesc:aad2d7e6a53d8746c66e8af9762c14484"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if node <em>u</em> is in this graph. <br /></td></tr>
<tr class="separator:aad2d7e6a53d8746c66e8af9762c14484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58918b2b3fe79dff35003604bdfa19f3" id="r_a58918b2b3fe79dff35003604bdfa19f3"><td class="memItemLeft" align="right" valign="top"><a id="a58918b2b3fe79dff35003604bdfa19f3" name="a58918b2b3fe79dff35003604bdfa19f3"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>get_num_nodes</b> () const noexcept</td></tr>
<tr class="memdesc:a58918b2b3fe79dff35003604bdfa19f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of ndoes. <br /></td></tr>
<tr class="separator:a58918b2b3fe79dff35003604bdfa19f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a351a7e8c6a0ec6c23026b0b0b57efd17" id="r_a351a7e8c6a0ec6c23026b0b0b57efd17"><td class="memItemLeft" align="right" valign="top"><a id="a351a7e8c6a0ec6c23026b0b0b57efd17" name="a351a7e8c6a0ec6c23026b0b0b57efd17"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>get_num_edges</b> () const noexcept</td></tr>
<tr class="memdesc:a351a7e8c6a0ec6c23026b0b0b57efd17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of edges. <br /></td></tr>
<tr class="separator:a351a7e8c6a0ec6c23026b0b0b57efd17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb9238eb8914e145736f1ac914f6b9d6" id="r_abb9238eb8914e145736f1ac914f6b9d6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1graph.html#abb9238eb8914e145736f1ac914f6b9d6">is_normalized</a> () const noexcept</td></tr>
<tr class="memdesc:abb9238eb8914e145736f1ac914f6b9d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether this graph is normalized or not.  <br /></td></tr>
<tr class="separator:abb9238eb8914e145736f1ac914f6b9d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ae644f013789ff98bcb57284059f89738" id="r_ae644f013789ff98bcb57284059f89738"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae644f013789ff98bcb57284059f89738">_init</a> (const uint64_t n) noexcept</td></tr>
<tr class="memdesc:ae644f013789ff98bcb57284059f89738"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the memory in the graph hierarchy.  <br /></td></tr>
<tr class="separator:ae644f013789ff98bcb57284059f89738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a70b515d28db827801c7dcea1a9799e" id="r_a1a70b515d28db827801c7dcea1a9799e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a70b515d28db827801c7dcea1a9799e">_clear</a> () noexcept</td></tr>
<tr class="memdesc:a1a70b515d28db827801c7dcea1a9799e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the memory in the graph hierarchy.  <br /></td></tr>
<tr class="separator:a1a70b515d28db827801c7dcea1a9799e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b6c5b10032d6486657af65fa1efb469" id="r_a1b6c5b10032d6486657af65fa1efb469"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b6c5b10032d6486657af65fa1efb469">actions_after_add_edge</a> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u, const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> v) noexcept</td></tr>
<tr class="memdesc:a1b6c5b10032d6486657af65fa1efb469"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do some extra work after the addition of an edge.  <br /></td></tr>
<tr class="separator:a1b6c5b10032d6486657af65fa1efb469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43f819b53ca12050c9afd4f7876706ae" id="r_a43f819b53ca12050c9afd4f7876706ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a43f819b53ca12050c9afd4f7876706ae">actions_after_add_edges</a> (const <a class="el" href="namespacelal.html#ab98936b00d896700a71899dff1ed9248">edge_list</a> &amp;e) noexcept</td></tr>
<tr class="memdesc:a43f819b53ca12050c9afd4f7876706ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do some extra work after the addition of several edges.  <br /></td></tr>
<tr class="separator:a43f819b53ca12050c9afd4f7876706ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c44f4a3b405b2140a21d221b85ab790" id="r_a1c44f4a3b405b2140a21d221b85ab790"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c44f4a3b405b2140a21d221b85ab790">actions_after_add_edges_bulk</a> () noexcept</td></tr>
<tr class="memdesc:a1c44f4a3b405b2140a21d221b85ab790"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do some extra work after the addition of several edges in bulk.  <br /></td></tr>
<tr class="separator:a1c44f4a3b405b2140a21d221b85ab790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a11bc77f5a58f731d76e51f013b8195" id="r_a7a11bc77f5a58f731d76e51f013b8195"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7a11bc77f5a58f731d76e51f013b8195">actions_after_remove_edge</a> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u, const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> v) noexcept</td></tr>
<tr class="memdesc:a7a11bc77f5a58f731d76e51f013b8195"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do some extra work after the removal of an edge.  <br /></td></tr>
<tr class="separator:a7a11bc77f5a58f731d76e51f013b8195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87f919e3637ce545101bd901ebf71a13" id="r_a87f919e3637ce545101bd901ebf71a13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a87f919e3637ce545101bd901ebf71a13">actions_after_remove_edges</a> (const <a class="el" href="namespacelal.html#ab98936b00d896700a71899dff1ed9248">edge_list</a> &amp;e) noexcept</td></tr>
<tr class="memdesc:a87f919e3637ce545101bd901ebf71a13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do some extra work after the removal of several edges.  <br /></td></tr>
<tr class="separator:a87f919e3637ce545101bd901ebf71a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5948c8e20e5feda6ae81e91a7b57be0e" id="r_a5948c8e20e5feda6ae81e91a7b57be0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5948c8e20e5feda6ae81e91a7b57be0e">actions_after_remove_edges_bulk</a> () noexcept</td></tr>
<tr class="memdesc:a5948c8e20e5feda6ae81e91a7b57be0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do some extra work after the removal of several edges in bulk.  <br /></td></tr>
<tr class="separator:a5948c8e20e5feda6ae81e91a7b57be0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02bc84af2dd2eb64d4eac9b21038100d" id="r_a02bc84af2dd2eb64d4eac9b21038100d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a02bc84af2dd2eb64d4eac9b21038100d">actions_before_remove_edges_incident_to</a> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u) noexcept</td></tr>
<tr class="memdesc:a02bc84af2dd2eb64d4eac9b21038100d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do some work before all edges incident to a node is removed.  <br /></td></tr>
<tr class="separator:a02bc84af2dd2eb64d4eac9b21038100d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a254e29f4c623d83fd3a67738d4ed8068" id="r_a254e29f4c623d83fd3a67738d4ed8068"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a254e29f4c623d83fd3a67738d4ed8068">actions_after_remove_node</a> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u) noexcept</td></tr>
<tr class="memdesc:a254e29f4c623d83fd3a67738d4ed8068"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do some work before the removal of a vertex.  <br /></td></tr>
<tr class="separator:a254e29f4c623d83fd3a67738d4ed8068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba129310bd758fa9cf03abceace19a4c" id="r_aba129310bd758fa9cf03abceace19a4c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba129310bd758fa9cf03abceace19a4c">update_union_find_after_add_edge</a> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u, const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> v, uint64_t *const root_of, uint64_t *const root_size) const noexcept</td></tr>
<tr class="memdesc:aba129310bd758fa9cf03abceace19a4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the union find data structure after an edge addition.  <br /></td></tr>
<tr class="separator:aba129310bd758fa9cf03abceace19a4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f13f1e17793bf01b693398287b2f9fa" id="r_a6f13f1e17793bf01b693398287b2f9fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6f13f1e17793bf01b693398287b2f9fa">update_union_find_after_add_edges</a> (const <a class="el" href="namespacelal.html#ab98936b00d896700a71899dff1ed9248">edge_list</a> &amp;edges, uint64_t *const root_of, uint64_t *const root_size) const noexcept</td></tr>
<tr class="memdesc:a6f13f1e17793bf01b693398287b2f9fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the union find data structure after the addition of a set of edges.  <br /></td></tr>
<tr class="separator:a6f13f1e17793bf01b693398287b2f9fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45f0c0a06ea7b5603b8f49708a372c92" id="r_a45f0c0a06ea7b5603b8f49708a372c92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45f0c0a06ea7b5603b8f49708a372c92">update_union_find_after_add_edges_bulk</a> (uint64_t *const root_of, uint64_t *const root_size) const noexcept</td></tr>
<tr class="memdesc:a45f0c0a06ea7b5603b8f49708a372c92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the union find data structure after the addition of several edges.  <br /></td></tr>
<tr class="separator:a45f0c0a06ea7b5603b8f49708a372c92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc881b926932ddeadd5823c751f51db4" id="r_abc881b926932ddeadd5823c751f51db4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc881b926932ddeadd5823c751f51db4">update_union_find_after_remove_edge</a> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u, const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> v, uint64_t *const root_of, uint64_t *const root_size) const noexcept</td></tr>
<tr class="memdesc:abc881b926932ddeadd5823c751f51db4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the union find data structure after an edge removal.  <br /></td></tr>
<tr class="separator:abc881b926932ddeadd5823c751f51db4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afce8358ccbbcb855c76091c736ddd90b" id="r_afce8358ccbbcb855c76091c736ddd90b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afce8358ccbbcb855c76091c736ddd90b">update_union_find_after_remove_edges</a> (const <a class="el" href="namespacelal.html#ab98936b00d896700a71899dff1ed9248">edge_list</a> &amp;edges, uint64_t *const root_of, uint64_t *const root_size) const noexcept</td></tr>
<tr class="memdesc:afce8358ccbbcb855c76091c736ddd90b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the union find data structure after the removal of a set of edges.  <br /></td></tr>
<tr class="separator:afce8358ccbbcb855c76091c736ddd90b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac41814d5fbe43cce354aa600f37b9c9f" id="r_ac41814d5fbe43cce354aa600f37b9c9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac41814d5fbe43cce354aa600f37b9c9f">update_union_find_after_remove_edges_bulk</a> (uint64_t *const root_of, uint64_t *const root_size) const noexcept</td></tr>
<tr class="memdesc:ac41814d5fbe43cce354aa600f37b9c9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the union find data structure after the removal of several edges.  <br /></td></tr>
<tr class="separator:ac41814d5fbe43cce354aa600f37b9c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84f5ebd803e3fd0dbda0a23306e7713e" id="r_a84f5ebd803e3fd0dbda0a23306e7713e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a84f5ebd803e3fd0dbda0a23306e7713e">update_union_find_before_remove_incident_edges_to</a> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u, uint64_t *const root_of, uint64_t *const root_size) const noexcept</td></tr>
<tr class="memdesc:a84f5ebd803e3fd0dbda0a23306e7713e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the union find data structure before the removal of all edges incident to a node.  <br /></td></tr>
<tr class="separator:a84f5ebd803e3fd0dbda0a23306e7713e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d116b07bf828274ee3edbddeffeee83" id="r_a0d116b07bf828274ee3edbddeffeee83"><td class="memItemLeft" align="right" valign="top"><a id="a0d116b07bf828274ee3edbddeffeee83" name="a0d116b07bf828274ee3edbddeffeee83"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>copy_full_rooted_tree</b> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">rooted_tree</a> &amp;r) noexcept</td></tr>
<tr class="memdesc:a0d116b07bf828274ee3edbddeffeee83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies all members of this class and the parent classes. <br /></td></tr>
<tr class="separator:a0d116b07bf828274ee3edbddeffeee83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addf9fd104124092fc78933ddb8a62be2" id="r_addf9fd104124092fc78933ddb8a62be2"><td class="memItemLeft" align="right" valign="top"><a id="addf9fd104124092fc78933ddb8a62be2" name="addf9fd104124092fc78933ddb8a62be2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>move_full_rooted_tree</b> (<a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">rooted_tree</a> &amp;&amp;r) noexcept</td></tr>
<tr class="memdesc:addf9fd104124092fc78933ddb8a62be2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves all members of this class and the parent classes. <br /></td></tr>
<tr class="separator:addf9fd104124092fc78933ddb8a62be2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dc067070236fec5b9fe626043732cf0" id="r_a2dc067070236fec5b9fe626043732cf0"><td class="memItemLeft" align="right" valign="top"><a id="a2dc067070236fec5b9fe626043732cf0" name="a2dc067070236fec5b9fe626043732cf0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>copy_full_directed_graph</b> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">directed_graph</a> &amp;d) noexcept</td></tr>
<tr class="memdesc:a2dc067070236fec5b9fe626043732cf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies all members of this class and the parent class. <br /></td></tr>
<tr class="separator:a2dc067070236fec5b9fe626043732cf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1876aab72e9c99dd94ed66b95682db85" id="r_a1876aab72e9c99dd94ed66b95682db85"><td class="memItemLeft" align="right" valign="top"><a id="a1876aab72e9c99dd94ed66b95682db85" name="a1876aab72e9c99dd94ed66b95682db85"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>move_full_directed_graph</b> (<a class="el" href="classlal_1_1graphs_1_1directed__graph.html">directed_graph</a> &amp;&amp;d) noexcept</td></tr>
<tr class="memdesc:a1876aab72e9c99dd94ed66b95682db85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves all members of this class and the parent class. <br /></td></tr>
<tr class="separator:a1876aab72e9c99dd94ed66b95682db85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a973468996f8ff425e9a37ae0788bc4c1" id="r_a973468996f8ff425e9a37ae0788bc4c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1tree.html#a973468996f8ff425e9a37ae0788bc4c1">tree_only_init</a> (const uint64_t n) noexcept</td></tr>
<tr class="memdesc:a973468996f8ff425e9a37ae0788bc4c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes only the memory of class <a class="el" href="classlal_1_1graphs_1_1tree.html">tree</a>.  <br /></td></tr>
<tr class="separator:a973468996f8ff425e9a37ae0788bc4c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade9b9ff890e9c0a809cdb39dd6a45d03" id="r_ade9b9ff890e9c0a809cdb39dd6a45d03"><td class="memItemLeft" align="right" valign="top"><a id="ade9b9ff890e9c0a809cdb39dd6a45d03" name="ade9b9ff890e9c0a809cdb39dd6a45d03"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>tree_only_clear</b> () noexcept</td></tr>
<tr class="memdesc:ade9b9ff890e9c0a809cdb39dd6a45d03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the memory used by only class <a class="el" href="classlal_1_1graphs_1_1tree.html">tree</a>. <br /></td></tr>
<tr class="separator:ade9b9ff890e9c0a809cdb39dd6a45d03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a98caa30febd772b6536f15aea33ea1" id="r_a3a98caa30febd772b6536f15aea33ea1"><td class="memItemLeft" align="right" valign="top"><a id="a3a98caa30febd772b6536f15aea33ea1" name="a3a98caa30febd772b6536f15aea33ea1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>tree_only_copy</b> (const <a class="el" href="classlal_1_1graphs_1_1tree.html">tree</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:a3a98caa30febd772b6536f15aea33ea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies only members of class <a class="el" href="classlal_1_1graphs_1_1tree.html">tree</a>. <br /></td></tr>
<tr class="separator:a3a98caa30febd772b6536f15aea33ea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c0ab812a8dead61f6e2e9253730f62a" id="r_a4c0ab812a8dead61f6e2e9253730f62a"><td class="memItemLeft" align="right" valign="top"><a id="a4c0ab812a8dead61f6e2e9253730f62a" name="a4c0ab812a8dead61f6e2e9253730f62a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>tree_only_move</b> (<a class="el" href="classlal_1_1graphs_1_1tree.html">tree</a> &amp;&amp;t) noexcept</td></tr>
<tr class="memdesc:a4c0ab812a8dead61f6e2e9253730f62a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves only members of class <a class="el" href="classlal_1_1graphs_1_1tree.html">tree</a>. <br /></td></tr>
<tr class="separator:a4c0ab812a8dead61f6e2e9253730f62a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65d589c9cedc11dac39baca2c0c58001" id="r_a65d589c9cedc11dac39baca2c0c58001"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1tree.html#a65d589c9cedc11dac39baca2c0c58001">tree_only_add_node</a> () noexcept</td></tr>
<tr class="memdesc:a65d589c9cedc11dac39baca2c0c58001"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a node to this tree.  <br /></td></tr>
<tr class="separator:a65d589c9cedc11dac39baca2c0c58001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ca79711e18e398299a3beb42fe3cc41" id="r_a2ca79711e18e398299a3beb42fe3cc41"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1tree.html#a2ca79711e18e398299a3beb42fe3cc41">tree_only_invalidate</a> () noexcept</td></tr>
<tr class="memdesc:a2ca79711e18e398299a3beb42fe3cc41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalidates the aggregated information of the tree.  <br /></td></tr>
<tr class="separator:a2ca79711e18e398299a3beb42fe3cc41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaabba99bcbca589ec9f8f5d3c85e6b43" id="r_aaabba99bcbca589ec9f8f5d3c85e6b43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1tree.html#aaabba99bcbca589ec9f8f5d3c85e6b43">tree_only_actions_after_add_edge</a> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u, const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> v) noexcept</td></tr>
<tr class="memdesc:aaabba99bcbca589ec9f8f5d3c85e6b43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do some work after the addition of an edge.  <br /></td></tr>
<tr class="separator:aaabba99bcbca589ec9f8f5d3c85e6b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7e746b8d5c0cd8f53890f046aeceb65" id="r_aa7e746b8d5c0cd8f53890f046aeceb65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1tree.html#aa7e746b8d5c0cd8f53890f046aeceb65">tree_only_actions_after_add_edges</a> (const <a class="el" href="namespacelal.html#ab98936b00d896700a71899dff1ed9248">edge_list</a> &amp;e) noexcept</td></tr>
<tr class="memdesc:aa7e746b8d5c0cd8f53890f046aeceb65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do some work after the addition of several edges.  <br /></td></tr>
<tr class="separator:aa7e746b8d5c0cd8f53890f046aeceb65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac759e6c7f4bf5bf2cee25fa274d9d4d5" id="r_ac759e6c7f4bf5bf2cee25fa274d9d4d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1tree.html#ac759e6c7f4bf5bf2cee25fa274d9d4d5">tree_only_actions_after_add_edges_bulk</a> () noexcept</td></tr>
<tr class="memdesc:ac759e6c7f4bf5bf2cee25fa274d9d4d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do some work after the addition of several edges in bulk.  <br /></td></tr>
<tr class="separator:ac759e6c7f4bf5bf2cee25fa274d9d4d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ba179a3180253e6eeb62d5b8df22066" id="r_a5ba179a3180253e6eeb62d5b8df22066"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1tree.html#a5ba179a3180253e6eeb62d5b8df22066">tree_only_actions_after_add_edges_bulk_complete</a> () noexcept</td></tr>
<tr class="memdesc:a5ba179a3180253e6eeb62d5b8df22066"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do some work after the addition of several edges in bulk.  <br /></td></tr>
<tr class="separator:a5ba179a3180253e6eeb62d5b8df22066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a43cfff1504c7ff6bcba9cd03e4743d" id="r_a9a43cfff1504c7ff6bcba9cd03e4743d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1tree.html#a9a43cfff1504c7ff6bcba9cd03e4743d">tree_only_actions_after_remove_edges_bulk</a> () noexcept</td></tr>
<tr class="memdesc:a9a43cfff1504c7ff6bcba9cd03e4743d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do some work after the removal of several edges in bulk.  <br /></td></tr>
<tr class="separator:a9a43cfff1504c7ff6bcba9cd03e4743d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d35e95e2d86ec20bcf8609f8f6f6a68" id="r_a3d35e95e2d86ec20bcf8609f8f6f6a68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1tree.html#a3d35e95e2d86ec20bcf8609f8f6f6a68">tree_only_actions_after_remove_edges_bulk_complete</a> () noexcept</td></tr>
<tr class="memdesc:a3d35e95e2d86ec20bcf8609f8f6f6a68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do some work after the removal of several edges in bulk.  <br /></td></tr>
<tr class="separator:a3d35e95e2d86ec20bcf8609f8f6f6a68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9474e409a3b4feb4c5806ee74c59c8ca" id="r_a9474e409a3b4feb4c5806ee74c59c8ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1tree.html#a9474e409a3b4feb4c5806ee74c59c8ca">tree_only_actions_after_remove_edge</a> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u, const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> v) noexcept</td></tr>
<tr class="memdesc:a9474e409a3b4feb4c5806ee74c59c8ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do some work after the removal of an edge.  <br /></td></tr>
<tr class="separator:a9474e409a3b4feb4c5806ee74c59c8ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ff43145e03d8074cbc513e2fe827454" id="r_a5ff43145e03d8074cbc513e2fe827454"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1tree.html#a5ff43145e03d8074cbc513e2fe827454">tree_only_actions_after_remove_edges</a> (const <a class="el" href="namespacelal.html#ab98936b00d896700a71899dff1ed9248">edge_list</a> &amp;e) noexcept</td></tr>
<tr class="memdesc:a5ff43145e03d8074cbc513e2fe827454"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do some work after the removal of several edges.  <br /></td></tr>
<tr class="separator:a5ff43145e03d8074cbc513e2fe827454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abca6ea36ec8d9b891395aaef69ece840" id="r_abca6ea36ec8d9b891395aaef69ece840"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1tree.html#abca6ea36ec8d9b891395aaef69ece840">tree_only_actions_after_remove_node</a> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u) noexcept</td></tr>
<tr class="memdesc:abca6ea36ec8d9b891395aaef69ece840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do some work before the removal of a vertex.  <br /></td></tr>
<tr class="separator:abca6ea36ec8d9b891395aaef69ece840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76ad30a023ad9b9bd3dd69bb350051ee" id="r_a76ad30a023ad9b9bd3dd69bb350051ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1tree.html#a76ad30a023ad9b9bd3dd69bb350051ee">tree_only_actions_before_remove_edges_incident_to</a> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u) noexcept</td></tr>
<tr class="memdesc:a76ad30a023ad9b9bd3dd69bb350051ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do some work before the removal of all edges incident to a vertex.  <br /></td></tr>
<tr class="separator:a76ad30a023ad9b9bd3dd69bb350051ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee4660ac324fd19a342f2369cf4f796f" id="r_aee4660ac324fd19a342f2369cf4f796f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1tree.html#aee4660ac324fd19a342f2369cf4f796f">tree_only_set_edges</a> () noexcept</td></tr>
<tr class="memdesc:aee4660ac324fd19a342f2369cf4f796f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the data structures of a tree after the graph structure has had its set of edges set.  <br /></td></tr>
<tr class="separator:aee4660ac324fd19a342f2369cf4f796f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00d8733492f1bba18638506af2a19d7e" id="r_a00d8733492f1bba18638506af2a19d7e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1tree.html#a00d8733492f1bba18638506af2a19d7e">tree_only_remove_node</a> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u) noexcept</td></tr>
<tr class="memdesc:a00d8733492f1bba18638506af2a19d7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a vertex from the union-find data structure.  <br /></td></tr>
<tr class="separator:a00d8733492f1bba18638506af2a19d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48fd37ac155705661e59e72b61bf9c75" id="r_a48fd37ac155705661e59e72b61bf9c75"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1tree.html#a48fd37ac155705661e59e72b61bf9c75">fill_union_find</a> () noexcept</td></tr>
<tr class="separator:a48fd37ac155705661e59e72b61bf9c75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61b72cd7fb8d43a96ae33436dbb12a35" id="r_a61b72cd7fb8d43a96ae33436dbb12a35"><td class="memItemLeft" align="right" valign="top"><a id="a61b72cd7fb8d43a96ae33436dbb12a35" name="a61b72cd7fb8d43a96ae33436dbb12a35"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>empty_union_find</b> () noexcept</td></tr>
<tr class="memdesc:a61b72cd7fb8d43a96ae33436dbb12a35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empties the Union-Find data structure assuming that the tree has no edges. <br /></td></tr>
<tr class="separator:a61b72cd7fb8d43a96ae33436dbb12a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ea60f01e9535ae965e54b9caa3d08fd" id="r_a0ea60f01e9535ae965e54b9caa3d08fd"><td class="memItemLeft" align="right" valign="top"><a id="a0ea60f01e9535ae965e54b9caa3d08fd" name="a0ea60f01e9535ae965e54b9caa3d08fd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>copy_full_graph</b> (const <a class="el" href="classlal_1_1graphs_1_1graph.html">graph</a> &amp;g) noexcept</td></tr>
<tr class="memdesc:a0ea60f01e9535ae965e54b9caa3d08fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies all members of this class. <br /></td></tr>
<tr class="separator:a0ea60f01e9535ae965e54b9caa3d08fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca19fcaa6d290a97c92ef95df92160ae" id="r_aca19fcaa6d290a97c92ef95df92160ae"><td class="memItemLeft" align="right" valign="top"><a id="aca19fcaa6d290a97c92ef95df92160ae" name="aca19fcaa6d290a97c92ef95df92160ae"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>move_full_graph</b> (<a class="el" href="classlal_1_1graphs_1_1graph.html">graph</a> &amp;&amp;g) noexcept</td></tr>
<tr class="memdesc:aca19fcaa6d290a97c92ef95df92160ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves all members of this class. <br /></td></tr>
<tr class="separator:aca19fcaa6d290a97c92ef95df92160ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb30bc5c7c927a2b32c2db7e0fcfeeee" id="r_aeb30bc5c7c927a2b32c2db7e0fcfeeee"><td class="memItemLeft" align="right" valign="top"><a id="aeb30bc5c7c927a2b32c2db7e0fcfeeee" name="aeb30bc5c7c927a2b32c2db7e0fcfeeee"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>__add_node</b> () noexcept</td></tr>
<tr class="memdesc:aeb30bc5c7c927a2b32c2db7e0fcfeeee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a node to the graph. <br /></td></tr>
<tr class="separator:aeb30bc5c7c927a2b32c2db7e0fcfeeee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2953c51682d770519cac771dc26c77ee" id="r_a2953c51682d770519cac771dc26c77ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1graph.html#a2953c51682d770519cac771dc26c77ee">__disjoint_union</a> (const <a class="el" href="classlal_1_1graphs_1_1graph.html">graph</a> &amp;g) noexcept</td></tr>
<tr class="memdesc:a2953c51682d770519cac771dc26c77ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disjoint union of graphs.  <br /></td></tr>
<tr class="separator:a2953c51682d770519cac771dc26c77ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a697a6199daaf909ae4d4f00ef70768b9" id="r_a697a6199daaf909ae4d4f00ef70768b9"><td class="memItemLeft" align="right" valign="top"><a id="a697a6199daaf909ae4d4f00ef70768b9" name="a697a6199daaf909ae4d4f00ef70768b9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>normalize_after_edge_addition</b> (const bool norm, const bool check) noexcept</td></tr>
<tr class="memdesc:a697a6199daaf909ae4d4f00ef70768b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize the graph after one (or more) edges have been added. <br /></td></tr>
<tr class="separator:a697a6199daaf909ae4d4f00ef70768b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31aee9e64b4839cb154c843c92c52507" id="r_a31aee9e64b4839cb154c843c92c52507"><td class="memItemLeft" align="right" valign="top"><a id="a31aee9e64b4839cb154c843c92c52507" name="a31aee9e64b4839cb154c843c92c52507"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>normalize_after_edge_removal</b> (const bool norm, const bool check) noexcept</td></tr>
<tr class="memdesc:a31aee9e64b4839cb154c843c92c52507"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize the graph after one (or more) edges have been removed. <br /></td></tr>
<tr class="separator:a31aee9e64b4839cb154c843c92c52507"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a3ba3e8552768ecaeef08c7db18e32823" id="r_a3ba3e8552768ecaeef08c7db18e32823"><td class="memItemLeft" align="right" valign="top"><a id="a3ba3e8552768ecaeef08c7db18e32823" name="a3ba3e8552768ecaeef08c7db18e32823"></a>
std::optional&lt; <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_root</b></td></tr>
<tr class="memdesc:a3ba3e8552768ecaeef08c7db18e32823"><td class="mdescLeft">&#160;</td><td class="mdescRight">Root of the tree. <br /></td></tr>
<tr class="separator:a3ba3e8552768ecaeef08c7db18e32823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8552f04dac202192255315d5c2fc7350" id="r_a8552f04dac202192255315d5c2fc7350"><td class="memItemLeft" align="right" valign="top">std::vector&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8552f04dac202192255315d5c2fc7350">m_size_subtrees</a></td></tr>
<tr class="memdesc:a8552f04dac202192255315d5c2fc7350"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of nodes of the subtrees rooted at a certain node.  <br /></td></tr>
<tr class="separator:a8552f04dac202192255315d5c2fc7350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd4774311bba4ffa6fa96d03a39df2be" id="r_afd4774311bba4ffa6fa96d03a39df2be"><td class="memItemLeft" align="right" valign="top"><a id="afd4774311bba4ffa6fa96d03a39df2be" name="afd4774311bba4ffa6fa96d03a39df2be"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>m_are_size_subtrees_valid</b> = false</td></tr>
<tr class="memdesc:afd4774311bba4ffa6fa96d03a39df2be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Are the contents of <a class="el" href="#a8552f04dac202192255315d5c2fc7350">m_size_subtrees</a> valid? <br /></td></tr>
<tr class="separator:afd4774311bba4ffa6fa96d03a39df2be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c93720588444d26ed92436bed7fe756" id="r_a0c93720588444d26ed92436bed7fe756"><td class="memItemLeft" align="right" valign="top"><a id="a0c93720588444d26ed92436bed7fe756" name="a0c93720588444d26ed92436bed7fe756"></a>
std::vector&lt; <a class="el" href="namespacelal.html#aef91d923414879a998619e9c65181d1f">neighbourhood</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_in_adjacency_list</b></td></tr>
<tr class="memdesc:a0c93720588444d26ed92436bed7fe756"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-neighbors for every node. <br /></td></tr>
<tr class="separator:a0c93720588444d26ed92436bed7fe756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0be40a4f9c7df1eb2dcbbe7b417ce73" id="r_ac0be40a4f9c7df1eb2dcbbe7b417ce73"><td class="memItemLeft" align="right" valign="top"><a id="ac0be40a4f9c7df1eb2dcbbe7b417ce73" name="ac0be40a4f9c7df1eb2dcbbe7b417ce73"></a>
std::vector&lt; <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_union_find__root_of</b></td></tr>
<tr class="memdesc:ac0be40a4f9c7df1eb2dcbbe7b417ce73"><td class="mdescLeft">&#160;</td><td class="mdescRight">The root of every vertex in the union-find data structure. <br /></td></tr>
<tr class="separator:ac0be40a4f9c7df1eb2dcbbe7b417ce73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11bb51b8c210daa43ad5bf6d11bfd35f" id="r_a11bb51b8c210daa43ad5bf6d11bfd35f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1tree.html#a11bb51b8c210daa43ad5bf6d11bfd35f">m_union_find__root_size</a></td></tr>
<tr class="memdesc:a11bb51b8c210daa43ad5bf6d11bfd35f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of the connected component that a <em>root</em> belongs to.  <br /></td></tr>
<tr class="separator:a11bb51b8c210daa43ad5bf6d11bfd35f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac27ba83912b248cd1160e0c6a0147b35" id="r_ac27ba83912b248cd1160e0c6a0147b35"><td class="memItemLeft" align="right" valign="top"><a id="ac27ba83912b248cd1160e0c6a0147b35" name="ac27ba83912b248cd1160e0c6a0147b35"></a>
std::array&lt; bool, <a class="el" href="namespacelal_1_1graphs.html#a1895a9ed855ad1d85cd9510de714a732">__tree_type_size</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_tree_type</b></td></tr>
<tr class="memdesc:ac27ba83912b248cd1160e0c6a0147b35"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of this tree. <br /></td></tr>
<tr class="separator:ac27ba83912b248cd1160e0c6a0147b35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a951a57e760385ce3de285089627b7bbb" id="r_a951a57e760385ce3de285089627b7bbb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1tree.html#a951a57e760385ce3de285089627b7bbb">m_is_tree_type_valid</a> = false</td></tr>
<tr class="memdesc:a951a57e760385ce3de285089627b7bbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the type of this tree valid?  <br /></td></tr>
<tr class="separator:a951a57e760385ce3de285089627b7bbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad87c640988218838def15ea96645bb84" id="r_ad87c640988218838def15ea96645bb84"><td class="memItemLeft" align="right" valign="top"><a id="ad87c640988218838def15ea96645bb84" name="ad87c640988218838def15ea96645bb84"></a>
std::vector&lt; <a class="el" href="namespacelal.html#aef91d923414879a998619e9c65181d1f">neighbourhood</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_adjacency_list</b></td></tr>
<tr class="memdesc:ad87c640988218838def15ea96645bb84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure that implements the graph. <br /></td></tr>
<tr class="separator:ad87c640988218838def15ea96645bb84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a028261ff75ed8e624f4f3fee4e3c5c06" id="r_a028261ff75ed8e624f4f3fee4e3c5c06"><td class="memItemLeft" align="right" valign="top"><a id="a028261ff75ed8e624f4f3fee4e3c5c06" name="a028261ff75ed8e624f4f3fee4e3c5c06"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>m_num_edges</b> = 0</td></tr>
<tr class="memdesc:a028261ff75ed8e624f4f3fee4e3c5c06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Amount of edges of this graph. <br /></td></tr>
<tr class="separator:a028261ff75ed8e624f4f3fee4e3c5c06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a427d63b1bef991f43db8f5d622567bb6" id="r_a427d63b1bef991f43db8f5d622567bb6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1graph.html#a427d63b1bef991f43db8f5d622567bb6">m_is_normalized</a> = true</td></tr>
<tr class="memdesc:a427d63b1bef991f43db8f5d622567bb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this graph normalized?  <br /></td></tr>
<tr class="separator:a427d63b1bef991f43db8f5d622567bb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ac333b30d221d8c5da985b09247d6e09c" id="r_ac333b30d221d8c5da985b09247d6e09c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1graphs_1_1directed__graph.html">directed_graph</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac333b30d221d8c5da985b09247d6e09c">disjoint_union</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">directed_graph</a> &amp;g) noexcept</td></tr>
<tr class="memdesc:ac333b30d221d8c5da985b09247d6e09c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disjoint union of graphs.  <br /></td></tr>
<tr class="separator:ac333b30d221d8c5da985b09247d6e09c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae3aa64a0f37563dbb8b9473eeba7ced" id="r_aae3aa64a0f37563dbb8b9473eeba7ced"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">directed_graph</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae3aa64a0f37563dbb8b9473eeba7ced">remove_node</a> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u, const bool norm=true, const bool check_norm=true) noexcept</td></tr>
<tr class="memdesc:aae3aa64a0f37563dbb8b9473eeba7ced"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a node from this graph.  <br /></td></tr>
<tr class="separator:aae3aa64a0f37563dbb8b9473eeba7ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49c96337e914f103b8e06d132b42102d" id="r_a49c96337e914f103b8e06d132b42102d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1directed__graph.html#a49c96337e914f103b8e06d132b42102d">remove_single_edge</a> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u, const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> v, <a class="el" href="namespacelal.html#aef91d923414879a998619e9c65181d1f">neighbourhood</a> &amp;out_u, <a class="el" href="namespacelal.html#aef91d923414879a998619e9c65181d1f">neighbourhood</a> &amp;in_v) noexcept</td></tr>
<tr class="memdesc:a49c96337e914f103b8e06d132b42102d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a single edge.  <br /></td></tr>
<tr class="separator:a49c96337e914f103b8e06d132b42102d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Rooted tree graph class. </p>
<p>This class provides its users with an abstraction of rooted trees. Rooted trees are free trees in which one vertex has been designated as the root. Furthermore, in the context of this library, these trees' edges are always oriented towards the leaves (away from the root); this is known as an arborescence. Many methods require objects of this class to be valid rooted trees: the object must be a tree (see <a class="el" href="classlal_1_1graphs_1_1tree.html#a25c8d57865fa5f7cb5d101fd5d07fe2d">is_tree</a>), must have a root (see <a class="el" href="#a8bd08e2ff59bf1037d70db8199543b2a">has_root</a>), and be a valid rooted tree (see <a class="el" href="#af464d98b1b5dfdbaaacea553d9c89154">is_rooted_tree</a>).</p>
<p>Rooted trees can be constructed in two different ways:</p><ul>
<li>Using an already-constructed free tree via a class constructor, where users have to indicate the root (either <a class="el" href="#ab42eb737eebdee2e8602f8c02a5a57f7">rooted_tree(const lal::graphs::free_tree&amp;, node, bool, bool)</a> or <a class="el" href="#a89c6d30586506028567a3ef5e5c85e4b">rooted_tree(lal::graphs::free_tree&amp;&amp;, node, bool, bool)</a>). Alternatively, one can use the method <a class="el" href="#ad35cda8a4fa8de6fcc9c92b8a132f21b">init_rooted</a>, which has the same set of parameters.</li>
<li>Adding edge after edge. In this class, as in <a class="el" href="classlal_1_1graphs_1_1free__tree.html">lal::graphs::free_tree</a>, this addition is constrained so that the underlying undirected graph does not contain cycles. Before (or after) the addition of all the edges, it is recommended the root be set using <a class="el" href="#a315021f4b8de00b99996d45c5bbb9c4a">set_root</a>.</li>
</ul>
<p>Adding edges one by one has a serious drawback. In case the edges do not have a consistent orientation (either always pointing away from the root or always pointing towards it), the resulting graph is not considered to be a valid rooted tree (see <a class="el" href="#af464d98b1b5dfdbaaacea553d9c89154">is_rooted_tree</a>). Therefore, consider the use of methods <a class="el" href="#a273d4cd55ab0ed2b35891f00b74a5e92">can_add_edge</a> or <a class="el" href="#ac66708cc747974506d27201655fa78bb">can_add_edges</a>. Recall that removal of edges is allowed at every moment.</p>
<p>The root allows defining further properties on these graphs. For example, the user can query information regarding subtrees of a particular rooted tree (see methods <a class="el" href="#ae6be97ab69d1c8bf6f085bef3cebbdfb">get_num_nodes_subtree</a>, <a class="el" href="#a5682b09580f720e6931f811d8b13659f">calculate_size_subtrees</a>, <a class="el" href="#a8d47b0d4f67a1b214eb120e5cb6c18ed">get_edges_subtree</a>, and <a class="el" href="#aecd3d53ae80a7aeb705bc5a3c543e901">get_subtree</a>). Not every vertex can be a root of the tree: in general, only those vertices with in-degree 0 can (see <a class="el" href="#a6e9cff34e745fb4b9388f73f91f43729">is_root_valid</a>).</p>
<p>This class allows flexibility of use of rooted trees regarding the root's choice (within the valid possibilities). Method <a class="el" href="#a315021f4b8de00b99996d45c5bbb9c4a">set_root</a> allows changing the root of rooted trees multiple times and at any time. However, when the tree has all of its edges then only one vertex can be the root (that with in-degree 0). For this reason, in case a user wants to build "different rooted
trees on different roots", it is strongly recommended that first a <a class="el" href="classlal_1_1graphs_1_1free__tree.html">lal::graphs::free_tree</a> is built, and then create a rooted tree using one of the two constructors with a free tree (either <a class="el" href="#ab42eb737eebdee2e8602f8c02a5a57f7">rooted_tree(const lal::graphs::free_tree&amp;, node, bool, bool)</a>, or <a class="el" href="#a89c6d30586506028567a3ef5e5c85e4b">rooted_tree(lal::graphs::free_tree&amp;&amp;, node, bool, bool)</a>), or the method <a class="el" href="#ad35cda8a4fa8de6fcc9c92b8a132f21b">init_rooted</a>. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af6fa8f965afc59d4c0250ef118fa30da" name="af6fa8f965afc59d4c0250ef118fa30da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6fa8f965afc59d4c0250ef118fa30da">&#9670;&#160;</a></span>rooted_tree() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">lal::graphs::rooted_tree::rooted_tree </td>
          <td>(</td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor with number of nodes and root node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of vertices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a947af40c3256a42866b92fc20f61ec19" name="a947af40c3256a42866b92fc20f61ec19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a947af40c3256a42866b92fc20f61ec19">&#9670;&#160;</a></span>rooted_tree() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">lal::graphs::rooted_tree::rooted_tree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">directed_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor with directed graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>A directed graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Graph <em>t</em> is a tree. </dd></dl>

</div>
</div>
<a id="ac311b00ac5f2baa34353c37cd5be5d7b" name="ac311b00ac5f2baa34353c37cd5be5d7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac311b00ac5f2baa34353c37cd5be5d7b">&#9670;&#160;</a></span>rooted_tree() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">lal::graphs::rooted_tree::rooted_tree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlal_1_1graphs_1_1directed__graph.html">directed_graph</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor with directed graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>A directed graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Graph <em>t</em> is a tree. </dd></dl>

</div>
</div>
<a id="a976ef24f6dabb3d250f325e943e9b1c8" name="a976ef24f6dabb3d250f325e943e9b1c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a976ef24f6dabb3d250f325e943e9b1c8">&#9670;&#160;</a></span>rooted_tree() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">lal::graphs::rooted_tree::rooted_tree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">rooted_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>r</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Rooted tree. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a02a2243d59de6bdb05d973956388005d" name="a02a2243d59de6bdb05d973956388005d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02a2243d59de6bdb05d973956388005d">&#9670;&#160;</a></span>rooted_tree() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">lal::graphs::rooted_tree::rooted_tree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">rooted_tree</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>r</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Rooted tree. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab42eb737eebdee2e8602f8c02a5a57f7" name="ab42eb737eebdee2e8602f8c02a5a57f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab42eb737eebdee2e8602f8c02a5a57f7">&#9670;&#160;</a></span>rooted_tree() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">lal::graphs::rooted_tree::rooted_tree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">free_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>norm</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>check_norm</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor with free tree and root node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Free tree. </td></tr>
    <tr><td class="paramname">r</td><td>Root node. </td></tr>
    <tr><td class="paramname">norm</td><td>Normalize the graph after the deletion. </td></tr>
    <tr><td class="paramname">check_norm</td><td>If <em>norm</em> is false then, should we check whether the result is normalized or not? This might be useful in case the resulting graph is normalized. If <em>norm</em> is true then <em>check_norm</em> is ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Tree <em>t</em> is a valid free tree. </dd></dl>

</div>
</div>
<a id="a89c6d30586506028567a3ef5e5c85e4b" name="a89c6d30586506028567a3ef5e5c85e4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89c6d30586506028567a3ef5e5c85e4b">&#9670;&#160;</a></span>rooted_tree() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">lal::graphs::rooted_tree::rooted_tree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlal_1_1graphs_1_1free__tree.html">free_tree</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>norm</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>check_norm</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor with tree and root node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Free tree. </td></tr>
    <tr><td class="paramname">r</td><td>Root node. </td></tr>
    <tr><td class="paramname">norm</td><td>Normalize the graph after the deletion. </td></tr>
    <tr><td class="paramname">check_norm</td><td>If <em>norm</em> is false then, should we check whether the result is normalized or not? This might be useful in case the resulting graph is normalized. If <em>norm</em> is true then <em>check_norm</em> is ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Tree <em>t</em> is a valid free tree. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Tree <em>t</em> is moved and should not be used. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a2953c51682d770519cac771dc26c77ee" name="a2953c51682d770519cac771dc26c77ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2953c51682d770519cac771dc26c77ee">&#9670;&#160;</a></span>__disjoint_union()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::graph::__disjoint_union </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1graph.html">graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disjoint union of graphs. </p>
<p>Given a graph, append it to the current graph.</p>
<p>All the nodes in <em>g</em> are relabelled starting at <em>n</em>, the number of nodes of the current graph. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>This graph and <em>g</em> must be of the same type (both must be either undirected, or both directed). </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The graph is normalized only if it was normalized before the call and <em>g</em> is also normalized. </dd></dl>

</div>
</div>
<a id="a1a70b515d28db827801c7dcea1a9799e" name="a1a70b515d28db827801c7dcea1a9799e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a70b515d28db827801c7dcea1a9799e">&#9670;&#160;</a></span>_clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::rooted_tree::_clear </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the memory in the graph hierarchy. </p>
<p>Clears the memory of <a class="el" href="classlal_1_1graphs_1_1free__tree.html">lal::graphs::free_tree</a>, <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">lal::graphs::undirected_graph</a> and <a class="el" href="classlal_1_1graphs_1_1graph.html">lal::graphs::graph</a> classes. </p>

<p>Reimplemented from <a class="el" href="classlal_1_1graphs_1_1directed__graph.html#a59e0515f2b02a576e10289a633ada49d">lal::graphs::directed_graph</a>.</p>

</div>
</div>
<a id="ae644f013789ff98bcb57284059f89738" name="ae644f013789ff98bcb57284059f89738"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae644f013789ff98bcb57284059f89738">&#9670;&#160;</a></span>_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::rooted_tree::_init </td>
          <td>(</td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the memory in the graph hierarchy. </p>
<p>Initializes memory of <a class="el" href="classlal_1_1graphs_1_1free__tree.html">lal::graphs::free_tree</a>, <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">lal::graphs::undirected_graph</a> and <a class="el" href="classlal_1_1graphs_1_1graph.html">lal::graphs::graph</a> classes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of nodes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The graph is cleared. </dd></dl>

<p>Reimplemented from <a class="el" href="classlal_1_1graphs_1_1directed__graph.html#a3d94bc0b0b7d824c714e6980ddc5f6de">lal::graphs::directed_graph</a>.</p>

</div>
</div>
<a id="a1b6c5b10032d6486657af65fa1efb469" name="a1b6c5b10032d6486657af65fa1efb469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b6c5b10032d6486657af65fa1efb469">&#9670;&#160;</a></span>actions_after_add_edge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::rooted_tree::actions_after_add_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do some extra work after the addition of an edge. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>Node of the edge </td></tr>
    <tr><td class="paramname">v</td><td>Node of the edge </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classlal_1_1graphs_1_1directed__graph.html#ac0cf22c45fc8d6a3c5cd29e00af7b9df">lal::graphs::directed_graph</a>.</p>

</div>
</div>
<a id="a43f819b53ca12050c9afd4f7876706ae" name="a43f819b53ca12050c9afd4f7876706ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43f819b53ca12050c9afd4f7876706ae">&#9670;&#160;</a></span>actions_after_add_edges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::rooted_tree::actions_after_add_edges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ab98936b00d896700a71899dff1ed9248">edge_list</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do some extra work after the addition of several edges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>List of edges. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classlal_1_1graphs_1_1directed__graph.html#a20e37ab891e53364f706f157695eda33">lal::graphs::directed_graph</a>.</p>

</div>
</div>
<a id="a1c44f4a3b405b2140a21d221b85ab790" name="a1c44f4a3b405b2140a21d221b85ab790"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c44f4a3b405b2140a21d221b85ab790">&#9670;&#160;</a></span>actions_after_add_edges_bulk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::rooted_tree::actions_after_add_edges_bulk </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do some extra work after the addition of several edges in bulk. </p>
<p>This method should only be called after several calls to <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html#a3d9454ddfaef55219be3ef00ecac1189">undirected_graph::add_edge_bulk</a> or <a class="el" href="classlal_1_1graphs_1_1directed__graph.html#a2867b035b48ab54df5f60e3b065fea66">directed_graph::add_edge_bulk</a>. </p>

<p>Reimplemented from <a class="el" href="classlal_1_1graphs_1_1directed__graph.html#a39ea733e148d29496a6db24189788d1d">lal::graphs::directed_graph</a>.</p>

</div>
</div>
<a id="a7a11bc77f5a58f731d76e51f013b8195" name="a7a11bc77f5a58f731d76e51f013b8195"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a11bc77f5a58f731d76e51f013b8195">&#9670;&#160;</a></span>actions_after_remove_edge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::rooted_tree::actions_after_remove_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do some extra work after the removal of an edge. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>Node of the edge </td></tr>
    <tr><td class="paramname">v</td><td>Node of the edge </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classlal_1_1graphs_1_1directed__graph.html#a2fb2e27dacaed104276a13e7024cffc9">lal::graphs::directed_graph</a>.</p>

</div>
</div>
<a id="a87f919e3637ce545101bd901ebf71a13" name="a87f919e3637ce545101bd901ebf71a13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87f919e3637ce545101bd901ebf71a13">&#9670;&#160;</a></span>actions_after_remove_edges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::rooted_tree::actions_after_remove_edges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ab98936b00d896700a71899dff1ed9248">edge_list</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do some extra work after the removal of several edges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>List of edges. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classlal_1_1graphs_1_1directed__graph.html#af60a3b6149315d98468c34fc144d93a1">lal::graphs::directed_graph</a>.</p>

</div>
</div>
<a id="a5948c8e20e5feda6ae81e91a7b57be0e" name="a5948c8e20e5feda6ae81e91a7b57be0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5948c8e20e5feda6ae81e91a7b57be0e">&#9670;&#160;</a></span>actions_after_remove_edges_bulk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::rooted_tree::actions_after_remove_edges_bulk </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do some extra work after the removal of several edges in bulk. </p>
<p>This method should only be called after several calls to <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html#a741081cc0646053bcb5fd5809eb19a21">undirected_graph::remove_edge_bulk</a> or <a class="el" href="classlal_1_1graphs_1_1directed__graph.html#a655fbacfd749a62e61933ae19cb647cb">directed_graph::remove_edge_bulk</a>. </p>

<p>Reimplemented from <a class="el" href="classlal_1_1graphs_1_1directed__graph.html#a89d0c4e8dff527470d7ea96f75726756">lal::graphs::directed_graph</a>.</p>

</div>
</div>
<a id="a254e29f4c623d83fd3a67738d4ed8068" name="a254e29f4c623d83fd3a67738d4ed8068"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a254e29f4c623d83fd3a67738d4ed8068">&#9670;&#160;</a></span>actions_after_remove_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::rooted_tree::actions_after_remove_node </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do some work before the removal of a vertex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>Node to be removed. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classlal_1_1graphs_1_1directed__graph.html#a703e14070ff7eae72ddc3a4307344605">lal::graphs::directed_graph</a>.</p>

</div>
</div>
<a id="a02bc84af2dd2eb64d4eac9b21038100d" name="a02bc84af2dd2eb64d4eac9b21038100d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02bc84af2dd2eb64d4eac9b21038100d">&#9670;&#160;</a></span>actions_before_remove_edges_incident_to()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::rooted_tree::actions_before_remove_edges_incident_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do some work before all edges incident to a node is removed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>Node whose incident edges are to be removed. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classlal_1_1graphs_1_1directed__graph.html#afc7874bcad8a4ff2c3059b054f2e863b">lal::graphs::directed_graph</a>.</p>

</div>
</div>
<a id="a49939ad6dffc54cd4d58bc1506f28f6b" name="a49939ad6dffc54cd4d58bc1506f28f6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49939ad6dffc54cd4d58bc1506f28f6b">&#9670;&#160;</a></span>add_edge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">rooted_tree</a> &amp; lal::graphs::rooted_tree::add_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>norm</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>check_norm</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an edge to the tree. </p>
<p>This operation checks that the edge added does not produce cycles only in a <em>debug</em> compilation of the library. For a more controlled addition of the edges, see <a class="el" href="#a273d4cd55ab0ed2b35891f00b74a5e92">can_add_edge</a>.</p>
<p><b>For developers:</b> method <a class="el" href="classlal_1_1graphs_1_1graph.html#a82d1dd3ec710c4ccf60100298a6cb5a1">lal::graphs::graph::actions_after_add_edge</a> is called after the edge has been added. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Valid node index: \(0 \le s &lt; n\). </td></tr>
    <tr><td class="paramname">t</td><td>Valid node index: \(0 \le t &lt; n\). </td></tr>
    <tr><td class="paramname">norm</td><td>Should the graph be normalized? </td></tr>
    <tr><td class="paramname">check_norm</td><td>If <em>norm</em> is false then, should we check whether the result is normalized or not? This might be useful in case the resulting graph is normalized. If <em>norm</em> is true then <em>check_norm</em> is ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>\(s \neq t\) </dd>
<dd>
Edge \(\{s,t\}\) is not part of the graph. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>If <em>norm</em> is true the graph is guaranteed to be normalized after the addition of the edge. </dd></dl>

<p>Reimplemented from <a class="el" href="classlal_1_1graphs_1_1directed__graph.html#ad4fd30bc89da5485d2938ae9809d4dac">lal::graphs::directed_graph</a>.</p>

</div>
</div>
<a id="a71bb1763d7603eacd42a5e8ed91defba" name="a71bb1763d7603eacd42a5e8ed91defba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71bb1763d7603eacd42a5e8ed91defba">&#9670;&#160;</a></span>add_edge_bulk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">rooted_tree</a> &amp; lal::graphs::rooted_tree::add_edge_bulk </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an edge to the graph. </p>
<p>This method only adds an edge, and does no other work: normalisation is not checked, and no extra work per edge is done. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Valid node index: \(0 \le s &lt; n\). </td></tr>
    <tr><td class="paramname">t</td><td>Valid node index: \(0 \le t &lt; n\). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>\(u \neq v\). </dd>
<dd>
The edge \(\{s,t\}\) is not part of the graph. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>If <em>norm</em> is true the graph is guaranteed to be normalized after the addition of the edge. </dd></dl>

</div>
</div>
<a id="a48e3d3f8b72122e829616edeeee05dfb" name="a48e3d3f8b72122e829616edeeee05dfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48e3d3f8b72122e829616edeeee05dfb">&#9670;&#160;</a></span>add_edges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">rooted_tree</a> &amp; lal::graphs::rooted_tree::add_edges </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacelal.html#a5969ec7ecc85697ebb9ec0ace78fbcab">edge</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>edges</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>norm</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>check_norm</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a list of edges to the graph. </p>
<p>This function checks that edges will not produce cycles only in a <em>debug</em> compilation of the library. Moreover, this operation is faster than calling <a class="el" href="#a49939ad6dffc54cd4d58bc1506f28f6b">add_edge</a> since the edges are added in bulk. For a more controlled addition of the edges, see <a class="el" href="#ac66708cc747974506d27201655fa78bb">can_add_edges</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edges</td><td>The edges to be added. </td></tr>
    <tr><td class="paramname">norm</td><td>Normalize the graph after the insertions. </td></tr>
    <tr><td class="paramname">check_norm</td><td>If <em>norm</em> is false then, should we check whether the result is normalized or not? This might be useful in case the resulting graph is normalized. If <em>norm</em> is true then <em>check_norm</em> is ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>All the edges in <em>edges</em> must meet the precondition of method <a class="el" href="#a49939ad6dffc54cd4d58bc1506f28f6b">add_edge</a>. </dd>
<dd>
None of the subsets of the list of edges can produce cycles when added. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>If <em>norm</em> is true the graph is guaranteed to be normalized after the addition of the edges. </dd></dl>

<p>Reimplemented from <a class="el" href="classlal_1_1graphs_1_1directed__graph.html#a211ff1b1441b0c27b1e1dfed8514eed7">lal::graphs::directed_graph</a>.</p>

</div>
</div>
<a id="a680f3d15750907dfd5183ec76b5fa7f8" name="a680f3d15750907dfd5183ec76b5fa7f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a680f3d15750907dfd5183ec76b5fa7f8">&#9670;&#160;</a></span>are_nodes_in_same_component()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::graphs::tree::are_nodes_in_same_component </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if two nodes are in the same connected component. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>First node. </td></tr>
    <tr><td class="paramname">v</td><td>Second node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True or false. </dd></dl>

</div>
</div>
<a id="a8922eeacf0937020d3008b94516a448c" name="a8922eeacf0937020d3008b94516a448c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8922eeacf0937020d3008b94516a448c">&#9670;&#160;</a></span>are_nodes_siblings()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::graphs::rooted_tree::are_nodes_siblings </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Are two nodes siblings? </p>
<p>Do to two nodes share the same parent? </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>A node. </td></tr>
    <tr><td class="paramname">v</td><td>Another node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the nodes are siblings. False, if they are not. </dd></dl>

</div>
</div>
<a id="ae92039a5723afd79aec1934f2b145dda" name="ae92039a5723afd79aec1934f2b145dda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae92039a5723afd79aec1934f2b145dda">&#9670;&#160;</a></span>are_size_subtrees_valid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::graphs::rooted_tree::are_size_subtrees_valid </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is a recalculation of the subtree's sizes needed? </p>
<p>If the method returns <em>false</em> then the user should call <a class="el" href="#a5682b09580f720e6931f811d8b13659f">calculate_size_subtrees</a> so that the size of every rooted subtree is recalculated. This information must be calculated prior to calling many functions of this library. </p><dl class="section return"><dt>Returns</dt><dd>Whether <a class="el" href="#a8552f04dac202192255315d5c2fc7350">m_size_subtrees</a> should be recalculated or not. </dd></dl>

</div>
</div>
<a id="a5682b09580f720e6931f811d8b13659f" name="a5682b09580f720e6931f811d8b13659f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5682b09580f720e6931f811d8b13659f">&#9670;&#160;</a></span>calculate_size_subtrees()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::rooted_tree::calculate_size_subtrees </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the number of nodes at every rooted subtree. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The object must be a tree (see <a class="el" href="classlal_1_1graphs_1_1tree.html#a25c8d57865fa5f7cb5d101fd5d07fe2d">is_tree</a>). </dd>
<dd>
The tree must have a root (see <a class="el" href="#a8bd08e2ff59bf1037d70db8199543b2a">has_root</a>). </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Method <a class="el" href="#ae92039a5723afd79aec1934f2b145dda">are_size_subtrees_valid</a> returns true. </dd></dl>

</div>
</div>
<a id="aaaa55acc91cddcd44f95419b83706ae9" name="aaaa55acc91cddcd44f95419b83706ae9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaa55acc91cddcd44f95419b83706ae9">&#9670;&#160;</a></span>calculate_tree_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::rooted_tree::calculate_tree_type </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the type of tree. </p>
<p>See <a class="el" href="namespacelal_1_1graphs.html#a18d52542088507e2be6241759722835b">tree_type</a> for the list of different tree types. </p>

<p>Implements <a class="el" href="classlal_1_1graphs_1_1tree.html#aa8a453d924452a46b781f1cf6bfb8360">lal::graphs::tree</a>.</p>

</div>
</div>
<a id="a273d4cd55ab0ed2b35891f00b74a5e92" name="a273d4cd55ab0ed2b35891f00b74a5e92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a273d4cd55ab0ed2b35891f00b74a5e92">&#9670;&#160;</a></span>can_add_edge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::graphs::rooted_tree::can_add_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Can this edge be added? </p>
<p>In a tree, an edge can only be added if it does not produce cycles, and it has not been added before.</p>
<p>In a rooted tree, an edge can only be added if the in-degree of vertex <em>t</em> (see <a class="el" href="classlal_1_1graphs_1_1directed__graph.html#aad08168cf9fd02b362013916bf308210">directed_graph::get_in_degree</a>) is exactly 1 after adding the edge. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>First node of the edge. </td></tr>
    <tr><td class="paramname">t</td><td>Second node of the edge. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not this edge can be added to the tree without producing cycles. </dd></dl>

<p>Reimplemented from <a class="el" href="classlal_1_1graphs_1_1tree.html#a3003f7649ef64924ff688a6f30d67b26">lal::graphs::tree</a>.</p>

</div>
</div>
<a id="ac66708cc747974506d27201655fa78bb" name="ac66708cc747974506d27201655fa78bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac66708cc747974506d27201655fa78bb">&#9670;&#160;</a></span>can_add_edges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::graphs::rooted_tree::can_add_edges </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacelal.html#a5969ec7ecc85697ebb9ec0ace78fbcab">edge</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>edges</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Can these edges be added? </p>
<p>In a tree, a set of edges can only be added if their addition to the tree do not produce cycles and none of them have been added before.</p>
<p>In a rooted tree, edges \((s,t)\) can only be added if the in-degree of vertex <em>t</em> (see <a class="el" href="classlal_1_1graphs_1_1directed__graph.html#aad08168cf9fd02b362013916bf308210">directed_graph::get_in_degree</a>) is exactly 1 after adding the edge. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edges</td><td>List of edges. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not these edges can be added to the tree without producing cycles. </dd></dl>

<p>Reimplemented from <a class="el" href="classlal_1_1graphs_1_1tree.html#a6d52f3c3edace3159f0cf5e31631dd63">lal::graphs::tree</a>.</p>

</div>
</div>
<a id="a23b10c47032b774696a5ed970b059cdb" name="a23b10c47032b774696a5ed970b059cdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23b10c47032b774696a5ed970b059cdb">&#9670;&#160;</a></span>check_normalized()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::graphs::directed_graph::check_normalized </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the graph is normalized. </p>
<p>Checks, whether the graph's adjacency structure is normalized or not. In case it is, attribute <a class="el" href="classlal_1_1graphs_1_1graph.html#a427d63b1bef991f43db8f5d622567bb6">m_is_normalized</a> is set to true, so method <a class="el" href="classlal_1_1graphs_1_1graph.html#abb9238eb8914e145736f1ac914f6b9d6">is_normalized</a> evaluates to true. </p>

<p>Reimplemented from <a class="el" href="classlal_1_1graphs_1_1graph.html#a0beca99dbbaa1a1a27db6c4e2d280ea5">lal::graphs::graph</a>.</p>

</div>
</div>
<a id="af8ba9ec6acf2306c84d9ddbd88fc8474" name="af8ba9ec6acf2306c84d9ddbd88fc8474"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8ba9ec6acf2306c84d9ddbd88fc8474">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void lal::graphs::graph::clear </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Frees the memory occupied by this graph. </p>
<p>See <a class="el" href="#a1a70b515d28db827801c7dcea1a9799e">_clear</a> for details. </p><dl class="section post"><dt>Postcondition</dt><dd>The graph is normalized. The number of edges is 0. </dd></dl>

</div>
</div>
<a id="ac333b30d221d8c5da985b09247d6e09c" name="ac333b30d221d8c5da985b09247d6e09c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac333b30d221d8c5da985b09247d6e09c">&#9670;&#160;</a></span>disjoint_union() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1graphs_1_1directed__graph.html">directed_graph</a> &amp; lal::graphs::directed_graph::disjoint_union </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">directed_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disjoint union of graphs. </p>
<p>Given a graph, append it to the current graph.</p>
<p>All the nodes in <em>g</em> are relabelled starting at <em>n</em>, the number of nodes of the current graph. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>The graph is normalized only if it was normalized before the call and <em>g</em> is also normalized. </dd></dl>

</div>
</div>
<a id="adec23a6b7b6c10c80a9cdc595cdf91f2" name="adec23a6b7b6c10c80a9cdc595cdf91f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adec23a6b7b6c10c80a9cdc595cdf91f2">&#9670;&#160;</a></span>disjoint_union() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">rooted_tree</a> &amp; lal::graphs::rooted_tree::disjoint_union </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">rooted_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>connect_roots</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disjoint union of trees. </p>
<p>Append a rooted tree to this tree. All the nodes in <em>t</em> are relabelled starting at <em>n</em>, the number of nodes of the current tree. If the current graph has no vertices, then the whole input tree (and its state) is simply copied into this tree.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input tree. </td></tr>
    <tr><td class="paramname">connect_roots</td><td>The root of the current tree and the root of <em>t</em> are joined by an edge. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>If <em>connect_roots</em> is true then both trees need to have a root (see method <a class="el" href="#a8bd08e2ff59bf1037d70db8199543b2a">has_root</a>). </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The root (if set) of the current tree is kept. </dd>
<dd>
The size of the subtrees might need recalculating:<ul>
<li>If method <a class="el" href="#ae92039a5723afd79aec1934f2b145dda">are_size_subtrees_valid()</a> returns true for both trees then the subtree sizes are updated and do not need to be recalculated and method <a class="el" href="#ae92039a5723afd79aec1934f2b145dda">are_size_subtrees_valid()</a> still returns true.</li>
<li>If for one of the two graphs the method <a class="el" href="#ae92039a5723afd79aec1934f2b145dda">are_size_subtrees_valid()</a> returns false then it will still return false after this operation. </li>
</ul>
</dd>
<dd>
The graph resulting from the union is normalized only if the two graphs were normalized prior to the union. </dd>
<dd>
The type of tree is invalidated. </dd></dl>

</div>
</div>
<a id="a48fd37ac155705661e59e72b61bf9c75" name="a48fd37ac155705661e59e72b61bf9c75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48fd37ac155705661e59e72b61bf9c75">&#9670;&#160;</a></span>fill_union_find()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::tree::fill_union_find </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fills the Union-Find data structure assuming that the graph structure has all of its edges. </p>

</div>
</div>
<a id="a01453a5f86572b1d6097cf9a1067e73c" name="a01453a5f86572b1d6097cf9a1067e73c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01453a5f86572b1d6097cf9a1067e73c">&#9670;&#160;</a></span>finish_bulk_add()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::rooted_tree::finish_bulk_add </td>
          <td>(</td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>norm</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>check</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finishes adding edges in bulk. </p>
<p>This method updates the Union-Find data structure and all the necessary members after several calls to <a class="el" href="#a71bb1763d7603eacd42a5e8ed91defba">add_edge_bulk</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">norm</td><td>Normalize the tree. </td></tr>
    <tr><td class="paramname">check</td><td>Check whether the tree is normalized or not. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classlal_1_1graphs_1_1directed__graph.html#a21efb8e78ed211739b6d355bbfd29ad6">lal::graphs::directed_graph</a>.</p>

</div>
</div>
<a id="a57459861c9e1917d66b11f1515acdcaa" name="a57459861c9e1917d66b11f1515acdcaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57459861c9e1917d66b11f1515acdcaa">&#9670;&#160;</a></span>finish_bulk_add_complete()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::rooted_tree::finish_bulk_add_complete </td>
          <td>(</td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>norm</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>check</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Completes the inner structure of the tree after adding edges in bulk. </p>
<p>This is meant to be used after several calls to <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html#a3d9454ddfaef55219be3ef00ecac1189">undirected_graph::add_edge_bulk</a>, <a class="el" href="classlal_1_1graphs_1_1directed__graph.html#a2867b035b48ab54df5f60e3b065fea66">directed_graph::add_edge_bulk</a>.</p>
<p>This method completes the Union-Find data structure and the other necessary members assuming that the tree is now complete. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">norm</td><td>Normalize the graph. </td></tr>
    <tr><td class="paramname">check</td><td>Check wether the graph is normalized or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>All edges have been added with method <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html#a3d9454ddfaef55219be3ef00ecac1189">undirected_graph::add_edge_bulk</a> or <a class="el" href="classlal_1_1graphs_1_1directed__graph.html#a2867b035b48ab54df5f60e3b065fea66">directed_graph::add_edge_bulk</a>. </dd></dl>

<p>Implements <a class="el" href="classlal_1_1graphs_1_1tree.html#ab3b9064bc1a7dbf90dfd72dba20073af">lal::graphs::tree</a>.</p>

</div>
</div>
<a id="aa6a62c89130506333d5a7edd221ec5fd" name="aa6a62c89130506333d5a7edd221ec5fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6a62c89130506333d5a7edd221ec5fd">&#9670;&#160;</a></span>finish_bulk_remove()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::rooted_tree::finish_bulk_remove </td>
          <td>(</td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>norm</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>check</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finishes removing edges in bulk. </p>
<p>This method updates the Union-Find data structure and all the necessary members after several calls to <a class="el" href="#a34fc00e1d6e5e84b480dfaaab9ab69e9">remove_edge_bulk</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">norm</td><td>Normalize the tree. </td></tr>
    <tr><td class="paramname">check</td><td>Check whether the tree is normalized or not. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classlal_1_1graphs_1_1directed__graph.html#a890ef15b90aefcda8c6aba36f48a6f8e">lal::graphs::directed_graph</a>.</p>

</div>
</div>
<a id="a68010a9d89ab810721e4abf3ea5008e2" name="a68010a9d89ab810721e4abf3ea5008e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68010a9d89ab810721e4abf3ea5008e2">&#9670;&#160;</a></span>finish_bulk_remove_complete()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::rooted_tree::finish_bulk_remove_complete </td>
          <td>(</td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>norm</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>check</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Completes the inner structure of the tree after removing edges in bulk. </p>
<p>This is meant to be used after several calls to <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html#a741081cc0646053bcb5fd5809eb19a21">undirected_graph::remove_edge_bulk</a>, <a class="el" href="classlal_1_1graphs_1_1directed__graph.html#a655fbacfd749a62e61933ae19cb647cb">directed_graph::remove_edge_bulk</a>.</p>
<p>This method completes the Union-Find data structure and the other necessary members assuming that the tree is now empty. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">norm</td><td>Normalize the graph. </td></tr>
    <tr><td class="paramname">check</td><td>Check wether the graph is normalized or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>All edges have been added with method <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html#a741081cc0646053bcb5fd5809eb19a21">undirected_graph::remove_edge_bulk</a> or <a class="el" href="classlal_1_1graphs_1_1directed__graph.html#a655fbacfd749a62e61933ae19cb647cb">directed_graph::remove_edge_bulk</a>. </dd></dl>

<p>Implements <a class="el" href="classlal_1_1graphs_1_1tree.html#aed5dea71acee5dff70ae746de0fafcc9">lal::graphs::tree</a>.</p>

</div>
</div>
<a id="a19e1904c2b9fe5c62237517c618ce71b" name="a19e1904c2b9fe5c62237517c618ce71b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19e1904c2b9fe5c62237517c618ce71b">&#9670;&#160;</a></span>get_component_representative()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lal::graphs::tree::get_component_representative </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Representative node of the connected component in which <em>u</em> belongs. </p>
<p>If the current graph lacks some edges then it is clearly a forest, i.e., a series of disconnected components. This function returns a representative node of the connected component to which node <em>u</em> belongs.</p>
<p>Further, let \(cc(u)\) be the connected component of vertex <em>u</em>, and \(rep(cc(u))\) be the representative node of \(cc(u)\). For every other node \(v\in cc(u)\), this function will return the same representative node \(rep(cc(u))\). Therefore, \(rep(cc(u))=rep(cc(v))\) for every \(v\in cc(u)\). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>Input node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The representative node of node <em>u's</em> component. </dd></dl>

</div>
</div>
<a id="a3153114956055fc2e0a801a9418d2ecd" name="a3153114956055fc2e0a801a9418d2ecd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3153114956055fc2e0a801a9418d2ecd">&#9670;&#160;</a></span>get_degree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lal::graphs::directed_graph::get_degree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the in-degree plus the out-degree of this vertex. </p>
<p>Returns the degree of this vertex in its underlying undirected structure. Same as <a class="el" href="classlal_1_1graphs_1_1directed__graph.html#aad08168cf9fd02b362013916bf308210">get_in_degree</a> + <a class="el" href="classlal_1_1graphs_1_1directed__graph.html#a24cc0db004249dbb192698454d4ce78f">get_out_degree</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>Vertex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The (in + out) degree of this vertex. </dd></dl>

</div>
</div>
<a id="a8d47b0d4f67a1b214eb120e5cb6c18ed" name="a8d47b0d4f67a1b214eb120e5cb6c18ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d47b0d4f67a1b214eb120e5cb6c18ed">&#9670;&#160;</a></span>get_edges_subtree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespacelal.html#a5969ec7ecc85697ebb9ec0ace78fbcab">edge</a> &gt; lal::graphs::rooted_tree::get_edges_subtree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>relab</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the edges of the subtree rooted at <em>u</em>. </p>
<p>The list of edges returned contains labels that depend on the parameter <em>relab</em>. If <em>relab</em> is true then the nodes are relabelled to numbers in \([0, n_u)\), where \(n_u\) is the number of nodes of the subtree rooted at <em>u</em>, rather than keeping the original labelling of numbers in \([0,n)\), where <em>n</em> is the number of nodes of the tree.</p>
<p>For example, consider the following complete binary tree of 7 nodes, whose edges are </p><pre>
0 -&gt; 1 -&gt; 3
       -&gt; 4
  -&gt; 2 -&gt; 5
       -&gt; 6
</pre><p> The edges of the subtree rooted at 1 are "1 -&gt; 3" and "1 -&gt; 4", or, for the mathematically inclined \((1,3), (1,4)\).</p>
<p>This method can be seen as a way of relabelling nodes when <em>u</em> is the root of the tree and <em>relab</em> is true. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>Root node of the subtree. </td></tr>
    <tr><td class="paramname">relab</td><td>Should the nodes be relabelled? </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of edges. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The object must be a valid rooted tree (see <a class="el" href="#af464d98b1b5dfdbaaacea553d9c89154">is_rooted_tree</a>). </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Whenever <em>relab</em> is true, the label of the first node of the first edge is guaranteed to be node '0'. </dd></dl>

</div>
</div>
<a id="a39fe1b8076010e6bdcb0620436e3a399" name="a39fe1b8076010e6bdcb0620436e3a399"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39fe1b8076010e6bdcb0620436e3a399">&#9670;&#160;</a></span>get_head_vector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacelal.html#a2eb5b7f5b50ff908a7a67889a9ea744d">head_vector</a> lal::graphs::rooted_tree::get_head_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>arr</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a rooted tree into a head vector. </p>
<p>See <a class="el" href="LAL_concepts.html#LAL_concepts__head_vector">Head vector</a> page for a definition of 'head vector'.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>Linear arrangement of the tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The head vector representation of this tree. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>This tree is a valid rooted tree (see <a class="el" href="#af464d98b1b5dfdbaaacea553d9c89154">is_rooted_tree</a>). </dd></dl>

</div>
</div>
<a id="a6bd3b9aaaab43d22af76dea13c4c8371" name="a6bd3b9aaaab43d22af76dea13c4c8371"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bd3b9aaaab43d22af76dea13c4c8371">&#9670;&#160;</a></span>get_in_neighbors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacelal.html#aef91d923414879a998619e9c65181d1f">neighbourhood</a> &amp; lal::graphs::directed_graph::get_in_neighbors </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the in-neighbors of node <em>u</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>Node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The list of nodes entering at node <em>u</em>. </dd></dl>

</div>
</div>
<a id="a54061e1790d0424cac8960a0a3277a99" name="a54061e1790d0424cac8960a0a3277a99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54061e1790d0424cac8960a0a3277a99">&#9670;&#160;</a></span>get_num_nodes_component()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lal::graphs::tree::get_num_nodes_component </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Amount of nodes in a connected component of the tree. </p>
<p>If the current graph lacks some edges then it is clearly a forest, i.e., a series of disconnected components. This function returns the size of the component node <em>u</em> belongs to.</p>
<p>In rooted trees one has to see this amount as the number of nodes of the component in the underlying undirected forest. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>Input node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size of the connected component of <em>u</em>. </dd></dl>

</div>
</div>
<a id="ae6be97ab69d1c8bf6f085bef3cebbdfb" name="ae6be97ab69d1c8bf6f085bef3cebbdfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6be97ab69d1c8bf6f085bef3cebbdfb">&#9670;&#160;</a></span>get_num_nodes_subtree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lal::graphs::rooted_tree::get_num_nodes_subtree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the size of a subtree rooted at a given node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>Vertex of the tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of nodes of the subtree rooted at <em>u</em>. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Method <a class="el" href="#ae92039a5723afd79aec1934f2b145dda">are_size_subtrees_valid</a> returns true. </dd></dl>

</div>
</div>
<a id="a94834a6fb04411d06eda59f998d2ff02" name="a94834a6fb04411d06eda59f998d2ff02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94834a6fb04411d06eda59f998d2ff02">&#9670;&#160;</a></span>get_out_neighbors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacelal.html#aef91d923414879a998619e9c65181d1f">neighbourhood</a> &amp; lal::graphs::directed_graph::get_out_neighbors </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the out-neighbors of node <em>u</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>Node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The list of nodes leaving node <em>u</em>. </dd></dl>

</div>
</div>
<a id="ade2f568db839f6ec8a6cdda5c49d86d8" name="ade2f568db839f6ec8a6cdda5c49d86d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade2f568db839f6ec8a6cdda5c49d86d8">&#9670;&#160;</a></span>get_parent_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> lal::graphs::rooted_tree::get_parent_node </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parent vertex of a node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>Input node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The parent vertex of a node. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Method <a class="el" href="#aea9359d7279ddd5c247da7483e888175">node_has_parent</a> must return true. </dd></dl>

</div>
</div>
<a id="a116071bf1763e9454e1fc047b6c236d8" name="a116071bf1763e9454e1fc047b6c236d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a116071bf1763e9454e1fc047b6c236d8">&#9670;&#160;</a></span>get_Q()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespacelal.html#a235d5351556fbc73aa51767ab7765f5c">edge_pair</a> &gt; lal::graphs::directed_graph::get_Q </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns all independent pairs of edges of this graph. </p>
<p>The set \(Q(G)\) is defined as the pairs of edges of \(G\), \(E(G) \times E(G)\), that are independent, that is, that share no nodes. </p>

<p>Implements <a class="el" href="classlal_1_1graphs_1_1graph.html#a91155aa7578956540e8811aa896d06c5">lal::graphs::graph</a>.</p>

</div>
</div>
<a id="aecd3d53ae80a7aeb705bc5a3c543e901" name="aecd3d53ae80a7aeb705bc5a3c543e901"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecd3d53ae80a7aeb705bc5a3c543e901">&#9670;&#160;</a></span>get_subtree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">rooted_tree</a> lal::graphs::rooted_tree::get_subtree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the subtree rooted at node <em>u</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>Root of the subtree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tree containing the nodes of the subtree rooted at node <em>u</em>. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The object must be a valid rooted tree (see <a class="el" href="#af464d98b1b5dfdbaaacea553d9c89154">is_rooted_tree</a>). </dd></dl>

</div>
</div>
<a id="ae51ce9ddffc9287f375545e2b2fec3e3" name="ae51ce9ddffc9287f375545e2b2fec3e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae51ce9ddffc9287f375545e2b2fec3e3">&#9670;&#160;</a></span>get_tree_type_list()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; lal::graphs::tree::get_tree_type_list </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the list of types as a list of strings. </p>
<dl class="section return"><dt>Returns</dt><dd>The list of types as a list of strings. </dd></dl>

</div>
</div>
<a id="a8bd08e2ff59bf1037d70db8199543b2a" name="a8bd08e2ff59bf1037d70db8199543b2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bd08e2ff59bf1037d70db8199543b2a">&#9670;&#160;</a></span>has_root()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::graphs::rooted_tree::has_root </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns whether this rooted tree's root has been set or not (see <a class="el" href="#a315021f4b8de00b99996d45c5bbb9c4a">set_root</a>). </p>

</div>
</div>
<a id="a0e3529632b38533c4be8b2a306a038c3" name="a0e3529632b38533c4be8b2a306a038c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e3529632b38533c4be8b2a306a038c3">&#9670;&#160;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void lal::graphs::graph::init </td>
          <td>(</td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates the necessary memory for this class. </p>
<p>See <a class="el" href="#ae644f013789ff98bcb57284059f89738">_init</a> for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of nodes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad35cda8a4fa8de6fcc9c92b8a132f21b" name="ad35cda8a4fa8de6fcc9c92b8a132f21b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad35cda8a4fa8de6fcc9c92b8a132f21b">&#9670;&#160;</a></span>init_rooted() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::rooted_tree::init_rooted </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">free_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>norm</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>check_norm</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializer with tree and root node. </p>
<p>Constructs a rooted tree from a free tree and one of its nodes as the root of the rooted tree.</p>
<p>Since the edges are oriented, method <a class="el" href="classlal_1_1graphs_1_1tree.html#a25c8d57865fa5f7cb5d101fd5d07fe2d">is_tree</a> must be true on parameter <em>t</em> (otherwise, some edges might not be reachable from the root and hence completely undirectable). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Undirected tree. </td></tr>
    <tr><td class="paramname">r</td><td>Root of the rooted tree. A node of <em>g</em>. </td></tr>
    <tr><td class="paramname">norm</td><td>Normalize the graph after the deletion. </td></tr>
    <tr><td class="paramname">check_norm</td><td>If <em>norm</em> is false then, should we check whether the result is normalized or not? This might be useful in case the resulting graph is normalized. If <em>norm</em> is true then <em>check_norm</em> is ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Parameter <em>t</em> must be a tree (see <a class="el" href="classlal_1_1graphs_1_1tree.html#a25c8d57865fa5f7cb5d101fd5d07fe2d">is_tree</a>). </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Method <a class="el" href="#af464d98b1b5dfdbaaacea553d9c89154">is_rooted_tree</a> returns true. </dd></dl>

</div>
</div>
<a id="a5062b5f398247b196495ab811b7f59ad" name="a5062b5f398247b196495ab811b7f59ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5062b5f398247b196495ab811b7f59ad">&#9670;&#160;</a></span>init_rooted() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::rooted_tree::init_rooted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlal_1_1graphs_1_1free__tree.html">free_tree</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>norm</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>check_norm</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializer with tree and root node. </p>
<p>Constructs a rooted tree from a free tree and one of its nodes as the root of the rooted tree.</p>
<p>Since the edges are oriented, method <a class="el" href="classlal_1_1graphs_1_1tree.html#a25c8d57865fa5f7cb5d101fd5d07fe2d">is_tree</a> must be true on parameter <em>t</em> (otherwise, some edges might not be reachable from the root and hence completely undirectable). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Undirected tree. </td></tr>
    <tr><td class="paramname">r</td><td>Root of the rooted tree. A node of <em>g</em>. </td></tr>
    <tr><td class="paramname">norm</td><td>Normalize the graph after the deletion. </td></tr>
    <tr><td class="paramname">check_norm</td><td>If <em>norm</em> is false then, should we check whether the result is normalized or not? This might be useful in case the resulting graph is normalized. If <em>norm</em> is true then <em>check_norm</em> is ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Parameter <em>t</em> must be a tree (see <a class="el" href="classlal_1_1graphs_1_1tree.html#a25c8d57865fa5f7cb5d101fd5d07fe2d">is_tree</a>). </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Method <a class="el" href="#af464d98b1b5dfdbaaacea553d9c89154">is_rooted_tree</a> returns true. </dd></dl>

</div>
</div>
<a id="abb9238eb8914e145736f1ac914f6b9d6" name="abb9238eb8914e145736f1ac914f6b9d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb9238eb8914e145736f1ac914f6b9d6">&#9670;&#160;</a></span>is_normalized()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::graphs::graph::is_normalized </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether this graph is normalized or not. </p>
<p>A graph is normalized if every node's adjacency list is sorted increasingly. For this, use method <a class="el" href="classlal_1_1graphs_1_1directed__graph.html#a4e4a81d38587995cb990e21e28aaf2b4">normalize()</a>. </p><dl class="section return"><dt>Returns</dt><dd>The value of <a class="el" href="classlal_1_1graphs_1_1graph.html#a427d63b1bef991f43db8f5d622567bb6">m_is_normalized</a>. </dd></dl>

</div>
</div>
<a id="a06ce8cc7afb074d2fecf70a0842adaaa" name="a06ce8cc7afb074d2fecf70a0842adaaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06ce8cc7afb074d2fecf70a0842adaaa">&#9670;&#160;</a></span>is_of_tree_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::graphs::tree::is_of_tree_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal_1_1graphs.html#a18d52542088507e2be6241759722835b">tree_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>tt</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether this tree is of type <em>tt</em>. </p>
<p>See method <a class="el" href="#aaaa55acc91cddcd44f95419b83706ae9">calculate_tree_type</a> to know how to calculate a tree's type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tt</td><td>Type of tree (see <a class="el" href="namespacelal_1_1graphs.html#a18d52542088507e2be6241759722835b">graphs::tree_type</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this tree is of type <em>tt</em>. </dd></dl>

</div>
</div>
<a id="a6e9cff34e745fb4b9388f73f91f43729" name="a6e9cff34e745fb4b9388f73f91f43729"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e9cff34e745fb4b9388f73f91f43729">&#9670;&#160;</a></span>is_root_valid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::graphs::rooted_tree::is_root_valid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>r</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the root valid? </p>
<p>A root is valid if it has in-degree 0. This is calculated as a function of the current state of the tree. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Given node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the node passed as parameter is a valid root. </dd></dl>

</div>
</div>
<a id="af464d98b1b5dfdbaaacea553d9c89154" name="af464d98b1b5dfdbaaacea553d9c89154"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af464d98b1b5dfdbaaacea553d9c89154">&#9670;&#160;</a></span>is_rooted_tree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::graphs::rooted_tree::is_rooted_tree </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this tree a valid rooted tree? </p>
<p>A tree is a valid rooted tree when:</p><ul>
<li>the underlying undirected graph is connected and does not contain cycles (see <a class="el" href="classlal_1_1graphs_1_1tree.html#a25c8d57865fa5f7cb5d101fd5d07fe2d">is_tree</a>),</li>
<li>the tree has a root (see <a class="el" href="#a8bd08e2ff59bf1037d70db8199543b2a">has_root</a>, <a class="el" href="#a315021f4b8de00b99996d45c5bbb9c4a">set_root</a>, <a class="el" href="#a8c188e4dc4a372c356e68ced5d80d5f6">get_root</a>).</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Whether this tree is a valid rooted tree or not. </dd></dl>

</div>
</div>
<a id="a25c8d57865fa5f7cb5d101fd5d07fe2d" name="a25c8d57865fa5f7cb5d101fd5d07fe2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25c8d57865fa5f7cb5d101fd5d07fe2d">&#9670;&#160;</a></span>is_tree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::graphs::tree::is_tree </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this graph an actual tree? </p>
<p>Returns true if the number of edges is one less than the number of nodes.</p>
<p>Note that this would not really be true if the addition of edges was not constrained. That is, since it is constrained (behind the scenes) in a way that no cycles can be produced (for example, see <a class="el" href="classlal_1_1graphs_1_1free__tree.html#af9a0b63cb35de6ddbbb67f37785c49f8">free_tree::add_edge</a>, or <a class="el" href="classlal_1_1graphs_1_1free__tree.html#ab0f485e3795909478b403c71cd777b2d">free_tree::add_edges</a>), then we only need to check for the number of edges.</p>
<p>For further characterisations of a tree see <a class="el" href="citelist.html#CITEREF_Harary1969a">[29]</a> (chapter 4, pages 32-33). </p><dl class="section return"><dt>Returns</dt><dd>True or false depending on whether this graph fits the defintion of tree. </dd></dl>

</div>
</div>
<a id="a9fc7f9e08db601f10982da6a01315cb3" name="a9fc7f9e08db601f10982da6a01315cb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fc7f9e08db601f10982da6a01315cb3">&#9670;&#160;</a></span>is_tree_type_valid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::graphs::tree::is_tree_type_valid </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the type of this tree valid? </p>
<p>This function enables users determine when this tree's type should be calculated.</p>
<p>In case this function returns false, users should call function <a class="el" href="#aaaa55acc91cddcd44f95419b83706ae9">calculate_tree_type</a> in order to obtain a valid tree type. Note, however, that prior to calling the function the type of this tree might be <a class="el" href="namespacelal_1_1graphs.html#a18d52542088507e2be6241759722835baad921d60486366258809553a3db49a4a">graphs::tree_type::unknown</a> and that the tree type may remain <a class="el" href="namespacelal_1_1graphs.html#a18d52542088507e2be6241759722835baad921d60486366258809553a3db49a4a">graphs::tree_type::unknown</a> even after the type has been calculated. Nevertheless, users should be suspicious of a tree being of <a class="el" href="namespacelal_1_1graphs.html#a18d52542088507e2be6241759722835baad921d60486366258809553a3db49a4a">graphs::tree_type::unknown</a> (in fact, of any) type if this method returns false, yet they should be sure of it if the type was calculated via method <a class="el" href="#aaaa55acc91cddcd44f95419b83706ae9">calculate_tree_type</a>. </p><dl class="section return"><dt>Returns</dt><dd>True or false depending on whether the tree type was calculated or not. </dd></dl>

</div>
</div>
<a id="aea9359d7279ddd5c247da7483e888175" name="aea9359d7279ddd5c247da7483e888175"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea9359d7279ddd5c247da7483e888175">&#9670;&#160;</a></span>node_has_parent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::graphs::rooted_tree::node_has_parent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does a node have a parent vertex? </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>Input node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the node has a parent vertex. </dd></dl>

</div>
</div>
<a id="a4e4a81d38587995cb990e21e28aaf2b4" name="a4e4a81d38587995cb990e21e28aaf2b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e4a81d38587995cb990e21e28aaf2b4">&#9670;&#160;</a></span>normalize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::directed_graph::normalize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Normalizes the graph. </p>
<p>Sorts this graph's adjacency list structure in increasing order.</p>
<p>Besides expensive, this method may be unnecessary. Method <a class="el" href="classlal_1_1graphs_1_1directed__graph.html#a23b10c47032b774696a5ed970b059cdb">check_normalized()</a> checks whether the graph is normalized or not; in case it is, using this method is completely unnecessary. </p><dl class="section post"><dt>Postcondition</dt><dd>Method <a class="el" href="classlal_1_1graphs_1_1graph.html#abb9238eb8914e145736f1ac914f6b9d6">is_normalized</a> evaluates to true. </dd></dl>

<p>Reimplemented from <a class="el" href="classlal_1_1graphs_1_1graph.html#abe2c7decb104857bd857c769feb75c98">lal::graphs::graph</a>.</p>

</div>
</div>
<a id="a3ea3a2ecbda50de43e57564855f7b61f" name="a3ea3a2ecbda50de43e57564855f7b61f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ea3a2ecbda50de43e57564855f7b61f">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">rooted_tree</a> &amp; lal::graphs::rooted_tree::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">rooted_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>r</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Rooted tree. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae19c29613069729e0bc0683a676a34ef" name="ae19c29613069729e0bc0683a676a34ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae19c29613069729e0bc0683a676a34ef">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">rooted_tree</a> &amp; lal::graphs::rooted_tree::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">rooted_tree</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>r</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Rooted tree. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac2b76c9b017ba87d0458b8a3bf89cc77" name="ac2b76c9b017ba87d0458b8a3bf89cc77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2b76c9b017ba87d0458b8a3bf89cc77">&#9670;&#160;</a></span>remove_edge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">rooted_tree</a> &amp; lal::graphs::rooted_tree::remove_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>norm</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>check_norm</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove an edge from this graph. </p>
<p><b>For developers:</b> method <a class="el" href="classlal_1_1graphs_1_1graph.html#a98d5b515434333420d3c0383118a40e9">lal::graphs::graph::actions_after_remove_edge</a> is called after the edge has been removed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Valid node index: \(0 \le s &lt; n\). </td></tr>
    <tr><td class="paramname">t</td><td>Valid node index: \(0 \le t &lt; n\). </td></tr>
    <tr><td class="paramname">norm</td><td>Normalize the graph after the deletion. </td></tr>
    <tr><td class="paramname">check_norm</td><td>If <em>norm</em> is false then, should we check whether the result is normalized or not? This might be useful in case the resulting graph is normalized. If <em>norm</em> is true then <em>check_norm</em> is ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The edge must exist. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>If <em>norm</em> is true the graph is guaranteed to be normalized after the addition of the edge. </dd></dl>

<p>Reimplemented from <a class="el" href="classlal_1_1graphs_1_1directed__graph.html#a2fdfa075c6d181f49640d30530f87dab">lal::graphs::directed_graph</a>.</p>

</div>
</div>
<a id="a34fc00e1d6e5e84b480dfaaab9ab69e9" name="a34fc00e1d6e5e84b480dfaaab9ab69e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34fc00e1d6e5e84b480dfaaab9ab69e9">&#9670;&#160;</a></span>remove_edge_bulk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">rooted_tree</a> &amp; lal::graphs::rooted_tree::remove_edge_bulk </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes an edge from the tree. </p>
<p>This method only removes an edge, and does no other work: normalisation is not checked, and no extra work per edge is done. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Valid node index: \(0 \le s &lt; n\). </td></tr>
    <tr><td class="paramname">t</td><td>Valid node index: \(0 \le t &lt; n\). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>\(u \neq v\). </dd>
<dd>
The edge \(\{s,t\}\) is not part of the graph. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>If <em>norm</em> is true the graph is guaranteed to be normalized after the removal of the edge. </dd></dl>

<p>Reimplemented from <a class="el" href="classlal_1_1graphs_1_1directed__graph.html#a655fbacfd749a62e61933ae19cb647cb">lal::graphs::directed_graph</a>.</p>

</div>
</div>
<a id="a3fb10a4c13c5c9fc6c082f1513844330" name="a3fb10a4c13c5c9fc6c082f1513844330"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fb10a4c13c5c9fc6c082f1513844330">&#9670;&#160;</a></span>remove_edges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">rooted_tree</a> &amp; lal::graphs::rooted_tree::remove_edges </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacelal.html#a5969ec7ecc85697ebb9ec0ace78fbcab">edge</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>edges</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>norm</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>check_norm</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove an edge from this graph. </p>
<p>This operation is faster than removing edges one by one with <a class="el" href="#ac2b76c9b017ba87d0458b8a3bf89cc77">remove_edge(node,node,bool,bool)</a> since the edges are removed in bulk. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edges</td><td>The edges to be deleted. </td></tr>
    <tr><td class="paramname">norm</td><td>Normalize the graph after the deletion. </td></tr>
    <tr><td class="paramname">check_norm</td><td>If <em>norm</em> is false then, should we check whether the result is normalized or not? This might be useful in case the resulting graph is normalized. If <em>norm</em> is true then <em>check_norm</em> is ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>All the edges in <em>edges</em> must meet the precondition of method <a class="el" href="#a49939ad6dffc54cd4d58bc1506f28f6b">add_edge(node,node,bool,bool)</a>. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>If <em>norm</em> is true the graph is guaranteed to be normalized after the addition of the edge. </dd></dl>

<p>Reimplemented from <a class="el" href="classlal_1_1graphs_1_1directed__graph.html#a859d69232a66987307b4fb67c9d36885">lal::graphs::directed_graph</a>.</p>

</div>
</div>
<a id="a87fe72ad0fd7894f19cb31883335682c" name="a87fe72ad0fd7894f19cb31883335682c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87fe72ad0fd7894f19cb31883335682c">&#9670;&#160;</a></span>remove_edges_incident_to()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">rooted_tree</a> &amp; lal::graphs::rooted_tree::remove_edges_incident_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>norm</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>check_norm</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove all edges incident to a given vertex. </p>
<p>This operation is faster than removing edges one by one with <a class="el" href="#ac2b76c9b017ba87d0458b8a3bf89cc77">remove_edge(node,node,bool,bool)</a> since the edges are removed in bulk. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>The node whose incident vertices are to be removed. </td></tr>
    <tr><td class="paramname">norm</td><td>Normalize the graph after the deletion. </td></tr>
    <tr><td class="paramname">check_norm</td><td>If <em>norm</em> is false then, should we check whether the result is normalized or not? This might be useful in case the resulting graph is normalized. If <em>norm</em> is true then <em>check_norm</em> is ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>If <em>norm</em> is true the graph is guaranteed to be normalized after the addition of the edge. </dd></dl>

<p>Reimplemented from <a class="el" href="classlal_1_1graphs_1_1directed__graph.html#a87ac6566448b6aaa20a1ed892c480e35">lal::graphs::directed_graph</a>.</p>

</div>
</div>
<a id="abfd2e63ab74fbbc367216f2c256f33c2" name="abfd2e63ab74fbbc367216f2c256f33c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfd2e63ab74fbbc367216f2c256f33c2">&#9670;&#160;</a></span>remove_node() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">rooted_tree</a> &amp; lal::graphs::rooted_tree::remove_node </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>connect</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>norm</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>check_norm</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a node from this tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>Valid node index: \(0 \le u &lt; n\). </td></tr>
    <tr><td class="paramname">connect</td><td>If connect is true then the parent of <em>u</em> is connected to the children of <em>u</em>, if both parent and children exist. </td></tr>
    <tr><td class="paramname">norm</td><td>Normalize the graph after the deletion. </td></tr>
    <tr><td class="paramname">check_norm</td><td>If <em>norm</em> is false then, should we check whether the result is normalized or not? This might be useful in case the resulting graph is normalized. If <em>norm</em> is true then <em>check_norm</em> is ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The node must exist. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>If <em>norm</em> is true the graph is guaranteed to be normalized after the removal of the node. </dd>
<dd>
If <em>u</em> is the root of this tree, then this tree no longer has a root. </dd></dl>

</div>
</div>
<a id="aae3aa64a0f37563dbb8b9473eeba7ced" name="aae3aa64a0f37563dbb8b9473eeba7ced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae3aa64a0f37563dbb8b9473eeba7ced">&#9670;&#160;</a></span>remove_node() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">directed_graph</a> &amp; lal::graphs::directed_graph::remove_node </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>norm</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>check_norm</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a node from this graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>Valid node index: \(0 \le u &lt; n\). </td></tr>
    <tr><td class="paramname">norm</td><td>Normalize the graph after the deletion. </td></tr>
    <tr><td class="paramname">check_norm</td><td>If <em>norm</em> is false then, should we check whether the result is normalized or not? This might be useful in case the resulting graph is normalized. If <em>norm</em> is true then <em>check_norm</em> is ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The node must exist. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>If <em>norm</em> is true the graph is guaranteed to be normalized after the addition of the edge. </dd></dl>

<p>Reimplemented from <a class="el" href="classlal_1_1graphs_1_1directed__graph.html#aae3aa64a0f37563dbb8b9473eeba7ced">lal::graphs::directed_graph</a>.</p>

</div>
</div>
<a id="a49c96337e914f103b8e06d132b42102d" name="a49c96337e914f103b8e06d132b42102d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49c96337e914f103b8e06d132b42102d">&#9670;&#160;</a></span>remove_single_edge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::directed_graph::remove_single_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelal.html#aef91d923414879a998619e9c65181d1f">neighbourhood</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>out_u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelal.html#aef91d923414879a998619e9c65181d1f">neighbourhood</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>in_v</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a single edge. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>First node of edge. </td></tr>
    <tr><td class="paramname">v</td><td>Second node of edge. </td></tr>
    <tr><td class="paramname">out_u</td><td>Out-neighbourhood of node <em>u</em>. </td></tr>
    <tr><td class="paramname">in_v</td><td>In-neighbourhood of node <em>v</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3a97b71616cedb7523b1ee712c30e4c1" name="a3a97b71616cedb7523b1ee712c30e4c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a97b71616cedb7523b1ee712c30e4c1">&#9670;&#160;</a></span>reserve_in_degree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::directed_graph::reserve_in_degree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>d</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Predicts that the in-degree of node <em>u</em> is <em>d</em>. </p>
<p>Memory of size <em>d</em> is reserved so that adding edges is done more efficiently. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>Node to reserve the degree for. </td></tr>
    <tr><td class="paramname">d</td><td>The amount of memory to reserve. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The graph must have been initialized. </dd></dl>

</div>
</div>
<a id="ad5f661e1f74f01757e0fb980aaf77562" name="ad5f661e1f74f01757e0fb980aaf77562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5f661e1f74f01757e0fb980aaf77562">&#9670;&#160;</a></span>reserve_out_degree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::directed_graph::reserve_out_degree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>d</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Predicts that the out-degree of node <em>u</em> is <em>d</em>. </p>
<p>Memory of size <em>d</em> is reserved so that adding edges is done more efficiently. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>Node to reserve the degree for. </td></tr>
    <tr><td class="paramname">d</td><td>The amount of memory to reserve. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The graph must have been initialized. </dd></dl>

</div>
</div>
<a id="af22c28ef3cc6dec9e2952f7ed943221d" name="af22c28ef3cc6dec9e2952f7ed943221d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af22c28ef3cc6dec9e2952f7ed943221d">&#9670;&#160;</a></span>set_edges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">rooted_tree</a> &amp; lal::graphs::rooted_tree::set_edges </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacelal.html#a5969ec7ecc85697ebb9ec0ace78fbcab">edge</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>edges</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>norm</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>check_norm</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the edges to the graph. </p>
<p>Sets the edges of this graph assuming that the nodes indexed in the list are, at most, the number of nodes of this graph.</p>
<p>This list of edges is assumed to be all the edges that are going to be added to this graph. This means that the internal data structures are constructed more efficiently than when adding edges one by one (see <a class="el" href="#a49939ad6dffc54cd4d58bc1506f28f6b">add_edge</a>) or in several chunks (see <a class="el" href="#a48e3d3f8b72122e829616edeeee05dfb">add_edges</a>). For a more controlled addition of the edges, see <a class="el" href="#ac66708cc747974506d27201655fa78bb">can_add_edges</a>.</p>
<p>Moreover, the current structure of the graph is cleared before setting the new edges. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edges</td><td>The edges to be added. </td></tr>
    <tr><td class="paramname">norm</td><td>Normalize the graph after the insertions. </td></tr>
    <tr><td class="paramname">check_norm</td><td>If <em>norm</em> is false then, should we check whether the result is normalized or not? This might be useful in case the resulting graph is normalized. If <em>norm</em> is true then <em>check_norm</em> is ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The graph has been initialized with as many nodes as vertices in the list of edges. </dd>
<dd>
There are no repeated edges in the list. </dd>
<dd>
The list of edges must form a valid rooted tree, i.e., there must be a unique vertex with no in-going edges, there must be no cycles, and every vertex has in-degree at most 1. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>If <em>norm</em> is true the graph is guaranteed to be normalized after the addition of the edge. </dd>
<dd>
The tree has a valid root which is, potentially, different from the previous root it had. Therefore, method <a class="el" href="#a8bd08e2ff59bf1037d70db8199543b2a">has_root</a> returns true. </dd>
<dd>
Method <a class="el" href="#af464d98b1b5dfdbaaacea553d9c89154">is_rooted_tree</a> returns true. </dd></dl>

<p>Reimplemented from <a class="el" href="classlal_1_1graphs_1_1directed__graph.html#a5ede56b5930ab3758ab55a81243743d6">lal::graphs::directed_graph</a>.</p>

</div>
</div>
<a id="a315021f4b8de00b99996d45c5bbb9c4a" name="a315021f4b8de00b99996d45c5bbb9c4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a315021f4b8de00b99996d45c5bbb9c4a">&#9670;&#160;</a></span>set_root()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::rooted_tree::set_root </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>r</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the root of this tree. </p>
<p>Changing the root of a rooted tree invalidates information dependant on the tree. See the postconditions for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>Vertex that represents the root. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The adjacency list must have been initialized. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Method <a class="el" href="#a8bd08e2ff59bf1037d70db8199543b2a">has_root</a> returns true. </dd>
<dd>
The type of rooted tree and the size of the subtrees are invalidated. </dd></dl>

</div>
</div>
<a id="aad96a414d470e9fbc8694601503da4ad" name="aad96a414d470e9fbc8694601503da4ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad96a414d470e9fbc8694601503da4ad">&#9670;&#160;</a></span>subtree_contains_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::graphs::rooted_tree::subtree_contains_node </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does the subtree rooted at <em>r</em> contain node <em>u</em>? </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>The root of the subtree. Notice that if <em>r</em> is the actual root of the subtree, the tree certainly contains <em>u</em>. </td></tr>
    <tr><td class="paramname">u</td><td>Node to query within the subtree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the subtree rooted at <em>r</em> contains node łe u. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Node <em>r</em> belongs to the tree (see <a class="el" href="classlal_1_1graphs_1_1graph.html#aad2d7e6a53d8746c66e8af9762c14484">has_node</a>). </dd>
<dd>
Node <em>u</em> belongs to the tree (see <a class="el" href="classlal_1_1graphs_1_1graph.html#aad2d7e6a53d8746c66e8af9762c14484">has_node</a>). </dd>
<dd>
This tree is a valid rooted tree (see <a class="el" href="#af464d98b1b5dfdbaaacea553d9c89154">is_rooted_tree</a>). </dd></dl>

</div>
</div>
<a id="a0600daeeb3542446c6c8d8299d7fffa6" name="a0600daeeb3542446c6c8d8299d7fffa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0600daeeb3542446c6c8d8299d7fffa6">&#9670;&#160;</a></span>to_free_tree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1graphs_1_1free__tree.html">free_tree</a> lal::graphs::rooted_tree::to_free_tree </td>
          <td>(</td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>norm</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>check</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts this rooted tree into a free tree (see <a class="el" href="classlal_1_1graphs_1_1free__tree.html">free_tree</a>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">norm</td><td>Normalize the tree. </td></tr>
    <tr><td class="paramname">check</td><td>Chech whether the resulting graph is normalized or not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad7bfd2d96d5110a7bf0d56c4df1618fd" name="ad7bfd2d96d5110a7bf0d56c4df1618fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7bfd2d96d5110a7bf0d56c4df1618fd">&#9670;&#160;</a></span>to_undirected()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">undirected_graph</a> lal::graphs::directed_graph::to_undirected </td>
          <td>(</td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>norm</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>check</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts this directed graph into an undirected graph. </p>
<p>The undirected graph returned connects two vertices \(u,v\) if these two vertices are connected by a directed edge ( \((u,v)\) or \((v,u)\)) in this graph. In other words, if two vertices are connected by a single directed edge, the direction is dropped. If two edges are connected by two directed edges (of opposite directions) then the two are merged into a single undirected edge. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">norm</td><td>Normalize the graph. </td></tr>
    <tr><td class="paramname">check</td><td>Chech whether the resulting graph is normalized or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This graph in which the edges are undirected. </dd></dl>

</div>
</div>
<a id="aaabba99bcbca589ec9f8f5d3c85e6b43" name="aaabba99bcbca589ec9f8f5d3c85e6b43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaabba99bcbca589ec9f8f5d3c85e6b43">&#9670;&#160;</a></span>tree_only_actions_after_add_edge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::tree::tree_only_actions_after_add_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do some work after the addition of an edge. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>First node of the edge. </td></tr>
    <tr><td class="paramname">v</td><td>Second node of the edge. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>The tree type is invalidated. </dd>
<dd>
Updated union-find. </dd></dl>

</div>
</div>
<a id="aa7e746b8d5c0cd8f53890f046aeceb65" name="aa7e746b8d5c0cd8f53890f046aeceb65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7e746b8d5c0cd8f53890f046aeceb65">&#9670;&#160;</a></span>tree_only_actions_after_add_edges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::tree::tree_only_actions_after_add_edges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ab98936b00d896700a71899dff1ed9248">edge_list</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do some work after the addition of several edges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>List of edges. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>The tree type is invalidated. </dd>
<dd>
Updated union-find. </dd></dl>

</div>
</div>
<a id="ac759e6c7f4bf5bf2cee25fa274d9d4d5" name="ac759e6c7f4bf5bf2cee25fa274d9d4d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac759e6c7f4bf5bf2cee25fa274d9d4d5">&#9670;&#160;</a></span>tree_only_actions_after_add_edges_bulk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::tree::tree_only_actions_after_add_edges_bulk </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do some work after the addition of several edges in bulk. </p>
<p>To be called only after veral calls to <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html#a3d9454ddfaef55219be3ef00ecac1189">undirected_graph::add_edge_bulk</a> or <a class="el" href="classlal_1_1graphs_1_1directed__graph.html#a2867b035b48ab54df5f60e3b065fea66">directed_graph::add_edge_bulk</a>. </p><dl class="section post"><dt>Postcondition</dt><dd>The tree type is invalidated. </dd>
<dd>
Updated union-find. </dd></dl>

</div>
</div>
<a id="a5ba179a3180253e6eeb62d5b8df22066" name="a5ba179a3180253e6eeb62d5b8df22066"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ba179a3180253e6eeb62d5b8df22066">&#9670;&#160;</a></span>tree_only_actions_after_add_edges_bulk_complete()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::tree::tree_only_actions_after_add_edges_bulk_complete </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do some work after the addition of several edges in bulk. </p>
<p>To be called only after veral calls to <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html#a3d9454ddfaef55219be3ef00ecac1189">undirected_graph::add_edge_bulk</a> or <a class="el" href="classlal_1_1graphs_1_1directed__graph.html#a2867b035b48ab54df5f60e3b065fea66">directed_graph::add_edge_bulk</a>. </p><dl class="section post"><dt>Postcondition</dt><dd>The tree type is invalidated. </dd>
<dd>
Updated union-find. </dd></dl>

</div>
</div>
<a id="a9474e409a3b4feb4c5806ee74c59c8ca" name="a9474e409a3b4feb4c5806ee74c59c8ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9474e409a3b4feb4c5806ee74c59c8ca">&#9670;&#160;</a></span>tree_only_actions_after_remove_edge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::tree::tree_only_actions_after_remove_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do some work after the removal of an edge. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>First node of the edge. </td></tr>
    <tr><td class="paramname">v</td><td>Second node of the edge. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>The tree type is invalidated. </dd>
<dd>
Updated union-find. </dd></dl>

</div>
</div>
<a id="a5ff43145e03d8074cbc513e2fe827454" name="a5ff43145e03d8074cbc513e2fe827454"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ff43145e03d8074cbc513e2fe827454">&#9670;&#160;</a></span>tree_only_actions_after_remove_edges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::tree::tree_only_actions_after_remove_edges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ab98936b00d896700a71899dff1ed9248">edge_list</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do some work after the removal of several edges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>List of edges. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>The tree type is invalidated. </dd>
<dd>
Updated union-find. </dd></dl>

</div>
</div>
<a id="a9a43cfff1504c7ff6bcba9cd03e4743d" name="a9a43cfff1504c7ff6bcba9cd03e4743d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a43cfff1504c7ff6bcba9cd03e4743d">&#9670;&#160;</a></span>tree_only_actions_after_remove_edges_bulk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::tree::tree_only_actions_after_remove_edges_bulk </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do some work after the removal of several edges in bulk. </p>
<p>To be called only after veral calls to <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html#a741081cc0646053bcb5fd5809eb19a21">undirected_graph::remove_edge_bulk</a> or <a class="el" href="classlal_1_1graphs_1_1directed__graph.html#a655fbacfd749a62e61933ae19cb647cb">directed_graph::remove_edge_bulk</a>. </p><dl class="section post"><dt>Postcondition</dt><dd>The tree type is invalidated. </dd>
<dd>
Updated union-find. </dd></dl>

</div>
</div>
<a id="a3d35e95e2d86ec20bcf8609f8f6f6a68" name="a3d35e95e2d86ec20bcf8609f8f6f6a68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d35e95e2d86ec20bcf8609f8f6f6a68">&#9670;&#160;</a></span>tree_only_actions_after_remove_edges_bulk_complete()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::tree::tree_only_actions_after_remove_edges_bulk_complete </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do some work after the removal of several edges in bulk. </p>
<p>To be called only after veral calls to <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html#a741081cc0646053bcb5fd5809eb19a21">undirected_graph::remove_edge_bulk</a> or <a class="el" href="classlal_1_1graphs_1_1directed__graph.html#a655fbacfd749a62e61933ae19cb647cb">directed_graph::remove_edge_bulk</a>. </p><dl class="section post"><dt>Postcondition</dt><dd>The tree type is invalidated. </dd>
<dd>
Updated union-find. </dd></dl>

</div>
</div>
<a id="abca6ea36ec8d9b891395aaef69ece840" name="abca6ea36ec8d9b891395aaef69ece840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abca6ea36ec8d9b891395aaef69ece840">&#9670;&#160;</a></span>tree_only_actions_after_remove_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::tree::tree_only_actions_after_remove_node </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do some work before the removal of a vertex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>Node to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>The tree type is invalidated. </dd>
<dd>
Updated union-find. </dd></dl>

</div>
</div>
<a id="a76ad30a023ad9b9bd3dd69bb350051ee" name="a76ad30a023ad9b9bd3dd69bb350051ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76ad30a023ad9b9bd3dd69bb350051ee">&#9670;&#160;</a></span>tree_only_actions_before_remove_edges_incident_to()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::tree::tree_only_actions_before_remove_edges_incident_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do some work before the removal of all edges incident to a vertex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>Node whose incident edges are to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>The tree type is invalidated. </dd>
<dd>
Updated union-find. </dd></dl>

</div>
</div>
<a id="a65d589c9cedc11dac39baca2c0c58001" name="a65d589c9cedc11dac39baca2c0c58001"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65d589c9cedc11dac39baca2c0c58001">&#9670;&#160;</a></span>tree_only_add_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::tree::tree_only_add_node </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a node to this tree. </p>
<p>Updates all the internal data structures. </p>

</div>
</div>
<a id="a973468996f8ff425e9a37ae0788bc4c1" name="a973468996f8ff425e9a37ae0788bc4c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a973468996f8ff425e9a37ae0788bc4c1">&#9670;&#160;</a></span>tree_only_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::tree::tree_only_init </td>
          <td>(</td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes only the memory of class <a class="el" href="classlal_1_1graphs_1_1tree.html">tree</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of vertices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2ca79711e18e398299a3beb42fe3cc41" name="a2ca79711e18e398299a3beb42fe3cc41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ca79711e18e398299a3beb42fe3cc41">&#9670;&#160;</a></span>tree_only_invalidate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::tree::tree_only_invalidate </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invalidates the aggregated information of the tree. </p>
<p>Invalidates:</p><ul>
<li><a class="el" href="classlal_1_1graphs_1_1tree.html#a951a57e760385ce3de285089627b7bbb">m_is_tree_type_valid</a>. </li>
</ul>

</div>
</div>
<a id="a00d8733492f1bba18638506af2a19d7e" name="a00d8733492f1bba18638506af2a19d7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00d8733492f1bba18638506af2a19d7e">&#9670;&#160;</a></span>tree_only_remove_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::tree::tree_only_remove_node </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a vertex from the union-find data structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>Node that was removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>The tree type is invalidated. </dd>
<dd>
Updated union-find. </dd></dl>

</div>
</div>
<a id="aee4660ac324fd19a342f2369cf4f796f" name="aee4660ac324fd19a342f2369cf4f796f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee4660ac324fd19a342f2369cf4f796f">&#9670;&#160;</a></span>tree_only_set_edges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::tree::tree_only_set_edges </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the data structures of a tree after the graph structure has had its set of edges set. </p>
<dl class="section post"><dt>Postcondition</dt><dd>The tree type is invalidated. </dd>
<dd>
Updated union-find. </dd></dl>

</div>
</div>
<a id="aba129310bd758fa9cf03abceace19a4c" name="aba129310bd758fa9cf03abceace19a4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba129310bd758fa9cf03abceace19a4c">&#9670;&#160;</a></span>update_union_find_after_add_edge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::rooted_tree::update_union_find_after_add_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *const</td>          <td class="paramname"><span class="paramname"><em>root_of</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *const</td>          <td class="paramname"><span class="paramname"><em>root_size</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the union find data structure after an edge addition. </p>
<p>This is a helper method to be able to call <a class="el" href="namespacelal_1_1detail.html#af50760eaee3200e963cc77c4c95470d6">lal::detail::update_unionfind_after_add_edge</a> which updates the Union-Find data structure under addition of an edge. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>Node that is connected to <em>v</em>. </td></tr>
    <tr><td class="paramname">v</td><td>Node that is connected to <em>u</em>. </td></tr>
    <tr><td class="paramname">root_of</td><td>Array of <em>n</em> elements relating each vertex to its root in the union find data structure. </td></tr>
    <tr><td class="paramname">root_size</td><td>Array of <em>n</em> elements relating each vertex to the size of the connected component it belongs to. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classlal_1_1graphs_1_1tree.html#adeab97d916ec9809fa2b03f96960159d">lal::graphs::tree</a>.</p>

</div>
</div>
<a id="a6f13f1e17793bf01b693398287b2f9fa" name="a6f13f1e17793bf01b693398287b2f9fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f13f1e17793bf01b693398287b2f9fa">&#9670;&#160;</a></span>update_union_find_after_add_edges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::rooted_tree::update_union_find_after_add_edges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ab98936b00d896700a71899dff1ed9248">edge_list</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>edges</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *const</td>          <td class="paramname"><span class="paramname"><em>root_of</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *const</td>          <td class="paramname"><span class="paramname"><em>root_size</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the union find data structure after the addition of a set of edges. </p>
<p>This is a helper method to be able to call <a class="el" href="namespacelal_1_1detail.html#a5cadd0c126ee7d5e745ee5188d67daff">lal::detail::update_unionfind_after_add_edges</a> which updates the Union-Find data structure under addition of an edge. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edges</td><td>A set of edges. </td></tr>
    <tr><td class="paramname">root_of</td><td>Array of <em>n</em> elements relating each vertex to its root in the union find data structure. </td></tr>
    <tr><td class="paramname">root_size</td><td>Array of <em>n</em> elements relating each vertex to the size of the connected component it belongs to. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classlal_1_1graphs_1_1tree.html#a1f932ae19c2eed5740cb12cca2efd7ee">lal::graphs::tree</a>.</p>

</div>
</div>
<a id="a45f0c0a06ea7b5603b8f49708a372c92" name="a45f0c0a06ea7b5603b8f49708a372c92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45f0c0a06ea7b5603b8f49708a372c92">&#9670;&#160;</a></span>update_union_find_after_add_edges_bulk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::rooted_tree::update_union_find_after_add_edges_bulk </td>
          <td>(</td>
          <td class="paramtype">uint64_t *const</td>          <td class="paramname"><span class="paramname"><em>root_of</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *const</td>          <td class="paramname"><span class="paramname"><em>root_size</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the union find data structure after the addition of several edges. </p>
<p>This is a helper method to be able to call <a class="el" href="namespacelal_1_1detail.html#a49b8ff3684b7c460352ee1678541b0d9">lal::detail::update_unionfind_after_add_rem_edges_bulk</a> which updates the Union-Find data structure after addition of several edges. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_of</td><td>Array of <em>n</em> elements relating each vertex to its root in the union find data structure. </td></tr>
    <tr><td class="paramname">root_size</td><td>Array of <em>n</em> elements relating each vertex to the size of the connected component it belongs to. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classlal_1_1graphs_1_1tree.html#aded95ef5a07fcbeface887f28e8b897d">lal::graphs::tree</a>.</p>

</div>
</div>
<a id="abc881b926932ddeadd5823c751f51db4" name="abc881b926932ddeadd5823c751f51db4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc881b926932ddeadd5823c751f51db4">&#9670;&#160;</a></span>update_union_find_after_remove_edge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::rooted_tree::update_union_find_after_remove_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *const</td>          <td class="paramname"><span class="paramname"><em>root_of</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *const</td>          <td class="paramname"><span class="paramname"><em>root_size</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the union find data structure after an edge removal. </p>
<p>This is a helper method to be able to call <a class="el" href="namespacelal_1_1detail.html#a773e3f33dbdcf3c44007f621eea0e4de">lal::detail::update_unionfind_after_remove_edge</a> which updates the Union-Find data structure under removal of an edge. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>Node that is connected to <em>v</em>. </td></tr>
    <tr><td class="paramname">v</td><td>Node that is connected to <em>u</em>. </td></tr>
    <tr><td class="paramname">root_of</td><td>Array of <em>n</em> elements relating each vertex to its root in the union find data structure. </td></tr>
    <tr><td class="paramname">root_size</td><td>Array of <em>n</em> elements relating each vertex to the size of the connected component it belongs to. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classlal_1_1graphs_1_1tree.html#aca432e67b4dd7fd49392f8afd53fed83">lal::graphs::tree</a>.</p>

</div>
</div>
<a id="afce8358ccbbcb855c76091c736ddd90b" name="afce8358ccbbcb855c76091c736ddd90b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afce8358ccbbcb855c76091c736ddd90b">&#9670;&#160;</a></span>update_union_find_after_remove_edges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::rooted_tree::update_union_find_after_remove_edges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ab98936b00d896700a71899dff1ed9248">edge_list</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>edges</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *const</td>          <td class="paramname"><span class="paramname"><em>root_of</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *const</td>          <td class="paramname"><span class="paramname"><em>root_size</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the union find data structure after the removal of a set of edges. </p>
<p>This is a helper method to be able to call <a class="el" href="namespacelal_1_1detail.html#a7c633651b077f8fd9417d8593e222dea">lal::detail::update_unionfind_after_remove_edges</a> which updates the Union-Find data structure under removal of an edge. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edges</td><td>A set of edges. </td></tr>
    <tr><td class="paramname">root_of</td><td>Array of <em>n</em> elements relating each vertex to its root in the union find data structure. </td></tr>
    <tr><td class="paramname">root_size</td><td>Array of <em>n</em> elements relating each vertex to the size of the connected component it belongs to. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classlal_1_1graphs_1_1tree.html#aec260049cf754a19ba9258d812cab80a">lal::graphs::tree</a>.</p>

</div>
</div>
<a id="ac41814d5fbe43cce354aa600f37b9c9f" name="ac41814d5fbe43cce354aa600f37b9c9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac41814d5fbe43cce354aa600f37b9c9f">&#9670;&#160;</a></span>update_union_find_after_remove_edges_bulk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::rooted_tree::update_union_find_after_remove_edges_bulk </td>
          <td>(</td>
          <td class="paramtype">uint64_t *const</td>          <td class="paramname"><span class="paramname"><em>root_of</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *const</td>          <td class="paramname"><span class="paramname"><em>root_size</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the union find data structure after the removal of several edges. </p>
<p>This is a helper method to be able to call <a class="el" href="namespacelal_1_1detail.html#a49b8ff3684b7c460352ee1678541b0d9">lal::detail::update_unionfind_after_add_rem_edges_bulk</a> which updates the Union-Find data structure under removal of several edges. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_of</td><td>Array of <em>n</em> elements relating each vertex to its root in the union find data structure. </td></tr>
    <tr><td class="paramname">root_size</td><td>Array of <em>n</em> elements relating each vertex to the size of the connected component it belongs to. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classlal_1_1graphs_1_1tree.html#a131a43d6c944ccc29b46b930818a2c52">lal::graphs::tree</a>.</p>

</div>
</div>
<a id="a84f5ebd803e3fd0dbda0a23306e7713e" name="a84f5ebd803e3fd0dbda0a23306e7713e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84f5ebd803e3fd0dbda0a23306e7713e">&#9670;&#160;</a></span>update_union_find_before_remove_incident_edges_to()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::rooted_tree::update_union_find_before_remove_incident_edges_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *const</td>          <td class="paramname"><span class="paramname"><em>root_of</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *const</td>          <td class="paramname"><span class="paramname"><em>root_size</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the union find data structure before the removal of all edges incident to a node. </p>
<p>This is a helper method to be able to call <a class="el" href="namespacelal_1_1detail.html#a13f00277c294d1ea536cb0359e2d28fd">lal::detail::update_unionfind_before_remove_edges_incident_to</a> which updates the Union-Find data structure under removal of all incident edges to a node. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>Node whose incident edges are to be removed. </td></tr>
    <tr><td class="paramname">root_of</td><td>Array of <em>n</em> elements relating each vertex to its root in the union find data structure. </td></tr>
    <tr><td class="paramname">root_size</td><td>Array of <em>n</em> elements relating each vertex to the size of the connected component it belongs to. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classlal_1_1graphs_1_1tree.html#a9ea87b62eceaadd99d9f1d5fba4856d9">lal::graphs::tree</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a427d63b1bef991f43db8f5d622567bb6" name="a427d63b1bef991f43db8f5d622567bb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a427d63b1bef991f43db8f5d622567bb6">&#9670;&#160;</a></span>m_is_normalized</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::graphs::graph::m_is_normalized = true</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this graph normalized? </p>
<p>An undirected graph is normalized iff every node's adjacency list is sorted in increasing order.</p>
<p>In directed graphs, however, it is necessary that the adjacency lists of the out-neighbors and in-neighbors of nodes be sorted.</p>
<p>This attribute is set to 'true' in all graph's initialisation and destruction (when <a class="el" href="classlal_1_1graphs_1_1graph.html#af8ba9ec6acf2306c84d9ddbd88fc8474">clear()</a> method is called). </p>

</div>
</div>
<a id="a951a57e760385ce3de285089627b7bbb" name="a951a57e760385ce3de285089627b7bbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a951a57e760385ce3de285089627b7bbb">&#9670;&#160;</a></span>m_is_tree_type_valid</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::graphs::tree::m_is_tree_type_valid = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the type of this tree valid? </p>
<p>This attribute keeps track of whether or not the function <a class="el" href="#aaaa55acc91cddcd44f95419b83706ae9">calculate_tree_type</a> should be called before querying the type of this tree via function <a class="el" href="classlal_1_1graphs_1_1tree.html#a06ce8cc7afb074d2fecf70a0842adaaa">is_of_tree_type</a>. </p>

</div>
</div>
<a id="a8552f04dac202192255315d5c2fc7350" name="a8552f04dac202192255315d5c2fc7350"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8552f04dac202192255315d5c2fc7350">&#9670;&#160;</a></span>m_size_subtrees</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;uint64_t&gt; lal::graphs::rooted_tree::m_size_subtrees</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of nodes of the subtrees rooted at a certain node. </p>
<p>Given a node <em>u</em>, <a class="el" href="#a8552f04dac202192255315d5c2fc7350">m_size_subtrees</a>[u] gives the number of nodes of the subtree rooted at <em>u</em>. </p>

</div>
</div>
<a id="a11bb51b8c210daa43ad5bf6d11bfd35f" name="a11bb51b8c210daa43ad5bf6d11bfd35f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11bb51b8c210daa43ad5bf6d11bfd35f">&#9670;&#160;</a></span>m_union_find__root_size</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;uint64_t&gt; lal::graphs::tree::m_union_find__root_size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The size of the connected component that a <em>root</em> belongs to. </p>
<p>Formally, <em>m_size_of</em>[v] is the size of the connected component of a <em>root</em> vertex <em>v</em>. A vertex <em>u</em> is a root vertex if there exists a vertex <em>w</em> such that <a class="el" href="classlal_1_1graphs_1_1tree.html#ac0be40a4f9c7df1eb2dcbbe7b417ce73">m_union_find__root_of</a>[w] = u.</p>
<p>In this context, root is within the union-find data structure. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>lal/graphs/<a class="el" href="rooted__tree_8hpp_source.html">rooted_tree.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
