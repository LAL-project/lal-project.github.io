<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LAL: Linear Arrangement Library: lal::detail::DMax::planar Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">LAL: Linear Arrangement Library<span id="projectnumber">&#160;24.10.00</span>
   </div>
   <div id="projectbrief">A library focused on algorithms on linear arrangements of graphs.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacelal.html">lal</a></li><li class="navelem"><a class="el" href="namespacelal_1_1detail.html">detail</a></li><li class="navelem"><a class="el" href="namespacelal_1_1detail_1_1DMax.html">DMax</a></li><li class="navelem"><a class="el" href="namespacelal_1_1detail_1_1DMax_1_1planar.html">planar</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">lal::detail::DMax::planar Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>In planar arrangements.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlal_1_1detail_1_1DMax_1_1planar_1_1edge__size__sigma.html">edge_size_sigma</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tuple used to construct the sorted adjacency list.  <a href="structlal_1_1detail_1_1DMax_1_1planar_1_1edge__size__sigma.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlal_1_1detail_1_1DMax_1_1planar_1_1sorted__adjacency__list__info.html">sorted_adjacency_list_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A piece of information within u's list.  <a href="structlal_1_1detail_1_1DMax_1_1planar_1_1sorted__adjacency__list__info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a2d17f1fea2da1fb144f1f6da3542baa1" id="r_a2d17f1fea2da1fb144f1f6da3542baa1"><td class="memItemLeft" align="right" valign="top"><a id="a2d17f1fea2da1fb144f1f6da3542baa1" name="a2d17f1fea2da1fb144f1f6da3542baa1"></a>
typedef std::vector&lt; std::vector&lt; <a class="el" href="structlal_1_1detail_1_1DMax_1_1planar_1_1sorted__adjacency__list__info.html">sorted_adjacency_list_info</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>sorted_adjacency_list</b></td></tr>
<tr class="memdesc:a2d17f1fea2da1fb144f1f6da3542baa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Useful shorthand for a sorted adjacency list. <br /></td></tr>
<tr class="separator:a2d17f1fea2da1fb144f1f6da3542baa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a9e4bcd711c10e83b9c3a61e9891c4c11" id="r_a9e4bcd711c10e83b9c3a61e9891c4c11"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9e4bcd711c10e83b9c3a61e9891c4c11">return_type_all_maxs</a> { <a class="el" href="#a9e4bcd711c10e83b9c3a61e9891c4c11a794adc71a051750441c4294e65de1099">DMax_value_vertex_and_max_root</a>
, <a class="el" href="#a9e4bcd711c10e83b9c3a61e9891c4c11a200dd683d9d593c50ac160e010559b61">DMax_value_vertex</a>
, <a class="el" href="#a9e4bcd711c10e83b9c3a61e9891c4c11abff44204d9ab68d0c9c9a996332d5375">max_root</a>
 }</td></tr>
<tr class="memdesc:a9e4bcd711c10e83b9c3a61e9891c4c11"><td class="mdescLeft">&#160;</td><td class="mdescRight">All return types as enumeration values.  <a href="#a9e4bcd711c10e83b9c3a61e9891c4c11">More...</a><br /></td></tr>
<tr class="separator:a9e4bcd711c10e83b9c3a61e9891c4c11"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aab78d4c97ed3153e45f5b0756e31e1e7" id="r_aab78d4c97ed3153e45f5b0756e31e1e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a2d17f1fea2da1fb144f1f6da3542baa1">sorted_adjacency_list</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aab78d4c97ed3153e45f5b0756e31e1e7">make_sorted_adjacency_list</a> (const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:aab78d4c97ed3153e45f5b0756e31e1e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the for every vertex in the tree. .  <br /></td></tr>
<tr class="separator:aab78d4c97ed3153e45f5b0756e31e1e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa15eda7816b063347ad841b521a6b237" id="r_aa15eda7816b063347ad841b521a6b237"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#a9e4bcd711c10e83b9c3a61e9891c4c11">return_type_all_maxs</a> res_type&gt; </td></tr>
<tr class="memitem:aa15eda7816b063347ad841b521a6b237"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacelal_1_1detail.html#a94b315fff0ef08b701cb06c1e4497bbb">conditional_list_t</a>&lt; <a class="el" href="structlal_1_1detail_1_1bool__sequence.html">bool_sequence</a>&lt; res_type==<a class="el" href="#a9e4bcd711c10e83b9c3a61e9891c4c11a794adc71a051750441c4294e65de1099">return_type_all_maxs::DMax_value_vertex_and_max_root</a>, res_type==<a class="el" href="#a9e4bcd711c10e83b9c3a61e9891c4c11a200dd683d9d593c50ac160e010559b61">return_type_all_maxs::DMax_value_vertex</a>, res_type==<a class="el" href="#a9e4bcd711c10e83b9c3a61e9891c4c11abff44204d9ab68d0c9c9a996332d5375">return_type_all_maxs::max_root</a> &gt;, <a class="el" href="structlal_1_1detail_1_1type__sequence.html">type_sequence</a>&lt; std::pair&lt; std::vector&lt; uint64_t &gt;, uint64_t &gt;, std::vector&lt; uint64_t &gt;, uint64_t &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa15eda7816b063347ad841b521a6b237">all_max_sum_lengths_values</a> (const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:aa15eda7816b063347ad841b521a6b237"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum planar arrangement of a free tree.  <br /></td></tr>
<tr class="separator:aa15eda7816b063347ad841b521a6b237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9edbbdbc93285c7048491084fdfc3497" id="r_a9edbbdbc93285c7048491084fdfc3497"><td class="memTemplParams" colspan="2">template&lt;bool make_arrangement&gt; </td></tr>
<tr class="memitem:a9edbbdbc93285c7048491084fdfc3497"><td class="memTemplItemLeft" align="right" valign="top">std::conditional_t&lt; make_arrangement, std::pair&lt; uint64_t, <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt;, uint64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9edbbdbc93285c7048491084fdfc3497">AEF</a> (const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:a9edbbdbc93285c7048491084fdfc3497"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum planar arrangement of a free tree.  <br /></td></tr>
<tr class="separator:a9edbbdbc93285c7048491084fdfc3497"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>In planar arrangements. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a9e4bcd711c10e83b9c3a61e9891c4c11" name="a9e4bcd711c10e83b9c3a61e9891c4c11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e4bcd711c10e83b9c3a61e9891c4c11">&#9670;&#160;</a></span>return_type_all_maxs</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a9e4bcd711c10e83b9c3a61e9891c4c11">lal::detail::DMax::planar::return_type_all_maxs</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>All return types as enumeration values. </p>
<p>For function <a class="el" href="#aa15eda7816b063347ad841b521a6b237">all_max_sum_lengths_values</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a9e4bcd711c10e83b9c3a61e9891c4c11a794adc71a051750441c4294e65de1099" name="a9e4bcd711c10e83b9c3a61e9891c4c11a794adc71a051750441c4294e65de1099"></a>DMax_value_vertex_and_max_root&#160;</td><td class="fielddoc"><p>Return both the set of max projective values at every vertex and the vertex that maximizes the maximum projective. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9e4bcd711c10e83b9c3a61e9891c4c11a200dd683d9d593c50ac160e010559b61" name="a9e4bcd711c10e83b9c3a61e9891c4c11a200dd683d9d593c50ac160e010559b61"></a>DMax_value_vertex&#160;</td><td class="fielddoc"><p>Return only the max projective values for every vertex of the tree. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9e4bcd711c10e83b9c3a61e9891c4c11abff44204d9ab68d0c9c9a996332d5375" name="a9e4bcd711c10e83b9c3a61e9891c4c11abff44204d9ab68d0c9c9a996332d5375"></a>max_root&#160;</td><td class="fielddoc"><p>Return only a vertex that maximizes the maximum projective. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a9edbbdbc93285c7048491084fdfc3497" name="a9edbbdbc93285c7048491084fdfc3497"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9edbbdbc93285c7048491084fdfc3497">&#9670;&#160;</a></span>AEF()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool make_arrangement&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; make_arrangement, std::pair&lt; uint64_t, <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt;, uint64_t &gt; lal::detail::DMax::planar::AEF </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximum planar arrangement of a free tree. </p>
<p>This algorithm calculates the maximum sum of edge lengths on every vertex and keeps track of the maximum. The calculation of <a class="el" href="namespacelal_1_1detail_1_1DMax.html" title="Namespace for algorithms to calculate the maximum sum of edge lengths.">DMax</a> on every vertex is done in \(O(n)\) thanks to the adjacency list calculated by function <a class="el" href="#aab78d4c97ed3153e45f5b0756e31e1e7">make_sorted_adjacency_list</a>.</p>
<p>This function calls <a class="el" href="#aa15eda7816b063347ad841b521a6b237">all_max_sum_lengths_values</a>, which implements the algorithm described in <a class="el" href="citelist.html#CITEREF_Alemany2024a">[8]</a>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">make_arrangement</td><td>Construct a maximum arrangement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair of cost and maximum linear arrangement. </dd></dl>

</div>
</div>
<a id="aa15eda7816b063347ad841b521a6b237" name="aa15eda7816b063347ad841b521a6b237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa15eda7816b063347ad841b521a6b237">&#9670;&#160;</a></span>all_max_sum_lengths_values()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#a9e4bcd711c10e83b9c3a61e9891c4c11">return_type_all_maxs</a> res_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacelal_1_1detail.html#a94b315fff0ef08b701cb06c1e4497bbb">conditional_list_t</a>&lt; <a class="el" href="structlal_1_1detail_1_1bool__sequence.html">bool_sequence</a>&lt; res_type==<a class="el" href="#a9e4bcd711c10e83b9c3a61e9891c4c11a794adc71a051750441c4294e65de1099">return_type_all_maxs::DMax_value_vertex_and_max_root</a>, res_type==<a class="el" href="#a9e4bcd711c10e83b9c3a61e9891c4c11a200dd683d9d593c50ac160e010559b61">return_type_all_maxs::DMax_value_vertex</a>, res_type==<a class="el" href="#a9e4bcd711c10e83b9c3a61e9891c4c11abff44204d9ab68d0c9c9a996332d5375">return_type_all_maxs::max_root</a> &gt;, <a class="el" href="structlal_1_1detail_1_1type__sequence.html">type_sequence</a>&lt; std::pair&lt; std::vector&lt; uint64_t &gt;, uint64_t &gt;, std::vector&lt; uint64_t &gt;, uint64_t &gt; &gt; lal::detail::DMax::planar::all_max_sum_lengths_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximum planar arrangement of a free tree. </p>
<p>This algorithm calculates the maximum sum of edge lengths on every vertex and keeps track of the maximum. The calculation of the maximum sum of edge lengths on every vertex is done in \(O(n)\) thanks to the adjacency list calculated by function <a class="el" href="#aab78d4c97ed3153e45f5b0756e31e1e7">make_sorted_adjacency_list</a>.</p>
<p>This function implements the algorithm in <a class="el" href="citelist.html#CITEREF_Alemany2024a">[8]</a>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">res_type</td><td>The type of result to return. See <a class="el" href="#a9e4bcd711c10e83b9c3a61e9891c4c11">return_type_all_maxs</a> for details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Depending of the value of <em>res_type</em>, a list of values, a p </dd></dl>

</div>
</div>
<a id="aab78d4c97ed3153e45f5b0756e31e1e7" name="aab78d4c97ed3153e45f5b0756e31e1e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab78d4c97ed3153e45f5b0756e31e1e7">&#9670;&#160;</a></span>make_sorted_adjacency_list()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a2d17f1fea2da1fb144f1f6da3542baa1">sorted_adjacency_list</a> lal::detail::DMax::planar::make_sorted_adjacency_list </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct the for every vertex in the tree. . </p>
<p>Sorted adjacency list needed to calculate the maximum sum of edge legnths.</p>
<p>This adjacency list is needed in function <a class="el" href="#aa15eda7816b063347ad841b521a6b237">all_max_sum_lengths_values</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input free tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The appropriate sorted adjacency list. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
