<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LAL: Linear Arrangement Library: lal::detail::DMax::unconstrained::AEF_BnB Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">LAL: Linear Arrangement Library<span id="projectnumber">&#160;24.10.00</span>
   </div>
   <div id="projectbrief">A library focused on algorithms on linear arrangements of graphs.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacelal.html">lal</a></li><li class="navelem"><a class="el" href="namespacelal_1_1detail.html">detail</a></li><li class="navelem"><a class="el" href="namespacelal_1_1detail_1_1DMax.html">DMax</a></li><li class="navelem"><a class="el" href="namespacelal_1_1detail_1_1DMax_1_1unconstrained.html">unconstrained</a></li><li class="navelem"><a class="el" href="classlal_1_1detail_1_1DMax_1_1unconstrained_1_1AEF__BnB.html">AEF_BnB</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#properties">Properties</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classlal_1_1detail_1_1DMax_1_1unconstrained_1_1AEF__BnB-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">lal::detail::DMax::unconstrained::AEF_BnB Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A Branch and Bound algorithm for the maximum sum of edge lengths.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="BnB_8hpp_source.html">BnB.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1detail_1_1DMax_1_1unconstrained_1_1AEF__BnB_1_1indexer__edge.html">indexer_edge</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class to be able to store edges in <a class="el" href="#a0bc81fefc6365485f87de202169d5961">m_E_p</a>, <a class="el" href="#a054eb8a07224e44d38355f6e48ec8385">m_E_ps</a>, <a class="el" href="#aa417a40b6a9ee35f10751d392425aa84">m_E_s</a>.  <a href="classlal_1_1detail_1_1DMax_1_1unconstrained_1_1AEF__BnB_1_1indexer__edge.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlal_1_1detail_1_1DMax_1_1unconstrained_1_1AEF__BnB_1_1path__info.html">path_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data related to paths in the tree.  <a href="structlal_1_1detail_1_1DMax_1_1unconstrained_1_1AEF__BnB_1_1path__info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a4f8f683e63c27df0d558ec81e330de99" id="r_a4f8f683e63c27df0d558ec81e330de99"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4f8f683e63c27df0d558ec81e330de99">process_end_result</a> { <a class="el" href="#a4f8f683e63c27df0d558ec81e330de99ad600390139979e4ff17e5e023763f199">did_not_reach_end</a> = 0b00000000
, <a class="el" href="#a4f8f683e63c27df0d558ec81e330de99af360bf61fd2ba6ee9c8bbf15e24447cd">reached_end</a> = 0b00000001
, <a class="el" href="#a4f8f683e63c27df0d558ec81e330de99a38a51714e9bbb6cacdda7b2017771e8b">found_max</a> = 0b00000010
 }</td></tr>
<tr class="memdesc:a4f8f683e63c27df0d558ec81e330de99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration used in the function <a class="el" href="#a0693a7a76d1f4a2e57b12533355a556a">process_end</a>.  <a href="#a4f8f683e63c27df0d558ec81e330de99">More...</a><br /></td></tr>
<tr class="separator:a4f8f683e63c27df0d558ec81e330de99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77828577047ac3b85344a1065a251460" id="r_a77828577047ac3b85344a1065a251460"><td class="memItemLeft" align="right" valign="top">typedef std::conditional_t&lt; <a class="el" href="#a93f0c53dcf1fee1caa54e76ae6c32270">debug_BnB</a>, bool, void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a77828577047ac3b85344a1065a251460">exe_result_type</a></td></tr>
<tr class="memdesc:a77828577047ac3b85344a1065a251460"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result of the main function of the algorithm.  <br /></td></tr>
<tr class="separator:a77828577047ac3b85344a1065a251460"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7818f664ae626ce14ca4825448ea5987" id="r_a7818f664ae626ce14ca4825448ea5987"><td class="memItemLeft" align="right" valign="top"><a id="a7818f664ae626ce14ca4825448ea5987" name="a7818f664ae626ce14ca4825448ea5987"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>did_reach_end</b> (const int at) const noexcept</td></tr>
<tr class="memdesc:a7818f664ae626ce14ca4825448ea5987"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <em>at</em> does not contain <a class="el" href="#a4f8f683e63c27df0d558ec81e330de99ad600390139979e4ff17e5e023763f199">process_end_result::did_not_reach_end</a>. <br /></td></tr>
<tr class="separator:a7818f664ae626ce14ca4825448ea5987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac981b4e4e6e4a2523de82b1cd2f19a5e" id="r_ac981b4e4e6e4a2523de82b1cd2f19a5e"><td class="memItemLeft" align="right" valign="top"><a id="ac981b4e4e6e4a2523de82b1cd2f19a5e" name="ac981b4e4e6e4a2523de82b1cd2f19a5e"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>did_find_max</b> (const int at) const noexcept</td></tr>
<tr class="memdesc:ac981b4e4e6e4a2523de82b1cd2f19a5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <em>at</em> contains <a class="el" href="#a4f8f683e63c27df0d558ec81e330de99a38a51714e9bbb6cacdda7b2017771e8b">process_end_result::found_max</a>. <br /></td></tr>
<tr class="separator:ac981b4e4e6e4a2523de82b1cd2f19a5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd7600fcf4a6a2c9d010193de9388191" id="r_afd7600fcf4a6a2c9d010193de9388191"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd7600fcf4a6a2c9d010193de9388191">AEF_BnB</a> (const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;t, const <a class="el" href="structlal_1_1detail_1_1array.html">array</a>&lt; std::vector&lt; <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> &gt; &gt; &amp;leaves, const <a class="el" href="classlal_1_1properties_1_1bipartite__graph__coloring.html">properties::bipartite_graph_coloring</a> &amp;colors, const uint64_t num_verts_blue, const uint64_t num_verts_red, const std::vector&lt; <a class="el" href="classlal_1_1properties_1_1branchless__path.html">properties::branchless_path</a> &gt; &amp;paths_in_tree, const <a class="el" href="structlal_1_1detail_1_1array.html">array</a>&lt; std::size_t &gt; &amp;node_to_path_idx, const <a class="el" href="structlal_1_1detail_1_1array.html">array</a>&lt; std::vector&lt; <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> &gt; &gt; &amp;incident_antennas, const std::vector&lt; std::vector&lt; <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> &gt; &gt; &amp;orbits, const <a class="el" href="structlal_1_1detail_1_1array.html">array</a>&lt; std::size_t &gt; &amp;vertex_to_orbit) noexcept</td></tr>
<tr class="memdesc:afd7600fcf4a6a2c9d010193de9388191"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <br /></td></tr>
<tr class="separator:afd7600fcf4a6a2c9d010193de9388191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1421085d4e59061aef7651e6d366ba27" id="r_a1421085d4e59061aef7651e6d366ba27"><td class="memItemLeft" align="right" valign="top"><a id="a1421085d4e59061aef7651e6d366ba27" name="a1421085d4e59061aef7651e6d366ba27"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~AEF_BnB</b> () noexcept=default</td></tr>
<tr class="memdesc:a1421085d4e59061aef7651e6d366ba27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a1421085d4e59061aef7651e6d366ba27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a715b28e7d05d5fc9f16fe92e96807742" id="r_a715b28e7d05d5fc9f16fe92e96807742"><td class="memItemLeft" align="right" valign="top"><a id="a715b28e7d05d5fc9f16fe92e96807742" name="a715b28e7d05d5fc9f16fe92e96807742"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>initialize</b> (const std::pair&lt; uint64_t, <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;initial_DMax) noexcept</td></tr>
<tr class="memdesc:a715b28e7d05d5fc9f16fe92e96807742"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the Branch and Bound algorithm. <br /></td></tr>
<tr class="separator:a715b28e7d05d5fc9f16fe92e96807742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad89784d56880ca66bb1885a3dd0596af" id="r_ad89784d56880ca66bb1885a3dd0596af"><td class="memItemLeft" align="right" valign="top"><a id="ad89784d56880ca66bb1885a3dd0596af" name="ad89784d56880ca66bb1885a3dd0596af"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>exe</b> (<a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> first_node) noexcept</td></tr>
<tr class="memdesc:ad89784d56880ca66bb1885a3dd0596af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute the algorithm starting at the given vertex. <br /></td></tr>
<tr class="separator:ad89784d56880ca66bb1885a3dd0596af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a431fcb275885b5237003e8808189c009" id="r_a431fcb275885b5237003e8808189c009"><td class="memItemLeft" align="right" valign="top"><a id="a431fcb275885b5237003e8808189c009" name="a431fcb275885b5237003e8808189c009"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>has_valid_LV_prediction</b> (<a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u) const noexcept</td></tr>
<tr class="memdesc:a431fcb275885b5237003e8808189c009"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does vertex <em>u</em> have a valid prediction of level value? <br /></td></tr>
<tr class="separator:a431fcb275885b5237003e8808189c009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb5ede352b6e85fa181e4ddf851671a1" id="r_abb5ede352b6e85fa181e4ddf851671a1"><td class="memItemLeft" align="right" valign="top"><a id="abb5ede352b6e85fa181e4ddf851671a1" name="abb5ede352b6e85fa181e4ddf851671a1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_node_a_trigger_of_LV</b> (<a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u) const noexcept</td></tr>
<tr class="memdesc:abb5ede352b6e85fa181e4ddf851671a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Did a propagation of level values start at vertex <em>u</em>? <br /></td></tr>
<tr class="separator:abb5ede352b6e85fa181e4ddf851671a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a1af60d30a7b104fc698b0f03f7e675c2" id="r_a1af60d30a7b104fc698b0f03f7e675c2"><td class="memItemLeft" align="right" valign="top"><a id="a1af60d30a7b104fc698b0f03f7e675c2" name="a1af60d30a7b104fc698b0f03f7e675c2"></a>
const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>m_t</b></td></tr>
<tr class="memdesc:a1af60d30a7b104fc698b0f03f7e675c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to the input free tree. <br /></td></tr>
<tr class="separator:a1af60d30a7b104fc698b0f03f7e675c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89b7e28cccad6bc9ea5bde3381d3b2f0" id="r_a89b7e28cccad6bc9ea5bde3381d3b2f0"><td class="memItemLeft" align="right" valign="top"><a id="a89b7e28cccad6bc9ea5bde3381d3b2f0" name="a89b7e28cccad6bc9ea5bde3381d3b2f0"></a>
<a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_rt</b></td></tr>
<tr class="memdesc:a89b7e28cccad6bc9ea5bde3381d3b2f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Temporary memory to store <a class="el" href="#a1af60d30a7b104fc698b0f03f7e675c2">m_t</a> as a rooted tree. <br /></td></tr>
<tr class="separator:a89b7e28cccad6bc9ea5bde3381d3b2f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d1cb52ec33c0bb7cba9712f60a62081" id="r_a8d1cb52ec33c0bb7cba9712f60a62081"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1detail_1_1DMax_1_1unconstrained_1_1set__maximum__arrangements.html">set_maximum_arrangements</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d1cb52ec33c0bb7cba9712f60a62081">m_max_arrs</a></td></tr>
<tr class="memdesc:a8d1cb52ec33c0bb7cba9712f60a62081"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complete result of the algorithm.  <br /></td></tr>
<tr class="separator:a8d1cb52ec33c0bb7cba9712f60a62081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02ad7da60db3f2b35b2bab14aa98f57c" id="r_a02ad7da60db3f2b35b2bab14aa98f57c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a02ad7da60db3f2b35b2bab14aa98f57c">m_arr</a></td></tr>
<tr class="memdesc:a02ad7da60db3f2b35b2bab14aa98f57c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial result of the algorithm.  <br /></td></tr>
<tr class="separator:a02ad7da60db3f2b35b2bab14aa98f57c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aa86e5740957c728022f88cdba2a9bc" id="r_a6aa86e5740957c728022f88cdba2a9bc"><td class="memItemLeft" align="right" valign="top"><a id="a6aa86e5740957c728022f88cdba2a9bc" name="a6aa86e5740957c728022f88cdba2a9bc"></a>
const uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>m_num_nodes_blue</b></td></tr>
<tr class="memdesc:a6aa86e5740957c728022f88cdba2a9bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of blue vertices (m_vertex_colors). <br /></td></tr>
<tr class="separator:a6aa86e5740957c728022f88cdba2a9bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a983c11d4762a3519f424a2671679e257" id="r_a983c11d4762a3519f424a2671679e257"><td class="memItemLeft" align="right" valign="top"><a id="a983c11d4762a3519f424a2671679e257" name="a983c11d4762a3519f424a2671679e257"></a>
const uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>m_num_nodes_red</b></td></tr>
<tr class="memdesc:a983c11d4762a3519f424a2671679e257"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of red vertices (m_vertex_colors). <br /></td></tr>
<tr class="separator:a983c11d4762a3519f424a2671679e257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a455029307fb3f8211dda374546b37625" id="r_a455029307fb3f8211dda374546b37625"><td class="memItemLeft" align="right" valign="top"><a id="a455029307fb3f8211dda374546b37625" name="a455029307fb3f8211dda374546b37625"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>m_num_assigned_nodes_blue</b></td></tr>
<tr class="memdesc:a455029307fb3f8211dda374546b37625"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of blue vertices that are assigned to the prefix of the arrangement (m_vertex_colors). <br /></td></tr>
<tr class="separator:a455029307fb3f8211dda374546b37625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47dc25662805fc820001c7623b351b4f" id="r_a47dc25662805fc820001c7623b351b4f"><td class="memItemLeft" align="right" valign="top"><a id="a47dc25662805fc820001c7623b351b4f" name="a47dc25662805fc820001c7623b351b4f"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>m_num_assigned_nodes_red</b></td></tr>
<tr class="memdesc:a47dc25662805fc820001c7623b351b4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of red vertices that are assigned to the prefix of the arrangement (m_vertex_colors). <br /></td></tr>
<tr class="separator:a47dc25662805fc820001c7623b351b4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdb6e5097841f0fc526c797619665f1d" id="r_abdb6e5097841f0fc526c797619665f1d"><td class="memItemLeft" align="right" valign="top"><a id="abdb6e5097841f0fc526c797619665f1d" name="abdb6e5097841f0fc526c797619665f1d"></a>
const std::vector&lt; <a class="el" href="classlal_1_1properties_1_1branchless__path.html">properties::branchless_path</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>m_paths_in_tree</b></td></tr>
<tr class="memdesc:abdb6e5097841f0fc526c797619665f1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">All the branchless paths of the tree. <br /></td></tr>
<tr class="separator:abdb6e5097841f0fc526c797619665f1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae807c6710b4f11a7a6ddb12d3cf7b234" id="r_ae807c6710b4f11a7a6ddb12d3cf7b234"><td class="memItemLeft" align="right" valign="top"><a id="ae807c6710b4f11a7a6ddb12d3cf7b234" name="ae807c6710b4f11a7a6ddb12d3cf7b234"></a>
const <a class="el" href="structlal_1_1detail_1_1array.html">array</a>&lt; std::size_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>m_node_to_path_idx</b></td></tr>
<tr class="memdesc:ae807c6710b4f11a7a6ddb12d3cf7b234"><td class="mdescLeft">&#160;</td><td class="mdescRight">An index for each vertex that points to its path in <a class="el" href="#abdb6e5097841f0fc526c797619665f1d">m_paths_in_tree</a>. <br /></td></tr>
<tr class="separator:ae807c6710b4f11a7a6ddb12d3cf7b234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae72f7024874c10ee148a89638caba6b2" id="r_ae72f7024874c10ee148a89638caba6b2"><td class="memItemLeft" align="right" valign="top"><a id="ae72f7024874c10ee148a89638caba6b2" name="ae72f7024874c10ee148a89638caba6b2"></a>
const std::vector&lt; std::vector&lt; <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>m_orbits</b></td></tr>
<tr class="memdesc:ae72f7024874c10ee148a89638caba6b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The set of vertex orbits of the tree. <br /></td></tr>
<tr class="separator:ae72f7024874c10ee148a89638caba6b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af046d4f2d176aa73bece3b24f3b1c8de" id="r_af046d4f2d176aa73bece3b24f3b1c8de"><td class="memItemLeft" align="right" valign="top"><a id="af046d4f2d176aa73bece3b24f3b1c8de" name="af046d4f2d176aa73bece3b24f3b1c8de"></a>
const <a class="el" href="structlal_1_1detail_1_1array.html">array</a>&lt; std::size_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>m_node_to_orbit</b></td></tr>
<tr class="memdesc:af046d4f2d176aa73bece3b24f3b1c8de"><td class="mdescLeft">&#160;</td><td class="mdescRight">An index for each vertex that points to its vertex orbit in <a class="el" href="#ae72f7024874c10ee148a89638caba6b2">m_orbits</a>. <br /></td></tr>
<tr class="separator:af046d4f2d176aa73bece3b24f3b1c8de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af034d8f33c161c58c5dc8fa4a8bcdd5f" id="r_af034d8f33c161c58c5dc8fa4a8bcdd5f"><td class="memItemLeft" align="right" valign="top"><a id="af034d8f33c161c58c5dc8fa4a8bcdd5f" name="af034d8f33c161c58c5dc8fa4a8bcdd5f"></a>
<a class="el" href="structlal_1_1detail_1_1array.html">array</a>&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_degree_count</b></td></tr>
<tr class="memdesc:af034d8f33c161c58c5dc8fa4a8bcdd5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frequency of degrees among unassigned vertices. <br /></td></tr>
<tr class="separator:af034d8f33c161c58c5dc8fa4a8bcdd5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaaa263a05f2591a4fb8e25d1f62d94b" id="r_adaaa263a05f2591a4fb8e25d1f62d94b"><td class="memItemLeft" align="right" valign="top"><a id="adaaa263a05f2591a4fb8e25d1f62d94b" name="adaaa263a05f2591a4fb8e25d1f62d94b"></a>
<a class="el" href="structlal_1_1detail_1_1array.html">array</a>&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_num_assigned_neighbors</b></td></tr>
<tr class="memdesc:adaaa263a05f2591a4fb8e25d1f62d94b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of assigned neighbor vertices for each vertex. <br /></td></tr>
<tr class="separator:adaaa263a05f2591a4fb8e25d1f62d94b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60f540535d5e0458215a9bb09316a0d4" id="r_a60f540535d5e0458215a9bb09316a0d4"><td class="memItemLeft" align="right" valign="top"><a id="a60f540535d5e0458215a9bb09316a0d4" name="a60f540535d5e0458215a9bb09316a0d4"></a>
<a class="el" href="structlal_1_1detail_1_1array.html">array</a>&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_num_unassigned_neighbors</b></td></tr>
<tr class="memdesc:a60f540535d5e0458215a9bb09316a0d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of unassigned neighbor vertices for each vertex. <br /></td></tr>
<tr class="separator:a60f540535d5e0458215a9bb09316a0d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a150d26460eb72200d8d72be33ab551dc" id="r_a150d26460eb72200d8d72be33ab551dc"><td class="memItemLeft" align="right" valign="top"><a id="a150d26460eb72200d8d72be33ab551dc" name="a150d26460eb72200d8d72be33ab551dc"></a>
<a class="el" href="classlal_1_1detail_1_1set__array.html">set_array</a>&lt; <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_border_nodes</b></td></tr>
<tr class="memdesc:a150d26460eb72200d8d72be33ab551dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The set of border vertices. <br /></td></tr>
<tr class="separator:a150d26460eb72200d8d72be33ab551dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b8be403b3d8782ff3c6ee2d657bd1b5" id="r_a7b8be403b3d8782ff3c6ee2d657bd1b5"><td class="memItemLeft" align="right" valign="top"><a id="a7b8be403b3d8782ff3c6ee2d657bd1b5" name="a7b8be403b3d8782ff3c6ee2d657bd1b5"></a>
<a class="el" href="structlal_1_1detail_1_1sorting_1_1countingsort_1_1memory.html">sorting::countingsort::memory</a>&lt; <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_sorting_memory</b></td></tr>
<tr class="memdesc:a7b8be403b3d8782ff3c6ee2d657bd1b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary memory to speed up the calculation of the upper bound. <br /></td></tr>
<tr class="separator:a7b8be403b3d8782ff3c6ee2d657bd1b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21cecabd762258f02c77ba57e35a1676" id="r_a21cecabd762258f02c77ba57e35a1676"><td class="memItemLeft" align="right" valign="top"><a id="a21cecabd762258f02c77ba57e35a1676" name="a21cecabd762258f02c77ba57e35a1676"></a>
<a class="el" href="structlal_1_1detail_1_1array.html">array</a>&lt; <a class="el" href="structlal_1_1detail_1_1DMax_1_1unconstrained_1_1AEF__BnB_1_1path__info.html">path_info</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_path_info</b></td></tr>
<tr class="memdesc:a21cecabd762258f02c77ba57e35a1676"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control of vertices to assign in the arrangement with a specific level value. <br /></td></tr>
<tr class="separator:a21cecabd762258f02c77ba57e35a1676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4386f8b6e5a72c7dd802b4bb3f76987" id="r_ac4386f8b6e5a72c7dd802b4bb3f76987"><td class="memItemLeft" align="right" valign="top"><a id="ac4386f8b6e5a72c7dd802b4bb3f76987" name="ac4386f8b6e5a72c7dd802b4bb3f76987"></a>
<a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_first_node</b></td></tr>
<tr class="memdesc:ac4386f8b6e5a72c7dd802b4bb3f76987"><td class="mdescLeft">&#160;</td><td class="mdescRight">First vertex with which to start the algorithm. <br /></td></tr>
<tr class="separator:ac4386f8b6e5a72c7dd802b4bb3f76987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46025a4f747e9d5d2e8c7cc423d14a2d" id="r_a46025a4f747e9d5d2e8c7cc423d14a2d"><td class="memItemLeft" align="right" valign="top"><a id="a46025a4f747e9d5d2e8c7cc423d14a2d" name="a46025a4f747e9d5d2e8c7cc423d14a2d"></a>
<a class="el" href="structlal_1_1detail_1_1array.html">array</a>&lt; char &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_is_node_assigned</b></td></tr>
<tr class="memdesc:a46025a4f747e9d5d2e8c7cc423d14a2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The set of assigned nodes. <br /></td></tr>
<tr class="separator:a46025a4f747e9d5d2e8c7cc423d14a2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bc81fefc6365485f87de202169d5961" id="r_a0bc81fefc6365485f87de202169d5961"><td class="memItemLeft" align="right" valign="top"><a id="a0bc81fefc6365485f87de202169d5961" name="a0bc81fefc6365485f87de202169d5961"></a>
<a class="el" href="classlal_1_1detail_1_1set__array.html">set_array</a>&lt; <a class="el" href="namespacelal.html#a5969ec7ecc85697ebb9ec0ace78fbcab">edge</a>, <a class="el" href="classlal_1_1detail_1_1DMax_1_1unconstrained_1_1AEF__BnB_1_1indexer__edge.html">indexer_edge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_E_p</b></td></tr>
<tr class="memdesc:a0bc81fefc6365485f87de202169d5961"><td class="mdescLeft">&#160;</td><td class="mdescRight">The set of edges fully contained in the prefix. <br /></td></tr>
<tr class="separator:a0bc81fefc6365485f87de202169d5961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a054eb8a07224e44d38355f6e48ec8385" id="r_a054eb8a07224e44d38355f6e48ec8385"><td class="memItemLeft" align="right" valign="top"><a id="a054eb8a07224e44d38355f6e48ec8385" name="a054eb8a07224e44d38355f6e48ec8385"></a>
<a class="el" href="classlal_1_1detail_1_1set__array.html">set_array</a>&lt; <a class="el" href="namespacelal.html#a5969ec7ecc85697ebb9ec0ace78fbcab">edge</a>, <a class="el" href="classlal_1_1detail_1_1DMax_1_1unconstrained_1_1AEF__BnB_1_1indexer__edge.html">indexer_edge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_E_ps</b></td></tr>
<tr class="memdesc:a054eb8a07224e44d38355f6e48ec8385"><td class="mdescLeft">&#160;</td><td class="mdescRight">The set of edges with one endpoint in the prefix, the other in the suffix. <br /></td></tr>
<tr class="separator:a054eb8a07224e44d38355f6e48ec8385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa417a40b6a9ee35f10751d392425aa84" id="r_aa417a40b6a9ee35f10751d392425aa84"><td class="memItemLeft" align="right" valign="top"><a id="aa417a40b6a9ee35f10751d392425aa84" name="aa417a40b6a9ee35f10751d392425aa84"></a>
<a class="el" href="classlal_1_1detail_1_1set__array.html">set_array</a>&lt; <a class="el" href="namespacelal.html#a5969ec7ecc85697ebb9ec0ace78fbcab">edge</a>, <a class="el" href="classlal_1_1detail_1_1DMax_1_1unconstrained_1_1AEF__BnB_1_1indexer__edge.html">indexer_edge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_E_s</b></td></tr>
<tr class="memdesc:aa417a40b6a9ee35f10751d392425aa84"><td class="mdescLeft">&#160;</td><td class="mdescRight">The set of edges fully contained in the suffix. <br /></td></tr>
<tr class="separator:aa417a40b6a9ee35f10751d392425aa84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e6b44dcc3278a8c5bad3735f72e7078" id="r_a0e6b44dcc3278a8c5bad3735f72e7078"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlal_1_1detail_1_1array.html">array</a>&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e6b44dcc3278a8c5bad3735f72e7078">m_node_left_degree</a></td></tr>
<tr class="memdesc:a0e6b44dcc3278a8c5bad3735f72e7078"><td class="mdescLeft">&#160;</td><td class="mdescRight">Directional left degree of each assigned vertex.  <br /></td></tr>
<tr class="separator:a0e6b44dcc3278a8c5bad3735f72e7078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9e535882643b6d941d4e4c9bf7fad5d" id="r_ac9e535882643b6d941d4e4c9bf7fad5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlal_1_1detail_1_1array.html">array</a>&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac9e535882643b6d941d4e4c9bf7fad5d">m_node_right_degree</a></td></tr>
<tr class="memdesc:ac9e535882643b6d941d4e4c9bf7fad5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Directional right degree of each assigned vertex.  <br /></td></tr>
<tr class="separator:ac9e535882643b6d941d4e4c9bf7fad5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f55c15ca2d1d726808e50f4de1e4dc2" id="r_a7f55c15ca2d1d726808e50f4de1e4dc2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlal_1_1detail_1_1array.html">array</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f55c15ca2d1d726808e50f4de1e4dc2">m_node_level</a></td></tr>
<tr class="memdesc:a7f55c15ca2d1d726808e50f4de1e4dc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The level value of each assigned vertex.  <br /></td></tr>
<tr class="separator:a7f55c15ca2d1d726808e50f4de1e4dc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5735a091f59a0a1eb5c3e62d61f8840e" id="r_a5735a091f59a0a1eb5c3e62d61f8840e"><td class="memItemLeft" align="right" valign="top"><a id="a5735a091f59a0a1eb5c3e62d61f8840e" name="a5735a091f59a0a1eb5c3e62d61f8840e"></a>
<a class="el" href="structlal_1_1detail_1_1array.html">array</a>&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_cut_values</b></td></tr>
<tr class="memdesc:a5735a091f59a0a1eb5c3e62d61f8840e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cuts in the arrangement. <br /></td></tr>
<tr class="separator:a5735a091f59a0a1eb5c3e62d61f8840e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a49c5d51cc28f9e887e7fa456b27a34" id="r_a1a49c5d51cc28f9e887e7fa456b27a34"><td class="memItemLeft" align="right" valign="top"><a id="a1a49c5d51cc28f9e887e7fa456b27a34" name="a1a49c5d51cc28f9e887e7fa456b27a34"></a>
<a class="el" href="structlal_1_1detail_1_1array.html">array</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_predicted_LV</b></td></tr>
<tr class="memdesc:a1a49c5d51cc28f9e887e7fa456b27a34"><td class="mdescLeft">&#160;</td><td class="mdescRight">The set of predicted level values for all vertices of the tree. <br /></td></tr>
<tr class="separator:a1a49c5d51cc28f9e887e7fa456b27a34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a366f89299fb6f6025f9098d4a378ec1b" id="r_a366f89299fb6f6025f9098d4a378ec1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlal_1_1detail_1_1array.html">array</a>&lt; <a class="el" href="namespacelal_1_1detail_1_1DMax_1_1unconstrained.html#a91afa1e2ca287e09560d9950b6a4d8ac">LV_propagation_origin</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a366f89299fb6f6025f9098d4a378ec1b">m_predicted_LV__origin</a></td></tr>
<tr class="memdesc:a366f89299fb6f6025f9098d4a378ec1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Origin of a propagation of level values.  <br /></td></tr>
<tr class="separator:a366f89299fb6f6025f9098d4a378ec1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a30ffdb9131d8f18aed4e4ebb6831b7d8" id="r_a30ffdb9131d8f18aed4e4ebb6831b7d8"><td class="memItemLeft" align="right" valign="top"><a id="a30ffdb9131d8f18aed4e4ebb6831b7d8" name="a30ffdb9131d8f18aed4e4ebb6831b7d8"></a>
static constexpr char&#160;</td><td class="memItemRight" valign="bottom"><b>VERTEX_ASSIGNED</b> = 1</td></tr>
<tr class="memdesc:a30ffdb9131d8f18aed4e4ebb6831b7d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value to indicate that a vertex is assigned to the arrangement. <br /></td></tr>
<tr class="separator:a30ffdb9131d8f18aed4e4ebb6831b7d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecb19256e3bbd8b4105f36f7c1b4efbc" id="r_aecb19256e3bbd8b4105f36f7c1b4efbc"><td class="memItemLeft" align="right" valign="top"><a id="aecb19256e3bbd8b4105f36f7c1b4efbc" name="aecb19256e3bbd8b4105f36f7c1b4efbc"></a>
static constexpr char&#160;</td><td class="memItemRight" valign="bottom"><b>VERTEX_UNASSIGNED</b> = 0</td></tr>
<tr class="memdesc:aecb19256e3bbd8b4105f36f7c1b4efbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value to indicate that a vertex is not assigned to the arrangement. <br /></td></tr>
<tr class="separator:aecb19256e3bbd8b4105f36f7c1b4efbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93f0c53dcf1fee1caa54e76ae6c32270" id="r_a93f0c53dcf1fee1caa54e76ae6c32270"><td class="memItemLeft" align="right" valign="top"><a id="a93f0c53dcf1fee1caa54e76ae6c32270" name="a93f0c53dcf1fee1caa54e76ae6c32270"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>debug_BnB</b></td></tr>
<tr class="memdesc:a93f0c53dcf1fee1caa54e76ae6c32270"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to determine the result type of certain functions. <br /></td></tr>
<tr class="separator:a93f0c53dcf1fee1caa54e76ae6c32270"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a595b688e56aebf40d637cad58040e219" id="r_a595b688e56aebf40d637cad58040e219"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacelal_1_1detail_1_1DMax_1_1unconstrained.html#a06676dd19037e1da66d1eac82183ea74">reason_discard</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a595b688e56aebf40d637cad58040e219">check_propagation_node_to_node</a> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u, const int64_t level_u, const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> v, const int64_t level_v) const noexcept</td></tr>
<tr class="memdesc:a595b688e56aebf40d637cad58040e219"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can the propagation from vertex <em>u</em> to vertex <em>v</em> fail?  <br /></td></tr>
<tr class="separator:a595b688e56aebf40d637cad58040e219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab508a711013167a7020abf3f9920606f" id="r_ab508a711013167a7020abf3f9920606f"><td class="memItemLeft" align="right" valign="top"><a id="ab508a711013167a7020abf3f9920606f" name="ab508a711013167a7020abf3f9920606f"></a>
<a class="el" href="namespacelal_1_1detail_1_1DMax_1_1unconstrained.html#a06676dd19037e1da66d1eac82183ea74">reason_discard</a>&#160;</td><td class="memItemRight" valign="bottom"><b>discard_node__degree_2__bridge__level_0</b> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u) const noexcept</td></tr>
<tr class="memdesc:ab508a711013167a7020abf3f9920606f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can a vertex of a bridge be discarded when it is to be assigned with level 0? <br /></td></tr>
<tr class="separator:ab508a711013167a7020abf3f9920606f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9211d41882566ac1bbe708d401fc0d7c" id="r_a9211d41882566ac1bbe708d401fc0d7c"><td class="memItemLeft" align="right" valign="top"><a id="a9211d41882566ac1bbe708d401fc0d7c" name="a9211d41882566ac1bbe708d401fc0d7c"></a>
<a class="el" href="namespacelal_1_1detail_1_1DMax_1_1unconstrained.html#a06676dd19037e1da66d1eac82183ea74">reason_discard</a>&#160;</td><td class="memItemRight" valign="bottom"><b>discard_node__degree_2__bridge__level_pm2</b> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u, const int64_t level_u) const noexcept</td></tr>
<tr class="memdesc:a9211d41882566ac1bbe708d401fc0d7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can a vertex of a bridge be discarded when it is to be assigned with level \(\pm2\)? <br /></td></tr>
<tr class="separator:a9211d41882566ac1bbe708d401fc0d7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad517df35d7771ea6194295214ea5199b" id="r_ad517df35d7771ea6194295214ea5199b"><td class="memItemLeft" align="right" valign="top"><a id="ad517df35d7771ea6194295214ea5199b" name="ad517df35d7771ea6194295214ea5199b"></a>
<a class="el" href="namespacelal_1_1detail_1_1DMax_1_1unconstrained.html#a06676dd19037e1da66d1eac82183ea74">reason_discard</a>&#160;</td><td class="memItemRight" valign="bottom"><b>discard_node_degree_2</b> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u, const int64_t level_u) const noexcept</td></tr>
<tr class="memdesc:ad517df35d7771ea6194295214ea5199b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can a vertex of degree 2 be discarded? <br /></td></tr>
<tr class="separator:ad517df35d7771ea6194295214ea5199b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a380a6906562218abf0464177eaf408ee" id="r_a380a6906562218abf0464177eaf408ee"><td class="memItemLeft" align="right" valign="top"><a id="a380a6906562218abf0464177eaf408ee" name="a380a6906562218abf0464177eaf408ee"></a>
<a class="el" href="namespacelal_1_1detail_1_1DMax_1_1unconstrained.html#a06676dd19037e1da66d1eac82183ea74">reason_discard</a>&#160;</td><td class="memItemRight" valign="bottom"><b>discard_node_degree_3</b> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u, const int64_t level_u) const noexcept</td></tr>
<tr class="memdesc:a380a6906562218abf0464177eaf408ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can a vertex of degree 3 be discarded? <br /></td></tr>
<tr class="separator:a380a6906562218abf0464177eaf408ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade6d40dcdd4595dc1e7c817c2bec86f4" id="r_ade6d40dcdd4595dc1e7c817c2bec86f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacelal_1_1detail_1_1DMax_1_1unconstrained.html#a06676dd19037e1da66d1eac82183ea74">reason_discard</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade6d40dcdd4595dc1e7c817c2bec86f4">discard_vertex</a> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u, const <a class="el" href="structlal_1_1position__t.html">position_t</a> pos) const noexcept</td></tr>
<tr class="memdesc:ade6d40dcdd4595dc1e7c817c2bec86f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to discard a vertex as the next vertex to add to the arrangement.  <br /></td></tr>
<tr class="separator:ade6d40dcdd4595dc1e7c817c2bec86f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbd58822d405f13a5b63021b73c628c5" id="r_acbd58822d405f13a5b63021b73c628c5"><td class="memItemLeft" align="right" valign="top"><a id="acbd58822d405f13a5b63021b73c628c5" name="acbd58822d405f13a5b63021b73c628c5"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>upper_bound_generic</b> (const uint64_t D_p, const uint64_t D_ps_m, const <a class="el" href="structlal_1_1position__t.html">position_t</a> pos) noexcept</td></tr>
<tr class="memdesc:acbd58822d405f13a5b63021b73c628c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate a 'generic' upper bound. <br /></td></tr>
<tr class="separator:acbd58822d405f13a5b63021b73c628c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a579acefbb244080a29df5ca8470579f2" id="r_a579acefbb244080a29df5ca8470579f2"><td class="memItemLeft" align="right" valign="top"><a id="a579acefbb244080a29df5ca8470579f2" name="a579acefbb244080a29df5ca8470579f2"></a>
<a class="el" href="namespacelal_1_1detail_1_1DMax_1_1unconstrained.html#a191231cbe0d46328f636a3c306e19a89">next_action</a>&#160;</td><td class="memItemRight" valign="bottom"><b>what_to_do_next</b> (const uint64_t D_p, const uint64_t D_ps_m, const <a class="el" href="structlal_1_1position__t.html">position_t</a> pos) noexcept</td></tr>
<tr class="memdesc:a579acefbb244080a29df5ca8470579f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decide what to do next according to the value of the upper bound. <br /></td></tr>
<tr class="separator:a579acefbb244080a29df5ca8470579f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71b9afacf89d8867b2795085f8fed091" id="r_a71b9afacf89d8867b2795085f8fed091"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a71b9afacf89d8867b2795085f8fed091">update_state</a> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u, const <a class="el" href="structlal_1_1position__t.html">position_t</a> pos, uint64_t &amp;D_p, uint64_t &amp;D_ps_m) noexcept</td></tr>
<tr class="memdesc:a71b9afacf89d8867b2795085f8fed091"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the internal state of the algorithm.  <br /></td></tr>
<tr class="separator:a71b9afacf89d8867b2795085f8fed091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b47d368e3c8d2e243b14dcab89a15d8" id="r_a9b47d368e3c8d2e243b14dcab89a15d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b47d368e3c8d2e243b14dcab89a15d8">recover_state</a> (const <a class="el" href="structlal_1_1position__t.html">position_t</a> pos) noexcept</td></tr>
<tr class="memdesc:a9b47d368e3c8d2e243b14dcab89a15d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the internal state of the algorithm.  <br /></td></tr>
<tr class="separator:a9b47d368e3c8d2e243b14dcab89a15d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebfdeb81ecf7c5be5c9aec515d1139a2" id="r_aebfdeb81ecf7c5be5c9aec515d1139a2"><td class="memItemLeft" align="right" valign="top"><a id="aebfdeb81ecf7c5be5c9aec515d1139a2" name="aebfdeb81ecf7c5be5c9aec515d1139a2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>propagate_LV__antenna__from_hub</b> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> h, const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u) noexcept</td></tr>
<tr class="memdesc:aebfdeb81ecf7c5be5c9aec515d1139a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Propagate level values at an antenna, starting at its hub. <br /></td></tr>
<tr class="separator:aebfdeb81ecf7c5be5c9aec515d1139a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b12269d15dfc8ed54dedab35bcc6323" id="r_a8b12269d15dfc8ed54dedab35bcc6323"><td class="memItemLeft" align="right" valign="top"><a id="a8b12269d15dfc8ed54dedab35bcc6323" name="a8b12269d15dfc8ed54dedab35bcc6323"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>propagate_LV__antenna__from_leaf</b> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u) noexcept</td></tr>
<tr class="memdesc:a8b12269d15dfc8ed54dedab35bcc6323"><td class="mdescLeft">&#160;</td><td class="mdescRight">Propagate level values at an antenna, starting at its leaf. <br /></td></tr>
<tr class="separator:a8b12269d15dfc8ed54dedab35bcc6323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a249cbdaf6b267b807f7a510a83ad94fb" id="r_a249cbdaf6b267b807f7a510a83ad94fb"><td class="memItemLeft" align="right" valign="top"><a id="a249cbdaf6b267b807f7a510a83ad94fb" name="a249cbdaf6b267b807f7a510a83ad94fb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>propagate_LV__antenna__from_internal</b> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u) noexcept</td></tr>
<tr class="memdesc:a249cbdaf6b267b807f7a510a83ad94fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Propagate level values at an antenna, starting at an internal vertex. <br /></td></tr>
<tr class="separator:a249cbdaf6b267b807f7a510a83ad94fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8ccb099976e742319cf4394a7ff02da" id="r_ad8ccb099976e742319cf4394a7ff02da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacelal_1_1detail_1_1DMax_1_1unconstrained.html#ae342c8db20fd874094d02df8bf53c995">propagation_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad8ccb099976e742319cf4394a7ff02da">propagate_LV__bridge__check_lowest_can_be_predicted</a> (const std::size_t path_idx, const <a class="el" href="namespacelal_1_1detail_1_1DMax_1_1unconstrained.html#a91afa1e2ca287e09560d9950b6a4d8ac">LV_propagation_origin</a> origin) noexcept</td></tr>
<tr class="memdesc:ad8ccb099976e742319cf4394a7ff02da"><td class="mdescLeft">&#160;</td><td class="mdescRight">In a bridge, predict the level value of the lowest lexicographic vertex.  <br /></td></tr>
<tr class="separator:ad8ccb099976e742319cf4394a7ff02da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5c6e892b9002b68c857127c02637514" id="r_ab5c6e892b9002b68c857127c02637514"><td class="memItemLeft" align="right" valign="top"><a id="ab5c6e892b9002b68c857127c02637514" name="ab5c6e892b9002b68c857127c02637514"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>propagate_LV__bridge__from_hub__h2</b> (const std::size_t path_idx) noexcept</td></tr>
<tr class="memdesc:ab5c6e892b9002b68c857127c02637514"><td class="mdescLeft">&#160;</td><td class="mdescRight">Propagate level values at a bridge, starting at the second hub. <br /></td></tr>
<tr class="separator:ab5c6e892b9002b68c857127c02637514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3f8c4ade2a74daef157d7a838c31991" id="r_ab3f8c4ade2a74daef157d7a838c31991"><td class="memItemLeft" align="right" valign="top"><a id="ab3f8c4ade2a74daef157d7a838c31991" name="ab3f8c4ade2a74daef157d7a838c31991"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>propagate_LV__bridge__from_hub__h1</b> (const std::size_t path_idx) noexcept</td></tr>
<tr class="memdesc:ab3f8c4ade2a74daef157d7a838c31991"><td class="mdescLeft">&#160;</td><td class="mdescRight">Propagate level values at a bridge, starting at the first hub. <br /></td></tr>
<tr class="separator:ab3f8c4ade2a74daef157d7a838c31991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e7a1168eaa26537aaefeee4aeb3b65d" id="r_a3e7a1168eaa26537aaefeee4aeb3b65d"><td class="memItemLeft" align="right" valign="top"><a id="a3e7a1168eaa26537aaefeee4aeb3b65d" name="a3e7a1168eaa26537aaefeee4aeb3b65d"></a>
<a class="el" href="namespacelal_1_1detail_1_1DMax_1_1unconstrained.html#ae342c8db20fd874094d02df8bf53c995">propagation_result</a>&#160;</td><td class="memItemRight" valign="bottom"><b>propagate_LV__bridge__from_hub</b> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> h, const std::size_t path_idx) noexcept</td></tr>
<tr class="memdesc:a3e7a1168eaa26537aaefeee4aeb3b65d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Propagate level values at a bridge, starting at a hub <em>h</em>. <br /></td></tr>
<tr class="separator:a3e7a1168eaa26537aaefeee4aeb3b65d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab844eb43b02af512184b27220f25c2e7" id="r_ab844eb43b02af512184b27220f25c2e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab844eb43b02af512184b27220f25c2e7">propagate_LV__bridge__from_lowest__level_0__towards_h2</a> (const std::size_t path_idx) noexcept</td></tr>
<tr class="separator:ab844eb43b02af512184b27220f25c2e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a00584c49083e79107c5e0185fd6aa2" id="r_a4a00584c49083e79107c5e0185fd6aa2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a00584c49083e79107c5e0185fd6aa2">propagate_LV__bridge__from_lowest__level_0__towards_h1</a> (const std::size_t path_idx) noexcept</td></tr>
<tr class="separator:a4a00584c49083e79107c5e0185fd6aa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e7fd43fe6e41a82d4b1d40e89a41246" id="r_a9e7fd43fe6e41a82d4b1d40e89a41246"><td class="memItemLeft" align="right" valign="top"><a id="a9e7fd43fe6e41a82d4b1d40e89a41246" name="a9e7fd43fe6e41a82d4b1d40e89a41246"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>propagate_LV__bridge__from_lowest__level_0</b> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u) noexcept</td></tr>
<tr class="memdesc:a9e7fd43fe6e41a82d4b1d40e89a41246"><td class="mdescLeft">&#160;</td><td class="mdescRight">Propagate level values at a bridge starting at the lowest lexicographic. <br /></td></tr>
<tr class="separator:a9e7fd43fe6e41a82d4b1d40e89a41246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f404f1a4c09e340bd5bc05f5efee741" id="r_a1f404f1a4c09e340bd5bc05f5efee741"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacelal_1_1detail_1_1DMax_1_1unconstrained.html#ae342c8db20fd874094d02df8bf53c995">propagation_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f404f1a4c09e340bd5bc05f5efee741">propagate_LV__bridge__from_lowest__level_pm2</a> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u) noexcept</td></tr>
<tr class="separator:a1f404f1a4c09e340bd5bc05f5efee741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97eb7d8b2c3f38937a4061d4aa84520c" id="r_a97eb7d8b2c3f38937a4061d4aa84520c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacelal_1_1detail_1_1DMax_1_1unconstrained.html#ae342c8db20fd874094d02df8bf53c995">propagation_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a97eb7d8b2c3f38937a4061d4aa84520c">propagate_LV__bridge__from_internal</a> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u) noexcept</td></tr>
<tr class="separator:a97eb7d8b2c3f38937a4061d4aa84520c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a621b1eecfe4f61b40d48c839316ea62e" id="r_a621b1eecfe4f61b40d48c839316ea62e"><td class="memItemLeft" align="right" valign="top"><a id="a621b1eecfe4f61b40d48c839316ea62e" name="a621b1eecfe4f61b40d48c839316ea62e"></a>
<a class="el" href="namespacelal_1_1detail_1_1DMax_1_1unconstrained.html#ae342c8db20fd874094d02df8bf53c995">propagation_result</a>&#160;</td><td class="memItemRight" valign="bottom"><b>propagate_constraints</b> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u) noexcept</td></tr>
<tr class="memdesc:a621b1eecfe4f61b40d48c839316ea62e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Propagate level values starting at vertex <em>u</em>. <br /></td></tr>
<tr class="separator:a621b1eecfe4f61b40d48c839316ea62e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ba2cc606f30d066aa07e3a99e5afab" id="r_a40ba2cc606f30d066aa07e3a99e5afab"><td class="memItemLeft" align="right" valign="top"><a id="a40ba2cc606f30d066aa07e3a99e5afab" name="a40ba2cc606f30d066aa07e3a99e5afab"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>roll_back_LV__antenna</b> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u) noexcept</td></tr>
<tr class="memdesc:a40ba2cc606f30d066aa07e3a99e5afab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undo the propagation of level values at an antenna. <br /></td></tr>
<tr class="separator:a40ba2cc606f30d066aa07e3a99e5afab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a498b64ed437c9a1c1c55ee34f0a71f57" id="r_a498b64ed437c9a1c1c55ee34f0a71f57"><td class="memItemLeft" align="right" valign="top"><a id="a498b64ed437c9a1c1c55ee34f0a71f57" name="a498b64ed437c9a1c1c55ee34f0a71f57"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>roll_back_LV__bridge__from_hub__h2</b> (const std::size_t path_idx) noexcept</td></tr>
<tr class="memdesc:a498b64ed437c9a1c1c55ee34f0a71f57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undo the propagation of level values at a bridge, starting at the second hub. <br /></td></tr>
<tr class="separator:a498b64ed437c9a1c1c55ee34f0a71f57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22992d529707ad1bcf4b3020d4a7a06e" id="r_a22992d529707ad1bcf4b3020d4a7a06e"><td class="memItemLeft" align="right" valign="top"><a id="a22992d529707ad1bcf4b3020d4a7a06e" name="a22992d529707ad1bcf4b3020d4a7a06e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>roll_back_LV__bridge__from_hub__h1</b> (const std::size_t path_idx) noexcept</td></tr>
<tr class="memdesc:a22992d529707ad1bcf4b3020d4a7a06e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undo the propagation of level values at a bridge, starting at the first hub. <br /></td></tr>
<tr class="separator:a22992d529707ad1bcf4b3020d4a7a06e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68531a7910d28918f74d2ded9e8fe24f" id="r_a68531a7910d28918f74d2ded9e8fe24f"><td class="memItemLeft" align="right" valign="top"><a id="a68531a7910d28918f74d2ded9e8fe24f" name="a68531a7910d28918f74d2ded9e8fe24f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>roll_back_LV__bridge__from_hub</b> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> h, const std::size_t path_idx) noexcept</td></tr>
<tr class="memdesc:a68531a7910d28918f74d2ded9e8fe24f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undo the propagation of level values at a bridge. <br /></td></tr>
<tr class="separator:a68531a7910d28918f74d2ded9e8fe24f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0272638ce173d569dfa997f419f31b1f" id="r_a0272638ce173d569dfa997f419f31b1f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0272638ce173d569dfa997f419f31b1f">roll_back_LV__bridge__from_lowest__level_0__towards_h2</a> (const std::size_t path_idx) noexcept</td></tr>
<tr class="separator:a0272638ce173d569dfa997f419f31b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ab597507381b32548067025f9ab3517" id="r_a8ab597507381b32548067025f9ab3517"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ab597507381b32548067025f9ab3517">roll_back_LV__bridge__from_lowest__level_0__towards_h1</a> (const std::size_t path_idx) noexcept</td></tr>
<tr class="separator:a8ab597507381b32548067025f9ab3517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2be4e311d802b27999a71d1db4ed190" id="r_af2be4e311d802b27999a71d1db4ed190"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af2be4e311d802b27999a71d1db4ed190">roll_back_LV__bridge__from_lowest__level_0</a> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u) noexcept</td></tr>
<tr class="separator:af2be4e311d802b27999a71d1db4ed190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf3afed8ec84b1c79aecb3ce3132ddc7" id="r_abf3afed8ec84b1c79aecb3ce3132ddc7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf3afed8ec84b1c79aecb3ce3132ddc7">roll_back_LV__bridge__from_lowest__level_pm2</a> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u) noexcept</td></tr>
<tr class="separator:abf3afed8ec84b1c79aecb3ce3132ddc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b86d5b9f383bc266bc0c480151c1c9e" id="r_a4b86d5b9f383bc266bc0c480151c1c9e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b86d5b9f383bc266bc0c480151c1c9e">roll_back_LV__bridge__from_internal</a> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u) noexcept</td></tr>
<tr class="separator:a4b86d5b9f383bc266bc0c480151c1c9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedcb0867b1b1022362dcd4f22df65b0d" id="r_aedcb0867b1b1022362dcd4f22df65b0d"><td class="memItemLeft" align="right" valign="top"><a id="aedcb0867b1b1022362dcd4f22df65b0d" name="aedcb0867b1b1022362dcd4f22df65b0d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>roll_back_constraints</b> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u) noexcept</td></tr>
<tr class="memdesc:aedcb0867b1b1022362dcd4f22df65b0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undo the propagation of level values at a vertex <em>u</em>. <br /></td></tr>
<tr class="separator:aedcb0867b1b1022362dcd4f22df65b0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0693a7a76d1f4a2e57b12533355a556a" id="r_a0693a7a76d1f4a2e57b12533355a556a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0693a7a76d1f4a2e57b12533355a556a">process_end</a> (const uint64_t D, const <a class="el" href="namespacelal.html#a5c3f34575ec933a44ed7b6d81e8c75f6">position</a> pos) noexcept</td></tr>
<tr class="memdesc:a0693a7a76d1f4a2e57b12533355a556a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take action at the end of the recursion.  <br /></td></tr>
<tr class="separator:a0693a7a76d1f4a2e57b12533355a556a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a626a719662d61c3311432415e760fa11" id="r_a626a719662d61c3311432415e760fa11"><td class="memItemLeft" align="right" valign="top"><a id="a626a719662d61c3311432415e760fa11" name="a626a719662d61c3311432415e760fa11"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_vertex_assigned</b> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u) const noexcept</td></tr>
<tr class="memdesc:a626a719662d61c3311432415e760fa11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is vertex <em>u</em> assigned to the prefix of the arrangement? <br /></td></tr>
<tr class="separator:a626a719662d61c3311432415e760fa11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbf8f662d1c533a9cb0e0b8d15f8d983" id="r_afbf8f662d1c533a9cb0e0b8d15f8d983"><td class="memItemLeft" align="right" valign="top"><a id="afbf8f662d1c533a9cb0e0b8d15f8d983" name="afbf8f662d1c533a9cb0e0b8d15f8d983"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_vertex_thistle</b> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u) const noexcept</td></tr>
<tr class="memdesc:afbf8f662d1c533a9cb0e0b8d15f8d983"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is vertex <em>u</em> a thistle vertex? <br /></td></tr>
<tr class="separator:afbf8f662d1c533a9cb0e0b8d15f8d983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f562a99d041f21fe1b382208593939b" id="r_a8f562a99d041f21fe1b382208593939b"><td class="memItemLeft" align="right" valign="top"><a id="a8f562a99d041f21fe1b382208593939b" name="a8f562a99d041f21fe1b382208593939b"></a>
<a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a>&#160;</td><td class="memItemRight" valign="bottom"><b>leaf_parent</b> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u) const noexcept</td></tr>
<tr class="memdesc:a8f562a99d041f21fe1b382208593939b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the only parent of the leaf <em>u</em>. <br /></td></tr>
<tr class="separator:a8f562a99d041f21fe1b382208593939b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e0588bd7366beb1c2705f18aed47d05" id="r_a0e0588bd7366beb1c2705f18aed47d05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a77828577047ac3b85344a1065a251460">exe_result_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e0588bd7366beb1c2705f18aed47d05">exe_independent_set</a> (const uint64_t D_p, <a class="el" href="namespacelal.html#a5c3f34575ec933a44ed7b6d81e8c75f6">position</a> pos) noexcept</td></tr>
<tr class="memdesc:a0e0588bd7366beb1c2705f18aed47d05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finish constructing the arrangement.  <br /></td></tr>
<tr class="separator:a0e0588bd7366beb1c2705f18aed47d05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9a4cf01425331435cc244eee35369a2" id="r_ac9a4cf01425331435cc244eee35369a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a77828577047ac3b85344a1065a251460">exe_result_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac9a4cf01425331435cc244eee35369a2">exe_independent_set_leaves</a> (const uint64_t D_p, <a class="el" href="namespacelal.html#a5c3f34575ec933a44ed7b6d81e8c75f6">position</a> pos) noexcept</td></tr>
<tr class="memdesc:ac9a4cf01425331435cc244eee35369a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finish constructing the arrangement.  <br /></td></tr>
<tr class="separator:ac9a4cf01425331435cc244eee35369a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac689b5747ac94507e19e3cb4f9c5a0bd" id="r_ac689b5747ac94507e19e3cb4f9c5a0bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a77828577047ac3b85344a1065a251460">exe_result_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac689b5747ac94507e19e3cb4f9c5a0bd">exe</a> (const uint64_t D_p, const uint64_t D_ps_m, const <a class="el" href="namespacelal.html#a5c3f34575ec933a44ed7b6d81e8c75f6">position</a> pos) noexcept</td></tr>
<tr class="memdesc:ac689b5747ac94507e19e3cb4f9c5a0bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute the Branch and Bound algorithm.  <br /></td></tr>
<tr class="separator:ac689b5747ac94507e19e3cb4f9c5a0bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="properties" name="properties"></a>
Properties</h2></td></tr>
<tr class="memitem:a0cde7dd9e7ccd87ea97ec51e95ed1b6d" id="r_a0cde7dd9e7ccd87ea97ec51e95ed1b6d"><td class="memItemLeft" align="right" valign="top"><a id="a0cde7dd9e7ccd87ea97ec51e95ed1b6d" name="a0cde7dd9e7ccd87ea97ec51e95ed1b6d"></a>
&#160;</td><td class="memItemRight" valign="bottom">:bipartite_graph_coloring&amp; m_vertex_colors</td></tr>
<tr class="memdesc:a0cde7dd9e7ccd87ea97ec51e95ed1b6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bipartite coloring of the tree. <br /></td></tr>
<tr class="separator:a0cde7dd9e7ccd87ea97ec51e95ed1b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a7581a1b626a9547160727c8c1b4e9374" id="r_a7581a1b626a9547160727c8c1b4e9374"><td class="memItemLeft" align="right" valign="top"><a id="a7581a1b626a9547160727c8c1b4e9374" name="a7581a1b626a9547160727c8c1b4e9374"></a>
const uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>m_n_nodes</b></td></tr>
<tr class="memdesc:a7581a1b626a9547160727c8c1b4e9374"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of nodes. <br /></td></tr>
<tr class="separator:a7581a1b626a9547160727c8c1b4e9374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb109fd5f767605d213a92693c38c001" id="r_abb109fd5f767605d213a92693c38c001"><td class="memItemLeft" align="right" valign="top"><a id="abb109fd5f767605d213a92693c38c001" name="abb109fd5f767605d213a92693c38c001"></a>
const <a class="el" href="structlal_1_1detail_1_1array.html">array</a>&lt; std::vector&lt; <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>m_leaves</b></td></tr>
<tr class="memdesc:abb109fd5f767605d213a92693c38c001"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set of leaves per vertex. <br /></td></tr>
<tr class="separator:abb109fd5f767605d213a92693c38c001"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A Branch and Bound algorithm for the maximum sum of edge lengths. </p>
<p>Readers are urged to read <a class="el" href="citelist.html#CITEREF_Alemany2023a">[7]</a> for the full details of the inner workings of the algorithm.</p>
<p>In many of the parameters of the functions of this class we find the names:</p><ul>
<li>D_p: this is the sum of edge lengths of the edges contained entirely in the prefix of the arrangement.</li>
<li>D_ps_m: this is the sum of edge lengths of the parts over the prefix of the arrangement of the edges partially contained in the prefix, </li>
</ul>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a77828577047ac3b85344a1065a251460" name="a77828577047ac3b85344a1065a251460"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77828577047ac3b85344a1065a251460">&#9670;&#160;</a></span>exe_result_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::conditional_t&lt;<a class="el" href="#a93f0c53dcf1fee1caa54e76ae6c32270">debug_BnB</a>, bool, void&gt; <a class="el" href="#a77828577047ac3b85344a1065a251460">lal::detail::DMax::unconstrained::AEF_BnB::exe_result_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Result of the main function of the algorithm. </p>
<p>If <a class="el" href="#a93f0c53dcf1fee1caa54e76ae6c32270">debug_BnB</a> is true, then the function is to return a Boolean value that indicates if it found a maxium arrangement. </p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a4f8f683e63c27df0d558ec81e330de99" name="a4f8f683e63c27df0d558ec81e330de99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f8f683e63c27df0d558ec81e330de99">&#9670;&#160;</a></span>process_end_result</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a4f8f683e63c27df0d558ec81e330de99">lal::detail::DMax::unconstrained::AEF_BnB::process_end_result</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumeration used in the function <a class="el" href="#a0693a7a76d1f4a2e57b12533355a556a">process_end</a>. </p>
<p>These values are used as flags! </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a4f8f683e63c27df0d558ec81e330de99ad600390139979e4ff17e5e023763f199" name="a4f8f683e63c27df0d558ec81e330de99ad600390139979e4ff17e5e023763f199"></a>did_not_reach_end&#160;</td><td class="fielddoc"><p>Algorithm did not completely construct the arrangement. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4f8f683e63c27df0d558ec81e330de99af360bf61fd2ba6ee9c8bbf15e24447cd" name="a4f8f683e63c27df0d558ec81e330de99af360bf61fd2ba6ee9c8bbf15e24447cd"></a>reached_end&#160;</td><td class="fielddoc"><p>Algorithm reached the end of the arrangement. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4f8f683e63c27df0d558ec81e330de99a38a51714e9bbb6cacdda7b2017771e8b" name="a4f8f683e63c27df0d558ec81e330de99a38a51714e9bbb6cacdda7b2017771e8b"></a>found_max&#160;</td><td class="fielddoc"><p>Algorithm reached found a new maximum. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="afd7600fcf4a6a2c9d010193de9388191" name="afd7600fcf4a6a2c9d010193de9388191"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd7600fcf4a6a2c9d010193de9388191">&#9670;&#160;</a></span>AEF_BnB()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">lal::detail::DMax::unconstrained::AEF_BnB::AEF_BnB </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlal_1_1detail_1_1array.html">array</a>&lt; std::vector&lt; <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>leaves</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1properties_1_1bipartite__graph__coloring.html">properties::bipartite_graph_coloring</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>colors</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>num_verts_blue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>num_verts_red</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classlal_1_1properties_1_1branchless__path.html">properties::branchless_path</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>paths_in_tree</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlal_1_1detail_1_1array.html">array</a>&lt; std::size_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>node_to_path_idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlal_1_1detail_1_1array.html">array</a>&lt; std::vector&lt; <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>incident_antennas</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>orbits</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlal_1_1detail_1_1array.html">array</a>&lt; std::size_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vertex_to_orbit</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input tree. </td></tr>
    <tr><td class="paramname">leaves</td><td>Set of leaves per vertex. </td></tr>
    <tr><td class="paramname">colors</td><td>Bipartite coloring of the tree. </td></tr>
    <tr><td class="paramname">num_verts_blue</td><td>Number of blue vertices. </td></tr>
    <tr><td class="paramname">num_verts_red</td><td>Number of red vertices. </td></tr>
    <tr><td class="paramname">paths_in_tree</td><td>All the branchless paths in the tree. </td></tr>
    <tr><td class="paramname">node_to_path_idx</td><td>An index for each vertex pointing to the branchless path it belongs. </td></tr>
    <tr><td class="paramname">incident_antennas</td><td>For every vertex <em>u</em>, this contains the list of the first nodes in all incident antennas </td></tr>
    <tr><td class="paramname">orbits</td><td>The set of vertex orbits of the tree. </td></tr>
    <tr><td class="paramname">vertex_to_orbit</td><td>An index for each vertex pointing to the vertex orbit it belongs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a595b688e56aebf40d637cad58040e219" name="a595b688e56aebf40d637cad58040e219"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a595b688e56aebf40d637cad58040e219">&#9670;&#160;</a></span>check_propagation_node_to_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacelal_1_1detail_1_1DMax_1_1unconstrained.html#a06676dd19037e1da66d1eac82183ea74">reason_discard</a> lal::detail::DMax::unconstrained::AEF_BnB::check_propagation_node_to_node </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t</td>          <td class="paramname"><span class="paramname"><em>level_u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t</td>          <td class="paramname"><span class="paramname"><em>level_v</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Can the propagation from vertex <em>u</em> to vertex <em>v</em> fail? </p>
<p>This is only checked for pairs of vertices connected by a propagation path (any pair of vertices in an antenna, or pairs of vertices in a bridge where both are on the same side of its lowest lexicographic). </p>

</div>
</div>
<a id="ade6d40dcdd4595dc1e7c817c2bec86f4" name="ade6d40dcdd4595dc1e7c817c2bec86f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade6d40dcdd4595dc1e7c817c2bec86f4">&#9670;&#160;</a></span>discard_vertex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacelal_1_1detail_1_1DMax_1_1unconstrained.html#a06676dd19037e1da66d1eac82183ea74">reason_discard</a> lal::detail::DMax::unconstrained::AEF_BnB::discard_vertex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlal_1_1position__t.html">position_t</a></td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function to discard a vertex as the next vertex to add to the arrangement. </p>
<p>This function implements symmetry breaking constraints, optimality constraints, ... For details see code, or the paper <a class="el" href="citelist.html#CITEREF_Alemany2023a">[7]</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>Vertex to test. </td></tr>
    <tr><td class="paramname">pos</td><td>Position where the vertex is to be placed at. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the vertex is to be discarded at this stage. </dd></dl>

</div>
</div>
<a id="ac689b5747ac94507e19e3cb4f9c5a0bd" name="ac689b5747ac94507e19e3cb4f9c5a0bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac689b5747ac94507e19e3cb4f9c5a0bd">&#9670;&#160;</a></span>exe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a77828577047ac3b85344a1065a251460">exe_result_type</a> lal::detail::DMax::unconstrained::AEF_BnB::exe </td>
          <td>(</td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>D_p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>D_ps_m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#a5c3f34575ec933a44ed7b6d81e8c75f6">position</a></td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute the Branch and Bound algorithm. </p>
<p>The algorithm will add vertices starting at position 'pos'.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">D_p</td><td>The sum of the lengths of the edges in E_p, that is, the set of edges where both endpoints are assigned to the prefix. </td></tr>
    <tr><td class="paramname">D_ps_m</td><td>The sum of the partial length of the edges in E_ps, from the vertex assigned to the prefix to the border that separates the prefix and the suffix (between positions 'pos-1' and 'pos'), calculated as the length of the edge as if it ended at position 'pos'. </td></tr>
    <tr><td class="paramname">pos</td><td>Position where to place the next vertex. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0e0588bd7366beb1c2705f18aed47d05" name="a0e0588bd7366beb1c2705f18aed47d05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e0588bd7366beb1c2705f18aed47d05">&#9670;&#160;</a></span>exe_independent_set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a77828577047ac3b85344a1065a251460">exe_result_type</a> lal::detail::DMax::unconstrained::AEF_BnB::exe_independent_set </td>
          <td>(</td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>D_p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelal.html#a5c3f34575ec933a44ed7b6d81e8c75f6">position</a></td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finish constructing the arrangement. </p>
<p>Under the assumption that the unassigned vertices make up an independent set. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">D_p</td><td>Sum of the lengths of the edges contained inside the prefix. </td></tr>
    <tr><td class="paramname">pos</td><td>Position where to continue building the arrangement from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the algorithm found a new maximum arrangement. </dd></dl>

</div>
</div>
<a id="ac9a4cf01425331435cc244eee35369a2" name="ac9a4cf01425331435cc244eee35369a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9a4cf01425331435cc244eee35369a2">&#9670;&#160;</a></span>exe_independent_set_leaves()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a77828577047ac3b85344a1065a251460">exe_result_type</a> lal::detail::DMax::unconstrained::AEF_BnB::exe_independent_set_leaves </td>
          <td>(</td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>D_p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelal.html#a5c3f34575ec933a44ed7b6d81e8c75f6">position</a></td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finish constructing the arrangement. </p>
<p>Under the assumption that the unassigned vertices make up an independent set, and that all remaining vertices are leaves. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">D_p</td><td>Sum of the lengths of the edges contained inside the prefix. </td></tr>
    <tr><td class="paramname">pos</td><td>Position where to continue building the arrangement from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the algorithm found a new maximum arrangement. </dd></dl>

</div>
</div>
<a id="a0693a7a76d1f4a2e57b12533355a556a" name="a0693a7a76d1f4a2e57b12533355a556a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0693a7a76d1f4a2e57b12533355a556a">&#9670;&#160;</a></span>process_end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int lal::detail::DMax::unconstrained::AEF_BnB::process_end </td>
          <td>(</td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>D</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#a5c3f34575ec933a44ed7b6d81e8c75f6">position</a></td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Take action at the end of the recursion. </p>
<p>The algorithm has finished the construction of a linear arrangement and it's time to add it to the set of maximum arrangements. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">D</td><td>Cost of the arrangement. </td></tr>
    <tr><td class="paramname">pos</td><td>Position to place the next vertex (it equals the number of vertices in this function). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the recursion actually constructed the arrangement. The values returned are a combination of the values in <a class="el" href="#a4f8f683e63c27df0d558ec81e330de99">process_end_result</a>. </dd></dl>

</div>
</div>
<a id="ad8ccb099976e742319cf4394a7ff02da" name="ad8ccb099976e742319cf4394a7ff02da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8ccb099976e742319cf4394a7ff02da">&#9670;&#160;</a></span>propagate_LV__bridge__check_lowest_can_be_predicted()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacelal_1_1detail_1_1DMax_1_1unconstrained.html#ae342c8db20fd874094d02df8bf53c995">propagation_result</a> lal::detail::DMax::unconstrained::AEF_BnB::propagate_LV__bridge__check_lowest_can_be_predicted </td>
          <td>(</td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>path_idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal_1_1detail_1_1DMax_1_1unconstrained.html#a91afa1e2ca287e09560d9950b6a4d8ac">LV_propagation_origin</a></td>          <td class="paramname"><span class="paramname"><em>origin</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In a bridge, predict the level value of the lowest lexicographic vertex. </p>
<p>Checks if, after several propagations on the bridge, the level value of the lowest lexicographic vertex can be predicted, and assigns one when appropriate. This check can fail. </p>

</div>
</div>
<a id="a97eb7d8b2c3f38937a4061d4aa84520c" name="a97eb7d8b2c3f38937a4061d4aa84520c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97eb7d8b2c3f38937a4061d4aa84520c">&#9670;&#160;</a></span>propagate_LV__bridge__from_internal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacelal_1_1detail_1_1DMax_1_1unconstrained.html#ae342c8db20fd874094d02df8bf53c995">propagation_result</a> lal::detail::DMax::unconstrained::AEF_BnB::propagate_LV__bridge__from_internal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Propagate level values at a bridge starting at an internal vertex that is not the lowest lexicographic. </p>

</div>
</div>
<a id="a4a00584c49083e79107c5e0185fd6aa2" name="a4a00584c49083e79107c5e0185fd6aa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a00584c49083e79107c5e0185fd6aa2">&#9670;&#160;</a></span>propagate_LV__bridge__from_lowest__level_0__towards_h1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::detail::DMax::unconstrained::AEF_BnB::propagate_LV__bridge__from_lowest__level_0__towards_h1 </td>
          <td>(</td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>path_idx</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Propagate level values at a bridge starting at the lowest lexicographic with level value \(\pm 2\) towards the first hub. </p>

</div>
</div>
<a id="ab844eb43b02af512184b27220f25c2e7" name="ab844eb43b02af512184b27220f25c2e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab844eb43b02af512184b27220f25c2e7">&#9670;&#160;</a></span>propagate_LV__bridge__from_lowest__level_0__towards_h2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::detail::DMax::unconstrained::AEF_BnB::propagate_LV__bridge__from_lowest__level_0__towards_h2 </td>
          <td>(</td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>path_idx</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Propagate level values at a bridge starting at the lowest lexicographic with level value \(\pm 2\) towards the second hub. </p>

</div>
</div>
<a id="a1f404f1a4c09e340bd5bc05f5efee741" name="a1f404f1a4c09e340bd5bc05f5efee741"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f404f1a4c09e340bd5bc05f5efee741">&#9670;&#160;</a></span>propagate_LV__bridge__from_lowest__level_pm2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacelal_1_1detail_1_1DMax_1_1unconstrained.html#ae342c8db20fd874094d02df8bf53c995">propagation_result</a> lal::detail::DMax::unconstrained::AEF_BnB::propagate_LV__bridge__from_lowest__level_pm2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Propagate level values at a bridge starting at the lowest lexicographic with level value \(0\). </p>

</div>
</div>
<a id="a9b47d368e3c8d2e243b14dcab89a15d8" name="a9b47d368e3c8d2e243b14dcab89a15d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b47d368e3c8d2e243b14dcab89a15d8">&#9670;&#160;</a></span>recover_state()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::detail::DMax::unconstrained::AEF_BnB::recover_state </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlal_1_1position__t.html">position_t</a></td>          <td class="paramname"><span class="paramname"><em>pos</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the internal state of the algorithm. </p>
<p>Assuming that the vertex at position <em>pos</em> will be removed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Position to remove the vertex from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4b86d5b9f383bc266bc0c480151c1c9e" name="a4b86d5b9f383bc266bc0c480151c1c9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b86d5b9f383bc266bc0c480151c1c9e">&#9670;&#160;</a></span>roll_back_LV__bridge__from_internal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::detail::DMax::unconstrained::AEF_BnB::roll_back_LV__bridge__from_internal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Undo the propagation of level values at a bridge, starting at an internal vertex. </p>

</div>
</div>
<a id="af2be4e311d802b27999a71d1db4ed190" name="af2be4e311d802b27999a71d1db4ed190"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2be4e311d802b27999a71d1db4ed190">&#9670;&#160;</a></span>roll_back_LV__bridge__from_lowest__level_0()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::detail::DMax::unconstrained::AEF_BnB::roll_back_LV__bridge__from_lowest__level_0 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Undo the propagation of level values at a bridge, starting at the lowest lexicographic of level value \(0\). </p>

</div>
</div>
<a id="a8ab597507381b32548067025f9ab3517" name="a8ab597507381b32548067025f9ab3517"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ab597507381b32548067025f9ab3517">&#9670;&#160;</a></span>roll_back_LV__bridge__from_lowest__level_0__towards_h1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::detail::DMax::unconstrained::AEF_BnB::roll_back_LV__bridge__from_lowest__level_0__towards_h1 </td>
          <td>(</td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>path_idx</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Undo the propagation of level values at a bridge, starting at the lowest lexicographic of level value \(0\) towards the first hub. </p>

</div>
</div>
<a id="a0272638ce173d569dfa997f419f31b1f" name="a0272638ce173d569dfa997f419f31b1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0272638ce173d569dfa997f419f31b1f">&#9670;&#160;</a></span>roll_back_LV__bridge__from_lowest__level_0__towards_h2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::detail::DMax::unconstrained::AEF_BnB::roll_back_LV__bridge__from_lowest__level_0__towards_h2 </td>
          <td>(</td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>path_idx</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Undo the propagation of level values at a bridge, starting at the lowest lexicographic of level value \(0\) towards the second hub. </p>

</div>
</div>
<a id="abf3afed8ec84b1c79aecb3ce3132ddc7" name="abf3afed8ec84b1c79aecb3ce3132ddc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf3afed8ec84b1c79aecb3ce3132ddc7">&#9670;&#160;</a></span>roll_back_LV__bridge__from_lowest__level_pm2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::detail::DMax::unconstrained::AEF_BnB::roll_back_LV__bridge__from_lowest__level_pm2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Undo the propagation of level values at a bridge, starting at the lowest lexicographic of level value \(\pm2\). </p>

</div>
</div>
<a id="a71b9afacf89d8867b2795085f8fed091" name="a71b9afacf89d8867b2795085f8fed091"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71b9afacf89d8867b2795085f8fed091">&#9670;&#160;</a></span>update_state()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::detail::DMax::unconstrained::AEF_BnB::update_state </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlal_1_1position__t.html">position_t</a></td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t &amp;</td>          <td class="paramname"><span class="paramname"><em>D_p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t &amp;</td>          <td class="paramname"><span class="paramname"><em>D_ps_m</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the internal state of the algorithm. </p>
<p>Assuming that vertex <em>u</em> will be placed at position <em>pos</em>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>Next vertex in the arrangement. </td></tr>
    <tr><td class="paramname">pos</td><td>Next position. </td></tr>
    <tr><td class="paramname">D_p</td><td>Sum of edge lengths of edges in the prefix. </td></tr>
    <tr><td class="paramname">D_ps_m</td><td>Sum of edge lengths of edges partially in the prefix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a02ad7da60db3f2b35b2bab14aa98f57c" name="a02ad7da60db3f2b35b2bab14aa98f57c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02ad7da60db3f2b35b2bab14aa98f57c">&#9670;&#160;</a></span>m_arr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> lal::detail::DMax::unconstrained::AEF_BnB::m_arr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Partial result of the algorithm. </p>
<p>This arrangement is built from left to right, adding vertices one by one. </p>

</div>
</div>
<a id="a8d1cb52ec33c0bb7cba9712f60a62081" name="a8d1cb52ec33c0bb7cba9712f60a62081"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d1cb52ec33c0bb7cba9712f60a62081">&#9670;&#160;</a></span>m_max_arrs</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1detail_1_1DMax_1_1unconstrained_1_1set__maximum__arrangements.html">set_maximum_arrangements</a> lal::detail::DMax::unconstrained::AEF_BnB::m_max_arrs</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Complete result of the algorithm. </p>
<p>The entire set of maximum arrangements we can make starting at the given vertex. </p>

</div>
</div>
<a id="a0e6b44dcc3278a8c5bad3735f72e7078" name="a0e6b44dcc3278a8c5bad3735f72e7078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e6b44dcc3278a8c5bad3735f72e7078">&#9670;&#160;</a></span>m_node_left_degree</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlal_1_1detail_1_1array.html">array</a>&lt;uint64_t&gt; lal::detail::DMax::unconstrained::AEF_BnB::m_node_left_degree</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Directional left degree of each assigned vertex. </p>
<p>This data is only valid for a vertex <em>u</em> when <a class="el" href="#a626a719662d61c3311432415e760fa11">is_vertex_assigned</a> returns true for <em>u</em>. </p>

</div>
</div>
<a id="a7f55c15ca2d1d726808e50f4de1e4dc2" name="a7f55c15ca2d1d726808e50f4de1e4dc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f55c15ca2d1d726808e50f4de1e4dc2">&#9670;&#160;</a></span>m_node_level</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlal_1_1detail_1_1array.html">array</a>&lt;int64_t&gt; lal::detail::DMax::unconstrained::AEF_BnB::m_node_level</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The level value of each assigned vertex. </p>
<p>This data is only valid for a vertex <em>u</em> when <a class="el" href="#a626a719662d61c3311432415e760fa11">is_vertex_assigned</a> returns true for <em>u</em>. </p>

</div>
</div>
<a id="ac9e535882643b6d941d4e4c9bf7fad5d" name="ac9e535882643b6d941d4e4c9bf7fad5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9e535882643b6d941d4e4c9bf7fad5d">&#9670;&#160;</a></span>m_node_right_degree</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlal_1_1detail_1_1array.html">array</a>&lt;uint64_t&gt; lal::detail::DMax::unconstrained::AEF_BnB::m_node_right_degree</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Directional right degree of each assigned vertex. </p>
<p>This data is only valid for a vertex <em>u</em> when <a class="el" href="#a626a719662d61c3311432415e760fa11">is_vertex_assigned</a> returns true for <em>u</em>. </p>

</div>
</div>
<a id="a366f89299fb6f6025f9098d4a378ec1b" name="a366f89299fb6f6025f9098d4a378ec1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a366f89299fb6f6025f9098d4a378ec1b">&#9670;&#160;</a></span>m_predicted_LV__origin</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlal_1_1detail_1_1array.html">array</a>&lt;<a class="el" href="namespacelal_1_1detail_1_1DMax_1_1unconstrained.html#a91afa1e2ca287e09560d9950b6a4d8ac">LV_propagation_origin</a>&gt; lal::detail::DMax::unconstrained::AEF_BnB::m_predicted_LV__origin</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Origin of a propagation of level values. </p>
<p>For each vertex <em>u</em>, information of the origin of the propagation of level values that went through <em>u</em>. Notice that <em>u</em> may be the origin of the propagation (see <a class="el" href="namespacelal_1_1detail_1_1DMax_1_1unconstrained.html#a91afa1e2ca287e09560d9950b6a4d8aca590f53e8699817c6fa498cc11a4cbe63">lal::detail::DMax::unconstrained::LV_propagation_origin::self</a>). </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>lal/detail/linarr/D/DMax/unconstrained/branch_and_bound/AEF/<a class="el" href="BnB_8hpp_source.html">BnB.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
