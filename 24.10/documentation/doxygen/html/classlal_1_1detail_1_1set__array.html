<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LAL: Linear Arrangement Library: lal::detail::set_array&lt; value_t, indexer_t &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">LAL: Linear Arrangement Library<span id="projectnumber">&#160;24.10.00</span>
   </div>
   <div id="projectbrief">A library focused on algorithms on linear arrangements of graphs.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacelal.html">lal</a></li><li class="navelem"><a class="el" href="namespacelal_1_1detail.html">detail</a></li><li class="navelem"><a class="el" href="classlal_1_1detail_1_1set__array.html">set_array</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a> &#124;
<a href="classlal_1_1detail_1_1set__array-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">lal::detail::set_array&lt; value_t, indexer_t &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A set-like data structure implemented with an array.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="set__array_8hpp_source.html">set_array.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a719a27d9ac1ab527fdbcf0ff7f6b7a7f" id="r_a719a27d9ac1ab527fdbcf0ff7f6b7a7f"><td class="memTemplParams" colspan="2">template&lt;typename vt  = value_t, typename it  = indexer_t, std::enable_if_t&lt; std::is_same_v&lt; vt, it &gt;, bool &gt;  = true&gt; </td></tr>
<tr class="memitem:a719a27d9ac1ab527fdbcf0ff7f6b7a7f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a719a27d9ac1ab527fdbcf0ff7f6b7a7f">init</a> (const std::size_t max_num_elems, const std::size_t max_index_value) noexcept</td></tr>
<tr class="memdesc:a719a27d9ac1ab527fdbcf0ff7f6b7a7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the set with no indexer object.  <br /></td></tr>
<tr class="separator:a719a27d9ac1ab527fdbcf0ff7f6b7a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e517b8dd0609a1ce7caf1f48f7ae380" id="r_a3e517b8dd0609a1ce7caf1f48f7ae380"><td class="memTemplParams" colspan="2">template&lt;typename vt  = value_t, typename it  = indexer_t, std::enable_if_t&lt; not std::is_same_v&lt; vt, it &gt;, bool &gt;  = true&gt; </td></tr>
<tr class="memitem:a3e517b8dd0609a1ce7caf1f48f7ae380"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3e517b8dd0609a1ce7caf1f48f7ae380">init</a> (const std::size_t max_num_elems, const std::size_t max_index_value, indexer_t &amp;&amp;i) noexcept</td></tr>
<tr class="memdesc:a3e517b8dd0609a1ce7caf1f48f7ae380"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the set with an indexer object.  <br /></td></tr>
<tr class="separator:a3e517b8dd0609a1ce7caf1f48f7ae380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a913141c148f276d0c716f63192f8a78b" id="r_a913141c148f276d0c716f63192f8a78b"><td class="memItemLeft" align="right" valign="top">const value_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a913141c148f276d0c716f63192f8a78b">operator[]</a> (const std::size_t i) const noexcept</td></tr>
<tr class="memdesc:a913141c148f276d0c716f63192f8a78b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator to access values in a given position.  <br /></td></tr>
<tr class="separator:a913141c148f276d0c716f63192f8a78b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86db2e6702e5337a553e5250c8f1844b" id="r_a86db2e6702e5337a553e5250c8f1844b"><td class="memItemLeft" align="right" valign="top"><a id="a86db2e6702e5337a553e5250c8f1844b" name="a86db2e6702e5337a553e5250c8f1844b"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>capacity</b> () const noexcept</td></tr>
<tr class="memdesc:a86db2e6702e5337a553e5250c8f1844b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum size of this set. <br /></td></tr>
<tr class="separator:a86db2e6702e5337a553e5250c8f1844b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af118b4673b485219f99155dad4d0cfa2" id="r_af118b4673b485219f99155dad4d0cfa2"><td class="memItemLeft" align="right" valign="top"><a id="af118b4673b485219f99155dad4d0cfa2" name="af118b4673b485219f99155dad4d0cfa2"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> () const noexcept</td></tr>
<tr class="memdesc:af118b4673b485219f99155dad4d0cfa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Actual size of this set. <br /></td></tr>
<tr class="separator:af118b4673b485219f99155dad4d0cfa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b5f8f1db73b402abd00b3c5961bac81" id="r_a9b5f8f1db73b402abd00b3c5961bac81"><td class="memItemLeft" align="right" valign="top"><a id="a9b5f8f1db73b402abd00b3c5961bac81" name="a9b5f8f1db73b402abd00b3c5961bac81"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>exists</b> (const value_t &amp;v) const noexcept</td></tr>
<tr class="memdesc:a9b5f8f1db73b402abd00b3c5961bac81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does an element exist? <br /></td></tr>
<tr class="separator:a9b5f8f1db73b402abd00b3c5961bac81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d4cbcc3f88d3bb81988e236e4035ed7" id="r_a2d4cbcc3f88d3bb81988e236e4035ed7"><td class="memItemLeft" align="right" valign="top"><a id="a2d4cbcc3f88d3bb81988e236e4035ed7" name="a2d4cbcc3f88d3bb81988e236e4035ed7"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>position</b> (const value_t &amp;v) const noexcept</td></tr>
<tr class="memdesc:a2d4cbcc3f88d3bb81988e236e4035ed7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Where is an element located? <br /></td></tr>
<tr class="separator:a2d4cbcc3f88d3bb81988e236e4035ed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbb54fe29ea460eb44c560adbce1db54" id="r_abbb54fe29ea460eb44c560adbce1db54"><td class="memItemLeft" align="right" valign="top"><a id="abbb54fe29ea460eb44c560adbce1db54" name="abbb54fe29ea460eb44c560adbce1db54"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>add</b> (const value_t &amp;v) noexcept</td></tr>
<tr class="memdesc:abbb54fe29ea460eb44c560adbce1db54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new element to the set. <br /></td></tr>
<tr class="separator:abbb54fe29ea460eb44c560adbce1db54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04c0e84fd2a78b9ebc17c012b30ec98a" id="r_a04c0e84fd2a78b9ebc17c012b30ec98a"><td class="memItemLeft" align="right" valign="top"><a id="a04c0e84fd2a78b9ebc17c012b30ec98a" name="a04c0e84fd2a78b9ebc17c012b30ec98a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>add</b> (value_t &amp;&amp;v) noexcept</td></tr>
<tr class="memdesc:a04c0e84fd2a78b9ebc17c012b30ec98a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new element to the set. <br /></td></tr>
<tr class="separator:a04c0e84fd2a78b9ebc17c012b30ec98a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab90dcdd1a21e5c1945edf4e06af106d6" id="r_ab90dcdd1a21e5c1945edf4e06af106d6"><td class="memItemLeft" align="right" valign="top"><a id="ab90dcdd1a21e5c1945edf4e06af106d6" name="ab90dcdd1a21e5c1945edf4e06af106d6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>remove</b> (const value_t &amp;v) noexcept</td></tr>
<tr class="memdesc:ab90dcdd1a21e5c1945edf4e06af106d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an element from the set. <br /></td></tr>
<tr class="separator:ab90dcdd1a21e5c1945edf4e06af106d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67a0ab1cdbe7a30ae55c2da4014703c5" id="r_a67a0ab1cdbe7a30ae55c2da4014703c5"><td class="memItemLeft" align="right" valign="top"><a id="a67a0ab1cdbe7a30ae55c2da4014703c5" name="a67a0ab1cdbe7a30ae55c2da4014703c5"></a>
const value_t *&#160;</td><td class="memItemRight" valign="bottom"><b>begin_values</b> () const noexcept</td></tr>
<tr class="memdesc:a67a0ab1cdbe7a30ae55c2da4014703c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin iterator to <a class="el" href="#a2c65e6010ab84584f9f8e365a9005d98">m_values</a>. <br /></td></tr>
<tr class="separator:a67a0ab1cdbe7a30ae55c2da4014703c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b16a3af6609cf5fdb09cb60f580f020" id="r_a2b16a3af6609cf5fdb09cb60f580f020"><td class="memItemLeft" align="right" valign="top"><a id="a2b16a3af6609cf5fdb09cb60f580f020" name="a2b16a3af6609cf5fdb09cb60f580f020"></a>
value_t *&#160;</td><td class="memItemRight" valign="bottom"><b>begin_values</b> () noexcept</td></tr>
<tr class="memdesc:a2b16a3af6609cf5fdb09cb60f580f020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin iterator to <a class="el" href="#a2c65e6010ab84584f9f8e365a9005d98">m_values</a>. <br /></td></tr>
<tr class="separator:a2b16a3af6609cf5fdb09cb60f580f020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3dae39f22757017ae8615b15818f35f" id="r_ad3dae39f22757017ae8615b15818f35f"><td class="memItemLeft" align="right" valign="top"><a id="ad3dae39f22757017ae8615b15818f35f" name="ad3dae39f22757017ae8615b15818f35f"></a>
const value_t *&#160;</td><td class="memItemRight" valign="bottom"><b>end_values</b> () const noexcept</td></tr>
<tr class="memdesc:ad3dae39f22757017ae8615b15818f35f"><td class="mdescLeft">&#160;</td><td class="mdescRight">End iterator to <a class="el" href="#a2c65e6010ab84584f9f8e365a9005d98">m_values</a>. <br /></td></tr>
<tr class="separator:ad3dae39f22757017ae8615b15818f35f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a734819f85d585d0e1b33d84ce48b8121" id="r_a734819f85d585d0e1b33d84ce48b8121"><td class="memItemLeft" align="right" valign="top"><a id="a734819f85d585d0e1b33d84ce48b8121" name="a734819f85d585d0e1b33d84ce48b8121"></a>
value_t *&#160;</td><td class="memItemRight" valign="bottom"><b>end_values</b> () noexcept</td></tr>
<tr class="memdesc:a734819f85d585d0e1b33d84ce48b8121"><td class="mdescLeft">&#160;</td><td class="mdescRight">End iterator to <a class="el" href="#a2c65e6010ab84584f9f8e365a9005d98">m_values</a>. <br /></td></tr>
<tr class="separator:a734819f85d585d0e1b33d84ce48b8121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5ab0eec21b0cfaaf201dd671281648c" id="r_ae5ab0eec21b0cfaaf201dd671281648c"><td class="memItemLeft" align="right" valign="top"><a id="ae5ab0eec21b0cfaaf201dd671281648c" name="ae5ab0eec21b0cfaaf201dd671281648c"></a>
const value_t *&#160;</td><td class="memItemRight" valign="bottom"><b>begin_position</b> () const noexcept</td></tr>
<tr class="memdesc:ae5ab0eec21b0cfaaf201dd671281648c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin iterator to <a class="el" href="#a56c22517d5ff8371931bafbe8b0ca123">m_position</a>. <br /></td></tr>
<tr class="separator:ae5ab0eec21b0cfaaf201dd671281648c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a506d2feff481221e0b7d3e383c0a3320" id="r_a506d2feff481221e0b7d3e383c0a3320"><td class="memItemLeft" align="right" valign="top"><a id="a506d2feff481221e0b7d3e383c0a3320" name="a506d2feff481221e0b7d3e383c0a3320"></a>
value_t *&#160;</td><td class="memItemRight" valign="bottom"><b>begin_position</b> () noexcept</td></tr>
<tr class="memdesc:a506d2feff481221e0b7d3e383c0a3320"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin iterator to <a class="el" href="#a56c22517d5ff8371931bafbe8b0ca123">m_position</a>. <br /></td></tr>
<tr class="separator:a506d2feff481221e0b7d3e383c0a3320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75e1e20b085c4e933890f1c3ff0b5b3b" id="r_a75e1e20b085c4e933890f1c3ff0b5b3b"><td class="memItemLeft" align="right" valign="top"><a id="a75e1e20b085c4e933890f1c3ff0b5b3b" name="a75e1e20b085c4e933890f1c3ff0b5b3b"></a>
const value_t *&#160;</td><td class="memItemRight" valign="bottom"><b>end_position</b> () const noexcept</td></tr>
<tr class="memdesc:a75e1e20b085c4e933890f1c3ff0b5b3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">End iterator to <a class="el" href="#a56c22517d5ff8371931bafbe8b0ca123">m_position</a>. <br /></td></tr>
<tr class="separator:a75e1e20b085c4e933890f1c3ff0b5b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafb38802947822fa27dd34c9bf85e3b7" id="r_aafb38802947822fa27dd34c9bf85e3b7"><td class="memItemLeft" align="right" valign="top"><a id="aafb38802947822fa27dd34c9bf85e3b7" name="aafb38802947822fa27dd34c9bf85e3b7"></a>
value_t *&#160;</td><td class="memItemRight" valign="bottom"><b>end_position</b> () noexcept</td></tr>
<tr class="memdesc:aafb38802947822fa27dd34c9bf85e3b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">End iterator to <a class="el" href="#a56c22517d5ff8371931bafbe8b0ca123">m_position</a>. <br /></td></tr>
<tr class="separator:aafb38802947822fa27dd34c9bf85e3b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:add7bdea84d8e208126080deb7dc1a730" id="r_add7bdea84d8e208126080deb7dc1a730"><td class="memItemLeft" align="right" valign="top"><a id="add7bdea84d8e208126080deb7dc1a730" name="add7bdea84d8e208126080deb7dc1a730"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>index</b> (const value_t &amp;v) const noexcept</td></tr>
<tr class="memdesc:add7bdea84d8e208126080deb7dc1a730"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the index of an element using the indexer object <a class="el" href="#abcf3d0e21cc99d5eb772d4ad08b5e8cc">m_I</a>. <br /></td></tr>
<tr class="separator:add7bdea84d8e208126080deb7dc1a730"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:abcf3d0e21cc99d5eb772d4ad08b5e8cc" id="r_abcf3d0e21cc99d5eb772d4ad08b5e8cc"><td class="memItemLeft" align="right" valign="top"><a id="abcf3d0e21cc99d5eb772d4ad08b5e8cc" name="abcf3d0e21cc99d5eb772d4ad08b5e8cc"></a>
indexer_t&#160;</td><td class="memItemRight" valign="bottom"><b>m_I</b></td></tr>
<tr class="memdesc:abcf3d0e21cc99d5eb772d4ad08b5e8cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The indexer object. <br /></td></tr>
<tr class="separator:abcf3d0e21cc99d5eb772d4ad08b5e8cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c65e6010ab84584f9f8e365a9005d98" id="r_a2c65e6010ab84584f9f8e365a9005d98"><td class="memItemLeft" align="right" valign="top"><a id="a2c65e6010ab84584f9f8e365a9005d98" name="a2c65e6010ab84584f9f8e365a9005d98"></a>
<a class="el" href="structlal_1_1detail_1_1array.html">array</a>&lt; value_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_values</b></td></tr>
<tr class="memdesc:a2c65e6010ab84584f9f8e365a9005d98"><td class="mdescLeft">&#160;</td><td class="mdescRight">The unique values in this set. <br /></td></tr>
<tr class="separator:a2c65e6010ab84584f9f8e365a9005d98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1e40bb076e158067087a2c03b262838" id="r_aa1e40bb076e158067087a2c03b262838"><td class="memItemLeft" align="right" valign="top"><a id="aa1e40bb076e158067087a2c03b262838" name="aa1e40bb076e158067087a2c03b262838"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>m_size</b></td></tr>
<tr class="memdesc:aa1e40bb076e158067087a2c03b262838"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of values in <a class="el" href="#a2c65e6010ab84584f9f8e365a9005d98">m_values</a>. <br /></td></tr>
<tr class="separator:aa1e40bb076e158067087a2c03b262838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09328c97c86372c8aad0ada95b72aca1" id="r_a09328c97c86372c8aad0ada95b72aca1"><td class="memItemLeft" align="right" valign="top"><a id="a09328c97c86372c8aad0ada95b72aca1" name="a09328c97c86372c8aad0ada95b72aca1"></a>
<a class="el" href="structlal_1_1detail_1_1array.html">array</a>&lt; char &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_exists</b></td></tr>
<tr class="memdesc:a09328c97c86372c8aad0ada95b72aca1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does a value exist in the set? <br /></td></tr>
<tr class="separator:a09328c97c86372c8aad0ada95b72aca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56c22517d5ff8371931bafbe8b0ca123" id="r_a56c22517d5ff8371931bafbe8b0ca123"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlal_1_1detail_1_1array.html">array</a>&lt; std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a56c22517d5ff8371931bafbe8b0ca123">m_position</a></td></tr>
<tr class="memdesc:a56c22517d5ff8371931bafbe8b0ca123"><td class="mdescLeft">&#160;</td><td class="mdescRight">The position of every value in the set.  <br /></td></tr>
<tr class="separator:a56c22517d5ff8371931bafbe8b0ca123"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-static-attribs" name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr class="memitem:abc01d2c140978dbd538877ee40d60515" id="r_abc01d2c140978dbd538877ee40d60515"><td class="memItemLeft" align="right" valign="top"><a id="abc01d2c140978dbd538877ee40d60515" name="abc01d2c140978dbd538877ee40d60515"></a>
static constexpr char&#160;</td><td class="memItemRight" valign="bottom"><b>EXISTS</b> = 1</td></tr>
<tr class="memdesc:abc01d2c140978dbd538877ee40d60515"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does an element exist in the set? <br /></td></tr>
<tr class="separator:abc01d2c140978dbd538877ee40d60515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0476cdf4d521b0b65c27cb3211ad165" id="r_af0476cdf4d521b0b65c27cb3211ad165"><td class="memItemLeft" align="right" valign="top"><a id="af0476cdf4d521b0b65c27cb3211ad165" name="af0476cdf4d521b0b65c27cb3211ad165"></a>
static constexpr char&#160;</td><td class="memItemRight" valign="bottom"><b>NOT_EXISTS</b> = 0</td></tr>
<tr class="memdesc:af0476cdf4d521b0b65c27cb3211ad165"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does an element not exist in the set? <br /></td></tr>
<tr class="separator:af0476cdf4d521b0b65c27cb3211ad165"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename value_t, class indexer_t = value_t&gt;<br />
class lal::detail::set_array&lt; value_t, indexer_t &gt;</div><p>A set-like data structure implemented with an array. </p>
<p>It is actually a simplified unordered hash map implemented using 4 arrays. The goal is to implement a set-like data structure. Elements contained in the set are added to array <a class="el" href="#a2c65e6010ab84584f9f8e365a9005d98">m_values</a> which is known to hold a maximum number of elements \(M\); its actual size is stored in <a class="el" href="#aa1e40bb076e158067087a2c03b262838">m_size</a>.</p>
<p>Every time an element \(E\) is added to the set, its position (in <a class="el" href="#a2c65e6010ab84584f9f8e365a9005d98">m_values</a>) is recorded in <a class="el" href="#a56c22517d5ff8371931bafbe8b0ca123">m_position</a> via a function that maps \(E\) to an integer value between \(0\) and \(M-1\). This function is implemented via a so-called <em>indexer</em> object, the only requirement of which is to have an operator (<em>value_t</em>) that returns said index. After the position is recorded, its existence in the set is also recorded, but in <a class="el" href="#a09328c97c86372c8aad0ada95b72aca1">m_exists</a>.</p>
<p>If two different elements \(E_1\) and \(E_2\) are mapped to the same index value via the indexer, then they will be treated as the same object.</p>
<p>If the contained elements are integer values (char, short, int, ...) there is no need to implement an indexer object and the type of the indexer value needs not be provided. If the elements are more complex, a requirement to use this object is to implement an indexer object.</p>
<p>When adding an element, the indexer object is called only once. When removing an element, the indexer object is called twice.</p>
<p>This set has to be initialized with a maximum size (which is the maximum number of elements this array would contain in the worst case) and a maximum index value (the highest index that an element could have in the worst case).</p>
<p>Now follows an example that shows how to use this set with integer types, </p><div class="fragment"><div class="line"><a class="code hl_class" href="classlal_1_1detail_1_1set__array.html">lal::detail::set_array&lt;int&gt;</a> s(10, 10);</div>
<div class="line">s.add(3);</div>
<div class="line">s.add(4);</div>
<div class="line">s.remove(3);</div>
<div class="ttc" id="aclasslal_1_1detail_1_1set__array_html"><div class="ttname"><a href="classlal_1_1detail_1_1set__array.html">lal::detail::set_array</a></div><div class="ttdoc">A set-like data structure implemented with an array.</div><div class="ttdef"><b>Definition</b> set_array.hpp:105</div></div>
</div><!-- fragment --><p> Now follows an example that shows how to use this set with pairs of integers, </p><div class="fragment"><div class="line"><span class="keyword">struct </span>indexer {</div>
<div class="line">    std::size_t operator()(<span class="keyword">const</span> <a class="code hl_typedef" href="namespacelal.html#a5969ec7ecc85697ebb9ec0ace78fbcab">lal::edge</a>&amp; p) <span class="keyword">const</span> <span class="keyword">noexcept</span> {</div>
<div class="line">        <span class="keywordflow">return</span> p.first + p.second*10;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line">indexer I;</div>
<div class="line"><a class="code hl_class" href="classlal_1_1detail_1_1set__array.html">lal::detail::set_array&lt;std::pair&lt;int, int&gt;</a>&gt; s(10, 100, std::move(I));</div>
<div class="line">s.add({3,4});</div>
<div class="line">s.add({4,4});</div>
<div class="line">s.remove({3,4});</div>
<div class="ttc" id="anamespacelal_html_a5969ec7ecc85697ebb9ec0ace78fbcab"><div class="ttname"><a href="namespacelal.html#a5969ec7ecc85697ebb9ec0ace78fbcab">lal::edge</a></div><div class="ttdeci">std::pair&lt; node, node &gt; edge</div><div class="ttdoc">See Edge page for further details.</div><div class="ttdef"><b>Definition</b> basic_types.hpp:56</div></div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">value_t</td><td>The type of the contained elements </td></tr>
    <tr><td class="paramname">indexer_t</td><td>The type of the indexer object </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a719a27d9ac1ab527fdbcf0ff7f6b7a7f" name="a719a27d9ac1ab527fdbcf0ff7f6b7a7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a719a27d9ac1ab527fdbcf0ff7f6b7a7f">&#9670;&#160;</a></span>init() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t , class indexer_t  = value_t&gt; </div>
<div class="memtemplate">
template&lt;typename vt  = value_t, typename it  = indexer_t, std::enable_if_t&lt; std::is_same_v&lt; vt, it &gt;, bool &gt;  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlal_1_1detail_1_1set__array.html">lal::detail::set_array</a>&lt; value_t, indexer_t &gt;::init </td>
          <td>(</td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>max_num_elems</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>max_index_value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the set with no indexer object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_num_elems</td><td>Maximum number of elements in this set. </td></tr>
    <tr><td class="paramname">max_index_value</td><td>Maximum index value in the worst case. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3e517b8dd0609a1ce7caf1f48f7ae380" name="a3e517b8dd0609a1ce7caf1f48f7ae380"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e517b8dd0609a1ce7caf1f48f7ae380">&#9670;&#160;</a></span>init() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t , class indexer_t  = value_t&gt; </div>
<div class="memtemplate">
template&lt;typename vt  = value_t, typename it  = indexer_t, std::enable_if_t&lt; not std::is_same_v&lt; vt, it &gt;, bool &gt;  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlal_1_1detail_1_1set__array.html">lal::detail::set_array</a>&lt; value_t, indexer_t &gt;::init </td>
          <td>(</td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>max_num_elems</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>max_index_value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">indexer_t &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>i</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the set with an indexer object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_num_elems</td><td>Maximum number of elements in this set. </td></tr>
    <tr><td class="paramname">max_index_value</td><td>Maximum index value in the worst case. </td></tr>
    <tr><td class="paramname">i</td><td>Indexer object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a913141c148f276d0c716f63192f8a78b" name="a913141c148f276d0c716f63192f8a78b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a913141c148f276d0c716f63192f8a78b">&#9670;&#160;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t , class indexer_t  = value_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const value_t &amp; <a class="el" href="classlal_1_1detail_1_1set__array.html">lal::detail::set_array</a>&lt; value_t, indexer_t &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operator to access values in a given position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Index value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value at the <em>i-th</em> position of <a class="el" href="#a2c65e6010ab84584f9f8e365a9005d98">m_values</a>. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a56c22517d5ff8371931bafbe8b0ca123" name="a56c22517d5ff8371931bafbe8b0ca123"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56c22517d5ff8371931bafbe8b0ca123">&#9670;&#160;</a></span>m_position</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_t , class indexer_t  = value_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlal_1_1detail_1_1array.html">array</a>&lt;std::size_t&gt; <a class="el" href="classlal_1_1detail_1_1set__array.html">lal::detail::set_array</a>&lt; value_t, indexer_t &gt;::m_position</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The position of every value in the set. </p>
<p>This position is an index that points to a cell of <a class="el" href="#a2c65e6010ab84584f9f8e365a9005d98">m_values</a>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>lal/detail/<a class="el" href="set__array_8hpp_source.html">set_array.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
