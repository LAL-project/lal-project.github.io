<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LAL: Linear Arrangement Library: lal::graphs::tree Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">LAL: Linear Arrangement Library<span id="projectnumber">&#160;24.10.00</span>
   </div>
   <div id="projectbrief">A library focused on algorithms on linear arrangements of graphs.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacelal.html">lal</a></li><li class="navelem"><a class="el" href="namespacelal_1_1graphs.html">graphs</a></li><li class="navelem"><a class="el" href="classlal_1_1graphs_1_1tree.html">tree</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classlal_1_1graphs_1_1tree-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">lal::graphs::tree Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>Tree graph class.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="tree_8hpp_source.html">tree.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for lal::graphs::tree:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classlal_1_1graphs_1_1tree.png" usemap="#lal::graphs::tree_map" alt=""/>
  <map id="lal::graphs::tree_map" name="lal::graphs::tree_map">
<area href="classlal_1_1graphs_1_1graph.html" title="Abstract class for graphs." alt="lal::graphs::graph" shape="rect" coords="75,0,216,24"/>
<area href="classlal_1_1graphs_1_1free__tree.html" title="Free tree graph class." alt="lal::graphs::free_tree" shape="rect" coords="0,112,141,136"/>
<area href="classlal_1_1graphs_1_1rooted__tree.html" title="Rooted tree graph class." alt="lal::graphs::rooted_tree" shape="rect" coords="151,112,292,136"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2ac1c7a57cffc67886c2704fb2fdf3b1" id="r_a2ac1c7a57cffc67886c2704fb2fdf3b1"><td class="memItemLeft" align="right" valign="top"><a id="a2ac1c7a57cffc67886c2704fb2fdf3b1" name="a2ac1c7a57cffc67886c2704fb2fdf3b1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>tree</b> () noexcept</td></tr>
<tr class="memdesc:a2ac1c7a57cffc67886c2704fb2fdf3b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty constructor. <br /></td></tr>
<tr class="separator:a2ac1c7a57cffc67886c2704fb2fdf3b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1455a41bdb8a6e4c638e3468ea457c7d" id="r_a1455a41bdb8a6e4c638e3468ea457c7d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1455a41bdb8a6e4c638e3468ea457c7d">tree</a> (const <a class="el" href="classlal_1_1graphs_1_1tree.html">tree</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:a1455a41bdb8a6e4c638e3468ea457c7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <br /></td></tr>
<tr class="separator:a1455a41bdb8a6e4c638e3468ea457c7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac67c5d26096ec29c46cca22b9d7b61dd" id="r_ac67c5d26096ec29c46cca22b9d7b61dd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac67c5d26096ec29c46cca22b9d7b61dd">tree</a> (<a class="el" href="classlal_1_1graphs_1_1tree.html">tree</a> &amp;&amp;t) noexcept</td></tr>
<tr class="memdesc:ac67c5d26096ec29c46cca22b9d7b61dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <br /></td></tr>
<tr class="separator:ac67c5d26096ec29c46cca22b9d7b61dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4db64d5f6d9f53f2e629e324df25d12c" id="r_a4db64d5f6d9f53f2e629e324df25d12c"><td class="memItemLeft" align="right" valign="top"><a id="a4db64d5f6d9f53f2e629e324df25d12c" name="a4db64d5f6d9f53f2e629e324df25d12c"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~tree</b> () noexcept</td></tr>
<tr class="memdesc:a4db64d5f6d9f53f2e629e324df25d12c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a4db64d5f6d9f53f2e629e324df25d12c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a047c0d257986a79742aad0c49b517bb4" id="r_a047c0d257986a79742aad0c49b517bb4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1graphs_1_1tree.html">tree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a047c0d257986a79742aad0c49b517bb4">operator=</a> (const <a class="el" href="classlal_1_1graphs_1_1tree.html">tree</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:a047c0d257986a79742aad0c49b517bb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator.  <br /></td></tr>
<tr class="separator:a047c0d257986a79742aad0c49b517bb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75314d033504b75f3cb0e7202890285b" id="r_a75314d033504b75f3cb0e7202890285b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1graphs_1_1tree.html">tree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a75314d033504b75f3cb0e7202890285b">operator=</a> (<a class="el" href="classlal_1_1graphs_1_1tree.html">tree</a> &amp;&amp;t) noexcept</td></tr>
<tr class="memdesc:a75314d033504b75f3cb0e7202890285b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator.  <br /></td></tr>
<tr class="separator:a75314d033504b75f3cb0e7202890285b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8a453d924452a46b781f1cf6bfb8360" id="r_aa8a453d924452a46b781f1cf6bfb8360"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa8a453d924452a46b781f1cf6bfb8360">calculate_tree_type</a> () noexcept=0</td></tr>
<tr class="memdesc:aa8a453d924452a46b781f1cf6bfb8360"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the type of tree.  <br /></td></tr>
<tr class="separator:aa8a453d924452a46b781f1cf6bfb8360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3b9064bc1a7dbf90dfd72dba20073af" id="r_ab3b9064bc1a7dbf90dfd72dba20073af"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3b9064bc1a7dbf90dfd72dba20073af">finish_bulk_add_complete</a> (const bool norm=true, const bool check=true) noexcept=0</td></tr>
<tr class="memdesc:ab3b9064bc1a7dbf90dfd72dba20073af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Completes the inner structure of the tree after adding edges in bulk.  <br /></td></tr>
<tr class="separator:ab3b9064bc1a7dbf90dfd72dba20073af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed5dea71acee5dff70ae746de0fafcc9" id="r_aed5dea71acee5dff70ae746de0fafcc9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed5dea71acee5dff70ae746de0fafcc9">finish_bulk_remove_complete</a> (const bool norm=true, const bool check=true) noexcept=0</td></tr>
<tr class="memdesc:aed5dea71acee5dff70ae746de0fafcc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Completes the inner structure of the tree after removing edges in bulk.  <br /></td></tr>
<tr class="separator:aed5dea71acee5dff70ae746de0fafcc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25c8d57865fa5f7cb5d101fd5d07fe2d" id="r_a25c8d57865fa5f7cb5d101fd5d07fe2d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a25c8d57865fa5f7cb5d101fd5d07fe2d">is_tree</a> () const noexcept</td></tr>
<tr class="memdesc:a25c8d57865fa5f7cb5d101fd5d07fe2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this graph an actual tree?  <br /></td></tr>
<tr class="separator:a25c8d57865fa5f7cb5d101fd5d07fe2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c283089c4933476c07de966ba5c6385" id="r_a1c283089c4933476c07de966ba5c6385"><td class="memItemLeft" align="right" valign="top"><a id="a1c283089c4933476c07de966ba5c6385" name="a1c283089c4933476c07de966ba5c6385"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_rooted</b> () const noexcept=0</td></tr>
<tr class="memdesc:a1c283089c4933476c07de966ba5c6385"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether this tree is a rooted tree. <br /></td></tr>
<tr class="separator:a1c283089c4933476c07de966ba5c6385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3003f7649ef64924ff688a6f30d67b26" id="r_a3003f7649ef64924ff688a6f30d67b26"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3003f7649ef64924ff688a6f30d67b26">can_add_edge</a> (<a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> const s, const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> t) const noexcept</td></tr>
<tr class="memdesc:a3003f7649ef64924ff688a6f30d67b26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can this edge be added?  <br /></td></tr>
<tr class="separator:a3003f7649ef64924ff688a6f30d67b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d52f3c3edace3159f0cf5e31631dd63" id="r_a6d52f3c3edace3159f0cf5e31631dd63"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6d52f3c3edace3159f0cf5e31631dd63">can_add_edges</a> (const std::vector&lt; <a class="el" href="namespacelal.html#a5969ec7ecc85697ebb9ec0ace78fbcab">edge</a> &gt; &amp;edges) const noexcept</td></tr>
<tr class="memdesc:a6d52f3c3edace3159f0cf5e31631dd63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can these edges be added?  <br /></td></tr>
<tr class="separator:a6d52f3c3edace3159f0cf5e31631dd63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19e1904c2b9fe5c62237517c618ce71b" id="r_a19e1904c2b9fe5c62237517c618ce71b"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a19e1904c2b9fe5c62237517c618ce71b">get_component_representative</a> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u) const noexcept</td></tr>
<tr class="memdesc:a19e1904c2b9fe5c62237517c618ce71b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representative node of the connected component in which <em>u</em> belongs.  <br /></td></tr>
<tr class="separator:a19e1904c2b9fe5c62237517c618ce71b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a680f3d15750907dfd5183ec76b5fa7f8" id="r_a680f3d15750907dfd5183ec76b5fa7f8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a680f3d15750907dfd5183ec76b5fa7f8">are_nodes_in_same_component</a> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u, const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> v) const noexcept</td></tr>
<tr class="memdesc:a680f3d15750907dfd5183ec76b5fa7f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two nodes are in the same connected component.  <br /></td></tr>
<tr class="separator:a680f3d15750907dfd5183ec76b5fa7f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54061e1790d0424cac8960a0a3277a99" id="r_a54061e1790d0424cac8960a0a3277a99"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a54061e1790d0424cac8960a0a3277a99">get_num_nodes_component</a> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u) const noexcept</td></tr>
<tr class="memdesc:a54061e1790d0424cac8960a0a3277a99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Amount of nodes in a connected component of the tree.  <br /></td></tr>
<tr class="separator:a54061e1790d0424cac8960a0a3277a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06ce8cc7afb074d2fecf70a0842adaaa" id="r_a06ce8cc7afb074d2fecf70a0842adaaa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a06ce8cc7afb074d2fecf70a0842adaaa">is_of_tree_type</a> (const <a class="el" href="namespacelal_1_1graphs.html#a18d52542088507e2be6241759722835b">tree_type</a> &amp;tt) const noexcept</td></tr>
<tr class="memdesc:a06ce8cc7afb074d2fecf70a0842adaaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether this tree is of type <em>tt</em>.  <br /></td></tr>
<tr class="separator:a06ce8cc7afb074d2fecf70a0842adaaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fc7f9e08db601f10982da6a01315cb3" id="r_a9fc7f9e08db601f10982da6a01315cb3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9fc7f9e08db601f10982da6a01315cb3">is_tree_type_valid</a> () const noexcept</td></tr>
<tr class="memdesc:a9fc7f9e08db601f10982da6a01315cb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the type of this tree valid?  <br /></td></tr>
<tr class="separator:a9fc7f9e08db601f10982da6a01315cb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae51ce9ddffc9287f375545e2b2fec3e3" id="r_ae51ce9ddffc9287f375545e2b2fec3e3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae51ce9ddffc9287f375545e2b2fec3e3">get_tree_type_list</a> () const noexcept</td></tr>
<tr class="memdesc:ae51ce9ddffc9287f375545e2b2fec3e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the list of types as a list of strings.  <br /></td></tr>
<tr class="separator:ae51ce9ddffc9287f375545e2b2fec3e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e3529632b38533c4be8b2a306a038c3" id="r_a0e3529632b38533c4be8b2a306a038c3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1graph.html#a0e3529632b38533c4be8b2a306a038c3">init</a> (const uint64_t n) noexcept</td></tr>
<tr class="memdesc:a0e3529632b38533c4be8b2a306a038c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates the necessary memory for this class.  <br /></td></tr>
<tr class="separator:a0e3529632b38533c4be8b2a306a038c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8ba9ec6acf2306c84d9ddbd88fc8474" id="r_af8ba9ec6acf2306c84d9ddbd88fc8474"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1graph.html#af8ba9ec6acf2306c84d9ddbd88fc8474">clear</a> () noexcept</td></tr>
<tr class="memdesc:af8ba9ec6acf2306c84d9ddbd88fc8474"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the memory occupied by this graph.  <br /></td></tr>
<tr class="separator:af8ba9ec6acf2306c84d9ddbd88fc8474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe2c7decb104857bd857c769feb75c98" id="r_abe2c7decb104857bd857c769feb75c98"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1graph.html#abe2c7decb104857bd857c769feb75c98">normalize</a> () noexcept</td></tr>
<tr class="memdesc:abe2c7decb104857bd857c769feb75c98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalizes the graph.  <br /></td></tr>
<tr class="separator:abe2c7decb104857bd857c769feb75c98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0beca99dbbaa1a1a27db6c4e2d280ea5" id="r_a0beca99dbbaa1a1a27db6c4e2d280ea5"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1graph.html#a0beca99dbbaa1a1a27db6c4e2d280ea5">check_normalized</a> () noexcept</td></tr>
<tr class="memdesc:a0beca99dbbaa1a1a27db6c4e2d280ea5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the graph is normalized.  <br /></td></tr>
<tr class="separator:a0beca99dbbaa1a1a27db6c4e2d280ea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af01a3a104e9b5b62ef385df4cb6a1bff" id="r_af01a3a104e9b5b62ef385df4cb6a1bff"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1graph.html#af01a3a104e9b5b62ef385df4cb6a1bff">finish_bulk_add</a> (const bool norm=true, const bool check=true) noexcept=0</td></tr>
<tr class="memdesc:af01a3a104e9b5b62ef385df4cb6a1bff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Completes the inner structure of the graph after adding a bulk of edges.  <br /></td></tr>
<tr class="separator:af01a3a104e9b5b62ef385df4cb6a1bff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3887a16f8193383c971bef9c35b6b700" id="r_a3887a16f8193383c971bef9c35b6b700"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1graph.html#a3887a16f8193383c971bef9c35b6b700">finish_bulk_remove</a> (const bool norm=true, const bool check=true) noexcept=0</td></tr>
<tr class="memdesc:a3887a16f8193383c971bef9c35b6b700"><td class="mdescLeft">&#160;</td><td class="mdescRight">Completes the inner structure of the graph after removing edges in bulk.  <br /></td></tr>
<tr class="separator:a3887a16f8193383c971bef9c35b6b700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbe53e770688c22a8c1e614d728d11cc" id="r_abbe53e770688c22a8c1e614d728d11cc"><td class="memItemLeft" align="right" valign="top"><a id="abbe53e770688c22a8c1e614d728d11cc" name="abbe53e770688c22a8c1e614d728d11cc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_normalized</b> (const bool v=true) noexcept</td></tr>
<tr class="memdesc:abbe53e770688c22a8c1e614d728d11cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether this graph is normalized or not. <br /></td></tr>
<tr class="separator:abbe53e770688c22a8c1e614d728d11cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91155aa7578956540e8811aa896d06c5" id="r_a91155aa7578956540e8811aa896d06c5"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="namespacelal.html#a235d5351556fbc73aa51767ab7765f5c">edge_pair</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1graph.html#a91155aa7578956540e8811aa896d06c5">get_Q</a> () const noexcept=0</td></tr>
<tr class="memdesc:a91155aa7578956540e8811aa896d06c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all independent pairs of edges of this graph.  <br /></td></tr>
<tr class="separator:a91155aa7578956540e8811aa896d06c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad2d7e6a53d8746c66e8af9762c14484" id="r_aad2d7e6a53d8746c66e8af9762c14484"><td class="memItemLeft" align="right" valign="top"><a id="aad2d7e6a53d8746c66e8af9762c14484" name="aad2d7e6a53d8746c66e8af9762c14484"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>has_node</b> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u) const noexcept</td></tr>
<tr class="memdesc:aad2d7e6a53d8746c66e8af9762c14484"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if node <em>u</em> is in this graph. <br /></td></tr>
<tr class="separator:aad2d7e6a53d8746c66e8af9762c14484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca1226c2c4c77e61ebd31d42e56e8afd" id="r_aca1226c2c4c77e61ebd31d42e56e8afd"><td class="memItemLeft" align="right" valign="top"><a id="aca1226c2c4c77e61ebd31d42e56e8afd" name="aca1226c2c4c77e61ebd31d42e56e8afd"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>has_edge</b> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u, const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> v) const =0</td></tr>
<tr class="memdesc:aca1226c2c4c77e61ebd31d42e56e8afd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the undirected edge (<em>u</em>, <em>v</em>) exists in the graph. <br /></td></tr>
<tr class="separator:aca1226c2c4c77e61ebd31d42e56e8afd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58918b2b3fe79dff35003604bdfa19f3" id="r_a58918b2b3fe79dff35003604bdfa19f3"><td class="memItemLeft" align="right" valign="top"><a id="a58918b2b3fe79dff35003604bdfa19f3" name="a58918b2b3fe79dff35003604bdfa19f3"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>get_num_nodes</b> () const noexcept</td></tr>
<tr class="memdesc:a58918b2b3fe79dff35003604bdfa19f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of ndoes. <br /></td></tr>
<tr class="separator:a58918b2b3fe79dff35003604bdfa19f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a351a7e8c6a0ec6c23026b0b0b57efd17" id="r_a351a7e8c6a0ec6c23026b0b0b57efd17"><td class="memItemLeft" align="right" valign="top"><a id="a351a7e8c6a0ec6c23026b0b0b57efd17" name="a351a7e8c6a0ec6c23026b0b0b57efd17"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>get_num_edges</b> () const noexcept</td></tr>
<tr class="memdesc:a351a7e8c6a0ec6c23026b0b0b57efd17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of edges. <br /></td></tr>
<tr class="separator:a351a7e8c6a0ec6c23026b0b0b57efd17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebdf79ccbdd3d0217ab4ebc2b85da9b1" id="r_aebdf79ccbdd3d0217ab4ebc2b85da9b1"><td class="memItemLeft" align="right" valign="top"><a id="aebdf79ccbdd3d0217ab4ebc2b85da9b1" name="aebdf79ccbdd3d0217ab4ebc2b85da9b1"></a>
virtual std::vector&lt; <a class="el" href="namespacelal.html#a5969ec7ecc85697ebb9ec0ace78fbcab">edge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>get_edges</b> () const noexcept=0</td></tr>
<tr class="memdesc:aebdf79ccbdd3d0217ab4ebc2b85da9b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all edges of this graph. <br /></td></tr>
<tr class="separator:aebdf79ccbdd3d0217ab4ebc2b85da9b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb9238eb8914e145736f1ac914f6b9d6" id="r_abb9238eb8914e145736f1ac914f6b9d6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1graph.html#abb9238eb8914e145736f1ac914f6b9d6">is_normalized</a> () const noexcept</td></tr>
<tr class="memdesc:abb9238eb8914e145736f1ac914f6b9d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether this graph is normalized or not.  <br /></td></tr>
<tr class="separator:abb9238eb8914e145736f1ac914f6b9d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49c2a4c21b5d1bc7a29c09af9fc555bc" id="r_a49c2a4c21b5d1bc7a29c09af9fc555bc"><td class="memItemLeft" align="right" valign="top"><a id="a49c2a4c21b5d1bc7a29c09af9fc555bc" name="a49c2a4c21b5d1bc7a29c09af9fc555bc"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_directed</b> () const noexcept=0</td></tr>
<tr class="memdesc:a49c2a4c21b5d1bc7a29c09af9fc555bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether this graph is directed or not. <br /></td></tr>
<tr class="separator:a49c2a4c21b5d1bc7a29c09af9fc555bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73db3be0a36fe9f49189b05258af2590" id="r_a73db3be0a36fe9f49189b05258af2590"><td class="memItemLeft" align="right" valign="top"><a id="a73db3be0a36fe9f49189b05258af2590" name="a73db3be0a36fe9f49189b05258af2590"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_undirected</b> () const noexcept=0</td></tr>
<tr class="memdesc:a73db3be0a36fe9f49189b05258af2590"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether this graph is undirected or not. <br /></td></tr>
<tr class="separator:a73db3be0a36fe9f49189b05258af2590"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a973468996f8ff425e9a37ae0788bc4c1" id="r_a973468996f8ff425e9a37ae0788bc4c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a973468996f8ff425e9a37ae0788bc4c1">tree_only_init</a> (const uint64_t n) noexcept</td></tr>
<tr class="memdesc:a973468996f8ff425e9a37ae0788bc4c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes only the memory of class <a class="el" href="classlal_1_1graphs_1_1tree.html">tree</a>.  <br /></td></tr>
<tr class="separator:a973468996f8ff425e9a37ae0788bc4c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade9b9ff890e9c0a809cdb39dd6a45d03" id="r_ade9b9ff890e9c0a809cdb39dd6a45d03"><td class="memItemLeft" align="right" valign="top"><a id="ade9b9ff890e9c0a809cdb39dd6a45d03" name="ade9b9ff890e9c0a809cdb39dd6a45d03"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>tree_only_clear</b> () noexcept</td></tr>
<tr class="memdesc:ade9b9ff890e9c0a809cdb39dd6a45d03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the memory used by only class <a class="el" href="classlal_1_1graphs_1_1tree.html">tree</a>. <br /></td></tr>
<tr class="separator:ade9b9ff890e9c0a809cdb39dd6a45d03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a98caa30febd772b6536f15aea33ea1" id="r_a3a98caa30febd772b6536f15aea33ea1"><td class="memItemLeft" align="right" valign="top"><a id="a3a98caa30febd772b6536f15aea33ea1" name="a3a98caa30febd772b6536f15aea33ea1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>tree_only_copy</b> (const <a class="el" href="classlal_1_1graphs_1_1tree.html">tree</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:a3a98caa30febd772b6536f15aea33ea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies only members of class <a class="el" href="classlal_1_1graphs_1_1tree.html">tree</a>. <br /></td></tr>
<tr class="separator:a3a98caa30febd772b6536f15aea33ea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c0ab812a8dead61f6e2e9253730f62a" id="r_a4c0ab812a8dead61f6e2e9253730f62a"><td class="memItemLeft" align="right" valign="top"><a id="a4c0ab812a8dead61f6e2e9253730f62a" name="a4c0ab812a8dead61f6e2e9253730f62a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>tree_only_move</b> (<a class="el" href="classlal_1_1graphs_1_1tree.html">tree</a> &amp;&amp;t) noexcept</td></tr>
<tr class="memdesc:a4c0ab812a8dead61f6e2e9253730f62a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves only members of class <a class="el" href="classlal_1_1graphs_1_1tree.html">tree</a>. <br /></td></tr>
<tr class="separator:a4c0ab812a8dead61f6e2e9253730f62a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65d589c9cedc11dac39baca2c0c58001" id="r_a65d589c9cedc11dac39baca2c0c58001"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a65d589c9cedc11dac39baca2c0c58001">tree_only_add_node</a> () noexcept</td></tr>
<tr class="memdesc:a65d589c9cedc11dac39baca2c0c58001"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a node to this tree.  <br /></td></tr>
<tr class="separator:a65d589c9cedc11dac39baca2c0c58001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ca79711e18e398299a3beb42fe3cc41" id="r_a2ca79711e18e398299a3beb42fe3cc41"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ca79711e18e398299a3beb42fe3cc41">tree_only_invalidate</a> () noexcept</td></tr>
<tr class="memdesc:a2ca79711e18e398299a3beb42fe3cc41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalidates the aggregated information of the tree.  <br /></td></tr>
<tr class="separator:a2ca79711e18e398299a3beb42fe3cc41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaabba99bcbca589ec9f8f5d3c85e6b43" id="r_aaabba99bcbca589ec9f8f5d3c85e6b43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaabba99bcbca589ec9f8f5d3c85e6b43">tree_only_actions_after_add_edge</a> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u, const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> v) noexcept</td></tr>
<tr class="memdesc:aaabba99bcbca589ec9f8f5d3c85e6b43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do some work after the addition of an edge.  <br /></td></tr>
<tr class="separator:aaabba99bcbca589ec9f8f5d3c85e6b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7e746b8d5c0cd8f53890f046aeceb65" id="r_aa7e746b8d5c0cd8f53890f046aeceb65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa7e746b8d5c0cd8f53890f046aeceb65">tree_only_actions_after_add_edges</a> (const <a class="el" href="namespacelal.html#ab98936b00d896700a71899dff1ed9248">edge_list</a> &amp;e) noexcept</td></tr>
<tr class="memdesc:aa7e746b8d5c0cd8f53890f046aeceb65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do some work after the addition of several edges.  <br /></td></tr>
<tr class="separator:aa7e746b8d5c0cd8f53890f046aeceb65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac759e6c7f4bf5bf2cee25fa274d9d4d5" id="r_ac759e6c7f4bf5bf2cee25fa274d9d4d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac759e6c7f4bf5bf2cee25fa274d9d4d5">tree_only_actions_after_add_edges_bulk</a> () noexcept</td></tr>
<tr class="memdesc:ac759e6c7f4bf5bf2cee25fa274d9d4d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do some work after the addition of several edges in bulk.  <br /></td></tr>
<tr class="separator:ac759e6c7f4bf5bf2cee25fa274d9d4d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ba179a3180253e6eeb62d5b8df22066" id="r_a5ba179a3180253e6eeb62d5b8df22066"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ba179a3180253e6eeb62d5b8df22066">tree_only_actions_after_add_edges_bulk_complete</a> () noexcept</td></tr>
<tr class="memdesc:a5ba179a3180253e6eeb62d5b8df22066"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do some work after the addition of several edges in bulk.  <br /></td></tr>
<tr class="separator:a5ba179a3180253e6eeb62d5b8df22066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a43cfff1504c7ff6bcba9cd03e4743d" id="r_a9a43cfff1504c7ff6bcba9cd03e4743d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9a43cfff1504c7ff6bcba9cd03e4743d">tree_only_actions_after_remove_edges_bulk</a> () noexcept</td></tr>
<tr class="memdesc:a9a43cfff1504c7ff6bcba9cd03e4743d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do some work after the removal of several edges in bulk.  <br /></td></tr>
<tr class="separator:a9a43cfff1504c7ff6bcba9cd03e4743d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d35e95e2d86ec20bcf8609f8f6f6a68" id="r_a3d35e95e2d86ec20bcf8609f8f6f6a68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d35e95e2d86ec20bcf8609f8f6f6a68">tree_only_actions_after_remove_edges_bulk_complete</a> () noexcept</td></tr>
<tr class="memdesc:a3d35e95e2d86ec20bcf8609f8f6f6a68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do some work after the removal of several edges in bulk.  <br /></td></tr>
<tr class="separator:a3d35e95e2d86ec20bcf8609f8f6f6a68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9474e409a3b4feb4c5806ee74c59c8ca" id="r_a9474e409a3b4feb4c5806ee74c59c8ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9474e409a3b4feb4c5806ee74c59c8ca">tree_only_actions_after_remove_edge</a> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u, const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> v) noexcept</td></tr>
<tr class="memdesc:a9474e409a3b4feb4c5806ee74c59c8ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do some work after the removal of an edge.  <br /></td></tr>
<tr class="separator:a9474e409a3b4feb4c5806ee74c59c8ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ff43145e03d8074cbc513e2fe827454" id="r_a5ff43145e03d8074cbc513e2fe827454"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ff43145e03d8074cbc513e2fe827454">tree_only_actions_after_remove_edges</a> (const <a class="el" href="namespacelal.html#ab98936b00d896700a71899dff1ed9248">edge_list</a> &amp;e) noexcept</td></tr>
<tr class="memdesc:a5ff43145e03d8074cbc513e2fe827454"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do some work after the removal of several edges.  <br /></td></tr>
<tr class="separator:a5ff43145e03d8074cbc513e2fe827454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abca6ea36ec8d9b891395aaef69ece840" id="r_abca6ea36ec8d9b891395aaef69ece840"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abca6ea36ec8d9b891395aaef69ece840">tree_only_actions_after_remove_node</a> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u) noexcept</td></tr>
<tr class="memdesc:abca6ea36ec8d9b891395aaef69ece840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do some work before the removal of a vertex.  <br /></td></tr>
<tr class="separator:abca6ea36ec8d9b891395aaef69ece840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76ad30a023ad9b9bd3dd69bb350051ee" id="r_a76ad30a023ad9b9bd3dd69bb350051ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a76ad30a023ad9b9bd3dd69bb350051ee">tree_only_actions_before_remove_edges_incident_to</a> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u) noexcept</td></tr>
<tr class="memdesc:a76ad30a023ad9b9bd3dd69bb350051ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do some work before the removal of all edges incident to a vertex.  <br /></td></tr>
<tr class="separator:a76ad30a023ad9b9bd3dd69bb350051ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee4660ac324fd19a342f2369cf4f796f" id="r_aee4660ac324fd19a342f2369cf4f796f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee4660ac324fd19a342f2369cf4f796f">tree_only_set_edges</a> () noexcept</td></tr>
<tr class="memdesc:aee4660ac324fd19a342f2369cf4f796f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the data structures of a tree after the graph structure has had its set of edges set.  <br /></td></tr>
<tr class="separator:aee4660ac324fd19a342f2369cf4f796f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00d8733492f1bba18638506af2a19d7e" id="r_a00d8733492f1bba18638506af2a19d7e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a00d8733492f1bba18638506af2a19d7e">tree_only_remove_node</a> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u) noexcept</td></tr>
<tr class="memdesc:a00d8733492f1bba18638506af2a19d7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a vertex from the union-find data structure.  <br /></td></tr>
<tr class="separator:a00d8733492f1bba18638506af2a19d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48fd37ac155705661e59e72b61bf9c75" id="r_a48fd37ac155705661e59e72b61bf9c75"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a48fd37ac155705661e59e72b61bf9c75">fill_union_find</a> () noexcept</td></tr>
<tr class="separator:a48fd37ac155705661e59e72b61bf9c75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61b72cd7fb8d43a96ae33436dbb12a35" id="r_a61b72cd7fb8d43a96ae33436dbb12a35"><td class="memItemLeft" align="right" valign="top"><a id="a61b72cd7fb8d43a96ae33436dbb12a35" name="a61b72cd7fb8d43a96ae33436dbb12a35"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>empty_union_find</b> () noexcept</td></tr>
<tr class="memdesc:a61b72cd7fb8d43a96ae33436dbb12a35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empties the Union-Find data structure assuming that the tree has no edges. <br /></td></tr>
<tr class="separator:a61b72cd7fb8d43a96ae33436dbb12a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeab97d916ec9809fa2b03f96960159d" id="r_adeab97d916ec9809fa2b03f96960159d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adeab97d916ec9809fa2b03f96960159d">update_union_find_after_add_edge</a> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u, const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> v, uint64_t *const root_of, uint64_t *const root_size) const noexcept=0</td></tr>
<tr class="memdesc:adeab97d916ec9809fa2b03f96960159d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the union find data structure after an edge addition.  <br /></td></tr>
<tr class="separator:adeab97d916ec9809fa2b03f96960159d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f932ae19c2eed5740cb12cca2efd7ee" id="r_a1f932ae19c2eed5740cb12cca2efd7ee"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f932ae19c2eed5740cb12cca2efd7ee">update_union_find_after_add_edges</a> (const <a class="el" href="namespacelal.html#ab98936b00d896700a71899dff1ed9248">edge_list</a> &amp;edges, uint64_t *const root_of, uint64_t *const root_size) const noexcept=0</td></tr>
<tr class="memdesc:a1f932ae19c2eed5740cb12cca2efd7ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the union find data structure after the addition of a set of edges.  <br /></td></tr>
<tr class="separator:a1f932ae19c2eed5740cb12cca2efd7ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aded95ef5a07fcbeface887f28e8b897d" id="r_aded95ef5a07fcbeface887f28e8b897d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aded95ef5a07fcbeface887f28e8b897d">update_union_find_after_add_edges_bulk</a> (uint64_t *const root_of, uint64_t *const root_size) const noexcept=0</td></tr>
<tr class="memdesc:aded95ef5a07fcbeface887f28e8b897d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the union find data structure after the addition of several edges.  <br /></td></tr>
<tr class="separator:aded95ef5a07fcbeface887f28e8b897d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a131a43d6c944ccc29b46b930818a2c52" id="r_a131a43d6c944ccc29b46b930818a2c52"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a131a43d6c944ccc29b46b930818a2c52">update_union_find_after_remove_edges_bulk</a> (uint64_t *const root_of, uint64_t *const root_size) const noexcept=0</td></tr>
<tr class="memdesc:a131a43d6c944ccc29b46b930818a2c52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the union find data structure after the removal of several edges.  <br /></td></tr>
<tr class="separator:a131a43d6c944ccc29b46b930818a2c52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca432e67b4dd7fd49392f8afd53fed83" id="r_aca432e67b4dd7fd49392f8afd53fed83"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aca432e67b4dd7fd49392f8afd53fed83">update_union_find_after_remove_edge</a> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u, const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> v, uint64_t *const root_of, uint64_t *const root_size) const noexcept=0</td></tr>
<tr class="memdesc:aca432e67b4dd7fd49392f8afd53fed83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the union find data structure after an edge removal.  <br /></td></tr>
<tr class="separator:aca432e67b4dd7fd49392f8afd53fed83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec260049cf754a19ba9258d812cab80a" id="r_aec260049cf754a19ba9258d812cab80a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aec260049cf754a19ba9258d812cab80a">update_union_find_after_remove_edges</a> (const <a class="el" href="namespacelal.html#ab98936b00d896700a71899dff1ed9248">edge_list</a> &amp;edges, uint64_t *const root_of, uint64_t *const root_size) const noexcept=0</td></tr>
<tr class="memdesc:aec260049cf754a19ba9258d812cab80a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the union find data structure after the removal of a set of edges.  <br /></td></tr>
<tr class="separator:aec260049cf754a19ba9258d812cab80a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ea87b62eceaadd99d9f1d5fba4856d9" id="r_a9ea87b62eceaadd99d9f1d5fba4856d9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ea87b62eceaadd99d9f1d5fba4856d9">update_union_find_before_remove_incident_edges_to</a> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u, uint64_t *const root_of, uint64_t *const root_size) const noexcept=0</td></tr>
<tr class="memdesc:a9ea87b62eceaadd99d9f1d5fba4856d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the union find data structure before the removal of all edges incident to a node.  <br /></td></tr>
<tr class="separator:a9ea87b62eceaadd99d9f1d5fba4856d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad95568f8b3a8ac76edfabd8581fa455" id="r_aad95568f8b3a8ac76edfabd8581fa455"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1graph.html#aad95568f8b3a8ac76edfabd8581fa455">_init</a> (const uint64_t n) noexcept</td></tr>
<tr class="memdesc:aad95568f8b3a8ac76edfabd8581fa455"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes memory of <a class="el" href="classlal_1_1graphs_1_1graph.html">graph</a> class.  <br /></td></tr>
<tr class="separator:aad95568f8b3a8ac76edfabd8581fa455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e650acae6ec4cf32e74670676455368" id="r_a6e650acae6ec4cf32e74670676455368"><td class="memItemLeft" align="right" valign="top"><a id="a6e650acae6ec4cf32e74670676455368" name="a6e650acae6ec4cf32e74670676455368"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>_clear</b> () noexcept</td></tr>
<tr class="memdesc:a6e650acae6ec4cf32e74670676455368"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears memory for the <a class="el" href="classlal_1_1graphs_1_1graph.html">graph</a> class. <br /></td></tr>
<tr class="separator:a6e650acae6ec4cf32e74670676455368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ea60f01e9535ae965e54b9caa3d08fd" id="r_a0ea60f01e9535ae965e54b9caa3d08fd"><td class="memItemLeft" align="right" valign="top"><a id="a0ea60f01e9535ae965e54b9caa3d08fd" name="a0ea60f01e9535ae965e54b9caa3d08fd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>copy_full_graph</b> (const <a class="el" href="classlal_1_1graphs_1_1graph.html">graph</a> &amp;g) noexcept</td></tr>
<tr class="memdesc:a0ea60f01e9535ae965e54b9caa3d08fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies all members of this class. <br /></td></tr>
<tr class="separator:a0ea60f01e9535ae965e54b9caa3d08fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca19fcaa6d290a97c92ef95df92160ae" id="r_aca19fcaa6d290a97c92ef95df92160ae"><td class="memItemLeft" align="right" valign="top"><a id="aca19fcaa6d290a97c92ef95df92160ae" name="aca19fcaa6d290a97c92ef95df92160ae"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>move_full_graph</b> (<a class="el" href="classlal_1_1graphs_1_1graph.html">graph</a> &amp;&amp;g) noexcept</td></tr>
<tr class="memdesc:aca19fcaa6d290a97c92ef95df92160ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves all members of this class. <br /></td></tr>
<tr class="separator:aca19fcaa6d290a97c92ef95df92160ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb30bc5c7c927a2b32c2db7e0fcfeeee" id="r_aeb30bc5c7c927a2b32c2db7e0fcfeeee"><td class="memItemLeft" align="right" valign="top"><a id="aeb30bc5c7c927a2b32c2db7e0fcfeeee" name="aeb30bc5c7c927a2b32c2db7e0fcfeeee"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>__add_node</b> () noexcept</td></tr>
<tr class="memdesc:aeb30bc5c7c927a2b32c2db7e0fcfeeee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a node to the graph. <br /></td></tr>
<tr class="separator:aeb30bc5c7c927a2b32c2db7e0fcfeeee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2953c51682d770519cac771dc26c77ee" id="r_a2953c51682d770519cac771dc26c77ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1graph.html#a2953c51682d770519cac771dc26c77ee">__disjoint_union</a> (const <a class="el" href="classlal_1_1graphs_1_1graph.html">graph</a> &amp;g) noexcept</td></tr>
<tr class="memdesc:a2953c51682d770519cac771dc26c77ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disjoint union of graphs.  <br /></td></tr>
<tr class="separator:a2953c51682d770519cac771dc26c77ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82d1dd3ec710c4ccf60100298a6cb5a1" id="r_a82d1dd3ec710c4ccf60100298a6cb5a1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1graph.html#a82d1dd3ec710c4ccf60100298a6cb5a1">actions_after_add_edge</a> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u, const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> v) noexcept</td></tr>
<tr class="memdesc:a82d1dd3ec710c4ccf60100298a6cb5a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do some extra work after the addition of an edge.  <br /></td></tr>
<tr class="separator:a82d1dd3ec710c4ccf60100298a6cb5a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0f77ff1a0513b0d2edd30e443e21a66" id="r_ac0f77ff1a0513b0d2edd30e443e21a66"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1graph.html#ac0f77ff1a0513b0d2edd30e443e21a66">actions_after_add_edges</a> (const <a class="el" href="namespacelal.html#ab98936b00d896700a71899dff1ed9248">edge_list</a> &amp;e) noexcept</td></tr>
<tr class="memdesc:ac0f77ff1a0513b0d2edd30e443e21a66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do some extra work after the addition of several edges.  <br /></td></tr>
<tr class="separator:ac0f77ff1a0513b0d2edd30e443e21a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90f34e52de222e529126803ee46be312" id="r_a90f34e52de222e529126803ee46be312"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1graph.html#a90f34e52de222e529126803ee46be312">actions_after_add_edges_bulk</a> () noexcept</td></tr>
<tr class="memdesc:a90f34e52de222e529126803ee46be312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do some extra work after the addition of several edges in bulk.  <br /></td></tr>
<tr class="separator:a90f34e52de222e529126803ee46be312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98d5b515434333420d3c0383118a40e9" id="r_a98d5b515434333420d3c0383118a40e9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1graph.html#a98d5b515434333420d3c0383118a40e9">actions_after_remove_edge</a> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u, const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> v) noexcept</td></tr>
<tr class="memdesc:a98d5b515434333420d3c0383118a40e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do some extra work after the removal of an edge.  <br /></td></tr>
<tr class="separator:a98d5b515434333420d3c0383118a40e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a956070ceaa53f3f27782e93ee789b52d" id="r_a956070ceaa53f3f27782e93ee789b52d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1graph.html#a956070ceaa53f3f27782e93ee789b52d">actions_after_remove_edges</a> (const <a class="el" href="namespacelal.html#ab98936b00d896700a71899dff1ed9248">edge_list</a> &amp;e) noexcept</td></tr>
<tr class="memdesc:a956070ceaa53f3f27782e93ee789b52d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do some extra work after the removal of several edges.  <br /></td></tr>
<tr class="separator:a956070ceaa53f3f27782e93ee789b52d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0652eaa93e528addf994e0a387c89a3" id="r_af0652eaa93e528addf994e0a387c89a3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1graph.html#af0652eaa93e528addf994e0a387c89a3">actions_after_remove_edges_bulk</a> () noexcept</td></tr>
<tr class="memdesc:af0652eaa93e528addf994e0a387c89a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do some extra work after the removal of several edges in bulk.  <br /></td></tr>
<tr class="separator:af0652eaa93e528addf994e0a387c89a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c27b3db924121cb7c8f739c79de1c81" id="r_a9c27b3db924121cb7c8f739c79de1c81"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1graph.html#a9c27b3db924121cb7c8f739c79de1c81">actions_before_remove_edges_incident_to</a> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u) noexcept</td></tr>
<tr class="memdesc:a9c27b3db924121cb7c8f739c79de1c81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do some work before all edges incident to a node is removed.  <br /></td></tr>
<tr class="separator:a9c27b3db924121cb7c8f739c79de1c81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace7b6a4bfae204ead0ef1a79d4bff84a" id="r_ace7b6a4bfae204ead0ef1a79d4bff84a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1graph.html#ace7b6a4bfae204ead0ef1a79d4bff84a">actions_after_remove_node</a> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u) noexcept</td></tr>
<tr class="memdesc:ace7b6a4bfae204ead0ef1a79d4bff84a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do some work before the removal of a vertex.  <br /></td></tr>
<tr class="separator:ace7b6a4bfae204ead0ef1a79d4bff84a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a697a6199daaf909ae4d4f00ef70768b9" id="r_a697a6199daaf909ae4d4f00ef70768b9"><td class="memItemLeft" align="right" valign="top"><a id="a697a6199daaf909ae4d4f00ef70768b9" name="a697a6199daaf909ae4d4f00ef70768b9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>normalize_after_edge_addition</b> (const bool norm, const bool check) noexcept</td></tr>
<tr class="memdesc:a697a6199daaf909ae4d4f00ef70768b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize the graph after one (or more) edges have been added. <br /></td></tr>
<tr class="separator:a697a6199daaf909ae4d4f00ef70768b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31aee9e64b4839cb154c843c92c52507" id="r_a31aee9e64b4839cb154c843c92c52507"><td class="memItemLeft" align="right" valign="top"><a id="a31aee9e64b4839cb154c843c92c52507" name="a31aee9e64b4839cb154c843c92c52507"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>normalize_after_edge_removal</b> (const bool norm, const bool check) noexcept</td></tr>
<tr class="memdesc:a31aee9e64b4839cb154c843c92c52507"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize the graph after one (or more) edges have been removed. <br /></td></tr>
<tr class="separator:a31aee9e64b4839cb154c843c92c52507"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ac0be40a4f9c7df1eb2dcbbe7b417ce73" id="r_ac0be40a4f9c7df1eb2dcbbe7b417ce73"><td class="memItemLeft" align="right" valign="top"><a id="ac0be40a4f9c7df1eb2dcbbe7b417ce73" name="ac0be40a4f9c7df1eb2dcbbe7b417ce73"></a>
std::vector&lt; <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_union_find__root_of</b></td></tr>
<tr class="memdesc:ac0be40a4f9c7df1eb2dcbbe7b417ce73"><td class="mdescLeft">&#160;</td><td class="mdescRight">The root of every vertex in the union-find data structure. <br /></td></tr>
<tr class="separator:ac0be40a4f9c7df1eb2dcbbe7b417ce73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11bb51b8c210daa43ad5bf6d11bfd35f" id="r_a11bb51b8c210daa43ad5bf6d11bfd35f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a11bb51b8c210daa43ad5bf6d11bfd35f">m_union_find__root_size</a></td></tr>
<tr class="memdesc:a11bb51b8c210daa43ad5bf6d11bfd35f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of the connected component that a <em>root</em> belongs to.  <br /></td></tr>
<tr class="separator:a11bb51b8c210daa43ad5bf6d11bfd35f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac27ba83912b248cd1160e0c6a0147b35" id="r_ac27ba83912b248cd1160e0c6a0147b35"><td class="memItemLeft" align="right" valign="top"><a id="ac27ba83912b248cd1160e0c6a0147b35" name="ac27ba83912b248cd1160e0c6a0147b35"></a>
std::array&lt; bool, <a class="el" href="namespacelal_1_1graphs.html#a1895a9ed855ad1d85cd9510de714a732">__tree_type_size</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_tree_type</b></td></tr>
<tr class="memdesc:ac27ba83912b248cd1160e0c6a0147b35"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of this tree. <br /></td></tr>
<tr class="separator:ac27ba83912b248cd1160e0c6a0147b35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a951a57e760385ce3de285089627b7bbb" id="r_a951a57e760385ce3de285089627b7bbb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a951a57e760385ce3de285089627b7bbb">m_is_tree_type_valid</a> = false</td></tr>
<tr class="memdesc:a951a57e760385ce3de285089627b7bbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the type of this tree valid?  <br /></td></tr>
<tr class="separator:a951a57e760385ce3de285089627b7bbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad87c640988218838def15ea96645bb84" id="r_ad87c640988218838def15ea96645bb84"><td class="memItemLeft" align="right" valign="top"><a id="ad87c640988218838def15ea96645bb84" name="ad87c640988218838def15ea96645bb84"></a>
std::vector&lt; <a class="el" href="namespacelal.html#aef91d923414879a998619e9c65181d1f">neighbourhood</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_adjacency_list</b></td></tr>
<tr class="memdesc:ad87c640988218838def15ea96645bb84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure that implements the graph. <br /></td></tr>
<tr class="separator:ad87c640988218838def15ea96645bb84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a028261ff75ed8e624f4f3fee4e3c5c06" id="r_a028261ff75ed8e624f4f3fee4e3c5c06"><td class="memItemLeft" align="right" valign="top"><a id="a028261ff75ed8e624f4f3fee4e3c5c06" name="a028261ff75ed8e624f4f3fee4e3c5c06"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>m_num_edges</b> = 0</td></tr>
<tr class="memdesc:a028261ff75ed8e624f4f3fee4e3c5c06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Amount of edges of this graph. <br /></td></tr>
<tr class="separator:a028261ff75ed8e624f4f3fee4e3c5c06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a427d63b1bef991f43db8f5d622567bb6" id="r_a427d63b1bef991f43db8f5d622567bb6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1graphs_1_1graph.html#a427d63b1bef991f43db8f5d622567bb6">m_is_normalized</a> = true</td></tr>
<tr class="memdesc:a427d63b1bef991f43db8f5d622567bb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this graph normalized?  <br /></td></tr>
<tr class="separator:a427d63b1bef991f43db8f5d622567bb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Tree graph class. </p>
<p>This is an abstract class for those tree-like graphs. Classes that implement different abstractions of trees and that inherit from this class are: <a class="el" href="classlal_1_1graphs_1_1free__tree.html">free_tree</a>, <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">rooted_tree</a>.</p>
<p>In these classes the addition of edges is constrained so as to ensure that the edges added actually yield trees, i.e., that cycles are never produced. For the sake of efficiency, only debug compilations of the library (compilations where the DEBUG symbol is defined) check that such additions do not produce cycles. In case of doubt, one can query the class using methods <a class="el" href="#a3003f7649ef64924ff688a6f30d67b26">can_add_edge</a> or <a class="el" href="#a6d52f3c3edace3159f0cf5e31631dd63">can_add_edges</a> prior to adding one or several edges. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a1455a41bdb8a6e4c638e3468ea457c7d" name="a1455a41bdb8a6e4c638e3468ea457c7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1455a41bdb8a6e4c638e3468ea457c7d">&#9670;&#160;</a></span>tree() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">lal::graphs::tree::tree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1tree.html">tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Tree. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac67c5d26096ec29c46cca22b9d7b61dd" name="ac67c5d26096ec29c46cca22b9d7b61dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac67c5d26096ec29c46cca22b9d7b61dd">&#9670;&#160;</a></span>tree() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">lal::graphs::tree::tree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlal_1_1graphs_1_1tree.html">tree</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Tree. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a2953c51682d770519cac771dc26c77ee" name="a2953c51682d770519cac771dc26c77ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2953c51682d770519cac771dc26c77ee">&#9670;&#160;</a></span>__disjoint_union()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::graph::__disjoint_union </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1graph.html">graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disjoint union of graphs. </p>
<p>Given a graph, append it to the current graph.</p>
<p>All the nodes in <em>g</em> are relabelled starting at <em>n</em>, the number of nodes of the current graph. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>This graph and <em>g</em> must be of the same type (both must be either undirected, or both directed). </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The graph is normalized only if it was normalized before the call and <em>g</em> is also normalized. </dd></dl>

</div>
</div>
<a id="aad95568f8b3a8ac76edfabd8581fa455" name="aad95568f8b3a8ac76edfabd8581fa455"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad95568f8b3a8ac76edfabd8581fa455">&#9670;&#160;</a></span>_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void lal::graphs::graph::_init </td>
          <td>(</td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes memory of <a class="el" href="classlal_1_1graphs_1_1graph.html">graph</a> class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of nodes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The graph is cleared. </dd></dl>

<p>Reimplemented in <a class="el" href="classlal_1_1graphs_1_1directed__graph.html#a3d94bc0b0b7d824c714e6980ddc5f6de">lal::graphs::directed_graph</a>, <a class="el" href="classlal_1_1graphs_1_1free__tree.html#a834869efb91c33eaacf6f54b59a6ce4b">lal::graphs::free_tree</a>, <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#ae644f013789ff98bcb57284059f89738">lal::graphs::rooted_tree</a>, and <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html#a68f60ab36b8ce7d6d1d0550f7f0ef419">lal::graphs::undirected_graph</a>.</p>

</div>
</div>
<a id="a82d1dd3ec710c4ccf60100298a6cb5a1" name="a82d1dd3ec710c4ccf60100298a6cb5a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82d1dd3ec710c4ccf60100298a6cb5a1">&#9670;&#160;</a></span>actions_after_add_edge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void lal::graphs::graph::actions_after_add_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do some extra work after the addition of an edge. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>Node of the edge </td></tr>
    <tr><td class="paramname">v</td><td>Node of the edge </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classlal_1_1graphs_1_1directed__graph.html#ac0cf22c45fc8d6a3c5cd29e00af7b9df">lal::graphs::directed_graph</a>, <a class="el" href="classlal_1_1graphs_1_1free__tree.html#ad637389b022aecfffce81b710e137dd5">lal::graphs::free_tree</a>, <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#a1b6c5b10032d6486657af65fa1efb469">lal::graphs::rooted_tree</a>, and <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html#a892f5505b799244d64c5efb6a4497010">lal::graphs::undirected_graph</a>.</p>

</div>
</div>
<a id="ac0f77ff1a0513b0d2edd30e443e21a66" name="ac0f77ff1a0513b0d2edd30e443e21a66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0f77ff1a0513b0d2edd30e443e21a66">&#9670;&#160;</a></span>actions_after_add_edges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void lal::graphs::graph::actions_after_add_edges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ab98936b00d896700a71899dff1ed9248">edge_list</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do some extra work after the addition of several edges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>List of edges. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classlal_1_1graphs_1_1directed__graph.html#a20e37ab891e53364f706f157695eda33">lal::graphs::directed_graph</a>, <a class="el" href="classlal_1_1graphs_1_1free__tree.html#aae1e7163c22e6f02cbe4a54f47d0d946">lal::graphs::free_tree</a>, <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#a43f819b53ca12050c9afd4f7876706ae">lal::graphs::rooted_tree</a>, and <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html#a68b3a367f35aee84177601b20af4b5e0">lal::graphs::undirected_graph</a>.</p>

</div>
</div>
<a id="a90f34e52de222e529126803ee46be312" name="a90f34e52de222e529126803ee46be312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90f34e52de222e529126803ee46be312">&#9670;&#160;</a></span>actions_after_add_edges_bulk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void lal::graphs::graph::actions_after_add_edges_bulk </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do some extra work after the addition of several edges in bulk. </p>
<p>This method should only be called after several calls to <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html#a3d9454ddfaef55219be3ef00ecac1189">undirected_graph::add_edge_bulk</a> or <a class="el" href="classlal_1_1graphs_1_1directed__graph.html#a2867b035b48ab54df5f60e3b065fea66">directed_graph::add_edge_bulk</a>. </p>

<p>Reimplemented in <a class="el" href="classlal_1_1graphs_1_1directed__graph.html#a39ea733e148d29496a6db24189788d1d">lal::graphs::directed_graph</a>, <a class="el" href="classlal_1_1graphs_1_1free__tree.html#a8461c8de4b20b5409c71fbb59191e0fe">lal::graphs::free_tree</a>, <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#a1c44f4a3b405b2140a21d221b85ab790">lal::graphs::rooted_tree</a>, and <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html#a1999da251b87ba0cf89c3734fb312464">lal::graphs::undirected_graph</a>.</p>

</div>
</div>
<a id="a98d5b515434333420d3c0383118a40e9" name="a98d5b515434333420d3c0383118a40e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98d5b515434333420d3c0383118a40e9">&#9670;&#160;</a></span>actions_after_remove_edge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void lal::graphs::graph::actions_after_remove_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do some extra work after the removal of an edge. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>Node of the edge </td></tr>
    <tr><td class="paramname">v</td><td>Node of the edge </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classlal_1_1graphs_1_1directed__graph.html#a2fb2e27dacaed104276a13e7024cffc9">lal::graphs::directed_graph</a>, <a class="el" href="classlal_1_1graphs_1_1free__tree.html#ac685ef6b44a13076355650f03dc93f46">lal::graphs::free_tree</a>, <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#a7a11bc77f5a58f731d76e51f013b8195">lal::graphs::rooted_tree</a>, and <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html#aa7aa01ad675c78f3f50ffa654cd2cb39">lal::graphs::undirected_graph</a>.</p>

</div>
</div>
<a id="a956070ceaa53f3f27782e93ee789b52d" name="a956070ceaa53f3f27782e93ee789b52d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a956070ceaa53f3f27782e93ee789b52d">&#9670;&#160;</a></span>actions_after_remove_edges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void lal::graphs::graph::actions_after_remove_edges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ab98936b00d896700a71899dff1ed9248">edge_list</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do some extra work after the removal of several edges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>List of edges. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classlal_1_1graphs_1_1directed__graph.html#af60a3b6149315d98468c34fc144d93a1">lal::graphs::directed_graph</a>, <a class="el" href="classlal_1_1graphs_1_1free__tree.html#a6a03891f968291167724f60de603e767">lal::graphs::free_tree</a>, <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#a87f919e3637ce545101bd901ebf71a13">lal::graphs::rooted_tree</a>, and <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html#a03a1ef7f25893f4010a233e168b68233">lal::graphs::undirected_graph</a>.</p>

</div>
</div>
<a id="af0652eaa93e528addf994e0a387c89a3" name="af0652eaa93e528addf994e0a387c89a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0652eaa93e528addf994e0a387c89a3">&#9670;&#160;</a></span>actions_after_remove_edges_bulk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void lal::graphs::graph::actions_after_remove_edges_bulk </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do some extra work after the removal of several edges in bulk. </p>
<p>This method should only be called after several calls to <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html#a741081cc0646053bcb5fd5809eb19a21">undirected_graph::remove_edge_bulk</a> or <a class="el" href="classlal_1_1graphs_1_1directed__graph.html#a655fbacfd749a62e61933ae19cb647cb">directed_graph::remove_edge_bulk</a>. </p>

<p>Reimplemented in <a class="el" href="classlal_1_1graphs_1_1directed__graph.html#a89d0c4e8dff527470d7ea96f75726756">lal::graphs::directed_graph</a>, <a class="el" href="classlal_1_1graphs_1_1free__tree.html#afe4b5655d3f16c3956e15e75be0ffd46">lal::graphs::free_tree</a>, <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#a5948c8e20e5feda6ae81e91a7b57be0e">lal::graphs::rooted_tree</a>, and <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html#a57bee07b192b3d56b6404f4752fd0e48">lal::graphs::undirected_graph</a>.</p>

</div>
</div>
<a id="ace7b6a4bfae204ead0ef1a79d4bff84a" name="ace7b6a4bfae204ead0ef1a79d4bff84a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace7b6a4bfae204ead0ef1a79d4bff84a">&#9670;&#160;</a></span>actions_after_remove_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void lal::graphs::graph::actions_after_remove_node </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do some work before the removal of a vertex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>Node to be removed. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classlal_1_1graphs_1_1directed__graph.html#a703e14070ff7eae72ddc3a4307344605">lal::graphs::directed_graph</a>, <a class="el" href="classlal_1_1graphs_1_1free__tree.html#ad9db64c2be7a1ed6ba273e505fc3d416">lal::graphs::free_tree</a>, <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#a254e29f4c623d83fd3a67738d4ed8068">lal::graphs::rooted_tree</a>, and <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html#a6749200d0a8cc8abe74a762e62036682">lal::graphs::undirected_graph</a>.</p>

</div>
</div>
<a id="a9c27b3db924121cb7c8f739c79de1c81" name="a9c27b3db924121cb7c8f739c79de1c81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c27b3db924121cb7c8f739c79de1c81">&#9670;&#160;</a></span>actions_before_remove_edges_incident_to()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void lal::graphs::graph::actions_before_remove_edges_incident_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do some work before all edges incident to a node is removed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>Node whose incident edges are to be removed. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classlal_1_1graphs_1_1directed__graph.html#afc7874bcad8a4ff2c3059b054f2e863b">lal::graphs::directed_graph</a>, <a class="el" href="classlal_1_1graphs_1_1free__tree.html#a738efff66b5dc7d22b82c2fa3089f113">lal::graphs::free_tree</a>, <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#a02bc84af2dd2eb64d4eac9b21038100d">lal::graphs::rooted_tree</a>, and <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html#a16e9a32f29eb84ffc36fa246f0eb3996">lal::graphs::undirected_graph</a>.</p>

</div>
</div>
<a id="a680f3d15750907dfd5183ec76b5fa7f8" name="a680f3d15750907dfd5183ec76b5fa7f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a680f3d15750907dfd5183ec76b5fa7f8">&#9670;&#160;</a></span>are_nodes_in_same_component()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::graphs::tree::are_nodes_in_same_component </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if two nodes are in the same connected component. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>First node. </td></tr>
    <tr><td class="paramname">v</td><td>Second node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True or false. </dd></dl>

</div>
</div>
<a id="aa8a453d924452a46b781f1cf6bfb8360" name="aa8a453d924452a46b781f1cf6bfb8360"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8a453d924452a46b781f1cf6bfb8360">&#9670;&#160;</a></span>calculate_tree_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void lal::graphs::tree::calculate_tree_type </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the type of tree. </p>
<p>See <a class="el" href="namespacelal_1_1graphs.html#a18d52542088507e2be6241759722835b">tree_type</a> for the list of different tree types. </p>

<p>Implemented in <a class="el" href="classlal_1_1graphs_1_1free__tree.html#a2355fb9491fe13bf32b32dd44d472977">lal::graphs::free_tree</a>, and <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#aaaa55acc91cddcd44f95419b83706ae9">lal::graphs::rooted_tree</a>.</p>

</div>
</div>
<a id="a3003f7649ef64924ff688a6f30d67b26" name="a3003f7649ef64924ff688a6f30d67b26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3003f7649ef64924ff688a6f30d67b26">&#9670;&#160;</a></span>can_add_edge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool lal::graphs::tree::can_add_edge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> const</td>          <td class="paramname"><span class="paramname"><em>s</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Can this edge be added? </p>
<p>In a tree, an edge can only be added if it does not produce cycles, and it has not been added before.</p>
<p>In a rooted tree, an edge can only be added if the in-degree of vertex <em>t</em> (see <a class="el" href="classlal_1_1graphs_1_1directed__graph.html#aad08168cf9fd02b362013916bf308210">directed_graph::get_in_degree</a>) is exactly 1 after adding the edge. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>First node of the edge. </td></tr>
    <tr><td class="paramname">t</td><td>Second node of the edge. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not this edge can be added to the tree without producing cycles. </dd></dl>

<p>Reimplemented in <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#a273d4cd55ab0ed2b35891f00b74a5e92">lal::graphs::rooted_tree</a>.</p>

</div>
</div>
<a id="a6d52f3c3edace3159f0cf5e31631dd63" name="a6d52f3c3edace3159f0cf5e31631dd63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d52f3c3edace3159f0cf5e31631dd63">&#9670;&#160;</a></span>can_add_edges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool lal::graphs::tree::can_add_edges </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacelal.html#a5969ec7ecc85697ebb9ec0ace78fbcab">edge</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>edges</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Can these edges be added? </p>
<p>In a tree, a set of edges can only be added if their addition to the tree do not produce cycles and none of them have been added before.</p>
<p>In a rooted tree, edges \((s,t)\) can only be added if the in-degree of vertex <em>t</em> (see <a class="el" href="classlal_1_1graphs_1_1directed__graph.html#aad08168cf9fd02b362013916bf308210">directed_graph::get_in_degree</a>) is exactly 1 after adding the edge. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edges</td><td>List of edges. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not these edges can be added to the tree without producing cycles. </dd></dl>

<p>Reimplemented in <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#ac66708cc747974506d27201655fa78bb">lal::graphs::rooted_tree</a>.</p>

</div>
</div>
<a id="a0beca99dbbaa1a1a27db6c4e2d280ea5" name="a0beca99dbbaa1a1a27db6c4e2d280ea5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0beca99dbbaa1a1a27db6c4e2d280ea5">&#9670;&#160;</a></span>check_normalized()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool lal::graphs::graph::check_normalized </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the graph is normalized. </p>
<p>Checks, whether the graph's adjacency structure is normalized or not. In case it is, attribute <a class="el" href="classlal_1_1graphs_1_1graph.html#a427d63b1bef991f43db8f5d622567bb6">m_is_normalized</a> is set to true, so method <a class="el" href="classlal_1_1graphs_1_1graph.html#abb9238eb8914e145736f1ac914f6b9d6">is_normalized</a> evaluates to true. </p>

<p>Reimplemented in <a class="el" href="classlal_1_1graphs_1_1directed__graph.html#a23b10c47032b774696a5ed970b059cdb">lal::graphs::directed_graph</a>.</p>

</div>
</div>
<a id="af8ba9ec6acf2306c84d9ddbd88fc8474" name="af8ba9ec6acf2306c84d9ddbd88fc8474"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8ba9ec6acf2306c84d9ddbd88fc8474">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void lal::graphs::graph::clear </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Frees the memory occupied by this graph. </p>
<p>See <a class="el" href="classlal_1_1graphs_1_1graph.html#a6e650acae6ec4cf32e74670676455368">_clear</a> for details. </p><dl class="section post"><dt>Postcondition</dt><dd>The graph is normalized. The number of edges is 0. </dd></dl>

</div>
</div>
<a id="a48fd37ac155705661e59e72b61bf9c75" name="a48fd37ac155705661e59e72b61bf9c75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48fd37ac155705661e59e72b61bf9c75">&#9670;&#160;</a></span>fill_union_find()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::tree::fill_union_find </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fills the Union-Find data structure assuming that the graph structure has all of its edges. </p>

</div>
</div>
<a id="af01a3a104e9b5b62ef385df4cb6a1bff" name="af01a3a104e9b5b62ef385df4cb6a1bff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af01a3a104e9b5b62ef385df4cb6a1bff">&#9670;&#160;</a></span>finish_bulk_add()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void lal::graphs::graph::finish_bulk_add </td>
          <td>(</td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>norm</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>check</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Completes the inner structure of the graph after adding a bulk of edges. </p>
<p>This is meant to be used after several calls to <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html#a3d9454ddfaef55219be3ef00ecac1189">undirected_graph::add_edge_bulk</a>, <a class="el" href="classlal_1_1graphs_1_1directed__graph.html#a2867b035b48ab54df5f60e3b065fea66">directed_graph::add_edge_bulk</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">norm</td><td>Normalize the graph. </td></tr>
    <tr><td class="paramname">check</td><td>Check wether the graph is normalized or not. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classlal_1_1graphs_1_1directed__graph.html#a21efb8e78ed211739b6d355bbfd29ad6">lal::graphs::directed_graph</a>, <a class="el" href="classlal_1_1graphs_1_1free__tree.html#a48ab9fe44eb2b9036039b4f0fb33a685">lal::graphs::free_tree</a>, <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#a01453a5f86572b1d6097cf9a1067e73c">lal::graphs::rooted_tree</a>, and <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html#a142e4c654924866732561edb7e91264e">lal::graphs::undirected_graph</a>.</p>

</div>
</div>
<a id="ab3b9064bc1a7dbf90dfd72dba20073af" name="ab3b9064bc1a7dbf90dfd72dba20073af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3b9064bc1a7dbf90dfd72dba20073af">&#9670;&#160;</a></span>finish_bulk_add_complete()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void lal::graphs::tree::finish_bulk_add_complete </td>
          <td>(</td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>norm</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>check</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Completes the inner structure of the tree after adding edges in bulk. </p>
<p>This is meant to be used after several calls to <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html#a3d9454ddfaef55219be3ef00ecac1189">undirected_graph::add_edge_bulk</a>, <a class="el" href="classlal_1_1graphs_1_1directed__graph.html#a2867b035b48ab54df5f60e3b065fea66">directed_graph::add_edge_bulk</a>.</p>
<p>This method completes the Union-Find data structure and the other necessary members assuming that the tree is now complete. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">norm</td><td>Normalize the graph. </td></tr>
    <tr><td class="paramname">check</td><td>Check wether the graph is normalized or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>All edges have been added with method <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html#a3d9454ddfaef55219be3ef00ecac1189">undirected_graph::add_edge_bulk</a> or <a class="el" href="classlal_1_1graphs_1_1directed__graph.html#a2867b035b48ab54df5f60e3b065fea66">directed_graph::add_edge_bulk</a>. </dd></dl>

<p>Implemented in <a class="el" href="classlal_1_1graphs_1_1free__tree.html#ae20ce18132c9884906b80acdb2623a94">lal::graphs::free_tree</a>, and <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#a57459861c9e1917d66b11f1515acdcaa">lal::graphs::rooted_tree</a>.</p>

</div>
</div>
<a id="a3887a16f8193383c971bef9c35b6b700" name="a3887a16f8193383c971bef9c35b6b700"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3887a16f8193383c971bef9c35b6b700">&#9670;&#160;</a></span>finish_bulk_remove()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void lal::graphs::graph::finish_bulk_remove </td>
          <td>(</td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>norm</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>check</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Completes the inner structure of the graph after removing edges in bulk. </p>
<p>This is meant to be used after several calls to <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html#a741081cc0646053bcb5fd5809eb19a21">undirected_graph::remove_edge_bulk</a>, <a class="el" href="classlal_1_1graphs_1_1directed__graph.html#a655fbacfd749a62e61933ae19cb647cb">directed_graph::remove_edge_bulk</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">norm</td><td>Normalize the graph. </td></tr>
    <tr><td class="paramname">check</td><td>Check wether the graph is normalized or not. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classlal_1_1graphs_1_1directed__graph.html#a890ef15b90aefcda8c6aba36f48a6f8e">lal::graphs::directed_graph</a>, <a class="el" href="classlal_1_1graphs_1_1free__tree.html#a37d87ca40ee7ee9b130f670cd582ed50">lal::graphs::free_tree</a>, <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#aa6a62c89130506333d5a7edd221ec5fd">lal::graphs::rooted_tree</a>, and <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html#ae6e8be3e2559490ac11d2e0f9561243e">lal::graphs::undirected_graph</a>.</p>

</div>
</div>
<a id="aed5dea71acee5dff70ae746de0fafcc9" name="aed5dea71acee5dff70ae746de0fafcc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed5dea71acee5dff70ae746de0fafcc9">&#9670;&#160;</a></span>finish_bulk_remove_complete()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void lal::graphs::tree::finish_bulk_remove_complete </td>
          <td>(</td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>norm</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>check</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Completes the inner structure of the tree after removing edges in bulk. </p>
<p>This is meant to be used after several calls to <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html#a741081cc0646053bcb5fd5809eb19a21">undirected_graph::remove_edge_bulk</a>, <a class="el" href="classlal_1_1graphs_1_1directed__graph.html#a655fbacfd749a62e61933ae19cb647cb">directed_graph::remove_edge_bulk</a>.</p>
<p>This method completes the Union-Find data structure and the other necessary members assuming that the tree is now empty. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">norm</td><td>Normalize the graph. </td></tr>
    <tr><td class="paramname">check</td><td>Check wether the graph is normalized or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>All edges have been added with method <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html#a741081cc0646053bcb5fd5809eb19a21">undirected_graph::remove_edge_bulk</a> or <a class="el" href="classlal_1_1graphs_1_1directed__graph.html#a655fbacfd749a62e61933ae19cb647cb">directed_graph::remove_edge_bulk</a>. </dd></dl>

<p>Implemented in <a class="el" href="classlal_1_1graphs_1_1free__tree.html#a351690ca4c8fc4e471dc87cbf1ed1707">lal::graphs::free_tree</a>, and <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#a68010a9d89ab810721e4abf3ea5008e2">lal::graphs::rooted_tree</a>.</p>

</div>
</div>
<a id="a19e1904c2b9fe5c62237517c618ce71b" name="a19e1904c2b9fe5c62237517c618ce71b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19e1904c2b9fe5c62237517c618ce71b">&#9670;&#160;</a></span>get_component_representative()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lal::graphs::tree::get_component_representative </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Representative node of the connected component in which <em>u</em> belongs. </p>
<p>If the current graph lacks some edges then it is clearly a forest, i.e., a series of disconnected components. This function returns a representative node of the connected component to which node <em>u</em> belongs.</p>
<p>Further, let \(cc(u)\) be the connected component of vertex <em>u</em>, and \(rep(cc(u))\) be the representative node of \(cc(u)\). For every other node \(v\in cc(u)\), this function will return the same representative node \(rep(cc(u))\). Therefore, \(rep(cc(u))=rep(cc(v))\) for every \(v\in cc(u)\). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>Input node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The representative node of node <em>u's</em> component. </dd></dl>

</div>
</div>
<a id="a54061e1790d0424cac8960a0a3277a99" name="a54061e1790d0424cac8960a0a3277a99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54061e1790d0424cac8960a0a3277a99">&#9670;&#160;</a></span>get_num_nodes_component()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lal::graphs::tree::get_num_nodes_component </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Amount of nodes in a connected component of the tree. </p>
<p>If the current graph lacks some edges then it is clearly a forest, i.e., a series of disconnected components. This function returns the size of the component node <em>u</em> belongs to.</p>
<p>In rooted trees one has to see this amount as the number of nodes of the component in the underlying undirected forest. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>Input node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size of the connected component of <em>u</em>. </dd></dl>

</div>
</div>
<a id="a91155aa7578956540e8811aa896d06c5" name="a91155aa7578956540e8811aa896d06c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91155aa7578956540e8811aa896d06c5">&#9670;&#160;</a></span>get_Q()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt; <a class="el" href="namespacelal.html#a235d5351556fbc73aa51767ab7765f5c">edge_pair</a> &gt; lal::graphs::graph::get_Q </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns all independent pairs of edges of this graph. </p>
<p>The set \(Q(G)\) is defined as the pairs of edges of \(G\), \(E(G) \times E(G)\), that are independent, that is, that share no nodes. </p>

<p>Implemented in <a class="el" href="classlal_1_1graphs_1_1directed__graph.html#a116071bf1763e9454e1fc047b6c236d8">lal::graphs::directed_graph</a>, and <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html#a742dbaac9c82914744e76de4bdcec277">lal::graphs::undirected_graph</a>.</p>

</div>
</div>
<a id="ae51ce9ddffc9287f375545e2b2fec3e3" name="ae51ce9ddffc9287f375545e2b2fec3e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae51ce9ddffc9287f375545e2b2fec3e3">&#9670;&#160;</a></span>get_tree_type_list()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; lal::graphs::tree::get_tree_type_list </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the list of types as a list of strings. </p>
<dl class="section return"><dt>Returns</dt><dd>The list of types as a list of strings. </dd></dl>

</div>
</div>
<a id="a0e3529632b38533c4be8b2a306a038c3" name="a0e3529632b38533c4be8b2a306a038c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e3529632b38533c4be8b2a306a038c3">&#9670;&#160;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void lal::graphs::graph::init </td>
          <td>(</td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates the necessary memory for this class. </p>
<p>See <a class="el" href="classlal_1_1graphs_1_1graph.html#aad95568f8b3a8ac76edfabd8581fa455">_init</a> for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of nodes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abb9238eb8914e145736f1ac914f6b9d6" name="abb9238eb8914e145736f1ac914f6b9d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb9238eb8914e145736f1ac914f6b9d6">&#9670;&#160;</a></span>is_normalized()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::graphs::graph::is_normalized </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether this graph is normalized or not. </p>
<p>A graph is normalized if every node's adjacency list is sorted increasingly. For this, use method <a class="el" href="classlal_1_1graphs_1_1graph.html#abe2c7decb104857bd857c769feb75c98">normalize()</a>. </p><dl class="section return"><dt>Returns</dt><dd>The value of <a class="el" href="classlal_1_1graphs_1_1graph.html#a427d63b1bef991f43db8f5d622567bb6">m_is_normalized</a>. </dd></dl>

</div>
</div>
<a id="a06ce8cc7afb074d2fecf70a0842adaaa" name="a06ce8cc7afb074d2fecf70a0842adaaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06ce8cc7afb074d2fecf70a0842adaaa">&#9670;&#160;</a></span>is_of_tree_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::graphs::tree::is_of_tree_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal_1_1graphs.html#a18d52542088507e2be6241759722835b">tree_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>tt</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether this tree is of type <em>tt</em>. </p>
<p>See method <a class="el" href="#aa8a453d924452a46b781f1cf6bfb8360">calculate_tree_type</a> to know how to calculate a tree's type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tt</td><td>Type of tree (see <a class="el" href="namespacelal_1_1graphs.html#a18d52542088507e2be6241759722835b">graphs::tree_type</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this tree is of type <em>tt</em>. </dd></dl>

</div>
</div>
<a id="a25c8d57865fa5f7cb5d101fd5d07fe2d" name="a25c8d57865fa5f7cb5d101fd5d07fe2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25c8d57865fa5f7cb5d101fd5d07fe2d">&#9670;&#160;</a></span>is_tree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::graphs::tree::is_tree </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this graph an actual tree? </p>
<p>Returns true if the number of edges is one less than the number of nodes.</p>
<p>Note that this would not really be true if the addition of edges was not constrained. That is, since it is constrained (behind the scenes) in a way that no cycles can be produced (for example, see <a class="el" href="classlal_1_1graphs_1_1free__tree.html#af9a0b63cb35de6ddbbb67f37785c49f8">free_tree::add_edge</a>, or <a class="el" href="classlal_1_1graphs_1_1free__tree.html#ab0f485e3795909478b403c71cd777b2d">free_tree::add_edges</a>), then we only need to check for the number of edges.</p>
<p>For further characterisations of a tree see <a class="el" href="citelist.html#CITEREF_Harary1969a">[29]</a> (chapter 4, pages 32-33). </p><dl class="section return"><dt>Returns</dt><dd>True or false depending on whether this graph fits the defintion of tree. </dd></dl>

</div>
</div>
<a id="a9fc7f9e08db601f10982da6a01315cb3" name="a9fc7f9e08db601f10982da6a01315cb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fc7f9e08db601f10982da6a01315cb3">&#9670;&#160;</a></span>is_tree_type_valid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::graphs::tree::is_tree_type_valid </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the type of this tree valid? </p>
<p>This function enables users determine when this tree's type should be calculated.</p>
<p>In case this function returns false, users should call function <a class="el" href="#aa8a453d924452a46b781f1cf6bfb8360">calculate_tree_type</a> in order to obtain a valid tree type. Note, however, that prior to calling the function the type of this tree might be <a class="el" href="namespacelal_1_1graphs.html#a18d52542088507e2be6241759722835baad921d60486366258809553a3db49a4a">graphs::tree_type::unknown</a> and that the tree type may remain <a class="el" href="namespacelal_1_1graphs.html#a18d52542088507e2be6241759722835baad921d60486366258809553a3db49a4a">graphs::tree_type::unknown</a> even after the type has been calculated. Nevertheless, users should be suspicious of a tree being of <a class="el" href="namespacelal_1_1graphs.html#a18d52542088507e2be6241759722835baad921d60486366258809553a3db49a4a">graphs::tree_type::unknown</a> (in fact, of any) type if this method returns false, yet they should be sure of it if the type was calculated via method <a class="el" href="#aa8a453d924452a46b781f1cf6bfb8360">calculate_tree_type</a>. </p><dl class="section return"><dt>Returns</dt><dd>True or false depending on whether the tree type was calculated or not. </dd></dl>

</div>
</div>
<a id="abe2c7decb104857bd857c769feb75c98" name="abe2c7decb104857bd857c769feb75c98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe2c7decb104857bd857c769feb75c98">&#9670;&#160;</a></span>normalize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void lal::graphs::graph::normalize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Normalizes the graph. </p>
<p>Sorts this graph's adjacency list structure in increasing order.</p>
<p>Besides expensive, this method may be unnecessary. Method <a class="el" href="classlal_1_1graphs_1_1graph.html#a0beca99dbbaa1a1a27db6c4e2d280ea5">check_normalized()</a> checks whether the graph is normalized or not; in case it is, using this method is completely unnecessary. </p><dl class="section post"><dt>Postcondition</dt><dd>Method <a class="el" href="classlal_1_1graphs_1_1graph.html#abb9238eb8914e145736f1ac914f6b9d6">is_normalized</a> evaluates to true. </dd></dl>

<p>Reimplemented in <a class="el" href="classlal_1_1graphs_1_1directed__graph.html#a4e4a81d38587995cb990e21e28aaf2b4">lal::graphs::directed_graph</a>.</p>

</div>
</div>
<a id="a047c0d257986a79742aad0c49b517bb4" name="a047c0d257986a79742aad0c49b517bb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a047c0d257986a79742aad0c49b517bb4">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1graphs_1_1tree.html">tree</a> &amp; lal::graphs::tree::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1tree.html">tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Tree. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a75314d033504b75f3cb0e7202890285b" name="a75314d033504b75f3cb0e7202890285b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75314d033504b75f3cb0e7202890285b">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1graphs_1_1tree.html">tree</a> &amp; lal::graphs::tree::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlal_1_1graphs_1_1tree.html">tree</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Tree. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaabba99bcbca589ec9f8f5d3c85e6b43" name="aaabba99bcbca589ec9f8f5d3c85e6b43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaabba99bcbca589ec9f8f5d3c85e6b43">&#9670;&#160;</a></span>tree_only_actions_after_add_edge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::tree::tree_only_actions_after_add_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do some work after the addition of an edge. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>First node of the edge. </td></tr>
    <tr><td class="paramname">v</td><td>Second node of the edge. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>The tree type is invalidated. </dd>
<dd>
Updated union-find. </dd></dl>

</div>
</div>
<a id="aa7e746b8d5c0cd8f53890f046aeceb65" name="aa7e746b8d5c0cd8f53890f046aeceb65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7e746b8d5c0cd8f53890f046aeceb65">&#9670;&#160;</a></span>tree_only_actions_after_add_edges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::tree::tree_only_actions_after_add_edges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ab98936b00d896700a71899dff1ed9248">edge_list</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do some work after the addition of several edges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>List of edges. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>The tree type is invalidated. </dd>
<dd>
Updated union-find. </dd></dl>

</div>
</div>
<a id="ac759e6c7f4bf5bf2cee25fa274d9d4d5" name="ac759e6c7f4bf5bf2cee25fa274d9d4d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac759e6c7f4bf5bf2cee25fa274d9d4d5">&#9670;&#160;</a></span>tree_only_actions_after_add_edges_bulk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::tree::tree_only_actions_after_add_edges_bulk </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do some work after the addition of several edges in bulk. </p>
<p>To be called only after veral calls to <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html#a3d9454ddfaef55219be3ef00ecac1189">undirected_graph::add_edge_bulk</a> or <a class="el" href="classlal_1_1graphs_1_1directed__graph.html#a2867b035b48ab54df5f60e3b065fea66">directed_graph::add_edge_bulk</a>. </p><dl class="section post"><dt>Postcondition</dt><dd>The tree type is invalidated. </dd>
<dd>
Updated union-find. </dd></dl>

</div>
</div>
<a id="a5ba179a3180253e6eeb62d5b8df22066" name="a5ba179a3180253e6eeb62d5b8df22066"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ba179a3180253e6eeb62d5b8df22066">&#9670;&#160;</a></span>tree_only_actions_after_add_edges_bulk_complete()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::tree::tree_only_actions_after_add_edges_bulk_complete </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do some work after the addition of several edges in bulk. </p>
<p>To be called only after veral calls to <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html#a3d9454ddfaef55219be3ef00ecac1189">undirected_graph::add_edge_bulk</a> or <a class="el" href="classlal_1_1graphs_1_1directed__graph.html#a2867b035b48ab54df5f60e3b065fea66">directed_graph::add_edge_bulk</a>. </p><dl class="section post"><dt>Postcondition</dt><dd>The tree type is invalidated. </dd>
<dd>
Updated union-find. </dd></dl>

</div>
</div>
<a id="a9474e409a3b4feb4c5806ee74c59c8ca" name="a9474e409a3b4feb4c5806ee74c59c8ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9474e409a3b4feb4c5806ee74c59c8ca">&#9670;&#160;</a></span>tree_only_actions_after_remove_edge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::tree::tree_only_actions_after_remove_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do some work after the removal of an edge. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>First node of the edge. </td></tr>
    <tr><td class="paramname">v</td><td>Second node of the edge. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>The tree type is invalidated. </dd>
<dd>
Updated union-find. </dd></dl>

</div>
</div>
<a id="a5ff43145e03d8074cbc513e2fe827454" name="a5ff43145e03d8074cbc513e2fe827454"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ff43145e03d8074cbc513e2fe827454">&#9670;&#160;</a></span>tree_only_actions_after_remove_edges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::tree::tree_only_actions_after_remove_edges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ab98936b00d896700a71899dff1ed9248">edge_list</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do some work after the removal of several edges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>List of edges. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>The tree type is invalidated. </dd>
<dd>
Updated union-find. </dd></dl>

</div>
</div>
<a id="a9a43cfff1504c7ff6bcba9cd03e4743d" name="a9a43cfff1504c7ff6bcba9cd03e4743d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a43cfff1504c7ff6bcba9cd03e4743d">&#9670;&#160;</a></span>tree_only_actions_after_remove_edges_bulk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::tree::tree_only_actions_after_remove_edges_bulk </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do some work after the removal of several edges in bulk. </p>
<p>To be called only after veral calls to <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html#a741081cc0646053bcb5fd5809eb19a21">undirected_graph::remove_edge_bulk</a> or <a class="el" href="classlal_1_1graphs_1_1directed__graph.html#a655fbacfd749a62e61933ae19cb647cb">directed_graph::remove_edge_bulk</a>. </p><dl class="section post"><dt>Postcondition</dt><dd>The tree type is invalidated. </dd>
<dd>
Updated union-find. </dd></dl>

</div>
</div>
<a id="a3d35e95e2d86ec20bcf8609f8f6f6a68" name="a3d35e95e2d86ec20bcf8609f8f6f6a68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d35e95e2d86ec20bcf8609f8f6f6a68">&#9670;&#160;</a></span>tree_only_actions_after_remove_edges_bulk_complete()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::tree::tree_only_actions_after_remove_edges_bulk_complete </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do some work after the removal of several edges in bulk. </p>
<p>To be called only after veral calls to <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html#a741081cc0646053bcb5fd5809eb19a21">undirected_graph::remove_edge_bulk</a> or <a class="el" href="classlal_1_1graphs_1_1directed__graph.html#a655fbacfd749a62e61933ae19cb647cb">directed_graph::remove_edge_bulk</a>. </p><dl class="section post"><dt>Postcondition</dt><dd>The tree type is invalidated. </dd>
<dd>
Updated union-find. </dd></dl>

</div>
</div>
<a id="abca6ea36ec8d9b891395aaef69ece840" name="abca6ea36ec8d9b891395aaef69ece840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abca6ea36ec8d9b891395aaef69ece840">&#9670;&#160;</a></span>tree_only_actions_after_remove_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::tree::tree_only_actions_after_remove_node </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do some work before the removal of a vertex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>Node to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>The tree type is invalidated. </dd>
<dd>
Updated union-find. </dd></dl>

</div>
</div>
<a id="a76ad30a023ad9b9bd3dd69bb350051ee" name="a76ad30a023ad9b9bd3dd69bb350051ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76ad30a023ad9b9bd3dd69bb350051ee">&#9670;&#160;</a></span>tree_only_actions_before_remove_edges_incident_to()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::tree::tree_only_actions_before_remove_edges_incident_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do some work before the removal of all edges incident to a vertex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>Node whose incident edges are to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>The tree type is invalidated. </dd>
<dd>
Updated union-find. </dd></dl>

</div>
</div>
<a id="a65d589c9cedc11dac39baca2c0c58001" name="a65d589c9cedc11dac39baca2c0c58001"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65d589c9cedc11dac39baca2c0c58001">&#9670;&#160;</a></span>tree_only_add_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::tree::tree_only_add_node </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a node to this tree. </p>
<p>Updates all the internal data structures. </p>

</div>
</div>
<a id="a973468996f8ff425e9a37ae0788bc4c1" name="a973468996f8ff425e9a37ae0788bc4c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a973468996f8ff425e9a37ae0788bc4c1">&#9670;&#160;</a></span>tree_only_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::tree::tree_only_init </td>
          <td>(</td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes only the memory of class <a class="el" href="classlal_1_1graphs_1_1tree.html">tree</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of vertices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2ca79711e18e398299a3beb42fe3cc41" name="a2ca79711e18e398299a3beb42fe3cc41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ca79711e18e398299a3beb42fe3cc41">&#9670;&#160;</a></span>tree_only_invalidate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::tree::tree_only_invalidate </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invalidates the aggregated information of the tree. </p>
<p>Invalidates:</p><ul>
<li><a class="el" href="#a951a57e760385ce3de285089627b7bbb">m_is_tree_type_valid</a>. </li>
</ul>

</div>
</div>
<a id="a00d8733492f1bba18638506af2a19d7e" name="a00d8733492f1bba18638506af2a19d7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00d8733492f1bba18638506af2a19d7e">&#9670;&#160;</a></span>tree_only_remove_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::tree::tree_only_remove_node </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a vertex from the union-find data structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>Node that was removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>The tree type is invalidated. </dd>
<dd>
Updated union-find. </dd></dl>

</div>
</div>
<a id="aee4660ac324fd19a342f2369cf4f796f" name="aee4660ac324fd19a342f2369cf4f796f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee4660ac324fd19a342f2369cf4f796f">&#9670;&#160;</a></span>tree_only_set_edges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::graphs::tree::tree_only_set_edges </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the data structures of a tree after the graph structure has had its set of edges set. </p>
<dl class="section post"><dt>Postcondition</dt><dd>The tree type is invalidated. </dd>
<dd>
Updated union-find. </dd></dl>

</div>
</div>
<a id="adeab97d916ec9809fa2b03f96960159d" name="adeab97d916ec9809fa2b03f96960159d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adeab97d916ec9809fa2b03f96960159d">&#9670;&#160;</a></span>update_union_find_after_add_edge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void lal::graphs::tree::update_union_find_after_add_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *const</td>          <td class="paramname"><span class="paramname"><em>root_of</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *const</td>          <td class="paramname"><span class="paramname"><em>root_size</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the union find data structure after an edge addition. </p>
<p>This is a helper method to be able to call <a class="el" href="namespacelal_1_1detail.html#af50760eaee3200e963cc77c4c95470d6">lal::detail::update_unionfind_after_add_edge</a> which updates the Union-Find data structure under addition of an edge. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>Node that is connected to <em>v</em>. </td></tr>
    <tr><td class="paramname">v</td><td>Node that is connected to <em>u</em>. </td></tr>
    <tr><td class="paramname">root_of</td><td>Array of <em>n</em> elements relating each vertex to its root in the union find data structure. </td></tr>
    <tr><td class="paramname">root_size</td><td>Array of <em>n</em> elements relating each vertex to the size of the connected component it belongs to. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classlal_1_1graphs_1_1free__tree.html#ab93024584e19121cddfcc0f19d80170d">lal::graphs::free_tree</a>, and <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#aba129310bd758fa9cf03abceace19a4c">lal::graphs::rooted_tree</a>.</p>

</div>
</div>
<a id="a1f932ae19c2eed5740cb12cca2efd7ee" name="a1f932ae19c2eed5740cb12cca2efd7ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f932ae19c2eed5740cb12cca2efd7ee">&#9670;&#160;</a></span>update_union_find_after_add_edges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void lal::graphs::tree::update_union_find_after_add_edges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ab98936b00d896700a71899dff1ed9248">edge_list</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>edges</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *const</td>          <td class="paramname"><span class="paramname"><em>root_of</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *const</td>          <td class="paramname"><span class="paramname"><em>root_size</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the union find data structure after the addition of a set of edges. </p>
<p>This is a helper method to be able to call <a class="el" href="namespacelal_1_1detail.html#a5cadd0c126ee7d5e745ee5188d67daff">lal::detail::update_unionfind_after_add_edges</a> which updates the Union-Find data structure under addition of an edge. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edges</td><td>A set of edges. </td></tr>
    <tr><td class="paramname">root_of</td><td>Array of <em>n</em> elements relating each vertex to its root in the union find data structure. </td></tr>
    <tr><td class="paramname">root_size</td><td>Array of <em>n</em> elements relating each vertex to the size of the connected component it belongs to. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classlal_1_1graphs_1_1free__tree.html#abe54dfa6ed437154ea710cf4b7ec26db">lal::graphs::free_tree</a>, and <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#a6f13f1e17793bf01b693398287b2f9fa">lal::graphs::rooted_tree</a>.</p>

</div>
</div>
<a id="aded95ef5a07fcbeface887f28e8b897d" name="aded95ef5a07fcbeface887f28e8b897d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aded95ef5a07fcbeface887f28e8b897d">&#9670;&#160;</a></span>update_union_find_after_add_edges_bulk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void lal::graphs::tree::update_union_find_after_add_edges_bulk </td>
          <td>(</td>
          <td class="paramtype">uint64_t *const</td>          <td class="paramname"><span class="paramname"><em>root_of</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *const</td>          <td class="paramname"><span class="paramname"><em>root_size</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the union find data structure after the addition of several edges. </p>
<p>This is a helper method to be able to call <a class="el" href="namespacelal_1_1detail.html#a49b8ff3684b7c460352ee1678541b0d9">lal::detail::update_unionfind_after_add_rem_edges_bulk</a> which updates the Union-Find data structure after addition of several edges. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_of</td><td>Array of <em>n</em> elements relating each vertex to its root in the union find data structure. </td></tr>
    <tr><td class="paramname">root_size</td><td>Array of <em>n</em> elements relating each vertex to the size of the connected component it belongs to. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classlal_1_1graphs_1_1free__tree.html#a2898a948210877b078cf99c5ba00eb6a">lal::graphs::free_tree</a>, and <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#a45f0c0a06ea7b5603b8f49708a372c92">lal::graphs::rooted_tree</a>.</p>

</div>
</div>
<a id="aca432e67b4dd7fd49392f8afd53fed83" name="aca432e67b4dd7fd49392f8afd53fed83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca432e67b4dd7fd49392f8afd53fed83">&#9670;&#160;</a></span>update_union_find_after_remove_edge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void lal::graphs::tree::update_union_find_after_remove_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *const</td>          <td class="paramname"><span class="paramname"><em>root_of</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *const</td>          <td class="paramname"><span class="paramname"><em>root_size</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the union find data structure after an edge removal. </p>
<p>This is a helper method to be able to call <a class="el" href="namespacelal_1_1detail.html#a773e3f33dbdcf3c44007f621eea0e4de">lal::detail::update_unionfind_after_remove_edge</a> which updates the Union-Find data structure under removal of an edge. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>Node that is connected to <em>v</em>. </td></tr>
    <tr><td class="paramname">v</td><td>Node that is connected to <em>u</em>. </td></tr>
    <tr><td class="paramname">root_of</td><td>Array of <em>n</em> elements relating each vertex to its root in the union find data structure. </td></tr>
    <tr><td class="paramname">root_size</td><td>Array of <em>n</em> elements relating each vertex to the size of the connected component it belongs to. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classlal_1_1graphs_1_1free__tree.html#a98feb6b21ba959247168007dd0ba7526">lal::graphs::free_tree</a>, and <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#abc881b926932ddeadd5823c751f51db4">lal::graphs::rooted_tree</a>.</p>

</div>
</div>
<a id="aec260049cf754a19ba9258d812cab80a" name="aec260049cf754a19ba9258d812cab80a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec260049cf754a19ba9258d812cab80a">&#9670;&#160;</a></span>update_union_find_after_remove_edges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void lal::graphs::tree::update_union_find_after_remove_edges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ab98936b00d896700a71899dff1ed9248">edge_list</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>edges</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *const</td>          <td class="paramname"><span class="paramname"><em>root_of</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *const</td>          <td class="paramname"><span class="paramname"><em>root_size</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the union find data structure after the removal of a set of edges. </p>
<p>This is a helper method to be able to call <a class="el" href="namespacelal_1_1detail.html#a7c633651b077f8fd9417d8593e222dea">lal::detail::update_unionfind_after_remove_edges</a> which updates the Union-Find data structure under removal of an edge. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edges</td><td>A set of edges. </td></tr>
    <tr><td class="paramname">root_of</td><td>Array of <em>n</em> elements relating each vertex to its root in the union find data structure. </td></tr>
    <tr><td class="paramname">root_size</td><td>Array of <em>n</em> elements relating each vertex to the size of the connected component it belongs to. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classlal_1_1graphs_1_1free__tree.html#a09ab0582495eb5cbdf85b3b88d5e1422">lal::graphs::free_tree</a>, and <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#afce8358ccbbcb855c76091c736ddd90b">lal::graphs::rooted_tree</a>.</p>

</div>
</div>
<a id="a131a43d6c944ccc29b46b930818a2c52" name="a131a43d6c944ccc29b46b930818a2c52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a131a43d6c944ccc29b46b930818a2c52">&#9670;&#160;</a></span>update_union_find_after_remove_edges_bulk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void lal::graphs::tree::update_union_find_after_remove_edges_bulk </td>
          <td>(</td>
          <td class="paramtype">uint64_t *const</td>          <td class="paramname"><span class="paramname"><em>root_of</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *const</td>          <td class="paramname"><span class="paramname"><em>root_size</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the union find data structure after the removal of several edges. </p>
<p>This is a helper method to be able to call <a class="el" href="namespacelal_1_1detail.html#a49b8ff3684b7c460352ee1678541b0d9">lal::detail::update_unionfind_after_add_rem_edges_bulk</a> which updates the Union-Find data structure under removal of several edges. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_of</td><td>Array of <em>n</em> elements relating each vertex to its root in the union find data structure. </td></tr>
    <tr><td class="paramname">root_size</td><td>Array of <em>n</em> elements relating each vertex to the size of the connected component it belongs to. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classlal_1_1graphs_1_1free__tree.html#aae5adc207532d74d2344206e838208f9">lal::graphs::free_tree</a>, and <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#ac41814d5fbe43cce354aa600f37b9c9f">lal::graphs::rooted_tree</a>.</p>

</div>
</div>
<a id="a9ea87b62eceaadd99d9f1d5fba4856d9" name="a9ea87b62eceaadd99d9f1d5fba4856d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ea87b62eceaadd99d9f1d5fba4856d9">&#9670;&#160;</a></span>update_union_find_before_remove_incident_edges_to()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void lal::graphs::tree::update_union_find_before_remove_incident_edges_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *const</td>          <td class="paramname"><span class="paramname"><em>root_of</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *const</td>          <td class="paramname"><span class="paramname"><em>root_size</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the union find data structure before the removal of all edges incident to a node. </p>
<p>This is a helper method to be able to call <a class="el" href="namespacelal_1_1detail.html#a13f00277c294d1ea536cb0359e2d28fd">lal::detail::update_unionfind_before_remove_edges_incident_to</a> which updates the Union-Find data structure under removal of all incident edges to a node. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>Node whose incident edges are to be removed. </td></tr>
    <tr><td class="paramname">root_of</td><td>Array of <em>n</em> elements relating each vertex to its root in the union find data structure. </td></tr>
    <tr><td class="paramname">root_size</td><td>Array of <em>n</em> elements relating each vertex to the size of the connected component it belongs to. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classlal_1_1graphs_1_1free__tree.html#ad205959ddd6b1d7886f4cec319c35396">lal::graphs::free_tree</a>, and <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#a84f5ebd803e3fd0dbda0a23306e7713e">lal::graphs::rooted_tree</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a427d63b1bef991f43db8f5d622567bb6" name="a427d63b1bef991f43db8f5d622567bb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a427d63b1bef991f43db8f5d622567bb6">&#9670;&#160;</a></span>m_is_normalized</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::graphs::graph::m_is_normalized = true</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this graph normalized? </p>
<p>An undirected graph is normalized iff every node's adjacency list is sorted in increasing order.</p>
<p>In directed graphs, however, it is necessary that the adjacency lists of the out-neighbors and in-neighbors of nodes be sorted.</p>
<p>This attribute is set to 'true' in all graph's initialisation and destruction (when <a class="el" href="classlal_1_1graphs_1_1graph.html#af8ba9ec6acf2306c84d9ddbd88fc8474">clear()</a> method is called). </p>

</div>
</div>
<a id="a951a57e760385ce3de285089627b7bbb" name="a951a57e760385ce3de285089627b7bbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a951a57e760385ce3de285089627b7bbb">&#9670;&#160;</a></span>m_is_tree_type_valid</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::graphs::tree::m_is_tree_type_valid = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the type of this tree valid? </p>
<p>This attribute keeps track of whether or not the function <a class="el" href="#aa8a453d924452a46b781f1cf6bfb8360">calculate_tree_type</a> should be called before querying the type of this tree via function <a class="el" href="#a06ce8cc7afb074d2fecf70a0842adaaa">is_of_tree_type</a>. </p>

</div>
</div>
<a id="a11bb51b8c210daa43ad5bf6d11bfd35f" name="a11bb51b8c210daa43ad5bf6d11bfd35f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11bb51b8c210daa43ad5bf6d11bfd35f">&#9670;&#160;</a></span>m_union_find__root_size</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;uint64_t&gt; lal::graphs::tree::m_union_find__root_size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The size of the connected component that a <em>root</em> belongs to. </p>
<p>Formally, <em>m_size_of</em>[v] is the size of the connected component of a <em>root</em> vertex <em>v</em>. A vertex <em>u</em> is a root vertex if there exists a vertex <em>w</em> such that <a class="el" href="#ac0be40a4f9c7df1eb2dcbbe7b417ce73">m_union_find__root_of</a>[w] = u.</p>
<p>In this context, root is within the union-find data structure. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>lal/graphs/<a class="el" href="tree_8hpp_source.html">tree.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
