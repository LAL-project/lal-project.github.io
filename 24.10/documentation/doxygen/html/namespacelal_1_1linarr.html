<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LAL: Linear Arrangement Library: lal::linarr Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">LAL: Linear Arrangement Library<span id="projectnumber">&#160;24.10.00</span>
   </div>
   <div id="projectbrief">A library focused on algorithms on linear arrangements of graphs.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacelal.html">lal</a></li><li class="navelem"><a class="el" href="namespacelal_1_1linarr.html">linarr</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">lal::linarr Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Namespace for all linear-arrangement-dependent algorithms.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1linarr_1_1chunk.html">chunk</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of a chunk.  <a href="classlal_1_1linarr_1_1chunk.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1linarr_1_1chunk__sequence.html">chunk_sequence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chunk sequence of a syntactic dependency tree.  <a href="classlal_1_1linarr_1_1chunk__sequence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlal_1_1linarr_1_1dependency__flux.html">dependency_flux</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dependency flux.  <a href="classlal_1_1linarr_1_1dependency__flux.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:aa7dc22d99964e6a6bb1fe5dd096e64b7" id="r_aa7dc22d99964e6a6bb1fe5dd096e64b7"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> { <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7a14eb8fb55e00336d36cb281764c88aa5">brute_force</a>
, <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7a724c4582f391c030da5a79ad83de9ecf">dynamic_programming</a>
, <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">ladder</a>
, <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7aea9e5920d6313045f9549b9a8808c8a7">stack_based</a>
 }</td></tr>
<tr class="memdesc:aa7dc22d99964e6a6bb1fe5dd096e64b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The different algorithms for computing the number of crossings.  <a href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">More...</a><br /></td></tr>
<tr class="separator:aa7dc22d99964e6a6bb1fe5dd096e64b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54918628e8da62ca7b52e6eb995b014f" id="r_a54918628e8da62ca7b52e6eb995b014f"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a54918628e8da62ca7b52e6eb995b014f">algorithms_chunking</a> { <a class="el" href="#a54918628e8da62ca7b52e6eb995b014fab32b1b822dd59451b17b08f97fdfe81e">Anderson</a>
, <a class="el" href="#a54918628e8da62ca7b52e6eb995b014fa94ac0c53893b2db4c53414298c8d7a78">Macutek</a>
 }</td></tr>
<tr class="memdesc:a54918628e8da62ca7b52e6eb995b014f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The different algorithms for chunking a syntactic dependency tree.  <a href="#a54918628e8da62ca7b52e6eb995b014f">More...</a><br /></td></tr>
<tr class="separator:a54918628e8da62ca7b52e6eb995b014f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c6a617eb12e032ee641fd390776ff3f" id="r_a1c6a617eb12e032ee641fd390776ff3f"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c6a617eb12e032ee641fd390776ff3f">algorithms_Dmin</a> { <a class="el" href="#a1c6a617eb12e032ee641fd390776ff3fae04de66d6cf0f6c6ec4036288f66bbed">Shiloach</a>
, <a class="el" href="#a1c6a617eb12e032ee641fd390776ff3fa6b1d14e66c988ccd420887b0774de1d6">Chung_2</a>
 }</td></tr>
<tr class="memdesc:a1c6a617eb12e032ee641fd390776ff3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The different algorithms for computing the minimum sum of the length of the edges \(D\).  <a href="#a1c6a617eb12e032ee641fd390776ff3f">More...</a><br /></td></tr>
<tr class="separator:a1c6a617eb12e032ee641fd390776ff3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a49efcc64c3b63502ad8cc18d508ce3" id="r_a4a49efcc64c3b63502ad8cc18d508ce3"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a49efcc64c3b63502ad8cc18d508ce3">algorithms_Dmin_planar</a> { <a class="el" href="#a4a49efcc64c3b63502ad8cc18d508ce3a37e3b966cac6fa2c0f649bd5cb42adca">AlemanyEstebanFerrer</a>
, <a class="el" href="#a4a49efcc64c3b63502ad8cc18d508ce3a5420b4f3654df1cf130da66c7a7aba6b">HochbergStallmann</a>
 }</td></tr>
<tr class="memdesc:a4a49efcc64c3b63502ad8cc18d508ce3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The different algorithms for computing the minimum sum of the length of the edges \(D\) in planar arrangements of free trees.  <a href="#a4a49efcc64c3b63502ad8cc18d508ce3">More...</a><br /></td></tr>
<tr class="separator:a4a49efcc64c3b63502ad8cc18d508ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30bc00af5439a56f037ed84875f1911f" id="r_a30bc00af5439a56f037ed84875f1911f"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a30bc00af5439a56f037ed84875f1911f">algorithms_Dmin_projective</a> { <a class="el" href="#a30bc00af5439a56f037ed84875f1911fa37e3b966cac6fa2c0f649bd5cb42adca">AlemanyEstebanFerrer</a>
, <a class="el" href="#a30bc00af5439a56f037ed84875f1911fa5420b4f3654df1cf130da66c7a7aba6b">HochbergStallmann</a>
 }</td></tr>
<tr class="memdesc:a30bc00af5439a56f037ed84875f1911f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The different algorithms for computing the minimum sum of the length of the edges \(D\) in projective arrangements of rooted trees.  <a href="#a30bc00af5439a56f037ed84875f1911f">More...</a><br /></td></tr>
<tr class="separator:a30bc00af5439a56f037ed84875f1911f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a682101b23eb6c0db724df82e2aae18dd" id="r_a682101b23eb6c0db724df82e2aae18dd"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a682101b23eb6c0db724df82e2aae18dd">syntactic_dependency_tree_type</a> { <br />
&#160;&#160;<a class="el" href="#a682101b23eb6c0db724df82e2aae18dda118c01813b90ed2f2630b6d66992ef7d">EC1</a>
, <a class="el" href="#a682101b23eb6c0db724df82e2aae18dda3be411765e710adc7764f5056e44138c">planar</a>
, <a class="el" href="#a682101b23eb6c0db724df82e2aae18dda768db0c0fba3c72a9886b833efe822ce">projective</a>
, <a class="el" href="#a682101b23eb6c0db724df82e2aae18ddacf92d51d12b1fc006d0a126c327caa14">WG1</a>
, <br />
&#160;&#160;<a class="el" href="#a682101b23eb6c0db724df82e2aae18ddaad921d60486366258809553a3db49a4a">unknown</a>
<br />
 }</td></tr>
<tr class="memdesc:a682101b23eb6c0db724df82e2aae18dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The different types of syntactic dependency tree structures.  <a href="#a682101b23eb6c0db724df82e2aae18dd">More...</a><br /></td></tr>
<tr class="separator:a682101b23eb6c0db724df82e2aae18dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae5d17b6e4ea1521b436dbb20817f41b1" id="r_ae5d17b6e4ea1521b436dbb20817f41b1"><td class="memTemplParams" colspan="2">template&lt;class graph_t &gt; </td></tr>
<tr class="memitem:ae5d17b6e4ea1521b436dbb20817f41b1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae5d17b6e4ea1521b436dbb20817f41b1">mean_dependency_distance_1level_rational</a> (const std::vector&lt; graph_t &gt; &amp;L, const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;P={}) noexcept</td></tr>
<tr class="memdesc:ae5d17b6e4ea1521b436dbb20817f41b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">1-level Mean Dependency Distance \(MDD\) over an ensemble of graphs.  <br /></td></tr>
<tr class="separator:ae5d17b6e4ea1521b436dbb20817f41b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f8c78736426eea6282258b26534c7e5" id="r_a1f8c78736426eea6282258b26534c7e5"><td class="memTemplParams" colspan="2">template&lt;class graph_t &gt; </td></tr>
<tr class="memitem:a1f8c78736426eea6282258b26534c7e5"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1f8c78736426eea6282258b26534c7e5">mean_dependency_distance_1level</a> (const std::vector&lt; graph_t &gt; &amp;L, const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;P={}) noexcept</td></tr>
<tr class="memdesc:a1f8c78736426eea6282258b26534c7e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">1-level Mean Dependency Distance \(MDD\) over an ensemble of graphs.  <br /></td></tr>
<tr class="separator:a1f8c78736426eea6282258b26534c7e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b2bbd3f6c94e03091186afd5ec3ae89" id="r_a0b2bbd3f6c94e03091186afd5ec3ae89"><td class="memTemplParams" colspan="2">template&lt;class graph_t &gt; </td></tr>
<tr class="memitem:a0b2bbd3f6c94e03091186afd5ec3ae89"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0b2bbd3f6c94e03091186afd5ec3ae89">mean_dependency_distance_2level_rational</a> (const std::vector&lt; graph_t &gt; &amp;L, const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;P={}) noexcept</td></tr>
<tr class="memdesc:a0b2bbd3f6c94e03091186afd5ec3ae89"><td class="mdescLeft">&#160;</td><td class="mdescRight">2-level Mean Dependency Distance \(MDD\) over an ensemble of graphs.  <br /></td></tr>
<tr class="separator:a0b2bbd3f6c94e03091186afd5ec3ae89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac837af66d13aa3e2865a6737aec34e7a" id="r_ac837af66d13aa3e2865a6737aec34e7a"><td class="memTemplParams" colspan="2">template&lt;class graph_t &gt; </td></tr>
<tr class="memitem:ac837af66d13aa3e2865a6737aec34e7a"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac837af66d13aa3e2865a6737aec34e7a">mean_dependency_distance_2level</a> (const std::vector&lt; graph_t &gt; &amp;L, const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;P={}) noexcept</td></tr>
<tr class="memdesc:ac837af66d13aa3e2865a6737aec34e7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">2-level Mean Dependency Distance \(MDD\) over an ensemble of graphs.  <br /></td></tr>
<tr class="separator:ac837af66d13aa3e2865a6737aec34e7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3806eb869914f45cf79c15e8aa7d2a51" id="r_a3806eb869914f45cf79c15e8aa7d2a51"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3806eb869914f45cf79c15e8aa7d2a51">num_crossings</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;G, const <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;A=<a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a>) noexcept</td></tr>
<tr class="memdesc:a3806eb869914f45cf79c15e8aa7d2a51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the number of edge crossings in a linear arrangement.  <br /></td></tr>
<tr class="separator:a3806eb869914f45cf79c15e8aa7d2a51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d16bf5730076cd9fabd4f25a38f61de" id="r_a3d16bf5730076cd9fabd4f25a38f61de"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d16bf5730076cd9fabd4f25a38f61de">num_crossings</a> (const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;G, const <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;A=<a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a>) noexcept</td></tr>
<tr class="memdesc:a3d16bf5730076cd9fabd4f25a38f61de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the number of edge crossings in a linear arrangement.  <br /></td></tr>
<tr class="separator:a3d16bf5730076cd9fabd4f25a38f61de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92f697f47063d903d2c092a6c4984595" id="r_a92f697f47063d903d2c092a6c4984595"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a92f697f47063d903d2c092a6c4984595">num_crossings</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;G, const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;arr, const <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;A=<a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a>) noexcept</td></tr>
<tr class="memdesc:a92f697f47063d903d2c092a6c4984595"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the number of edge crossings in a linear arrangement.  <br /></td></tr>
<tr class="separator:a92f697f47063d903d2c092a6c4984595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a1346c7b927d34465602d1a0a5010c9" id="r_a9a1346c7b927d34465602d1a0a5010c9"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9a1346c7b927d34465602d1a0a5010c9">num_crossings</a> (const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;G, const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;arr, const <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;A=<a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a>) noexcept</td></tr>
<tr class="memdesc:a9a1346c7b927d34465602d1a0a5010c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the number of edge crossings in a linear arrangement.  <br /></td></tr>
<tr class="separator:a9a1346c7b927d34465602d1a0a5010c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a986371a18404f18e4589c7b709c55315" id="r_a986371a18404f18e4589c7b709c55315"><td class="memItemLeft" align="right" valign="top">std::vector&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a986371a18404f18e4589c7b709c55315">num_crossings_list</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;G, const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;arrs, const <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;A=<a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a>) noexcept</td></tr>
<tr class="memdesc:a986371a18404f18e4589c7b709c55315"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the number of edge crossings in a linear arrangement.  <br /></td></tr>
<tr class="separator:a986371a18404f18e4589c7b709c55315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6282f5b1fb20e9f86a8fd6747d543262" id="r_a6282f5b1fb20e9f86a8fd6747d543262"><td class="memItemLeft" align="right" valign="top">std::vector&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6282f5b1fb20e9f86a8fd6747d543262">num_crossings_list</a> (const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;G, const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;arrs, const <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;A=<a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a>) noexcept</td></tr>
<tr class="memdesc:a6282f5b1fb20e9f86a8fd6747d543262"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the number of edge crossings in a linear arrangement.  <br /></td></tr>
<tr class="separator:a6282f5b1fb20e9f86a8fd6747d543262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc11f3fe70559983423bbf39f6893104" id="r_acc11f3fe70559983423bbf39f6893104"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acc11f3fe70559983423bbf39f6893104">is_num_crossings_lesseq_than</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;G, const uint64_t upper_bound, const <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;A=<a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a>) noexcept</td></tr>
<tr class="memdesc:acc11f3fe70559983423bbf39f6893104"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the number of crossings in the linear arrangement less than a constant?  <br /></td></tr>
<tr class="separator:acc11f3fe70559983423bbf39f6893104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae547be7d64c76708906e8751c361ce4a" id="r_ae547be7d64c76708906e8751c361ce4a"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae547be7d64c76708906e8751c361ce4a">is_num_crossings_lesseq_than</a> (const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;G, const uint64_t upper_bound, const <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;A=<a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a>) noexcept</td></tr>
<tr class="memdesc:ae547be7d64c76708906e8751c361ce4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the number of crossings in the linear arrangement less than a constant?  <br /></td></tr>
<tr class="separator:ae547be7d64c76708906e8751c361ce4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad66ef36b5872e3de7c9add305352bfdd" id="r_ad66ef36b5872e3de7c9add305352bfdd"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad66ef36b5872e3de7c9add305352bfdd">is_num_crossings_lesseq_than</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;G, const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;arr, const uint64_t upper_bound, const <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;A=<a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a>) noexcept</td></tr>
<tr class="memdesc:ad66ef36b5872e3de7c9add305352bfdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the number of crossings in the linear arrangement less than a constant?  <br /></td></tr>
<tr class="separator:ad66ef36b5872e3de7c9add305352bfdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fcbb92e98d7fce27bfc4d075a792c5c" id="r_a4fcbb92e98d7fce27bfc4d075a792c5c"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4fcbb92e98d7fce27bfc4d075a792c5c">is_num_crossings_lesseq_than</a> (const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;G, const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;arr, const uint64_t upper_bound, const <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;A=<a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a>) noexcept</td></tr>
<tr class="memdesc:a4fcbb92e98d7fce27bfc4d075a792c5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the number of crossings in the linear arrangement less than a constant?  <br /></td></tr>
<tr class="separator:a4fcbb92e98d7fce27bfc4d075a792c5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a767ab48c6d71e287fbb1d06aa324435b" id="r_a767ab48c6d71e287fbb1d06aa324435b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a767ab48c6d71e287fbb1d06aa324435b">is_num_crossings_lesseq_than_list</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;G, const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;arrs, const uint64_t upper_bound, const <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;A=<a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a>) noexcept</td></tr>
<tr class="memdesc:a767ab48c6d71e287fbb1d06aa324435b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the number of crossings in the linear arrangement less than a constant?  <br /></td></tr>
<tr class="separator:a767ab48c6d71e287fbb1d06aa324435b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fa0c34487537ec8fd7e7bccb769b294" id="r_a5fa0c34487537ec8fd7e7bccb769b294"><td class="memItemLeft" align="right" valign="top">std::vector&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5fa0c34487537ec8fd7e7bccb769b294">is_num_crossings_lesseq_than_list</a> (const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;G, const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;arrs, const uint64_t upper_bound, const <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;A=<a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a>) noexcept</td></tr>
<tr class="memdesc:a5fa0c34487537ec8fd7e7bccb769b294"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the number of crossings in the linear arrangement less than a constant?  <br /></td></tr>
<tr class="separator:a5fa0c34487537ec8fd7e7bccb769b294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae06f54984c51091894dd9bb8946547f7" id="r_ae06f54984c51091894dd9bb8946547f7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae06f54984c51091894dd9bb8946547f7">is_num_crossings_lesseq_than_list</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;G, const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;arrs, const std::vector&lt; uint64_t &gt; &amp;upper_bounds, const <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;A=<a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a>) noexcept</td></tr>
<tr class="memdesc:ae06f54984c51091894dd9bb8946547f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the number of crossings in the linear arrangement less than a constant?  <br /></td></tr>
<tr class="separator:ae06f54984c51091894dd9bb8946547f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a406b2456d635ac4efcbd7ed7270bf173" id="r_a406b2456d635ac4efcbd7ed7270bf173"><td class="memItemLeft" align="right" valign="top">std::vector&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a406b2456d635ac4efcbd7ed7270bf173">is_num_crossings_lesseq_than_list</a> (const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;G, const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;arrs, const std::vector&lt; uint64_t &gt; &amp;upper_bounds, const <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;A=<a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a>) noexcept</td></tr>
<tr class="memdesc:a406b2456d635ac4efcbd7ed7270bf173"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the number of crossings in the linear arrangement less than a constant?  <br /></td></tr>
<tr class="separator:a406b2456d635ac4efcbd7ed7270bf173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5078b16561c6ebe15a88a9b6b5b574bc" id="r_a5078b16561c6ebe15a88a9b6b5b574bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5078b16561c6ebe15a88a9b6b5b574bc">predicted_num_crossings_rational</a> (const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;g, const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;arr={}) noexcept</td></tr>
<tr class="memdesc:a5078b16561c6ebe15a88a9b6b5b574bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicts the number of crossings.  <br /></td></tr>
<tr class="separator:a5078b16561c6ebe15a88a9b6b5b574bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24d733f3e2029e5cfe5497708a3baf64" id="r_a24d733f3e2029e5cfe5497708a3baf64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a24d733f3e2029e5cfe5497708a3baf64">predicted_num_crossings_rational</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;g, const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;arr={}) noexcept</td></tr>
<tr class="memdesc:a24d733f3e2029e5cfe5497708a3baf64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicts the number of crossings.  <br /></td></tr>
<tr class="separator:a24d733f3e2029e5cfe5497708a3baf64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9db950bbaa1d8623c561142f14f06920" id="r_a9db950bbaa1d8623c561142f14f06920"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9db950bbaa1d8623c561142f14f06920">predicted_num_crossings</a> (const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;g, const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;arr={}) noexcept</td></tr>
<tr class="memdesc:a9db950bbaa1d8623c561142f14f06920"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximates the number of crossings.  <br /></td></tr>
<tr class="separator:a9db950bbaa1d8623c561142f14f06920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a659d080affa5219805b9a40f6f0164e6" id="r_a659d080affa5219805b9a40f6f0164e6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a659d080affa5219805b9a40f6f0164e6">predicted_num_crossings</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;g, const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;arr={}) noexcept</td></tr>
<tr class="memdesc:a659d080affa5219805b9a40f6f0164e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximates the number of crossings.  <br /></td></tr>
<tr class="separator:a659d080affa5219805b9a40f6f0164e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef106fb90f318c4b87d37b8b8df14b14" id="r_aef106fb90f318c4b87d37b8b8df14b14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aef106fb90f318c4b87d37b8b8df14b14">make_tree_from_chunk_sequence</a> (const <a class="el" href="classlal_1_1linarr_1_1chunk__sequence.html">chunk_sequence</a> &amp;seq) noexcept</td></tr>
<tr class="memdesc:aef106fb90f318c4b87d37b8b8df14b14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a rooted tree from the given chunk sequence.  <br /></td></tr>
<tr class="separator:aef106fb90f318c4b87d37b8b8df14b14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc9c26416976d5b89cb2b081eb40acfc" id="r_afc9c26416976d5b89cb2b081eb40acfc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afc9c26416976d5b89cb2b081eb40acfc">chunk_syntactic_dependency_tree</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;rt, const <a class="el" href="#a54918628e8da62ca7b52e6eb995b014f">algorithms_chunking</a> &amp;algo) noexcept</td></tr>
<tr class="memdesc:afc9c26416976d5b89cb2b081eb40acfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chunks a syntactic dependency tree according to the algorithm passed as parameter.  <br /></td></tr>
<tr class="separator:afc9c26416976d5b89cb2b081eb40acfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac2ab64bd596bd38332b74a35c9eca5" id="r_adac2ab64bd596bd38332b74a35c9eca5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adac2ab64bd596bd38332b74a35c9eca5">chunk_syntactic_dependency_tree</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;rt, const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;arr, const <a class="el" href="#a54918628e8da62ca7b52e6eb995b014f">algorithms_chunking</a> &amp;algo) noexcept</td></tr>
<tr class="memdesc:adac2ab64bd596bd38332b74a35c9eca5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chunks a syntactic dependency tree according to the algorithm passed as parameter.  <br /></td></tr>
<tr class="separator:adac2ab64bd596bd38332b74a35c9eca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a3d7e7db786d80c01bc9fe9ddbd0a73" id="r_a1a3d7e7db786d80c01bc9fe9ddbd0a73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1linarr_1_1chunk__sequence.html">chunk_sequence</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a3d7e7db786d80c01bc9fe9ddbd0a73">chunk_syntactic_dependency_tree_as_sequence</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;rt, const <a class="el" href="#a54918628e8da62ca7b52e6eb995b014f">algorithms_chunking</a> &amp;algo) noexcept</td></tr>
<tr class="memdesc:a1a3d7e7db786d80c01bc9fe9ddbd0a73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chunks a syntactic dependency tree according to the algorithm passed as parameter.  <br /></td></tr>
<tr class="separator:a1a3d7e7db786d80c01bc9fe9ddbd0a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ec1b821885ddbe855e0b55e3e4b5b1" id="r_a92ec1b821885ddbe855e0b55e3e4b5b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1linarr_1_1chunk__sequence.html">chunk_sequence</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a92ec1b821885ddbe855e0b55e3e4b5b1">chunk_syntactic_dependency_tree_as_sequence</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;rt, const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;arr, const <a class="el" href="#a54918628e8da62ca7b52e6eb995b014f">algorithms_chunking</a> &amp;algo) noexcept</td></tr>
<tr class="memdesc:a92ec1b821885ddbe855e0b55e3e4b5b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chunks a syntactic dependency tree according to the algorithm passed as parameter.  <br /></td></tr>
<tr class="separator:a92ec1b821885ddbe855e0b55e3e4b5b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a563b246458a32226833073c5d248500e" id="r_a563b246458a32226833073c5d248500e"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a563b246458a32226833073c5d248500e">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classlal_1_1linarr_1_1chunk.html">chunk</a> &amp;c) noexcept</td></tr>
<tr class="memdesc:a563b246458a32226833073c5d248500e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard output operator for chunks.  <br /></td></tr>
<tr class="separator:a563b246458a32226833073c5d248500e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae44186b49349b0f49daaf8ec968ba34b" id="r_ae44186b49349b0f49daaf8ec968ba34b"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae44186b49349b0f49daaf8ec968ba34b">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classlal_1_1linarr_1_1chunk__sequence.html">chunk_sequence</a> &amp;seq) noexcept</td></tr>
<tr class="memdesc:ae44186b49349b0f49daaf8ec968ba34b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard output operator for chunk sequences.  <br /></td></tr>
<tr class="separator:ae44186b49349b0f49daaf8ec968ba34b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab70693683a8da54a2e4350c665067cf1" id="r_ab70693683a8da54a2e4350c665067cf1"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab70693683a8da54a2e4350c665067cf1">sum_edge_lengths</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;g, const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;pi={}) noexcept</td></tr>
<tr class="memdesc:ab70693683a8da54a2e4350c665067cf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sum of the length of the edges in a linear arrangement.  <br /></td></tr>
<tr class="separator:ab70693683a8da54a2e4350c665067cf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7ded133434870e08c4473c12e7a03ce" id="r_ad7ded133434870e08c4473c12e7a03ce"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad7ded133434870e08c4473c12e7a03ce">sum_edge_lengths</a> (const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;g, const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;pi={}) noexcept</td></tr>
<tr class="memdesc:ad7ded133434870e08c4473c12e7a03ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sum of the length of the edges in a linear arrangement.  <br /></td></tr>
<tr class="separator:ad7ded133434870e08c4473c12e7a03ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a679b59e355c13c9ac4969f897b731582" id="r_a679b59e355c13c9ac4969f897b731582"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a679b59e355c13c9ac4969f897b731582">mean_dependency_distance_rational</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;g, const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;pi={}) noexcept</td></tr>
<tr class="memdesc:a679b59e355c13c9ac4969f897b731582"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the mean dependency distance \(MDD\) as an exact rational value.  <br /></td></tr>
<tr class="separator:a679b59e355c13c9ac4969f897b731582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77d3933929930331d44200deed260a41" id="r_a77d3933929930331d44200deed260a41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a77d3933929930331d44200deed260a41">mean_dependency_distance_rational</a> (const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;g, const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;pi={}) noexcept</td></tr>
<tr class="memdesc:a77d3933929930331d44200deed260a41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the mean dependency distance \(MDD\) as an exact rational value.  <br /></td></tr>
<tr class="separator:a77d3933929930331d44200deed260a41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2030c0f279ced9571405cebe5675e241" id="r_a2030c0f279ced9571405cebe5675e241"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2030c0f279ced9571405cebe5675e241">mean_dependency_distance</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;g, const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;pi={}) noexcept</td></tr>
<tr class="memdesc:a2030c0f279ced9571405cebe5675e241"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the mean dependency distance \(MDD\) as a floating point value.  <br /></td></tr>
<tr class="separator:a2030c0f279ced9571405cebe5675e241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43bba5ac9ff41d48b5320b70d9e4f403" id="r_a43bba5ac9ff41d48b5320b70d9e4f403"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a43bba5ac9ff41d48b5320b70d9e4f403">mean_dependency_distance</a> (const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;g, const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;pi={}) noexcept</td></tr>
<tr class="memdesc:a43bba5ac9ff41d48b5320b70d9e4f403"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the mean dependency distance \(MDD\) as a floating point value.  <br /></td></tr>
<tr class="separator:a43bba5ac9ff41d48b5320b70d9e4f403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fcc4229c7e0af8e9232d898345bba84" id="r_a6fcc4229c7e0af8e9232d898345bba84"><td class="memItemLeft" align="right" valign="top">std::pair&lt; uint64_t, std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6fcc4229c7e0af8e9232d898345bba84">max_sum_edge_lengths_all</a> (const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;t, const std::vector&lt; std::vector&lt; <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> &gt; &gt; &amp;orbits, const <a class="el" href="classlal_1_1properties_1_1bipartite__graph__coloring.html">properties::bipartite_graph_coloring</a> &amp;c, const std::vector&lt; <a class="el" href="classlal_1_1properties_1_1branchless__path.html">properties::branchless_path</a> &gt; &amp;bps, const std::size_t num_threads=1) noexcept</td></tr>
<tr class="memdesc:a6fcc4229c7e0af8e9232d898345bba84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates all the linear arrangements that yield the maximum sum of edge lengths.  <br /></td></tr>
<tr class="separator:a6fcc4229c7e0af8e9232d898345bba84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71300d3bd6cc55fe943d5be45640f5cf" id="r_a71300d3bd6cc55fe943d5be45640f5cf"><td class="memItemLeft" align="right" valign="top">std::pair&lt; uint64_t, std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a71300d3bd6cc55fe943d5be45640f5cf">max_sum_edge_lengths_all</a> (const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;t, const std::vector&lt; std::vector&lt; <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> &gt; &gt; &amp;orbits, const std::vector&lt; <a class="el" href="classlal_1_1properties_1_1branchless__path.html">properties::branchless_path</a> &gt; &amp;bps, const std::size_t num_threads=1) noexcept</td></tr>
<tr class="memdesc:a71300d3bd6cc55fe943d5be45640f5cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates all the linear arrangements that yield the maximum sum of edge lengths.  <br /></td></tr>
<tr class="separator:a71300d3bd6cc55fe943d5be45640f5cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05e5c47f61a0f13559aeca60212f6466" id="r_a05e5c47f61a0f13559aeca60212f6466"><td class="memItemLeft" align="right" valign="top">std::pair&lt; uint64_t, std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a05e5c47f61a0f13559aeca60212f6466">max_sum_edge_lengths_all</a> (const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;t, const <a class="el" href="classlal_1_1properties_1_1bipartite__graph__coloring.html">properties::bipartite_graph_coloring</a> &amp;c, const std::vector&lt; <a class="el" href="classlal_1_1properties_1_1branchless__path.html">properties::branchless_path</a> &gt; &amp;bps, const std::size_t num_threads=1) noexcept</td></tr>
<tr class="memdesc:a05e5c47f61a0f13559aeca60212f6466"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates all the linear arrangements that yield the maximum sum of edge lengths.  <br /></td></tr>
<tr class="separator:a05e5c47f61a0f13559aeca60212f6466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac087d62d5e2507a5b8218eb63c09cc04" id="r_ac087d62d5e2507a5b8218eb63c09cc04"><td class="memItemLeft" align="right" valign="top">std::pair&lt; uint64_t, std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac087d62d5e2507a5b8218eb63c09cc04">max_sum_edge_lengths_all</a> (const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;t, const std::vector&lt; std::vector&lt; <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> &gt; &gt; &amp;orbits, const <a class="el" href="classlal_1_1properties_1_1bipartite__graph__coloring.html">properties::bipartite_graph_coloring</a> &amp;c, const std::size_t num_threads=1) noexcept</td></tr>
<tr class="memdesc:ac087d62d5e2507a5b8218eb63c09cc04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates all the linear arrangements that yield the maximum sum of edge lengths.  <br /></td></tr>
<tr class="separator:ac087d62d5e2507a5b8218eb63c09cc04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31240c715bf8e46c4ca107db5f844881" id="r_a31240c715bf8e46c4ca107db5f844881"><td class="memItemLeft" align="right" valign="top">std::pair&lt; uint64_t, std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a31240c715bf8e46c4ca107db5f844881">max_sum_edge_lengths_all</a> (const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;t, const std::vector&lt; <a class="el" href="classlal_1_1properties_1_1branchless__path.html">properties::branchless_path</a> &gt; &amp;bps, const std::size_t num_threads=1) noexcept</td></tr>
<tr class="memdesc:a31240c715bf8e46c4ca107db5f844881"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates all the linear arrangements that yield the maximum sum of edge lengths.  <br /></td></tr>
<tr class="separator:a31240c715bf8e46c4ca107db5f844881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad717598c95a01c00d5278ca6e7e24c1d" id="r_ad717598c95a01c00d5278ca6e7e24c1d"><td class="memItemLeft" align="right" valign="top">std::pair&lt; uint64_t, std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad717598c95a01c00d5278ca6e7e24c1d">max_sum_edge_lengths_all</a> (const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;t, const <a class="el" href="classlal_1_1properties_1_1bipartite__graph__coloring.html">properties::bipartite_graph_coloring</a> &amp;c, const std::size_t num_threads=1) noexcept</td></tr>
<tr class="memdesc:ad717598c95a01c00d5278ca6e7e24c1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates all the linear arrangements that yield the maximum sum of edge lengths.  <br /></td></tr>
<tr class="separator:ad717598c95a01c00d5278ca6e7e24c1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a908aa23d4e14bc8705e387394f2f0ce6" id="r_a908aa23d4e14bc8705e387394f2f0ce6"><td class="memItemLeft" align="right" valign="top">std::pair&lt; uint64_t, std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a908aa23d4e14bc8705e387394f2f0ce6">max_sum_edge_lengths_all</a> (const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;t, const std::vector&lt; std::vector&lt; <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> &gt; &gt; &amp;orbits, const std::size_t num_threads=1) noexcept</td></tr>
<tr class="memdesc:a908aa23d4e14bc8705e387394f2f0ce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates all the linear arrangements that yield the maximum sum of edge lengths.  <br /></td></tr>
<tr class="separator:a908aa23d4e14bc8705e387394f2f0ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a642b9f5697f7c9933b9b5c7424fed6e0" id="r_a642b9f5697f7c9933b9b5c7424fed6e0"><td class="memItemLeft" align="right" valign="top">std::pair&lt; uint64_t, std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a642b9f5697f7c9933b9b5c7424fed6e0">max_sum_edge_lengths_all</a> (const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;t, const std::size_t num_threads=1) noexcept</td></tr>
<tr class="memdesc:a642b9f5697f7c9933b9b5c7424fed6e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates all the linear arrangements that yield the maximum sum of edge lengths.  <br /></td></tr>
<tr class="separator:a642b9f5697f7c9933b9b5c7424fed6e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c8fab121c5848258cca520291219485" id="r_a7c8fab121c5848258cca520291219485"><td class="memItemLeft" align="right" valign="top">std::pair&lt; uint64_t, <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c8fab121c5848258cca520291219485">max_sum_edge_lengths_1_le_thistle</a> (const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;t, const <a class="el" href="classlal_1_1properties_1_1bipartite__graph__coloring.html">properties::bipartite_graph_coloring</a> &amp;c, const std::vector&lt; <a class="el" href="classlal_1_1properties_1_1branchless__path.html">properties::branchless_path</a> &gt; &amp;bps) noexcept</td></tr>
<tr class="memdesc:a7c8fab121c5848258cca520291219485"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the solution to \(\le 1\)-thistle MaxLA.  <br /></td></tr>
<tr class="separator:a7c8fab121c5848258cca520291219485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a960914f91aa21cad269a9e5337ed0e57" id="r_a960914f91aa21cad269a9e5337ed0e57"><td class="memItemLeft" align="right" valign="top">std::pair&lt; uint64_t, <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a960914f91aa21cad269a9e5337ed0e57">max_sum_edge_lengths_1_le_thistle</a> (const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;t, const std::vector&lt; <a class="el" href="classlal_1_1properties_1_1branchless__path.html">properties::branchless_path</a> &gt; &amp;bps) noexcept</td></tr>
<tr class="memdesc:a960914f91aa21cad269a9e5337ed0e57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the solution to \(\le 1\)-thistle MaxLA.  <br /></td></tr>
<tr class="separator:a960914f91aa21cad269a9e5337ed0e57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfa7344412a999dec210f438a73a7886" id="r_abfa7344412a999dec210f438a73a7886"><td class="memItemLeft" align="right" valign="top">std::pair&lt; uint64_t, <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abfa7344412a999dec210f438a73a7886">max_sum_edge_lengths_1_le_thistle</a> (const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;t, const <a class="el" href="classlal_1_1properties_1_1bipartite__graph__coloring.html">properties::bipartite_graph_coloring</a> &amp;c) noexcept</td></tr>
<tr class="memdesc:abfa7344412a999dec210f438a73a7886"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the solution to \(\le 1\)-thistle MaxLA.  <br /></td></tr>
<tr class="separator:abfa7344412a999dec210f438a73a7886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a828b5f04d55df1ac45ab686d7396ee0b" id="r_a828b5f04d55df1ac45ab686d7396ee0b"><td class="memItemLeft" align="right" valign="top">std::pair&lt; uint64_t, <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a828b5f04d55df1ac45ab686d7396ee0b">max_sum_edge_lengths_1_le_thistle</a> (const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:a828b5f04d55df1ac45ab686d7396ee0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the solution to \(\le1\)-thistle MaxLA.  <br /></td></tr>
<tr class="separator:a828b5f04d55df1ac45ab686d7396ee0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78ceee860452715ca4739adc28e53226" id="r_a78ceee860452715ca4739adc28e53226"><td class="memItemLeft" align="right" valign="top">std::pair&lt; uint64_t, <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a78ceee860452715ca4739adc28e53226">max_sum_edge_lengths_1_eq_thistle</a> (const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;t, const std::vector&lt; <a class="el" href="classlal_1_1properties_1_1branchless__path.html">properties::branchless_path</a> &gt; &amp;bps) noexcept</td></tr>
<tr class="memdesc:a78ceee860452715ca4739adc28e53226"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the solution to \(=1\)-thistle MaxLA.  <br /></td></tr>
<tr class="separator:a78ceee860452715ca4739adc28e53226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c405d6ac3dee765c48402faf922d706" id="r_a9c405d6ac3dee765c48402faf922d706"><td class="memItemLeft" align="right" valign="top">std::pair&lt; uint64_t, <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c405d6ac3dee765c48402faf922d706">max_sum_edge_lengths_1_eq_thistle</a> (const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:a9c405d6ac3dee765c48402faf922d706"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the solution to \(=1\)-thistle MaxLA.  <br /></td></tr>
<tr class="separator:a9c405d6ac3dee765c48402faf922d706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19e9a8803e21a8cfdef8f2f327e4a1ae" id="r_a19e9a8803e21a8cfdef8f2f327e4a1ae"><td class="memItemLeft" align="right" valign="top">std::pair&lt; uint64_t, <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a19e9a8803e21a8cfdef8f2f327e4a1ae">max_sum_edge_lengths_bipartite</a> (const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;g, const <a class="el" href="classlal_1_1properties_1_1bipartite__graph__coloring.html">properties::bipartite_graph_coloring</a> &amp;c) noexcept</td></tr>
<tr class="memdesc:a19e9a8803e21a8cfdef8f2f327e4a1ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the solution to Bipartite MaxLA as defined in <a class="el" href="citelist.html#CITEREF_Alemany2024a">[8]</a>.  <br /></td></tr>
<tr class="separator:a19e9a8803e21a8cfdef8f2f327e4a1ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45de867badd5a87cd98e66cd47da4d2d" id="r_a45de867badd5a87cd98e66cd47da4d2d"><td class="memItemLeft" align="right" valign="top">std::pair&lt; uint64_t, <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45de867badd5a87cd98e66cd47da4d2d">max_sum_edge_lengths_bipartite</a> (const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;g) noexcept</td></tr>
<tr class="memdesc:a45de867badd5a87cd98e66cd47da4d2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the solution to Bipartite MaxLA as defined in <a class="el" href="citelist.html#CITEREF_Alemany2024a">[8]</a>.  <br /></td></tr>
<tr class="separator:a45de867badd5a87cd98e66cd47da4d2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abca71b14ed3772dcf7a7b714cc7c5a00" id="r_abca71b14ed3772dcf7a7b714cc7c5a00"><td class="memItemLeft" align="right" valign="top">std::pair&lt; uint64_t, <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abca71b14ed3772dcf7a7b714cc7c5a00">max_sum_edge_lengths_bipartite</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;g, const <a class="el" href="classlal_1_1properties_1_1bipartite__graph__coloring.html">properties::bipartite_graph_coloring</a> &amp;c) noexcept</td></tr>
<tr class="memdesc:abca71b14ed3772dcf7a7b714cc7c5a00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the solution to Bipartite MaxLA as defined in <a class="el" href="citelist.html#CITEREF_Alemany2024a">[8]</a>.  <br /></td></tr>
<tr class="separator:abca71b14ed3772dcf7a7b714cc7c5a00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9229a1219e31cef1d5964af6a3283e19" id="r_a9229a1219e31cef1d5964af6a3283e19"><td class="memItemLeft" align="right" valign="top">std::pair&lt; uint64_t, <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9229a1219e31cef1d5964af6a3283e19">max_sum_edge_lengths_bipartite</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;g) noexcept</td></tr>
<tr class="memdesc:a9229a1219e31cef1d5964af6a3283e19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the solution to Bipartite MaxLA as defined in <a class="el" href="citelist.html#CITEREF_Alemany2024a">[8]</a>.  <br /></td></tr>
<tr class="separator:a9229a1219e31cef1d5964af6a3283e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadd6d6ed9cadb57228200d32c3a99191" id="r_aadd6d6ed9cadb57228200d32c3a99191"><td class="memItemLeft" align="right" valign="top">std::pair&lt; uint64_t, <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aadd6d6ed9cadb57228200d32c3a99191">max_sum_edge_lengths_planar</a> (const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:aadd6d6ed9cadb57228200d32c3a99191"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the maximum value of \(D\) in trees under the planarity constraint.  <br /></td></tr>
<tr class="separator:aadd6d6ed9cadb57228200d32c3a99191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95e4fa9607ca43dfe0ba110eb9e2ddd7" id="r_a95e4fa9607ca43dfe0ba110eb9e2ddd7"><td class="memItemLeft" align="right" valign="top">std::pair&lt; uint64_t, <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a95e4fa9607ca43dfe0ba110eb9e2ddd7">max_sum_edge_lengths_planar</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:a95e4fa9607ca43dfe0ba110eb9e2ddd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the maximum value of \(D\) in trees under the planarity constraint.  <br /></td></tr>
<tr class="separator:a95e4fa9607ca43dfe0ba110eb9e2ddd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a605f9fb7f2214a6dfd4021c12134a85c" id="r_a605f9fb7f2214a6dfd4021c12134a85c"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; uint64_t &gt;, <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a605f9fb7f2214a6dfd4021c12134a85c">max_sum_edge_lengths_projective_roots</a> (const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:a605f9fb7f2214a6dfd4021c12134a85c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the maximum value of \(D\) in trees under the projectivity constraint at every vertex of the tree.  <br /></td></tr>
<tr class="separator:a605f9fb7f2214a6dfd4021c12134a85c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d92a7d183caf25d9c881f8ee9d3833c" id="r_a4d92a7d183caf25d9c881f8ee9d3833c"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; uint64_t &gt;, <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4d92a7d183caf25d9c881f8ee9d3833c">max_sum_edge_lengths_projective_roots</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:a4d92a7d183caf25d9c881f8ee9d3833c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the maximum value of \(D\) in trees under the projectivity constraint at every vertex of the tree.  <br /></td></tr>
<tr class="separator:a4d92a7d183caf25d9c881f8ee9d3833c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0886a4326be3b40cf34ee526514d60ab" id="r_a0886a4326be3b40cf34ee526514d60ab"><td class="memItemLeft" align="right" valign="top">std::pair&lt; uint64_t, <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0886a4326be3b40cf34ee526514d60ab">max_sum_edge_lengths_projective</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:a0886a4326be3b40cf34ee526514d60ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the maximum value of \(D\) in rooted trees under the projectivity constraint.  <br /></td></tr>
<tr class="separator:a0886a4326be3b40cf34ee526514d60ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a450d0dd41fec42a39bb1204ecedaaa91" id="r_a450d0dd41fec42a39bb1204ecedaaa91"><td class="memItemLeft" align="right" valign="top">std::pair&lt; uint64_t, <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a450d0dd41fec42a39bb1204ecedaaa91">min_sum_edge_lengths</a> (const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;t, const <a class="el" href="#a1c6a617eb12e032ee641fd390776ff3f">algorithms_Dmin</a> &amp;a=<a class="el" href="#a1c6a617eb12e032ee641fd390776ff3fae04de66d6cf0f6c6ec4036288f66bbed">algorithms_Dmin::Shiloach</a>) noexcept</td></tr>
<tr class="memdesc:a450d0dd41fec42a39bb1204ecedaaa91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the minimum value of \(D\) in free trees.  <br /></td></tr>
<tr class="separator:a450d0dd41fec42a39bb1204ecedaaa91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22429c80001ad8fd3dbed68a59ef29fb" id="r_a22429c80001ad8fd3dbed68a59ef29fb"><td class="memItemLeft" align="right" valign="top">std::pair&lt; uint64_t, <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a22429c80001ad8fd3dbed68a59ef29fb">min_sum_edge_lengths</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;t, const <a class="el" href="#a1c6a617eb12e032ee641fd390776ff3f">algorithms_Dmin</a> &amp;a=<a class="el" href="#a1c6a617eb12e032ee641fd390776ff3fae04de66d6cf0f6c6ec4036288f66bbed">algorithms_Dmin::Shiloach</a>) noexcept</td></tr>
<tr class="memdesc:a22429c80001ad8fd3dbed68a59ef29fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the minimum value of \(D\) in trees.  <br /></td></tr>
<tr class="separator:a22429c80001ad8fd3dbed68a59ef29fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b0afdaae4943c26a3ba771d47ed92fb" id="r_a5b0afdaae4943c26a3ba771d47ed92fb"><td class="memItemLeft" align="right" valign="top">std::pair&lt; uint64_t, <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b0afdaae4943c26a3ba771d47ed92fb">min_sum_edge_lengths_bipartite</a> (const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;t, const <a class="el" href="classlal_1_1properties_1_1bipartite__graph__coloring.html">properties::bipartite_graph_coloring</a> &amp;c) noexcept</td></tr>
<tr class="memdesc:a5b0afdaae4943c26a3ba771d47ed92fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the minimum value of \(D\) in trees over bipartite arrangements.  <br /></td></tr>
<tr class="separator:a5b0afdaae4943c26a3ba771d47ed92fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a709afb09b93614ee58517d379bce3c8b" id="r_a709afb09b93614ee58517d379bce3c8b"><td class="memItemLeft" align="right" valign="top">std::pair&lt; uint64_t, <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a709afb09b93614ee58517d379bce3c8b">min_sum_edge_lengths_bipartite</a> (const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;t) noexcept</td></tr>
<tr class="memdesc:a709afb09b93614ee58517d379bce3c8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the minimum value of \(D\) in trees over bipartite arrangements.  <br /></td></tr>
<tr class="separator:a709afb09b93614ee58517d379bce3c8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ee049d439a7e8dd41ac0145679a84bb" id="r_a8ee049d439a7e8dd41ac0145679a84bb"><td class="memItemLeft" align="right" valign="top">std::pair&lt; uint64_t, <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ee049d439a7e8dd41ac0145679a84bb">min_sum_edge_lengths_planar</a> (const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;t, const <a class="el" href="#a4a49efcc64c3b63502ad8cc18d508ce3">algorithms_Dmin_planar</a> &amp;a=<a class="el" href="#a4a49efcc64c3b63502ad8cc18d508ce3a37e3b966cac6fa2c0f649bd5cb42adca">algorithms_Dmin_planar::AlemanyEstebanFerrer</a>) noexcept</td></tr>
<tr class="memdesc:a8ee049d439a7e8dd41ac0145679a84bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the minimum value of \(D\) in trees under the planarity constraint.  <br /></td></tr>
<tr class="separator:a8ee049d439a7e8dd41ac0145679a84bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab154f955e7f6887c6d8115108a4bf242" id="r_ab154f955e7f6887c6d8115108a4bf242"><td class="memItemLeft" align="right" valign="top">std::pair&lt; uint64_t, <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab154f955e7f6887c6d8115108a4bf242">min_sum_edge_lengths_planar</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;t, const <a class="el" href="#a4a49efcc64c3b63502ad8cc18d508ce3">algorithms_Dmin_planar</a> &amp;a=<a class="el" href="#a4a49efcc64c3b63502ad8cc18d508ce3a37e3b966cac6fa2c0f649bd5cb42adca">algorithms_Dmin_planar::AlemanyEstebanFerrer</a>) noexcept</td></tr>
<tr class="memdesc:ab154f955e7f6887c6d8115108a4bf242"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the minimum value of \(D\) in trees under the planarity constraint.  <br /></td></tr>
<tr class="separator:ab154f955e7f6887c6d8115108a4bf242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff8ac86ade398306f32ee39692ebfe4a" id="r_aff8ac86ade398306f32ee39692ebfe4a"><td class="memItemLeft" align="right" valign="top">std::pair&lt; uint64_t, <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff8ac86ade398306f32ee39692ebfe4a">min_sum_edge_lengths_projective</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;t, const <a class="el" href="#a30bc00af5439a56f037ed84875f1911f">algorithms_Dmin_projective</a> &amp;a=<a class="el" href="#a30bc00af5439a56f037ed84875f1911fa37e3b966cac6fa2c0f649bd5cb42adca">algorithms_Dmin_projective::AlemanyEstebanFerrer</a>) noexcept</td></tr>
<tr class="memdesc:aff8ac86ade398306f32ee39692ebfe4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the minimum value of \(D\) in rooted trees under the projectivity constraint.  <br /></td></tr>
<tr class="separator:aff8ac86ade398306f32ee39692ebfe4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43894fa63315bdf3ad82705ff248c1dc" id="r_a43894fa63315bdf3ad82705ff248c1dc"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classlal_1_1linarr_1_1dependency__flux.html">dependency_flux</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a43894fa63315bdf3ad82705ff248c1dc">dependency_flux_compute</a> (const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;t, const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;pi={}) noexcept</td></tr>
<tr class="memdesc:a43894fa63315bdf3ad82705ff248c1dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the flux of a dependency tree.  <br /></td></tr>
<tr class="separator:a43894fa63315bdf3ad82705ff248c1dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5622dab3db1402a6e361481f77ecaca" id="r_ac5622dab3db1402a6e361481f77ecaca"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classlal_1_1linarr_1_1dependency__flux.html">dependency_flux</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac5622dab3db1402a6e361481f77ecaca">dependency_flux_compute</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;t, const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;pi={}) noexcept</td></tr>
<tr class="memdesc:ac5622dab3db1402a6e361481f77ecaca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the flux of a dependency tree.  <br /></td></tr>
<tr class="separator:ac5622dab3db1402a6e361481f77ecaca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b3203432e13dfec29563796643e6187" id="r_a6b3203432e13dfec29563796643e6187"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b3203432e13dfec29563796643e6187">is_permutation</a> (const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;arr={}) noexcept</td></tr>
<tr class="memdesc:a6b3203432e13dfec29563796643e6187"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is a given input arrangement a permutation?  <br /></td></tr>
<tr class="separator:a6b3203432e13dfec29563796643e6187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b1d2f0e450b5f30c29e111884cc9ce8" id="r_a6b1d2f0e450b5f30c29e111884cc9ce8"><td class="memTemplParams" colspan="2">template&lt;class graph_t &gt; </td></tr>
<tr class="memitem:a6b1d2f0e450b5f30c29e111884cc9ce8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6b1d2f0e450b5f30c29e111884cc9ce8">is_arrangement</a> (const graph_t &amp;g, const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;arr) noexcept</td></tr>
<tr class="memdesc:a6b1d2f0e450b5f30c29e111884cc9ce8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is a given arrangement valid?  <br /></td></tr>
<tr class="separator:a6b1d2f0e450b5f30c29e111884cc9ce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abee7135280ad5d0c211fbf9008785d72" id="r_abee7135280ad5d0c211fbf9008785d72"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abee7135280ad5d0c211fbf9008785d72">is_bipartite</a> (const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;g, const <a class="el" href="classlal_1_1properties_1_1bipartite__graph__coloring.html">properties::bipartite_graph_coloring</a> &amp;c, const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;arr={}) noexcept</td></tr>
<tr class="memdesc:abee7135280ad5d0c211fbf9008785d72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is a given arrangement bipartite?  <br /></td></tr>
<tr class="separator:abee7135280ad5d0c211fbf9008785d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf424d86b6efad382339fb9f93c771c4" id="r_adf424d86b6efad382339fb9f93c771c4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adf424d86b6efad382339fb9f93c771c4">is_bipartite</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;g, const <a class="el" href="classlal_1_1properties_1_1bipartite__graph__coloring.html">properties::bipartite_graph_coloring</a> &amp;c, const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;arr={}) noexcept</td></tr>
<tr class="memdesc:adf424d86b6efad382339fb9f93c771c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is a given arrangement bipartite?  <br /></td></tr>
<tr class="separator:adf424d86b6efad382339fb9f93c771c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a387dd45cbe5fdaba0ecd76f8ad057127" id="r_a387dd45cbe5fdaba0ecd76f8ad057127"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a387dd45cbe5fdaba0ecd76f8ad057127">is_bipartite</a> (const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;g, const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;arr={}) noexcept</td></tr>
<tr class="memdesc:a387dd45cbe5fdaba0ecd76f8ad057127"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is a given arrangement bipartite?  <br /></td></tr>
<tr class="separator:a387dd45cbe5fdaba0ecd76f8ad057127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a073229916333514982d5f8766efb309f" id="r_a073229916333514982d5f8766efb309f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a073229916333514982d5f8766efb309f">is_bipartite</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;g, const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;arr={}) noexcept</td></tr>
<tr class="memdesc:a073229916333514982d5f8766efb309f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is a given arrangement bipartite?  <br /></td></tr>
<tr class="separator:a073229916333514982d5f8766efb309f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeb1b7dcc4cda2e1c366e02b2d03c627" id="r_aaeb1b7dcc4cda2e1c366e02b2d03c627"><td class="memTemplParams" colspan="2">template&lt;class graph_t &gt; </td></tr>
<tr class="memitem:aaeb1b7dcc4cda2e1c366e02b2d03c627"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aaeb1b7dcc4cda2e1c366e02b2d03c627">is_planar</a> (const graph_t &amp;g, const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;arr={}) noexcept</td></tr>
<tr class="memdesc:aaeb1b7dcc4cda2e1c366e02b2d03c627"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is a given arrangement planar?  <br /></td></tr>
<tr class="separator:aaeb1b7dcc4cda2e1c366e02b2d03c627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78b17d7726acf0ce82625c3d13987bfa" id="r_a78b17d7726acf0ce82625c3d13987bfa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a78b17d7726acf0ce82625c3d13987bfa">is_root_covered</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;rt, const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;arr) noexcept</td></tr>
<tr class="memdesc:a78b17d7726acf0ce82625c3d13987bfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the root of a rooted tree covered in a given arrangement?  <br /></td></tr>
<tr class="separator:a78b17d7726acf0ce82625c3d13987bfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae404b93b3b1730f61299f78f4ba89585" id="r_ae404b93b3b1730f61299f78f4ba89585"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae404b93b3b1730f61299f78f4ba89585">is_projective</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;rt, const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;arr) noexcept</td></tr>
<tr class="memdesc:ae404b93b3b1730f61299f78f4ba89585"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is a given arrangement projective?  <br /></td></tr>
<tr class="separator:ae404b93b3b1730f61299f78f4ba89585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a057b0d2eb4b8df8ed96d2a258b83035f" id="r_a057b0d2eb4b8df8ed96d2a258b83035f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a057b0d2eb4b8df8ed96d2a258b83035f">head_initial_rational</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;g, const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;pi={}) noexcept</td></tr>
<tr class="memdesc:a057b0d2eb4b8df8ed96d2a258b83035f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the headedness of a directed graph as an exact rational number.  <br /></td></tr>
<tr class="separator:a057b0d2eb4b8df8ed96d2a258b83035f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc15417e84e2d272ca8d49a266929e12" id="r_acc15417e84e2d272ca8d49a266929e12"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acc15417e84e2d272ca8d49a266929e12">head_initial</a> (const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;g, const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;pi={}) noexcept</td></tr>
<tr class="memdesc:acc15417e84e2d272ca8d49a266929e12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the headedness of a linearly arranged directed graph.  <br /></td></tr>
<tr class="separator:acc15417e84e2d272ca8d49a266929e12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f4c5571263d6aaeddeaecc3d37f7e1c" id="r_a7f4c5571263d6aaeddeaecc3d37f7e1c"><td class="memItemLeft" align="right" valign="top">std::array&lt; bool, <a class="el" href="#a7f09036a41db5bf5009bff33658c988e">__syntactic_dependency_tree_size</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f4c5571263d6aaeddeaecc3d37f7e1c">syntactic_dependency_tree_classify</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;t, const uint64_t C, const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;pi={}) noexcept</td></tr>
<tr class="memdesc:a7f4c5571263d6aaeddeaecc3d37f7e1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the type of syntactic dependency tree.  <br /></td></tr>
<tr class="separator:a7f4c5571263d6aaeddeaecc3d37f7e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcb046c518ebe8b9c7aa17f4141c0f80" id="r_adcb046c518ebe8b9c7aa17f4141c0f80"><td class="memItemLeft" align="right" valign="top">std::array&lt; bool, <a class="el" href="#a7f09036a41db5bf5009bff33658c988e">__syntactic_dependency_tree_size</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adcb046c518ebe8b9c7aa17f4141c0f80">syntactic_dependency_tree_classify</a> (const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;t, const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;pi={}) noexcept</td></tr>
<tr class="memdesc:adcb046c518ebe8b9c7aa17f4141c0f80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the type of syntactic dependency tree.  <br /></td></tr>
<tr class="separator:adcb046c518ebe8b9c7aa17f4141c0f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a7f09036a41db5bf5009bff33658c988e" id="r_a7f09036a41db5bf5009bff33658c988e"><td class="memItemLeft" align="right" valign="top"><a id="a7f09036a41db5bf5009bff33658c988e" name="a7f09036a41db5bf5009bff33658c988e"></a>
constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>__syntactic_dependency_tree_size</b></td></tr>
<tr class="memdesc:a7f09036a41db5bf5009bff33658c988e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of elements within enumeration <a class="el" href="#a682101b23eb6c0db724df82e2aae18dd">syntactic_dependency_tree_type</a>. <br /></td></tr>
<tr class="separator:a7f09036a41db5bf5009bff33658c988e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Namespace for all linear-arrangement-dependent algorithms. </p>
<p>This namespace contains functions to calculate properties of graphs that depend on a linear arrangement. Said arrangement van be given explicitly, i.e., by constructing a <a class="el" href="classlal_1_1linear__arrangement.html">lal::linear_arrangement</a> object, or by omitting it in the functions to let these use the labelling of the graph (to read more about the concept of linear arrangement see the <a class="el" href="LAL_concepts.html#LAL_concepts__linear_arrangement">Linear Arrangement</a> page). For example, given a graph</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classlal_1_1graphs_1_1undirected__graph.html">lal::graphs::undirected_graph</a> g;</div>
<div class="ttc" id="aclasslal_1_1graphs_1_1undirected__graph_html"><div class="ttname"><a href="classlal_1_1graphs_1_1undirected__graph.html">lal::graphs::undirected_graph</a></div><div class="ttdoc">Undirected graph class.</div><div class="ttdef"><b>Definition</b> undirected_graph.hpp:66</div></div>
</div><!-- fragment --><p>we can calculate the sum of length of the edges using function <a class="el" href="#ab70693683a8da54a2e4350c665067cf1">lal::linarr::sum_edge_lengths</a> in two different ways. The first is by omitting the arrangement:</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ab70693683a8da54a2e4350c665067cf1">lal::linarr::sum_edge_lengths</a>(g);</div>
<div class="ttc" id="anamespacelal_1_1linarr_html_ab70693683a8da54a2e4350c665067cf1"><div class="ttname"><a href="#ab70693683a8da54a2e4350c665067cf1">lal::linarr::sum_edge_lengths</a></div><div class="ttdeci">uint64_t sum_edge_lengths(const graphs::directed_graph &amp;g, const linear_arrangement &amp;pi={}) noexcept</div><div class="ttdoc">Computes the sum of the length of the edges in a linear arrangement.</div></div>
</div><!-- fragment --><p>or by giving one explicitly</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ab70693683a8da54a2e4350c665067cf1">lal::linarr::sum_edge_lengths</a>(g, {...});</div>
</div><!-- fragment --> </div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="aa7dc22d99964e6a6bb1fe5dd096e64b7" name="aa7dc22d99964e6a6bb1fe5dd096e64b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">&#9670;&#160;</a></span>algorithms_C</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">lal::linarr::algorithms_C</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The different algorithms for computing the number of crossings. </p>
<p>See <a class="el" href="LAL_concepts.html#LAL_concepts__linear_arrangement__properties">Properties that can be defined in linear arrangements</a> for the definition of edge crossings. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa7dc22d99964e6a6bb1fe5dd096e64b7a14eb8fb55e00336d36cb281764c88aa5" name="aa7dc22d99964e6a6bb1fe5dd096e64b7a14eb8fb55e00336d36cb281764c88aa5"></a>brute_force&#160;</td><td class="fielddoc"><p>Brute force computation of the number of crossings. </p>
<p>Complexity: time \(O(m^2)\), space \(O(1)\). </p>
</td></tr>
<tr><td class="fieldname"><a id="aa7dc22d99964e6a6bb1fe5dd096e64b7a724c4582f391c030da5a79ad83de9ecf" name="aa7dc22d99964e6a6bb1fe5dd096e64b7a724c4582f391c030da5a79ad83de9ecf"></a>dynamic_programming&#160;</td><td class="fielddoc"><p>Dynamic programming algorithm <a class="el" href="citelist.html#CITEREF_Alemany2019a">[9]</a>. </p>
<p>Complexity: time \(O(n^2)\), space \(O(n^2)\). </p>
</td></tr>
<tr><td class="fieldname"><a id="aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06" name="aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06"></a>ladder&#160;</td><td class="fielddoc"><p>Dynamic programming algorithm <a class="el" href="citelist.html#CITEREF_Alemany2019a">[9]</a>. </p>
<p>Complexity: time \(O(n^2)\), space \(O(n)\). </p>
</td></tr>
<tr><td class="fieldname"><a id="aa7dc22d99964e6a6bb1fe5dd096e64b7aea9e5920d6313045f9549b9a8808c8a7" name="aa7dc22d99964e6a6bb1fe5dd096e64b7aea9e5920d6313045f9549b9a8808c8a7"></a>stack_based&#160;</td><td class="fielddoc"><p>Algorithm based on sorting <a class="el" href="citelist.html#CITEREF_Alemany2019a">[9]</a>. </p>
<p>Complexity: time \(O(m\log n)\), space \(O(m)\). </p>
</td></tr>
</table>

</div>
</div>
<a id="a54918628e8da62ca7b52e6eb995b014f" name="a54918628e8da62ca7b52e6eb995b014f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54918628e8da62ca7b52e6eb995b014f">&#9670;&#160;</a></span>algorithms_chunking</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a54918628e8da62ca7b52e6eb995b014f">lal::linarr::algorithms_chunking</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The different algorithms for chunking a syntactic dependency tree. </p>
<p>Chunking is the art of grouping nodes (a.k.a. words) of a syntactic dependency tree in such a way that the resulting groups share common properties. This enumeration lists all the chunking algorithms implemented in this library.</p>
<p>Here we use 'chunking' as an umbrella term for all the algorithms that group nodes in units in a systematic way. Some researchers may not use this term. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a54918628e8da62ca7b52e6eb995b014fab32b1b822dd59451b17b08f97fdfe81e" name="a54918628e8da62ca7b52e6eb995b014fab32b1b822dd59451b17b08f97fdfe81e"></a>Anderson&#160;</td><td class="fielddoc"><p>Chunking algorithm by Anderson. </p>
<p>For further details see <a class="el" href="citelist.html#CITEREF_Anderson2021a">[12]</a> and <a class="el" href="citelist.html#CITEREF_Anderson2019a">[11]</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a54918628e8da62ca7b52e6eb995b014fa94ac0c53893b2db4c53414298c8d7a78" name="a54918628e8da62ca7b52e6eb995b014fa94ac0c53893b2db4c53414298c8d7a78"></a>Macutek&#160;</td><td class="fielddoc"><p>Chunking algorithm by Mautek. </p>
<p>Mautek et al. termed chunks as Linear Dependency Sequences (LDSs). For further details see <a class="el" href="citelist.html#CITEREF_Macutek2021a">[35]</a>.</p>
<p>Note: the implementation of Mautek's algorithm in LAL does not take clauses into account when computing an LDS. </p>
</td></tr>
</table>

</div>
</div>
<a id="a1c6a617eb12e032ee641fd390776ff3f" name="a1c6a617eb12e032ee641fd390776ff3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c6a617eb12e032ee641fd390776ff3f">&#9670;&#160;</a></span>algorithms_Dmin</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a1c6a617eb12e032ee641fd390776ff3f">lal::linarr::algorithms_Dmin</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The different algorithms for computing the minimum sum of the length of the edges \(D\). </p>
<p>This enumeration's values are used to choose the algorithm which the functions <a class="el" href="#a450d0dd41fec42a39bb1204ecedaaa91">lal::linarr::min_sum_edge_lengths</a> use to compute the minimum value of the sum of the length of the edges \(D\). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1c6a617eb12e032ee641fd390776ff3fae04de66d6cf0f6c6ec4036288f66bbed" name="a1c6a617eb12e032ee641fd390776ff3fae04de66d6cf0f6c6ec4036288f66bbed"></a>Shiloach&#160;</td><td class="fielddoc"><p>Yossi Shiloach's algorithm. </p>
<p>Shiloach's quadratic algorithm \(O(n^{2.2})\). Said algorithm was published in <a class="el" href="citelist.html#CITEREF_Shiloach1979a">[43]</a>, but the implementation applies the correction published in <a class="el" href="citelist.html#CITEREF_Esteban2017a">[19]</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1c6a617eb12e032ee641fd390776ff3fa6b1d14e66c988ccd420887b0774de1d6" name="a1c6a617eb12e032ee641fd390776ff3fa6b1d14e66c988ccd420887b0774de1d6"></a>Chung_2&#160;</td><td class="fielddoc"><p>Fan Chung's quadratic algorithm. </p>
<p>Fan Chung's quadratic algorithm \(O(n^2)\). Said algorithm was published in <a class="el" href="citelist.html#CITEREF_Chung1984a">[15]</a>. In particular, this implements Fan Chung's quadratic algorithm (Section 3). </p>
</td></tr>
</table>

</div>
</div>
<a id="a4a49efcc64c3b63502ad8cc18d508ce3" name="a4a49efcc64c3b63502ad8cc18d508ce3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a49efcc64c3b63502ad8cc18d508ce3">&#9670;&#160;</a></span>algorithms_Dmin_planar</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a4a49efcc64c3b63502ad8cc18d508ce3">lal::linarr::algorithms_Dmin_planar</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The different algorithms for computing the minimum sum of the length of the edges \(D\) in planar arrangements of free trees. </p>
<p>Recall that a planar arrangement is one in which there are no edge crossings.</p>
<p>This enumeration's values are used to choose the algorithm which the functions <a class="el" href="#a8ee049d439a7e8dd41ac0145679a84bb">lal::linarr::min_sum_edge_lengths_planar</a> use to compute the minimum value of the sum of the length of the edges \(D\). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a4a49efcc64c3b63502ad8cc18d508ce3a37e3b966cac6fa2c0f649bd5cb42adca" name="a4a49efcc64c3b63502ad8cc18d508ce3a37e3b966cac6fa2c0f649bd5cb42adca"></a>AlemanyEstebanFerrer&#160;</td><td class="fielddoc"><p>Alemany-Esteban-Ferrer's algorithm. </p>
<p>Interval-based approach to the calculation of minimum planar arrangements. Algorithm published in <a class="el" href="citelist.html#CITEREF_Alemany2022a">[6]</a>.</p>
<p>This algorithm's complexity is \(O(n)\). </p>
</td></tr>
<tr><td class="fieldname"><a id="a4a49efcc64c3b63502ad8cc18d508ce3a5420b4f3654df1cf130da66c7a7aba6b" name="a4a49efcc64c3b63502ad8cc18d508ce3a5420b4f3654df1cf130da66c7a7aba6b"></a>HochbergStallmann&#160;</td><td class="fielddoc"><p>Hochberg-Stallmann's algorithm. </p>
<p>Displacement-based approach to the calculation of minimum planar arrangements. The algorithm was originally published in <a class="el" href="citelist.html#CITEREF_Hochberg2003a">[30]</a>, however, the implementation uses the correction in <a class="el" href="citelist.html#CITEREF_Alemany2022a">[6]</a>.</p>
<p>This algorithm's complexity is \(O(n)\). </p>
</td></tr>
</table>

</div>
</div>
<a id="a30bc00af5439a56f037ed84875f1911f" name="a30bc00af5439a56f037ed84875f1911f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30bc00af5439a56f037ed84875f1911f">&#9670;&#160;</a></span>algorithms_Dmin_projective</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a30bc00af5439a56f037ed84875f1911f">lal::linarr::algorithms_Dmin_projective</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The different algorithms for computing the minimum sum of the length of the edges \(D\) in projective arrangements of rooted trees. </p>
<p>Recall that a projective arrangement is one in which there are no edge crossings and the root is not covered by any edge.</p>
<p>This enumeration's values are used to choose the algorithm which the functions <a class="el" href="#aff8ac86ade398306f32ee39692ebfe4a">lal::linarr::min_sum_edge_lengths_projective</a> use to compute the minimum value of the sum of the length of the edges \(D\). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a30bc00af5439a56f037ed84875f1911fa37e3b966cac6fa2c0f649bd5cb42adca" name="a30bc00af5439a56f037ed84875f1911fa37e3b966cac6fa2c0f649bd5cb42adca"></a>AlemanyEstebanFerrer&#160;</td><td class="fielddoc"><p>Alemany-Esteban-Ferrer's algorithm. </p>
<p>Interval-based approach to the calculation of minimum projective arrangements. Algorithm published in <a class="el" href="citelist.html#CITEREF_Alemany2022a">[6]</a>.</p>
<p>This algorithm's complexity is \(O(n)\). </p>
</td></tr>
<tr><td class="fieldname"><a id="a30bc00af5439a56f037ed84875f1911fa5420b4f3654df1cf130da66c7a7aba6b" name="a30bc00af5439a56f037ed84875f1911fa5420b4f3654df1cf130da66c7a7aba6b"></a>HochbergStallmann&#160;</td><td class="fielddoc"><p>Hochberg-Stallmann's algorithm. </p>
<p>Displacement-based approach to the calculation of minimum projective arrangements. The algorithm was originally published in <a class="el" href="citelist.html#CITEREF_Hochberg2003a">[30]</a>, however, the implementation uses the correction in <a class="el" href="citelist.html#CITEREF_Alemany2022a">[6]</a>.</p>
<p>This algorithm's complexity is \(O(n)\). </p>
</td></tr>
</table>

</div>
</div>
<a id="a682101b23eb6c0db724df82e2aae18dd" name="a682101b23eb6c0db724df82e2aae18dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a682101b23eb6c0db724df82e2aae18dd">&#9670;&#160;</a></span>syntactic_dependency_tree_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a682101b23eb6c0db724df82e2aae18dd">lal::linarr::syntactic_dependency_tree_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The different types of syntactic dependency tree structures. </p>
<p>Any tree with its nodes linearly arranged can be classified into several different classes. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a682101b23eb6c0db724df82e2aae18dda118c01813b90ed2f2630b6d66992ef7d" name="a682101b23eb6c0db724df82e2aae18dda118c01813b90ed2f2630b6d66992ef7d"></a>EC1&#160;</td><td class="fielddoc"><p>1-Endpoint Crossing. </p>
<p>A structure is 1-endpoint crossing if, given any dependency, all other dependencies crossing it are incident to a common node. See <a class="el" href="citelist.html#CITEREF_Pitler2013a">[42]</a> for further details. </p>
</td></tr>
<tr><td class="fieldname"><a id="a682101b23eb6c0db724df82e2aae18dda3be411765e710adc7764f5056e44138c" name="a682101b23eb6c0db724df82e2aae18dda3be411765e710adc7764f5056e44138c"></a>planar&#160;</td><td class="fielddoc"><p>Planar structures. </p>
<p>A structure is planar if none of its dependencies cross. Two dependencies \((s,t), (u,v)\) cross if, and only if, their positions in the arrangement are interleaved, i.e., if \(\pi(s) &lt; \pi(u) &lt; \pi(t) &lt; \pi(v)\), assuming that \(s\) precedes \(t\) and \(u\) precedes \(v\) in the arrangement. </p>
</td></tr>
<tr><td class="fieldname"><a id="a682101b23eb6c0db724df82e2aae18dda768db0c0fba3c72a9886b833efe822ce" name="a682101b23eb6c0db724df82e2aae18dda768db0c0fba3c72a9886b833efe822ce"></a>projective&#160;</td><td class="fielddoc"><p>Projective structures. </p>
<p>A structure is projective if it is <a class="el" href="#a682101b23eb6c0db724df82e2aae18dda3be411765e710adc7764f5056e44138c">lal::linarr::syntactic_dependency_tree_type::planar</a> and the root is not covered by any dependency. </p>
</td></tr>
<tr><td class="fieldname"><a id="a682101b23eb6c0db724df82e2aae18ddacf92d51d12b1fc006d0a126c327caa14" name="a682101b23eb6c0db724df82e2aae18ddacf92d51d12b1fc006d0a126c327caa14"></a>WG1&#160;</td><td class="fielddoc"><p>Well nested trees with maximum gap-degree 1. </p>
<p>All trees classified (by this library) as \(WG_1\) are not in \(WG_0\) (notice that \(WG_0\) is the class of projective trees).</p>
<p>For further details and thorough definitions of \(WG_k\), see <a class="el" href="citelist.html#CITEREF_Gomez2011a">[27]</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a682101b23eb6c0db724df82e2aae18ddaad921d60486366258809553a3db49a4a" name="a682101b23eb6c0db724df82e2aae18ddaad921d60486366258809553a3db49a4a"></a>unknown&#160;</td><td class="fielddoc"><p>The structure could not be classified. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="afc9c26416976d5b89cb2b081eb40acfc" name="afc9c26416976d5b89cb2b081eb40acfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc9c26416976d5b89cb2b081eb40acfc">&#9670;&#160;</a></span>chunk_syntactic_dependency_tree() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> lal::linarr::chunk_syntactic_dependency_tree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a54918628e8da62ca7b52e6eb995b014f">algorithms_chunking</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>algo</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Chunks a syntactic dependency tree according to the algorithm passed as parameter. </p>
<p>This function assumes the identity arrangement to chunk this tree. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rt</td><td>Input syntactic dependency tree. </td></tr>
    <tr><td class="paramname">algo</td><td>Algorithm of choice. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A syntactic dependency tree result of the chosen chunking algorithm. </dd></dl>

</div>
</div>
<a id="adac2ab64bd596bd38332b74a35c9eca5" name="adac2ab64bd596bd38332b74a35c9eca5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adac2ab64bd596bd38332b74a35c9eca5">&#9670;&#160;</a></span>chunk_syntactic_dependency_tree() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> lal::linarr::chunk_syntactic_dependency_tree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>arr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a54918628e8da62ca7b52e6eb995b014f">algorithms_chunking</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>algo</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Chunks a syntactic dependency tree according to the algorithm passed as parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rt</td><td>Input syntactic dependency tree. </td></tr>
    <tr><td class="paramname">arr</td><td>Non-empty input linear arrangement. </td></tr>
    <tr><td class="paramname">algo</td><td>Algorithm of choice. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A syntactic dependency tree result of the chosen chunking algorithm. </dd></dl>

</div>
</div>
<a id="a1a3d7e7db786d80c01bc9fe9ddbd0a73" name="a1a3d7e7db786d80c01bc9fe9ddbd0a73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a3d7e7db786d80c01bc9fe9ddbd0a73">&#9670;&#160;</a></span>chunk_syntactic_dependency_tree_as_sequence() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1linarr_1_1chunk__sequence.html">chunk_sequence</a> lal::linarr::chunk_syntactic_dependency_tree_as_sequence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a54918628e8da62ca7b52e6eb995b014f">algorithms_chunking</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>algo</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Chunks a syntactic dependency tree according to the algorithm passed as parameter. </p>
<p>This function assumes the identity arrangement to chunk this tree. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rt</td><td>Input syntactic dependency tree. </td></tr>
    <tr><td class="paramname">algo</td><td>Algorithm of choice. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sequence of chunks as a simple collection of nodes plus parent node for each chunk. </dd></dl>

</div>
</div>
<a id="a92ec1b821885ddbe855e0b55e3e4b5b1" name="a92ec1b821885ddbe855e0b55e3e4b5b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92ec1b821885ddbe855e0b55e3e4b5b1">&#9670;&#160;</a></span>chunk_syntactic_dependency_tree_as_sequence() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1linarr_1_1chunk__sequence.html">chunk_sequence</a> lal::linarr::chunk_syntactic_dependency_tree_as_sequence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>arr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a54918628e8da62ca7b52e6eb995b014f">algorithms_chunking</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>algo</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Chunks a syntactic dependency tree according to the algorithm passed as parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rt</td><td>Input syntactic dependency tree. </td></tr>
    <tr><td class="paramname">arr</td><td>Non-empty input linear arrangement. </td></tr>
    <tr><td class="paramname">algo</td><td>Algorithm of choice. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sequence of chunks as a simple collection of nodes plus parent node for each chunk. </dd></dl>

</div>
</div>
<a id="a43894fa63315bdf3ad82705ff248c1dc" name="a43894fa63315bdf3ad82705ff248c1dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43894fa63315bdf3ad82705ff248c1dc">&#9670;&#160;</a></span>dependency_flux_compute() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classlal_1_1linarr_1_1dependency__flux.html">dependency_flux</a> &gt; lal::linarr::dependency_flux_compute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pi</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the flux of a dependency tree. </p>
<p>This function is implemented based on the explanations given in <a class="el" href="citelist.html#CITEREF_Kahane2017a">[32]</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input free tree (or dependency tree). </td></tr>
    <tr><td class="paramname">pi</td><td>A linear arrangement of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The set of dependency fluxes in the arrangement. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The tree <em>t</em> is a valid free tree. Method <a class="el" href="classlal_1_1graphs_1_1tree.html#a25c8d57865fa5f7cb5d101fd5d07fe2d" title="Is this graph an actual tree?">lal::graphs::free_tree::is_tree</a> returns true. </dd></dl>

</div>
</div>
<a id="ac5622dab3db1402a6e361481f77ecaca" name="ac5622dab3db1402a6e361481f77ecaca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5622dab3db1402a6e361481f77ecaca">&#9670;&#160;</a></span>dependency_flux_compute() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classlal_1_1linarr_1_1dependency__flux.html">dependency_flux</a> &gt; lal::linarr::dependency_flux_compute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pi</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the flux of a dependency tree. </p>
<p>This function is implemented based on the explanations given in <a class="el" href="citelist.html#CITEREF_Kahane2017a">[32]</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input rooted tree (or dependency tree). </td></tr>
    <tr><td class="paramname">pi</td><td>A linear arrangement of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The set of dependency fluxes in the arrangement. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The tree <em>t</em> is a valid rooted tree. Method <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#af464d98b1b5dfdbaaacea553d9c89154" title="Is this tree a valid rooted tree?">lal::graphs::rooted_tree::is_rooted_tree</a> returns true. </dd></dl>

</div>
</div>
<a id="acc15417e84e2d272ca8d49a266929e12" name="acc15417e84e2d272ca8d49a266929e12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc15417e84e2d272ca8d49a266929e12">&#9670;&#160;</a></span>head_initial()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double lal::linarr::head_initial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pi</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the headedness of a linearly arranged directed graph. </p>
<p>See <a class="el" href="#a057b0d2eb4b8df8ed96d2a258b83035f">lal::linarr::head_initial_rational</a> for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">pi</td><td>Permutation of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return value is a floating point value. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>\(m &gt; 0\). </dd></dl>

</div>
</div>
<a id="a057b0d2eb4b8df8ed96d2a258b83035f" name="a057b0d2eb4b8df8ed96d2a258b83035f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a057b0d2eb4b8df8ed96d2a258b83035f">&#9670;&#160;</a></span>head_initial_rational()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a> lal::linarr::head_initial_rational </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pi</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the headedness of a directed graph as an exact rational number. </p>
<p>Given a graph and a permutation of its nodes, the headedness \(h\) is the ratio of right-branching edges over the total amount of edges. More precisely, it is</p>
<p>\(h = \frac{r}{m}\)</p>
<p>where \(r\) is the number of right-branching edges and \(m\) is the number of edges of the graph.</p>
<p>A value of 0 indicates perfect left branching, and a value of 1 indicates perfect right-branching. See <a class="el" href="citelist.html#CITEREF_Liu2010a">[34]</a> for further detals. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">pi</td><td>Permutation of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The headedness ratio as an exact rational number. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>\(m &gt; 0\). </dd></dl>

</div>
</div>
<a id="a6b1d2f0e450b5f30c29e111884cc9ce8" name="a6b1d2f0e450b5f30c29e111884cc9ce8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b1d2f0e450b5f30c29e111884cc9ce8">&#9670;&#160;</a></span>is_arrangement()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class graph_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::linarr::is_arrangement </td>
          <td>(</td>
          <td class="paramtype">const graph_t &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>arr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is a given arrangement valid? </p>
<p>Checks that an input arrangement is valid for the corresponding input graph. An arrangement is valid if it is a valid permutation of the vertices of the graph. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arr</td><td>Input arrangement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the input arrangement is a valid permutation. </dd></dl>

</div>
</div>
<a id="a073229916333514982d5f8766efb309f" name="a073229916333514982d5f8766efb309f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a073229916333514982d5f8766efb309f">&#9670;&#160;</a></span>is_bipartite() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::linarr::is_bipartite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>arr</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is a given arrangement bipartite? </p>
<p>See <a class="el" href="LAL_concepts.html#LAL_concepts__linear_arrangement__types">Types of arrangements</a> for the definition of bipartite arrangement.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input directed graph. </td></tr>
    <tr><td class="paramname">arr</td><td>Input linear arrangement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the input arrangment of <em>g</em> is bipartite. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The underlying undirected graph is bipartite, but needs not be connected. </dd></dl>

</div>
</div>
<a id="adf424d86b6efad382339fb9f93c771c4" name="adf424d86b6efad382339fb9f93c771c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf424d86b6efad382339fb9f93c771c4">&#9670;&#160;</a></span>is_bipartite() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::linarr::is_bipartite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1properties_1_1bipartite__graph__coloring.html">properties::bipartite_graph_coloring</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>arr</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is a given arrangement bipartite? </p>
<p>See <a class="el" href="LAL_concepts.html#LAL_concepts__linear_arrangement__types">Types of arrangements</a> for the definition of bipartite arrangement.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input directed graph. </td></tr>
    <tr><td class="paramname">c</td><td>Coloring of the input graph. </td></tr>
    <tr><td class="paramname">arr</td><td>Input linear arrangement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the input arrangment of <em>g</em> is bipartite. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The underlying undirected graph is bipartite and connected. </dd></dl>

</div>
</div>
<a id="a387dd45cbe5fdaba0ecd76f8ad057127" name="a387dd45cbe5fdaba0ecd76f8ad057127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a387dd45cbe5fdaba0ecd76f8ad057127">&#9670;&#160;</a></span>is_bipartite() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::linarr::is_bipartite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>arr</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is a given arrangement bipartite? </p>
<p>See <a class="el" href="LAL_concepts.html#LAL_concepts__linear_arrangement__types">Types of arrangements</a> for the definition of bipartite arrangement.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input undirected graph. </td></tr>
    <tr><td class="paramname">arr</td><td>Input linear arrangement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the input arrangment of <em>g</em> is bipartite. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The input graph is bipartite, and needs not be connected. </dd></dl>

</div>
</div>
<a id="abee7135280ad5d0c211fbf9008785d72" name="abee7135280ad5d0c211fbf9008785d72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abee7135280ad5d0c211fbf9008785d72">&#9670;&#160;</a></span>is_bipartite() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::linarr::is_bipartite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1properties_1_1bipartite__graph__coloring.html">properties::bipartite_graph_coloring</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>arr</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is a given arrangement bipartite? </p>
<p>See <a class="el" href="LAL_concepts.html#LAL_concepts__linear_arrangement__types">Types of arrangements</a> for the definition of bipartite arrangement.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input undirected graph. </td></tr>
    <tr><td class="paramname">c</td><td>Coloring of the input graph. </td></tr>
    <tr><td class="paramname">arr</td><td>Input linear arrangement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the input arrangment of <em>g</em> is bipartite. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The input graph is bipartite and connected. </dd></dl>

</div>
</div>
<a id="ad66ef36b5872e3de7c9add305352bfdd" name="ad66ef36b5872e3de7c9add305352bfdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad66ef36b5872e3de7c9add305352bfdd">&#9670;&#160;</a></span>is_num_crossings_lesseq_than() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lal::linarr::is_num_crossings_lesseq_than </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>G</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>arr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>upper_bound</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the number of crossings in the linear arrangement less than a constant? </p>
<p>Given a graph \(G\) and a linear arrangements \(\pi\) of its nodes, returns the number of edge crossings \(C_{\pi}(G)\) if it is less than or equal to the given upper bound constant \(u\). In case the number of crossings is greater, returns a value strictly larger than the upper bound. This function uses a modified version of the algorithm specified by the parameter <em>A</em>. The modification involves early termination in case the actual number of crossings is strictly larger than the upper bound. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arr</td><td>A linear arrangement of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
    <tr><td class="paramname">upper_bound</td><td>Upper bound on the number of crossings. </td></tr>
    <tr><td class="paramname">A</td><td>Algorithm to use to compute the number of crossings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of crossings \(C\) if said number is less than or equal to the upper bound. The function returns a value strictly larger than the upper bound if otherwise. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The preconditions of this function depend on the choice of algorithm. See the preconditions of each algorithm in <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">lal::linarr::algorithms_C</a>. </dd></dl>

</div>
</div>
<a id="acc11f3fe70559983423bbf39f6893104" name="acc11f3fe70559983423bbf39f6893104"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc11f3fe70559983423bbf39f6893104">&#9670;&#160;</a></span>is_num_crossings_lesseq_than() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lal::linarr::is_num_crossings_lesseq_than </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>G</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>upper_bound</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the number of crossings in the linear arrangement less than a constant? </p>
<p>Given a graph \(G\) computes the number of edge crossings using the identity arrangement \(\pi_I\), \(C_{\pi_I}(G)\), if it is less than or equal to the given upper bound constant \(u\). In case the number of crossings is greater, returns a value strictly larger than the upper bound. This function uses a modified version of the algorithm specified by the parameter <em>A</em>. The modification involves early termination in case the actual number of crossings is strictly larger than the upper bound. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>Input graph. </td></tr>
    <tr><td class="paramname">upper_bound</td><td>Upper bound on the number of crossings. </td></tr>
    <tr><td class="paramname">A</td><td>Algorithm to use to compute the number of crossings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of crossings \(C\) if said number is less than or equal to the upper bound. The function returns a value strictly larger than the upper bound if otherwise. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The preconditions of this function depend on the choice of algorithm. See the preconditions of each algorithm in <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">lal::linarr::algorithms_C</a>. </dd></dl>

</div>
</div>
<a id="a4fcbb92e98d7fce27bfc4d075a792c5c" name="a4fcbb92e98d7fce27bfc4d075a792c5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fcbb92e98d7fce27bfc4d075a792c5c">&#9670;&#160;</a></span>is_num_crossings_lesseq_than() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lal::linarr::is_num_crossings_lesseq_than </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>G</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>arr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>upper_bound</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the number of crossings in the linear arrangement less than a constant? </p>
<p>Given a graph \(G\) and a linear arrangements \(\pi\) of its nodes, returns the number of edge crossings \(C_{\pi}(G)\) if is less than or equal to the given upper bound constant \(u\). In case the number of crossings is greater, returns a value strictly larger than the upper bound. This function uses a modified version of the algorithm specified by the parameter <em>A</em>. The modification involves early termination in case the actual number of crossings is strictly larger than the upper bound. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arr</td><td>A linear arrangement of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
    <tr><td class="paramname">upper_bound</td><td>Upper bound on the number of crossings. </td></tr>
    <tr><td class="paramname">A</td><td>Algorithm to use to compute the number of crossings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of crossings \(C\) if said number is less than or equal to the upper bound. The function returns a value strictly larger than than the upper bound if otherwise. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The preconditions of this function depend on the choice of algorithm. See the preconditions of each algorithm in <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">lal::linarr::algorithms_C</a>. </dd></dl>

</div>
</div>
<a id="ae547be7d64c76708906e8751c361ce4a" name="ae547be7d64c76708906e8751c361ce4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae547be7d64c76708906e8751c361ce4a">&#9670;&#160;</a></span>is_num_crossings_lesseq_than() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lal::linarr::is_num_crossings_lesseq_than </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>G</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>upper_bound</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the number of crossings in the linear arrangement less than a constant? </p>
<p>Given a graph \(G\) computes the number of edge crossings using the identity arrangement \(\pi_I\), \(C_{\pi_I}(G)\), if it is less than or equal to the given upper bound constant \(u\). In case the number of crossings is greater, returns a value strictly larger than the upper bound. This function uses a modified version of the algorithm specified by the parameter <em>A</em>. The modification involves early termination in case the actual number of crossings is strictly larger than the upper bound. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>Input graph. </td></tr>
    <tr><td class="paramname">upper_bound</td><td>Upper bound on the number of crossings. </td></tr>
    <tr><td class="paramname">A</td><td>Algorithm to use to compute the number of crossings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of crossings \(C\) if said number is less than or equal to the upper bound. The function returns a value strictly larger than the upper bound if otherwise. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The preconditions of this function depend on the choice of algorithm. See the preconditions of each algorithm in <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">lal::linarr::algorithms_C</a>. </dd></dl>

</div>
</div>
<a id="ae06f54984c51091894dd9bb8946547f7" name="ae06f54984c51091894dd9bb8946547f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae06f54984c51091894dd9bb8946547f7">&#9670;&#160;</a></span>is_num_crossings_lesseq_than_list() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; uint64_t &gt; lal::linarr::is_num_crossings_lesseq_than_list </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>G</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>arrs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint64_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>upper_bounds</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the number of crossings in the linear arrangement less than a constant? </p>
<p>Given a graph \(G\), a list of linear arrangements \(L=\{\pi_i\}_{i=1}^k\) of its nodes and a list of upper bounds \(\{u_i\}_{i=1}^k\), computes the number of edge crossings for each of the linear arrangements \(\pi_i\) if that amount is less than or equal to the given upper bound \(u_i\), i.e., computes \(\{ f_i \}_{i=1}^k\), where \(f_i=C_{\pi_i}(G)\) if \(C_{\pi_i}(G)\le u_i\), or a value larger than \(u_i\) if \(C_{\pi_i}(G)&gt;u_i\). This function uses a modified version of the algorithm specified by the parameter <em>A</em>. The modification involves early termination in case the actual number of crossings is strictly larger than the upper bound. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arrs</td><td>A linear arrangement of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
    <tr><td class="paramname">upper_bounds</td><td>A list of upper bounds on the number of crossings for each linear arrangement. </td></tr>
    <tr><td class="paramname">A</td><td>Algorithm to use to compute the number of crossings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of crossings \(C\) if said number is less than or equal to the upper bound. The function returns a value strictly larger than the upper bound if otherwise. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>There must be as many linear arrangements as upper bounds. </dd>
<dd>
The preconditions of this function depend on the choice of algorithm. See the preconditions of each algorithm in <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">lal::linarr::algorithms_C</a>. </dd></dl>

</div>
</div>
<a id="a767ab48c6d71e287fbb1d06aa324435b" name="a767ab48c6d71e287fbb1d06aa324435b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a767ab48c6d71e287fbb1d06aa324435b">&#9670;&#160;</a></span>is_num_crossings_lesseq_than_list() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; uint64_t &gt; lal::linarr::is_num_crossings_lesseq_than_list </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>G</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>arrs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>upper_bound</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the number of crossings in the linear arrangement less than a constant? </p>
<p>Given a graph \(G\) and a list of linear arrangements \(L=\{\pi_i\}_{i=1}^k\) of its nodes, computes the number of edge crossings for each of the linear arrangements \(\pi_i\) if that amount is less than or equal to the given upper bound \(u\), i.e., computes \(\{f_i\}_{i=1}^k\), where \(f_i=C_{\pi_i}(G)\) if \(C_{\pi_i}(G)\le u\), or a value strictly larger than the upper bound \(u\) if \(C_{\pi_i}(G)&gt;u\). This function uses a modified version of the algorithm specified by the parameter <em>A</em>. The modification involves early termination in case the actual number of crossings is strictly larger than the upper bound. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arrs</td><td>A linear arrangement of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
    <tr><td class="paramname">upper_bound</td><td>Upper bound on the number of crossings. </td></tr>
    <tr><td class="paramname">A</td><td>Algorithm to use to compute the number of crossings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of crossings \(C\) if said number is less than or equal to the upper bound. The function returns a value strictly larger than the upper bound if otherwise. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The preconditions of this function depend on the choice of algorithm. See the preconditions of each algorithm in <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">lal::linarr::algorithms_C</a>. </dd></dl>

</div>
</div>
<a id="a406b2456d635ac4efcbd7ed7270bf173" name="a406b2456d635ac4efcbd7ed7270bf173"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a406b2456d635ac4efcbd7ed7270bf173">&#9670;&#160;</a></span>is_num_crossings_lesseq_than_list() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; uint64_t &gt; lal::linarr::is_num_crossings_lesseq_than_list </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>G</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>arrs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint64_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>upper_bounds</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the number of crossings in the linear arrangement less than a constant? </p>
<p>Given a graph \(G\), a list of linear arrangements \(L=\{\pi_i\}_{i=1}^k\) of its nodes and a list of upper bounds \(\{u_i\}_{i=1}^k\), computes the number of edge crossings for each of the linear arrangements \(\pi_i\) if that amount is less than or equal to the given upper bound \(u_i\), i.e., computes \(\{ f_i \}_{i=1}^k\), where \(f_i=C_{\pi_i}(G)\) if \(C_{\pi_i}(G)\le u_i\), or \(f_i&gt;m^2\) if \(C_{\pi_i}(G)&gt;u_i\). This function uses a modified version of the algorithm specified by the parameter <em>A</em>. The modification involves early termination in case the actual number of crossings is strictly larger than the upper bound. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arrs</td><td>A linear arrangement of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
    <tr><td class="paramname">upper_bounds</td><td>A list of upper bounds on the number of crossings for each linear arrangement. </td></tr>
    <tr><td class="paramname">A</td><td>Algorithm to use to compute the number of crossings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of crossings \(C\) if said number is less than or equal to the upper bound. The function returns a value strictly larger than the upper bound if otherwise. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>There must be as many linear arrangements as upper bounds. </dd>
<dd>
The preconditions of this function depend on the choice of algorithm. See the preconditions of each algorithm in <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">lal::linarr::algorithms_C</a>. </dd></dl>

</div>
</div>
<a id="a5fa0c34487537ec8fd7e7bccb769b294" name="a5fa0c34487537ec8fd7e7bccb769b294"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fa0c34487537ec8fd7e7bccb769b294">&#9670;&#160;</a></span>is_num_crossings_lesseq_than_list() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; uint64_t &gt; lal::linarr::is_num_crossings_lesseq_than_list </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>G</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>arrs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>upper_bound</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the number of crossings in the linear arrangement less than a constant? </p>
<p>Given a graph \(G\) and a list of linear arrangements \(L=\{\pi_i\}_{i=1}^k\) of its nodes, computes the number of edge crossings for each of the linear arrangements \(\pi_i\) if that amount is less than or equal to the given upper bound \(u\), i.e., computes \(\{f_i\}_{i=1}^k\), where \(f_i=C_{\pi_i}(G)\) if \(C_{\pi_i}(G)\le u\), or \(f_i&gt;m^2\) if \(C_{\pi_i}(G)&gt;u\). This function uses a modified version of the algorithm specified by the parameter <em>A</em>. The modification involves early termination in case the actual number of crossings is strictly larger than the upper bound. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arrs</td><td>A linear arrangement of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
    <tr><td class="paramname">upper_bound</td><td>Upper bound on the number of crossings. </td></tr>
    <tr><td class="paramname">A</td><td>Algorithm to use to compute the number of crossings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of crossings \(C\) if said number is less than or equal to the upper bound. The function returns a value strictly larger than the upper bound if otherwise. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The preconditions of this function depend on the choice of algorithm. See the preconditions of each algorithm in <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">lal::linarr::algorithms_C</a>. </dd></dl>

</div>
</div>
<a id="a6b3203432e13dfec29563796643e6187" name="a6b3203432e13dfec29563796643e6187"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b3203432e13dfec29563796643e6187">&#9670;&#160;</a></span>is_permutation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::linarr::is_permutation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>arr</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is a given input arrangement a permutation? </p>
<p>A linear arrangement is a permutation if all the positions are numbers in \([0,n-1]\), where \(n\) denotes the size of the arrangement and if no two numbers appear twice in the arrangement. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>Input linear arrangement </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the input arrangement is a valid permutation. </dd></dl>

</div>
</div>
<a id="aaeb1b7dcc4cda2e1c366e02b2d03c627" name="aaeb1b7dcc4cda2e1c366e02b2d03c627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeb1b7dcc4cda2e1c366e02b2d03c627">&#9670;&#160;</a></span>is_planar()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class graph_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::linarr::is_planar </td>
          <td>(</td>
          <td class="paramtype">const graph_t &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>arr</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is a given arrangement planar? </p>
<p>See <a class="el" href="LAL_concepts.html#LAL_concepts__linear_arrangement__types">Types of arrangements</a> for the definition of planar arrangement.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arr</td><td>Input linear arrangement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the input arrangment of <em>g</em> is planar. </dd></dl>

</div>
</div>
<a id="ae404b93b3b1730f61299f78f4ba89585" name="ae404b93b3b1730f61299f78f4ba89585"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae404b93b3b1730f61299f78f4ba89585">&#9670;&#160;</a></span>is_projective()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::linarr::is_projective </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>arr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is a given arrangement projective? </p>
<p>See <a class="el" href="LAL_concepts.html#LAL_concepts__linear_arrangement__types">Types of arrangements</a> for the definition of projective arrangement.</p>
<p>If the input arrangement is empty then the identity arrangement \(\pi_I\) is used. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rt</td><td>Input rooted tree </td></tr>
    <tr><td class="paramname">arr</td><td>Input linear arrangement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the input arrangment of <em>rt</em> is projective. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The input rooted tree must be a valid rooted tree (see <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#af464d98b1b5dfdbaaacea553d9c89154">lal::graphs::rooted_tree::is_rooted_tree</a>). </dd></dl>

</div>
</div>
<a id="a78b17d7726acf0ce82625c3d13987bfa" name="a78b17d7726acf0ce82625c3d13987bfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78b17d7726acf0ce82625c3d13987bfa">&#9670;&#160;</a></span>is_root_covered()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool lal::linarr::is_root_covered </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>arr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the root of a rooted tree covered in a given arrangement? </p>
<p>See <a class="el" href="LAL_concepts.html#LAL_concepts__linear_arrangement__properties">Properties that can be defined in linear arrangements</a> for the definition of vertex covering.</p>
<p>If the input arrangement is empty then the identity arrangement \(\pi_I\) is used. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rt</td><td>Input rooted tree </td></tr>
    <tr><td class="paramname">arr</td><td>Input linear arrangement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the root is covered in the given arrangement. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The input rooted tree must be a valid rooted tree (see <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#af464d98b1b5dfdbaaacea553d9c89154">lal::graphs::rooted_tree::is_rooted_tree</a>). </dd></dl>

</div>
</div>
<a id="aef106fb90f318c4b87d37b8b8df14b14" name="aef106fb90f318c4b87d37b8b8df14b14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef106fb90f318c4b87d37b8b8df14b14">&#9670;&#160;</a></span>make_tree_from_chunk_sequence()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> lal::linarr::make_tree_from_chunk_sequence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linarr_1_1chunk__sequence.html">chunk_sequence</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>seq</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a rooted tree from the given chunk sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seq</td><td>Chunk sequence </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A rooted tree. </dd></dl>

</div>
</div>
<a id="a9c405d6ac3dee765c48402faf922d706" name="a9c405d6ac3dee765c48402faf922d706"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c405d6ac3dee765c48402faf922d706">&#9670;&#160;</a></span>max_sum_edge_lengths_1_eq_thistle() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; uint64_t, <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; lal::linarr::max_sum_edge_lengths_1_eq_thistle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the solution to \(=1\)-thistle MaxLA. </p>
<p>It computes a maximal non-bipartite arrangement of a tree constrained to the arrangement having only one thistle vertex. This function implements the algorithm described in <a class="el" href="citelist.html#CITEREF_Alemany2023a">[7]</a>.</p>
<p>See <a class="el" href="LAL_concepts.html#LAL_concepts__linear_arrangement__types">Types of arrangements</a> for the definition of bipartite arrangement. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input free tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Input tree <em>t</em> must be a valid tree (see <a class="el" href="classlal_1_1graphs_1_1tree.html#a25c8d57865fa5f7cb5d101fd5d07fe2d">lal::graphs::tree::is_tree</a>). </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A maximal non-bipartite arrangement with exactly one thistle vertex. </dd></dl>

</div>
</div>
<a id="a78ceee860452715ca4739adc28e53226" name="a78ceee860452715ca4739adc28e53226"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78ceee860452715ca4739adc28e53226">&#9670;&#160;</a></span>max_sum_edge_lengths_1_eq_thistle() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; uint64_t, <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; lal::linarr::max_sum_edge_lengths_1_eq_thistle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classlal_1_1properties_1_1branchless__path.html">properties::branchless_path</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>bps</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the solution to \(=1\)-thistle MaxLA. </p>
<p>It computes a maximal either bipartite or non-bipartite arrangement of a tree constrained to having at most one thistle vertex. This function implements the algorithm described in <a class="el" href="citelist.html#CITEREF_Alemany2023a">[7]</a>.</p>
<p>See <a class="el" href="LAL_concepts.html#LAL_concepts__linear_arrangement__types">Types of arrangements</a> for the definition of bipartite arrangement. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input free tree. </td></tr>
    <tr><td class="paramname">bps</td><td>All branchless paths of the tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A maximal arrangement with at most one thistle vertex. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Input tree <em>t</em> must be a valid tree (see <a class="el" href="classlal_1_1graphs_1_1tree.html#a25c8d57865fa5f7cb5d101fd5d07fe2d">lal::graphs::tree::is_tree</a>). </dd></dl>

</div>
</div>
<a id="a828b5f04d55df1ac45ab686d7396ee0b" name="a828b5f04d55df1ac45ab686d7396ee0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a828b5f04d55df1ac45ab686d7396ee0b">&#9670;&#160;</a></span>max_sum_edge_lengths_1_le_thistle() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; uint64_t, <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; lal::linarr::max_sum_edge_lengths_1_le_thistle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the solution to \(\le1\)-thistle MaxLA. </p>
<p>It computes a maximal either bipartite or non-bipartite arrangement of a tree constrained to having at most one thistle vertex. This function implements the algorithm described in <a class="el" href="citelist.html#CITEREF_Alemany2023a">[7]</a>.</p>
<p>See <a class="el" href="LAL_concepts.html#LAL_concepts__linear_arrangement__types">Types of arrangements</a> for the definition of bipartite arrangement. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input free tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A maximal arrangement with at most one thistle vertex. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Input tree <em>t</em> must be a valid tree (see <a class="el" href="classlal_1_1graphs_1_1tree.html#a25c8d57865fa5f7cb5d101fd5d07fe2d">lal::graphs::tree::is_tree</a>). </dd></dl>

</div>
</div>
<a id="abfa7344412a999dec210f438a73a7886" name="abfa7344412a999dec210f438a73a7886"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfa7344412a999dec210f438a73a7886">&#9670;&#160;</a></span>max_sum_edge_lengths_1_le_thistle() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; uint64_t, <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; lal::linarr::max_sum_edge_lengths_1_le_thistle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1properties_1_1bipartite__graph__coloring.html">properties::bipartite_graph_coloring</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the solution to \(\le 1\)-thistle MaxLA. </p>
<p>It computes a maximal either bipartite or non-bipartite arrangement of a tree constrained to having at most one thistle vertex. This function implements the algorithm described in <a class="el" href="citelist.html#CITEREF_Alemany2023a">[7]</a>.</p>
<p>See <a class="el" href="LAL_concepts.html#LAL_concepts__linear_arrangement__types">Types of arrangements</a> for the definition of bipartite arrangement. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input free tree. </td></tr>
    <tr><td class="paramname">c</td><td>Bipartite coloring of the input tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A maximal arrangement with at most one thistle vertex. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Input tree <em>t</em> must be a valid tree (see <a class="el" href="classlal_1_1graphs_1_1tree.html#a25c8d57865fa5f7cb5d101fd5d07fe2d">lal::graphs::tree::is_tree</a>). </dd></dl>

</div>
</div>
<a id="a7c8fab121c5848258cca520291219485" name="a7c8fab121c5848258cca520291219485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c8fab121c5848258cca520291219485">&#9670;&#160;</a></span>max_sum_edge_lengths_1_le_thistle() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; uint64_t, <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; lal::linarr::max_sum_edge_lengths_1_le_thistle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1properties_1_1bipartite__graph__coloring.html">properties::bipartite_graph_coloring</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classlal_1_1properties_1_1branchless__path.html">properties::branchless_path</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>bps</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the solution to \(\le 1\)-thistle MaxLA. </p>
<p>It computes a maximal either bipartite or non-bipartite arrangement of a tree constrained to having at most one thistle vertex. This function implements the algorithm described in <a class="el" href="citelist.html#CITEREF_Alemany2023a">[7]</a>.</p>
<p>See <a class="el" href="LAL_concepts.html#LAL_concepts__linear_arrangement__types">Types of arrangements</a> for the definition of bipartite arrangement. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input free tree. </td></tr>
    <tr><td class="paramname">c</td><td>Bipartite coloring of the input tree. </td></tr>
    <tr><td class="paramname">bps</td><td>All branchless paths of the tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A maximal arrangement with at most one thistle vertex. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Input tree <em>t</em> must be a valid tree (see <a class="el" href="classlal_1_1graphs_1_1tree.html#a25c8d57865fa5f7cb5d101fd5d07fe2d">lal::graphs::tree::is_tree</a>). </dd></dl>

</div>
</div>
<a id="a960914f91aa21cad269a9e5337ed0e57" name="a960914f91aa21cad269a9e5337ed0e57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a960914f91aa21cad269a9e5337ed0e57">&#9670;&#160;</a></span>max_sum_edge_lengths_1_le_thistle() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; uint64_t, <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; lal::linarr::max_sum_edge_lengths_1_le_thistle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classlal_1_1properties_1_1branchless__path.html">properties::branchless_path</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>bps</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the solution to \(\le 1\)-thistle MaxLA. </p>
<p>It computes a maximal either bipartite or non-bipartite arrangement of a tree constrained to having at most one thistle vertex. This function implements the algorithm described in <a class="el" href="citelist.html#CITEREF_Alemany2023a">[7]</a>.</p>
<p>See <a class="el" href="LAL_concepts.html#LAL_concepts__linear_arrangement__types">Types of arrangements</a> for the definition of bipartite arrangement. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input free tree. </td></tr>
    <tr><td class="paramname">bps</td><td>All branchless paths of the tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Input tree <em>t</em> must be a valid tree (see <a class="el" href="classlal_1_1graphs_1_1tree.html#a25c8d57865fa5f7cb5d101fd5d07fe2d">lal::graphs::tree::is_tree</a>). </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A maximal arrangement with at most one thistle vertex. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Input tree <em>t</em> must be a valid tree (see <a class="el" href="classlal_1_1graphs_1_1tree.html#a25c8d57865fa5f7cb5d101fd5d07fe2d">lal::graphs::tree::is_tree</a>). </dd></dl>

</div>
</div>
<a id="ad717598c95a01c00d5278ca6e7e24c1d" name="ad717598c95a01c00d5278ca6e7e24c1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad717598c95a01c00d5278ca6e7e24c1d">&#9670;&#160;</a></span>max_sum_edge_lengths_all() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; uint64_t, std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &gt; lal::linarr::max_sum_edge_lengths_all </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1properties_1_1bipartite__graph__coloring.html">properties::bipartite_graph_coloring</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>num_threads</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates all the linear arrangements that yield the maximum sum of edge lengths. </p>
<p>This function runs a Branch and Bound algorithm that finds al arrangements (up to level isomorphism) that yield the maximum sum of edge lengths over the entire set of \(n!\) arrangements.</p>
<p>This function implements the Branch and Bound algorithm described in <a class="el" href="citelist.html#CITEREF_Alemany2023a">[7]</a>.</p>
<p>See <a class="el" href="LAL_concepts.html#LAL_concepts__linear_arrangement__isomorphism">Arrangement isomorphism</a> for the definition of level isomorphism. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input free tree. </td></tr>
    <tr><td class="paramname">c</td><td>Bipartite coloring of the input tree. </td></tr>
    <tr><td class="paramname">num_threads</td><td>Number of threads to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>All maximum arrangements up to level isomorphism. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Input tree <em>t</em> must be a valid tree (see <a class="el" href="classlal_1_1graphs_1_1tree.html#a25c8d57865fa5f7cb5d101fd5d07fe2d">lal::graphs::tree::is_tree</a>). </dd></dl>

</div>
</div>
<a id="a05e5c47f61a0f13559aeca60212f6466" name="a05e5c47f61a0f13559aeca60212f6466"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05e5c47f61a0f13559aeca60212f6466">&#9670;&#160;</a></span>max_sum_edge_lengths_all() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; uint64_t, std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &gt; lal::linarr::max_sum_edge_lengths_all </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1properties_1_1bipartite__graph__coloring.html">properties::bipartite_graph_coloring</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classlal_1_1properties_1_1branchless__path.html">properties::branchless_path</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>bps</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>num_threads</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates all the linear arrangements that yield the maximum sum of edge lengths. </p>
<p>This function runs a Branch and Bound algorithm that finds al arrangements (up to level isomorphism) that yield the maximum sum of edge lengths over the entire set of \(n!\) arrangements.</p>
<p>This function implements the Branch and Bound algorithm described in <a class="el" href="citelist.html#CITEREF_Alemany2023a">[7]</a>.</p>
<p>See <a class="el" href="LAL_concepts.html#LAL_concepts__linear_arrangement__isomorphism">Arrangement isomorphism</a> for the definition of level isomorphism. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input free tree. </td></tr>
    <tr><td class="paramname">c</td><td>Bipartite coloring of the input tree. </td></tr>
    <tr><td class="paramname">bps</td><td>All branchless paths of the tree. </td></tr>
    <tr><td class="paramname">num_threads</td><td>Number of threads to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>All maximum arrangements up to level isomorphism. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Input tree <em>t</em> must be a valid tree (see <a class="el" href="classlal_1_1graphs_1_1tree.html#a25c8d57865fa5f7cb5d101fd5d07fe2d">lal::graphs::tree::is_tree</a>). </dd></dl>

</div>
</div>
<a id="a642b9f5697f7c9933b9b5c7424fed6e0" name="a642b9f5697f7c9933b9b5c7424fed6e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a642b9f5697f7c9933b9b5c7424fed6e0">&#9670;&#160;</a></span>max_sum_edge_lengths_all() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; uint64_t, std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &gt; lal::linarr::max_sum_edge_lengths_all </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>num_threads</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates all the linear arrangements that yield the maximum sum of edge lengths. </p>
<p>This function runs a Branch and Bound algorithm that finds al arrangements (up to level isomorphism) that yield the maximum sum of edge lengths over the entire set of \(n!\) arrangements.</p>
<p>This function implements the Branch and Bound algorithm described in <a class="el" href="citelist.html#CITEREF_Alemany2023a">[7]</a>.</p>
<p>See <a class="el" href="LAL_concepts.html#LAL_concepts__linear_arrangement__isomorphism">Arrangement isomorphism</a> for the definition of level isomorphism. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input free tree. </td></tr>
    <tr><td class="paramname">num_threads</td><td>Number of threads to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>All maximum arrangements up to level isomorphism. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Input tree <em>t</em> must be a valid tree (see <a class="el" href="classlal_1_1graphs_1_1tree.html#a25c8d57865fa5f7cb5d101fd5d07fe2d">lal::graphs::tree::is_tree</a>). </dd></dl>

</div>
</div>
<a id="a31240c715bf8e46c4ca107db5f844881" name="a31240c715bf8e46c4ca107db5f844881"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31240c715bf8e46c4ca107db5f844881">&#9670;&#160;</a></span>max_sum_edge_lengths_all() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; uint64_t, std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &gt; lal::linarr::max_sum_edge_lengths_all </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classlal_1_1properties_1_1branchless__path.html">properties::branchless_path</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>bps</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>num_threads</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates all the linear arrangements that yield the maximum sum of edge lengths. </p>
<p>This function runs a Branch and Bound algorithm that finds al arrangements (up to level isomorphism) that yield the maximum sum of edge lengths over the entire set of \(n!\) arrangements.</p>
<p>This function implements the Branch and Bound algorithm described in <a class="el" href="citelist.html#CITEREF_Alemany2023a">[7]</a>.</p>
<p>See <a class="el" href="LAL_concepts.html#LAL_concepts__linear_arrangement__isomorphism">Arrangement isomorphism</a> for the definition of level isomorphism. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input free tree. </td></tr>
    <tr><td class="paramname">bps</td><td>All branchless paths of the tree. </td></tr>
    <tr><td class="paramname">num_threads</td><td>Number of threads to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>All maximum arrangements up to level isomorphism. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Input tree <em>t</em> must be a valid tree (see <a class="el" href="classlal_1_1graphs_1_1tree.html#a25c8d57865fa5f7cb5d101fd5d07fe2d">lal::graphs::tree::is_tree</a>). </dd></dl>

</div>
</div>
<a id="ac087d62d5e2507a5b8218eb63c09cc04" name="ac087d62d5e2507a5b8218eb63c09cc04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac087d62d5e2507a5b8218eb63c09cc04">&#9670;&#160;</a></span>max_sum_edge_lengths_all() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; uint64_t, std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &gt; lal::linarr::max_sum_edge_lengths_all </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>orbits</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1properties_1_1bipartite__graph__coloring.html">properties::bipartite_graph_coloring</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>num_threads</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates all the linear arrangements that yield the maximum sum of edge lengths. </p>
<p>This function runs a Branch and Bound algorithm that finds al arrangements (up to level isomorphism) that yield the maximum sum of edge lengths over the entire set of \(n!\) arrangements.</p>
<p>This function implements the Branch and Bound algorithm described in <a class="el" href="citelist.html#CITEREF_Alemany2023a">[7]</a>.</p>
<p>See <a class="el" href="LAL_concepts.html#LAL_concepts__linear_arrangement__isomorphism">Arrangement isomorphism</a> for the definition of level isomorphism. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input free tree. </td></tr>
    <tr><td class="paramname">orbits</td><td>The orbits of the input graph. </td></tr>
    <tr><td class="paramname">c</td><td>Bipartite coloring of the input tree. </td></tr>
    <tr><td class="paramname">num_threads</td><td>Number of threads to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>All maximum arrangements up to level isomorphism. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Input tree <em>t</em> must be a valid tree (see <a class="el" href="classlal_1_1graphs_1_1tree.html#a25c8d57865fa5f7cb5d101fd5d07fe2d">lal::graphs::tree::is_tree</a>). </dd></dl>

</div>
</div>
<a id="a6fcc4229c7e0af8e9232d898345bba84" name="a6fcc4229c7e0af8e9232d898345bba84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fcc4229c7e0af8e9232d898345bba84">&#9670;&#160;</a></span>max_sum_edge_lengths_all() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; uint64_t, std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &gt; lal::linarr::max_sum_edge_lengths_all </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>orbits</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1properties_1_1bipartite__graph__coloring.html">properties::bipartite_graph_coloring</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classlal_1_1properties_1_1branchless__path.html">properties::branchless_path</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>bps</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>num_threads</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates all the linear arrangements that yield the maximum sum of edge lengths. </p>
<p>This function runs a Branch and Bound algorithm that finds al arrangements (up to level isomorphism) that yield the maximum sum of edge lengths over the entire set of \(n!\) arrangements.</p>
<p>This function implements the Branch and Bound algorithm described in <a class="el" href="citelist.html#CITEREF_Alemany2023a">[7]</a>.</p>
<p>See <a class="el" href="LAL_concepts.html#LAL_concepts__linear_arrangement__isomorphism">Arrangement isomorphism</a> for the definition of level isomorphism. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input free tree. </td></tr>
    <tr><td class="paramname">orbits</td><td>The orbits of the input graph. </td></tr>
    <tr><td class="paramname">c</td><td>Bipartite coloring of the input tree. </td></tr>
    <tr><td class="paramname">bps</td><td>All branchless paths of the tree. </td></tr>
    <tr><td class="paramname">num_threads</td><td>Number of threads to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>All maximum arrangements up to level isomorphism. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Input tree <em>t</em> must be a valid tree (see <a class="el" href="classlal_1_1graphs_1_1tree.html#a25c8d57865fa5f7cb5d101fd5d07fe2d">lal::graphs::tree::is_tree</a>). </dd></dl>

</div>
</div>
<a id="a908aa23d4e14bc8705e387394f2f0ce6" name="a908aa23d4e14bc8705e387394f2f0ce6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a908aa23d4e14bc8705e387394f2f0ce6">&#9670;&#160;</a></span>max_sum_edge_lengths_all() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; uint64_t, std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &gt; lal::linarr::max_sum_edge_lengths_all </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>orbits</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>num_threads</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates all the linear arrangements that yield the maximum sum of edge lengths. </p>
<p>This function runs a Branch and Bound algorithm that finds al arrangements (up to level isomorphism) that yield the maximum sum of edge lengths over the entire set of \(n!\) arrangements.</p>
<p>This function implements the Branch and Bound algorithm described in <a class="el" href="citelist.html#CITEREF_Alemany2023a">[7]</a>.</p>
<p>See <a class="el" href="LAL_concepts.html#LAL_concepts__linear_arrangement__isomorphism">Arrangement isomorphism</a> for the definition of level isomorphism. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input free tree. </td></tr>
    <tr><td class="paramname">orbits</td><td>The orbits of the input graph. </td></tr>
    <tr><td class="paramname">num_threads</td><td>Number of threads to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>All maximum arrangements up to level isomorphism. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Input tree <em>t</em> must be a valid tree (see <a class="el" href="classlal_1_1graphs_1_1tree.html#a25c8d57865fa5f7cb5d101fd5d07fe2d">lal::graphs::tree::is_tree</a>). </dd></dl>

</div>
</div>
<a id="a71300d3bd6cc55fe943d5be45640f5cf" name="a71300d3bd6cc55fe943d5be45640f5cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71300d3bd6cc55fe943d5be45640f5cf">&#9670;&#160;</a></span>max_sum_edge_lengths_all() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; uint64_t, std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &gt; lal::linarr::max_sum_edge_lengths_all </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>orbits</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classlal_1_1properties_1_1branchless__path.html">properties::branchless_path</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>bps</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>num_threads</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates all the linear arrangements that yield the maximum sum of edge lengths. </p>
<p>This function runs a Branch and Bound algorithm that finds al arrangements (up to level isomorphism) that yield the maximum sum of edge lengths over the entire set of \(n!\) arrangements.</p>
<p>This function implements the Branch and Bound algorithm described in <a class="el" href="citelist.html#CITEREF_Alemany2023a">[7]</a>.</p>
<p>See <a class="el" href="LAL_concepts.html#LAL_concepts__linear_arrangement__isomorphism">Arrangement isomorphism</a> for the definition of level isomorphism. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input free tree. </td></tr>
    <tr><td class="paramname">orbits</td><td>The orbits of the input graph. </td></tr>
    <tr><td class="paramname">bps</td><td>All branchless paths of the tree. </td></tr>
    <tr><td class="paramname">num_threads</td><td>Number of threads to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>All maximum arrangements up to level isomorphism. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Input tree <em>t</em> must be a valid tree (see <a class="el" href="classlal_1_1graphs_1_1tree.html#a25c8d57865fa5f7cb5d101fd5d07fe2d">lal::graphs::tree::is_tree</a>). </dd></dl>

</div>
</div>
<a id="a9229a1219e31cef1d5964af6a3283e19" name="a9229a1219e31cef1d5964af6a3283e19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9229a1219e31cef1d5964af6a3283e19">&#9670;&#160;</a></span>max_sum_edge_lengths_bipartite() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; uint64_t, <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; lal::linarr::max_sum_edge_lengths_bipartite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the solution to Bipartite MaxLA as defined in <a class="el" href="citelist.html#CITEREF_Alemany2024a">[8]</a>. </p>
<p>It computes a maximal bipartite arrangement of a bipartite graph. This function implements the algorithm described in <a class="el" href="citelist.html#CITEREF_Alemany2023a">[7]</a>.</p>
<p>See <a class="el" href="LAL_concepts.html#LAL_concepts__linear_arrangement__types">Types of arrangements</a> for the definition of bipartite arrangement.</p>
<p>This function converts the input rooted into a free tree (see <a class="el" href="classlal_1_1graphs_1_1directed__graph.html#ad7bfd2d96d5110a7bf0d56c4df1618fd">lal::graphs::directed_graph::to_undirected()</a>) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input directed graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A maximal bipartite arrangement. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The input graph <em>g</em> is a connected bipartite graph (ignoring orientation of edges). </dd></dl>

</div>
</div>
<a id="abca71b14ed3772dcf7a7b714cc7c5a00" name="abca71b14ed3772dcf7a7b714cc7c5a00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abca71b14ed3772dcf7a7b714cc7c5a00">&#9670;&#160;</a></span>max_sum_edge_lengths_bipartite() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; uint64_t, <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; lal::linarr::max_sum_edge_lengths_bipartite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1properties_1_1bipartite__graph__coloring.html">properties::bipartite_graph_coloring</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the solution to Bipartite MaxLA as defined in <a class="el" href="citelist.html#CITEREF_Alemany2024a">[8]</a>. </p>
<p>It computes a maximal bipartite arrangement of a bipartite graph. This function implements the algorithm described in <a class="el" href="citelist.html#CITEREF_Alemany2023a">[7]</a>.</p>
<p>See <a class="el" href="LAL_concepts.html#LAL_concepts__linear_arrangement__types">Types of arrangements</a> for the definition of bipartite arrangement.</p>
<p>This function converts the input directed graph into an undirected graph (see <a class="el" href="classlal_1_1graphs_1_1directed__graph.html#ad7bfd2d96d5110a7bf0d56c4df1618fd">lal::graphs::directed_graph::to_undirected()</a>). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input directed graph. </td></tr>
    <tr><td class="paramname">c</td><td>Coloring of the input graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A maximal bipartite arrangement. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The input graph <em>g</em> is a connected bipartite graph (ignoring orientation of edges). </dd></dl>

</div>
</div>
<a id="a45de867badd5a87cd98e66cd47da4d2d" name="a45de867badd5a87cd98e66cd47da4d2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45de867badd5a87cd98e66cd47da4d2d">&#9670;&#160;</a></span>max_sum_edge_lengths_bipartite() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; uint64_t, <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; lal::linarr::max_sum_edge_lengths_bipartite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the solution to Bipartite MaxLA as defined in <a class="el" href="citelist.html#CITEREF_Alemany2024a">[8]</a>. </p>
<p>It computes a maximal bipartite arrangement of a bipartite graph. This function implements the algorithm described in <a class="el" href="citelist.html#CITEREF_Alemany2023a">[7]</a>.</p>
<p>See <a class="el" href="LAL_concepts.html#LAL_concepts__linear_arrangement__types">Types of arrangements</a> for the definition of bipartite arrangement. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input undirected graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A maximal bipartite arrangement. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The input graph <em>g</em> is a connected bipartite graph. </dd></dl>

</div>
</div>
<a id="a19e9a8803e21a8cfdef8f2f327e4a1ae" name="a19e9a8803e21a8cfdef8f2f327e4a1ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19e9a8803e21a8cfdef8f2f327e4a1ae">&#9670;&#160;</a></span>max_sum_edge_lengths_bipartite() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; uint64_t, <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; lal::linarr::max_sum_edge_lengths_bipartite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1properties_1_1bipartite__graph__coloring.html">properties::bipartite_graph_coloring</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the solution to Bipartite MaxLA as defined in <a class="el" href="citelist.html#CITEREF_Alemany2024a">[8]</a>. </p>
<p>It computes a maximal bipartite arrangement of a bipartite graph. This function implements the algorithm described in <a class="el" href="citelist.html#CITEREF_Alemany2023a">[7]</a>.</p>
<p>See <a class="el" href="LAL_concepts.html#LAL_concepts__linear_arrangement__types">Types of arrangements</a> for the definition of bipartite arrangement. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input undirected graph. </td></tr>
    <tr><td class="paramname">c</td><td>Coloring of the input graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A maximal bipartite arrangement. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The input graph <em>g</em> is a connected bipartite graph. </dd></dl>

</div>
</div>
<a id="aadd6d6ed9cadb57228200d32c3a99191" name="aadd6d6ed9cadb57228200d32c3a99191"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadd6d6ed9cadb57228200d32c3a99191">&#9670;&#160;</a></span>max_sum_edge_lengths_planar() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; uint64_t, <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; lal::linarr::max_sum_edge_lengths_planar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the maximum value of \(D\) in trees under the planarity constraint. </p>
<p>Calculates the maximum value of \(D\) over all planar arrangements of the input tree. This function also returns the linear arrangement that yields the maximum value. The caller can choose the algorithm to calculate such maximum value.</p>
<p>See <a class="el" href="LAL_concepts.html#LAL_concepts__linear_arrangement__types">Types of arrangements</a> for the definition of planar arrangement.</p>
<p>This function implements the algorithm described in <a class="el" href="citelist.html#CITEREF_Alemany2024a">[8]</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input free tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The maximum value of \(D\) and a maximum arrangement. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Input tree <em>t</em> must be a valid tree (see <a class="el" href="classlal_1_1graphs_1_1tree.html#a25c8d57865fa5f7cb5d101fd5d07fe2d">lal::graphs::tree::is_tree</a>). </dd></dl>

</div>
</div>
<a id="a95e4fa9607ca43dfe0ba110eb9e2ddd7" name="a95e4fa9607ca43dfe0ba110eb9e2ddd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95e4fa9607ca43dfe0ba110eb9e2ddd7">&#9670;&#160;</a></span>max_sum_edge_lengths_planar() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; uint64_t, <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; lal::linarr::max_sum_edge_lengths_planar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the maximum value of \(D\) in trees under the planarity constraint. </p>
<p>Calculates the maximum value of \(D\) over all planar arrangements of the input tree. This function also returns the linear arrangement that yields the maximum value. The caller can choose the algorithm to calculate such maximum value.</p>
<p>See <a class="el" href="LAL_concepts.html#LAL_concepts__linear_arrangement__types">Types of arrangements</a> for the definition of planar arrangement.</p>
<p>This function implements the algorithm described in <a class="el" href="citelist.html#CITEREF_Alemany2024a">[8]</a>.</p>
<p>This function converts the input rooted tree into a free tree (see <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#a0600daeeb3542446c6c8d8299d7fffa6">lal::graphs::rooted_tree::to_free_tree()</a>) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input rooted tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The maximum value of \(D\) and a maximum arrangement. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Input tree <em>t</em> must be a valid tree (see <a class="el" href="classlal_1_1graphs_1_1tree.html#a25c8d57865fa5f7cb5d101fd5d07fe2d">lal::graphs::tree::is_tree</a>). </dd></dl>

</div>
</div>
<a id="a0886a4326be3b40cf34ee526514d60ab" name="a0886a4326be3b40cf34ee526514d60ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0886a4326be3b40cf34ee526514d60ab">&#9670;&#160;</a></span>max_sum_edge_lengths_projective()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; uint64_t, <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; lal::linarr::max_sum_edge_lengths_projective </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the maximum value of \(D\) in rooted trees under the projectivity constraint. </p>
<p>Calculates the maximum value of \(D\) over all projective arrangements of the input tree. This function also returns the linear arrangement that yields the maximum value. The caller can choose the algorithm to calculate such maximum value.</p>
<p>See <a class="el" href="LAL_concepts.html#LAL_concepts__linear_arrangement__types">Types of arrangements</a> for the definition of projective arrangement.</p>
<p>This function implements the algorithm described in <a class="el" href="citelist.html#CITEREF_Alemany2024a">[8]</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input rooted tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The maximum value of \(D\) and a maximum arrangement. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Input tree <em>t</em> must be a valid tree (see <a class="el" href="classlal_1_1graphs_1_1tree.html#a25c8d57865fa5f7cb5d101fd5d07fe2d">lal::graphs::tree::is_tree</a>). </dd></dl>

</div>
</div>
<a id="a605f9fb7f2214a6dfd4021c12134a85c" name="a605f9fb7f2214a6dfd4021c12134a85c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a605f9fb7f2214a6dfd4021c12134a85c">&#9670;&#160;</a></span>max_sum_edge_lengths_projective_roots() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; uint64_t &gt;, <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> &gt; lal::linarr::max_sum_edge_lengths_projective_roots </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the maximum value of \(D\) in trees under the projectivity constraint at every vertex of the tree. </p>
<p>Calculates the maximum sum of edge lengths under the projectivity constraint at every vertex of the tree, that is, the result returned is a list of values \(\{M_1,M_2,\dots,M_n\}\) where \(M_i\) is the maximum sum of edge lengths under projectivity for the tree rooted at the \(i\)-th vertex.</p>
<p>See <a class="el" href="LAL_concepts.html#LAL_concepts__linear_arrangement__types">Types of arrangements</a> for the definition of projective arrangement.</p>
<p>This function implements the algorithm described in <a class="el" href="citelist.html#CITEREF_Alemany2024a">[8]</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input free tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The maximum value of \(D\) and a maximum arrangement. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Input tree <em>t</em> must be a valid tree (see <a class="el" href="classlal_1_1graphs_1_1tree.html#a25c8d57865fa5f7cb5d101fd5d07fe2d">lal::graphs::tree::is_tree</a>). </dd></dl>

</div>
</div>
<a id="a4d92a7d183caf25d9c881f8ee9d3833c" name="a4d92a7d183caf25d9c881f8ee9d3833c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d92a7d183caf25d9c881f8ee9d3833c">&#9670;&#160;</a></span>max_sum_edge_lengths_projective_roots() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; uint64_t &gt;, <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> &gt; lal::linarr::max_sum_edge_lengths_projective_roots </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the maximum value of \(D\) in trees under the projectivity constraint at every vertex of the tree. </p>
<p>Calculates the maximum sum of edge lengths under the projectivity constraint at every vertex of the tree, that is, the result returned is a list of values \(\{M_1,M_2,\dots,M_n\}\) where \(M_i\) is the maximum sum of edge lengths under projectivity for the tree rooted at the \(i\)-th vertex.</p>
<p>See <a class="el" href="LAL_concepts.html#LAL_concepts__linear_arrangement__types">Types of arrangements</a> for the definition of projective arrangement.</p>
<p>This function implements the algorithm described in <a class="el" href="citelist.html#CITEREF_Alemany2024a">[8]</a>.</p>
<p>This function converts the input rooted tree into a free tree (see <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#a0600daeeb3542446c6c8d8299d7fffa6">lal::graphs::rooted_tree::to_free_tree</a>). Therefore, the root is ignored. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input free tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The maximum value of \(D\) and a maximum arrangement. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Input tree <em>t</em> must be a valid tree (see <a class="el" href="classlal_1_1graphs_1_1tree.html#a25c8d57865fa5f7cb5d101fd5d07fe2d">lal::graphs::tree::is_tree</a>). </dd></dl>

</div>
</div>
<a id="a2030c0f279ced9571405cebe5675e241" name="a2030c0f279ced9571405cebe5675e241"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2030c0f279ced9571405cebe5675e241">&#9670;&#160;</a></span>mean_dependency_distance() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double lal::linarr::mean_dependency_distance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pi</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the mean dependency distance \(MDD\) as a floating point value. </p>
<p>See <a class="el" href="#a679b59e355c13c9ac4969f897b731582">lal::linarr::mean_dependency_distance_rational</a> for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">pi</td><td>Linear arrangement of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return value is a floating point value. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>\(m &gt; 0\). </dd></dl>

</div>
</div>
<a id="a43bba5ac9ff41d48b5320b70d9e4f403" name="a43bba5ac9ff41d48b5320b70d9e4f403"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43bba5ac9ff41d48b5320b70d9e4f403">&#9670;&#160;</a></span>mean_dependency_distance() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double lal::linarr::mean_dependency_distance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pi</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the mean dependency distance \(MDD\) as a floating point value. </p>
<p>See <a class="el" href="#a679b59e355c13c9ac4969f897b731582">lal::linarr::mean_dependency_distance_rational</a> for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">pi</td><td>Linear arrangement of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return value is a floating point value. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>\(m &gt; 0\). </dd></dl>

</div>
</div>
<a id="a1f8c78736426eea6282258b26534c7e5" name="a1f8c78736426eea6282258b26534c7e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f8c78736426eea6282258b26534c7e5">&#9670;&#160;</a></span>mean_dependency_distance_1level()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class graph_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double lal::linarr::mean_dependency_distance_1level </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; graph_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>L</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>P</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>1-level Mean Dependency Distance \(MDD\) over an ensemble of graphs. </p>
<p>See <a class="el" href="#ae5d17b6e4ea1521b436dbb20817f41b1">lal::linarr::mean_dependency_distance_1level_rational</a> for further details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>List of input graphs. </td></tr>
    <tr><td class="paramname">P</td><td>List of linear arrangements of the nodes \(Pi = \{\pi_i\}_{i=1}^k\). When omitted, \(\pi_I\) is used for every graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">graph_t</td><td>A graph type. A class that derives from <a class="el" href="classlal_1_1graphs_1_1graph.html">lal::graphs::graph</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Jing's and Liu's 1-level \(MDD\) for an ensemble of graphs as a floating point value. </dd></dl>

</div>
</div>
<a id="ae5d17b6e4ea1521b436dbb20817f41b1" name="ae5d17b6e4ea1521b436dbb20817f41b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5d17b6e4ea1521b436dbb20817f41b1">&#9670;&#160;</a></span>mean_dependency_distance_1level_rational()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class graph_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a> lal::linarr::mean_dependency_distance_1level_rational </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; graph_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>L</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>P</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>1-level Mean Dependency Distance \(MDD\) over an ensemble of graphs. </p>
<p>Given a list of graphs \(L\) and a list of linear arrangements for each of them, \(P\), computes the 1-level Mean Dependency Distance as the quotient of \(D\), the sum of all the edge lengths of each graph, and of \(M\) the sum of the number of edges of all the graphs.</p>
<p>Formally, given a list of graphs \(L = \{L_i\}_{i=1}^k\) and a list of linear arrangements \(\Pi = \{\pi_i\}_{i=1}^k\), computes \(D/M\), where</p><ul>
<li>\(D = \sum_{i=1}^k D(L_i, \pi_i)\) is the sum of edge lengths of all graphs.</li>
<li>\(M = \sum_{i=1}^k |E(L_i)|\) is the sum of the number of edges of all graphs.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>List of input graphs. </td></tr>
    <tr><td class="paramname">P</td><td>List of linear arrangements of the nodes \(\Pi = \{\pi_i\}_{i=1}^k\). When omitted, \(\pi_I\) is used for every graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">graph_t</td><td>A graph type. A class that derives from <a class="el" href="classlal_1_1graphs_1_1graph.html">lal::graphs::graph</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Jing's and Liu's 1-level \(MDD\) for an ensemble of graphs as an exact rational value. </dd></dl>

</div>
</div>
<a id="ac837af66d13aa3e2865a6737aec34e7a" name="ac837af66d13aa3e2865a6737aec34e7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac837af66d13aa3e2865a6737aec34e7a">&#9670;&#160;</a></span>mean_dependency_distance_2level()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class graph_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double lal::linarr::mean_dependency_distance_2level </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; graph_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>L</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>P</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>2-level Mean Dependency Distance \(MDD\) over an ensemble of graphs. </p>
<p>See <a class="el" href="#a0b2bbd3f6c94e03091186afd5ec3ae89">lal::linarr::mean_dependency_distance_2level_rational</a> for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>List of input graphs. </td></tr>
    <tr><td class="paramname">P</td><td>List of linear arrangements of the nodes \(L = \{\pi_i\}_{i=1}^k\). When omitted, \(\pi_I\) is used for every graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">graph_t</td><td>A graph type. A class that derives from <a class="el" href="classlal_1_1graphs_1_1graph.html">lal::graphs::graph</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Jing's and Liu's 2-level \(MDD\) for an ensemble of graphs as a floating point value. </dd></dl>

</div>
</div>
<a id="a0b2bbd3f6c94e03091186afd5ec3ae89" name="a0b2bbd3f6c94e03091186afd5ec3ae89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b2bbd3f6c94e03091186afd5ec3ae89">&#9670;&#160;</a></span>mean_dependency_distance_2level_rational()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class graph_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a> lal::linarr::mean_dependency_distance_2level_rational </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; graph_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>L</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>P</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>2-level Mean Dependency Distance \(MDD\) over an ensemble of graphs. </p>
<p>Given a list of graphs \(L\) and a list of linear arrangements of the nodes for each of them, \(P\), computes the 2-level Mean Dependency Distance, i.e., it computes the average Mean Dependency Distance of the graphs in the list.</p>
<p>Formally, given a list of graphs \(L = \{L_i\}_{i=1}^k\) and a list of linear arrangements \(P = \{\pi_i\}_{i=1}^k\), computes \((1/k)S_{&lt;d&gt;}\), where \(S_{&lt;d&gt;} = \sum_{i=1}^k MDD(L_i, \pi_i)\) is the sum of the mean dependency distances of every graph (see <a class="el" href="#a679b59e355c13c9ac4969f897b731582">lal::linarr::mean_dependency_distance_rational</a> for details on the definition of the Mean Dependency Distance).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>List of input graphs. </td></tr>
    <tr><td class="paramname">P</td><td>List of linear arrangements of the nodes \(P = \{\pi_i\}_{i=1}^k\). When omitted, \(\pi_I\) is used for every graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">graph_t</td><td>A graph type. A class that derives from <a class="el" href="classlal_1_1graphs_1_1graph.html">lal::graphs::graph</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Jing's and Liu's 2-level \(MDD\) for an ensemble of graphs as an exact rational value. </dd></dl>

</div>
</div>
<a id="a679b59e355c13c9ac4969f897b731582" name="a679b59e355c13c9ac4969f897b731582"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a679b59e355c13c9ac4969f897b731582">&#9670;&#160;</a></span>mean_dependency_distance_rational() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a> lal::linarr::mean_dependency_distance_rational </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pi</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the mean dependency distance \(MDD\) as an exact rational value. </p>
<p>Given a graph \(G\) and a linear arrangement of its nodes \(\pi\), computes the average edge length, or the mean dependency distance (see <a class="el" href="citelist.html#CITEREF_Jing2015a">[31]</a>). Formally, it computes \(\frac{D_{\pi}(G)}{|E(G)|}\). See function <a class="el" href="#ab70693683a8da54a2e4350c665067cf1">sum_edge_lengths</a> for further details on \(D_{\pi}(G)\).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">pi</td><td>Linear arrangement of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Jing's and Liu's \(MDD\). </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>\(m &gt; 0\). </dd></dl>

</div>
</div>
<a id="a77d3933929930331d44200deed260a41" name="a77d3933929930331d44200deed260a41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77d3933929930331d44200deed260a41">&#9670;&#160;</a></span>mean_dependency_distance_rational() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a> lal::linarr::mean_dependency_distance_rational </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pi</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the mean dependency distance \(MDD\) as an exact rational value. </p>
<p>Given a graph \(G\) and a linear arrangement of its nodes \(\pi\), computes the average edge length, or the mean dependency distance (see <a class="el" href="citelist.html#CITEREF_Jing2015a">[31]</a>). Formally, it computes \(\frac{D_{\pi}(G)}{|E(G)|}\). See function <a class="el" href="#ab70693683a8da54a2e4350c665067cf1">sum_edge_lengths</a> for further details on \(D_{\pi}(G)\).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">pi</td><td>Linear arrangement of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Jing's and Liu's \(MDD\). </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>\(m &gt; 0\). </dd></dl>

</div>
</div>
<a id="a450d0dd41fec42a39bb1204ecedaaa91" name="a450d0dd41fec42a39bb1204ecedaaa91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a450d0dd41fec42a39bb1204ecedaaa91">&#9670;&#160;</a></span>min_sum_edge_lengths() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; uint64_t, <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; lal::linarr::min_sum_edge_lengths </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a1c6a617eb12e032ee641fd390776ff3f">algorithms_Dmin</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a1c6a617eb12e032ee641fd390776ff3fae04de66d6cf0f6c6ec4036288f66bbed">algorithms_Dmin::Shiloach</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the minimum value of \(D\) in free trees. </p>
<p>Calculates the minimum value of \(D\) over all possible arrangements of the input tree. This function also returns the linear arrangement that yields the minimum value. The caller can choose the algorithm to calculate such minimum value.</p>
<p>See the description of the values in <a class="el" href="#a1c6a617eb12e032ee641fd390776ff3f">lal::linarr::algorithms_Dmin</a> for details on the algorithm implemented and to see references to the papers. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input free tree. </td></tr>
    <tr><td class="paramname">a</td><td>The algorithm to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The minimum value of \(D\) and a minimum arrangement. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Input tree <em>t</em> must be a valid tree (see <a class="el" href="classlal_1_1graphs_1_1tree.html#a25c8d57865fa5f7cb5d101fd5d07fe2d">lal::graphs::tree::is_tree</a>). </dd>
<dd>
This function has as extra preconditions those specified in the enumeration passed as parameter. </dd></dl>

</div>
</div>
<a id="a22429c80001ad8fd3dbed68a59ef29fb" name="a22429c80001ad8fd3dbed68a59ef29fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22429c80001ad8fd3dbed68a59ef29fb">&#9670;&#160;</a></span>min_sum_edge_lengths() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; uint64_t, <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; lal::linarr::min_sum_edge_lengths </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a1c6a617eb12e032ee641fd390776ff3f">algorithms_Dmin</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a1c6a617eb12e032ee641fd390776ff3fae04de66d6cf0f6c6ec4036288f66bbed">algorithms_Dmin::Shiloach</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the minimum value of \(D\) in trees. </p>
<p>Calculates the minimum value of \(D\) over all possible arrangements of the input tree. This function also returns the linear arrangement that yields the minimum value. The caller can choose the algorithm to calculate such minimum value.</p>
<p>See the description of the values in <a class="el" href="#a1c6a617eb12e032ee641fd390776ff3f">lal::linarr::algorithms_Dmin</a> for details on the algorithm to be used and to see references to the papers.</p>
<p>This function converts the input rooted into a free tree (see <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#a0600daeeb3542446c6c8d8299d7fffa6">lal::graphs::rooted_tree::to_free_tree()</a>) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input rooted tree. </td></tr>
    <tr><td class="paramname">a</td><td>The algorithm to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The minimum value of \(D\) and a minimum arrangement. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Input tree <em>t</em> must be a valid tree (see <a class="el" href="classlal_1_1graphs_1_1tree.html#a25c8d57865fa5f7cb5d101fd5d07fe2d">lal::graphs::tree::is_tree</a>). </dd>
<dd>
This function has as extra preconditions those specified in the enumeration passed as parameter. </dd></dl>

</div>
</div>
<a id="a709afb09b93614ee58517d379bce3c8b" name="a709afb09b93614ee58517d379bce3c8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a709afb09b93614ee58517d379bce3c8b">&#9670;&#160;</a></span>min_sum_edge_lengths_bipartite() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; uint64_t, <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; lal::linarr::min_sum_edge_lengths_bipartite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the minimum value of \(D\) in trees over bipartite arrangements. </p>
<p>Calculates the minimum value of \(D\) over all bipartite arrangements of the input tree. This function also returns the linear arrangement that yields the minimum value. This function implements the algorithm described in <a class="el" href="citelist.html#CITEREF_Alemany2024b">[10]</a>.</p>
<p>See <a class="el" href="LAL_concepts.html#LAL_concepts__linear_arrangement__types">Types of arrangements</a> for the definition of bipartite arrangement. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input free tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The minimum value of \(D\) and a minimum arrangement. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Input tree <em>t</em> must be a valid tree (see <a class="el" href="classlal_1_1graphs_1_1tree.html#a25c8d57865fa5f7cb5d101fd5d07fe2d">lal::graphs::tree::is_tree</a>). </dd></dl>

</div>
</div>
<a id="a5b0afdaae4943c26a3ba771d47ed92fb" name="a5b0afdaae4943c26a3ba771d47ed92fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b0afdaae4943c26a3ba771d47ed92fb">&#9670;&#160;</a></span>min_sum_edge_lengths_bipartite() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; uint64_t, <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; lal::linarr::min_sum_edge_lengths_bipartite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1properties_1_1bipartite__graph__coloring.html">properties::bipartite_graph_coloring</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the minimum value of \(D\) in trees over bipartite arrangements. </p>
<p>Calculates the minimum value of \(D\) over all bipartite arrangements of the input tree. This function also returns the linear arrangement that yields the minimum value. This function implements the algorithm described in <a class="el" href="citelist.html#CITEREF_Alemany2024b">[10]</a>.</p>
<p>See <a class="el" href="LAL_concepts.html#LAL_concepts__linear_arrangement__types">Types of arrangements</a> for the definition of bipartite arrangement. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input free tree. </td></tr>
    <tr><td class="paramname">c</td><td>Coloring of the input graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The minimum value of \(D\) and a minimum arrangement. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Input tree <em>t</em> must be a valid tree (see <a class="el" href="classlal_1_1graphs_1_1tree.html#a25c8d57865fa5f7cb5d101fd5d07fe2d">lal::graphs::tree::is_tree</a>). </dd></dl>

</div>
</div>
<a id="a8ee049d439a7e8dd41ac0145679a84bb" name="a8ee049d439a7e8dd41ac0145679a84bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ee049d439a7e8dd41ac0145679a84bb">&#9670;&#160;</a></span>min_sum_edge_lengths_planar() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; uint64_t, <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; lal::linarr::min_sum_edge_lengths_planar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1free__tree.html">graphs::free_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a4a49efcc64c3b63502ad8cc18d508ce3">algorithms_Dmin_planar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a4a49efcc64c3b63502ad8cc18d508ce3a37e3b966cac6fa2c0f649bd5cb42adca">algorithms_Dmin_planar::AlemanyEstebanFerrer</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the minimum value of \(D\) in trees under the planarity constraint. </p>
<p>Calculates the minimum value of \(D\) over all planar arrangements of the input tree. This function also returns the linear arrangement that yields the minimum value. The caller can choose the algorithm to calculate such minimum value.</p>
<p>See <a class="el" href="LAL_concepts.html#LAL_concepts__linear_arrangement__types">Types of arrangements</a> for the definition of planar arrangement.</p>
<p>See the description of the values in <a class="el" href="#a4a49efcc64c3b63502ad8cc18d508ce3">lal::linarr::algorithms_Dmin_planar</a> for details on the algorithm to be used and to see references to the papers. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input free tree. </td></tr>
    <tr><td class="paramname">a</td><td>The algorithm to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The minimum value of \(D\) and a minimum arrangement. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Input tree <em>t</em> must be a valid tree (see <a class="el" href="classlal_1_1graphs_1_1tree.html#a25c8d57865fa5f7cb5d101fd5d07fe2d">lal::graphs::tree::is_tree</a>). </dd></dl>

</div>
</div>
<a id="ab154f955e7f6887c6d8115108a4bf242" name="ab154f955e7f6887c6d8115108a4bf242"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab154f955e7f6887c6d8115108a4bf242">&#9670;&#160;</a></span>min_sum_edge_lengths_planar() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; uint64_t, <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; lal::linarr::min_sum_edge_lengths_planar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a4a49efcc64c3b63502ad8cc18d508ce3">algorithms_Dmin_planar</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a4a49efcc64c3b63502ad8cc18d508ce3a37e3b966cac6fa2c0f649bd5cb42adca">algorithms_Dmin_planar::AlemanyEstebanFerrer</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the minimum value of \(D\) in trees under the planarity constraint. </p>
<p>Calculates the minimum value of \(D\) over all planar arrangements of the input tree. This function also returns the linear arrangement that yields the minimum value. The caller can choose the algorithm to calculate such minimum value.</p>
<p>See <a class="el" href="LAL_concepts.html#LAL_concepts__linear_arrangement__types">Types of arrangements</a> for the definition of planar arrangement.</p>
<p>See the description of the values in <a class="el" href="#a4a49efcc64c3b63502ad8cc18d508ce3">lal::linarr::algorithms_Dmin_planar</a> for details on the algorithm to be used and to see references to the papers.</p>
<p>This function converts the input rooted into a free tree (see <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html#a0600daeeb3542446c6c8d8299d7fffa6">lal::graphs::rooted_tree::to_free_tree()</a>) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input rooted tree. </td></tr>
    <tr><td class="paramname">a</td><td>The algorithm to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The minimum value of \(D\) and a minimum arrangement. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Input tree <em>t</em> must be a valid tree (see <a class="el" href="classlal_1_1graphs_1_1tree.html#a25c8d57865fa5f7cb5d101fd5d07fe2d">lal::graphs::tree::is_tree</a>). </dd></dl>

</div>
</div>
<a id="aff8ac86ade398306f32ee39692ebfe4a" name="aff8ac86ade398306f32ee39692ebfe4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff8ac86ade398306f32ee39692ebfe4a">&#9670;&#160;</a></span>min_sum_edge_lengths_projective()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; uint64_t, <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; lal::linarr::min_sum_edge_lengths_projective </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a30bc00af5439a56f037ed84875f1911f">algorithms_Dmin_projective</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a30bc00af5439a56f037ed84875f1911fa37e3b966cac6fa2c0f649bd5cb42adca">algorithms_Dmin_projective::AlemanyEstebanFerrer</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the minimum value of \(D\) in rooted trees under the projectivity constraint. </p>
<p>Calculates the minimum value of \(D\) over all projective arrangements of the input tree. This function also returns the linear arrangement that yields the minimum value. The caller can choose the algorithm to calculate such minimum value.</p>
<p>See <a class="el" href="LAL_concepts.html#LAL_concepts__linear_arrangement__types">Types of arrangements</a> for the definition of projective arrangement.</p>
<p>See the description of the values in <a class="el" href="#a30bc00af5439a56f037ed84875f1911f">lal::linarr::algorithms_Dmin_projective</a> for details on the algorithm to be used and to see references to the papers. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input rooted tree. </td></tr>
    <tr><td class="paramname">a</td><td>The algorithm to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The minimum value of \(D\) and a minimum arrangement. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Input tree <em>t</em> must be a valid tree (see <a class="el" href="classlal_1_1graphs_1_1tree.html#a25c8d57865fa5f7cb5d101fd5d07fe2d">lal::graphs::tree::is_tree</a>). </dd></dl>

</div>
</div>
<a id="a3806eb869914f45cf79c15e8aa7d2a51" name="a3806eb869914f45cf79c15e8aa7d2a51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3806eb869914f45cf79c15e8aa7d2a51">&#9670;&#160;</a></span>num_crossings() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lal::linarr::num_crossings </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>G</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the number of edge crossings in a linear arrangement. </p>
<p>Given a graph \(G\), computes the number of edge crossings using the identity arrangement \(\pi_I\), i.e., computes \(C_{\pi_I}(G)\) using the algorithm specified by the parameter <em>A</em>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>Input graph. </td></tr>
    <tr><td class="paramname">A</td><td>Algorithm to use to compute the number of crossings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of crossings \(C\). </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The preconditions of this function depend on the choice of algorithm. See the preconditions of each algorithm in <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">lal::linarr::algorithms_C</a>. </dd></dl>

</div>
</div>
<a id="a92f697f47063d903d2c092a6c4984595" name="a92f697f47063d903d2c092a6c4984595"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92f697f47063d903d2c092a6c4984595">&#9670;&#160;</a></span>num_crossings() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lal::linarr::num_crossings </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>G</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>arr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the number of edge crossings in a linear arrangement. </p>
<p>Given a graph \(G\) and a linear arrangements \(\pi\) of its nodes, computes the number of edge crossings \(C_{\pi}(G)\) using the algorithm specified by the parameter <em>A</em>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arr</td><td>A linear arrangement of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
    <tr><td class="paramname">A</td><td>Algorithm to use to compute the number of crossings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of crossings \(C\). </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The preconditions of this function depend on the choice of algorithm. See the preconditions of each algorithm in <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">lal::linarr::algorithms_C</a>. </dd></dl>

</div>
</div>
<a id="a3d16bf5730076cd9fabd4f25a38f61de" name="a3d16bf5730076cd9fabd4f25a38f61de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d16bf5730076cd9fabd4f25a38f61de">&#9670;&#160;</a></span>num_crossings() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lal::linarr::num_crossings </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>G</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the number of edge crossings in a linear arrangement. </p>
<p>Given a graph \(G\), computes the number of edge crossings using the identity arrangement \(\pi_I\), i.e., computes \(C_{\pi_I}(G)\) using the algorithm specified by the parameter <em>A</em>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>Input graph. </td></tr>
    <tr><td class="paramname">A</td><td>Algorithm to use to compute the number of crossings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of crossings \(C\). </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The preconditions of this function depend on the choice of algorithm. See the preconditions of each algorithm in <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">lal::linarr::algorithms_C</a>. </dd></dl>

</div>
</div>
<a id="a9a1346c7b927d34465602d1a0a5010c9" name="a9a1346c7b927d34465602d1a0a5010c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a1346c7b927d34465602d1a0a5010c9">&#9670;&#160;</a></span>num_crossings() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lal::linarr::num_crossings </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>G</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>arr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the number of edge crossings in a linear arrangement. </p>
<p>Given a graph \(G\) and a linear arrangements \(\pi\) of its nodes, computes the number of edge crossings \(C_{\pi}(G)\) using the algorithm specified by the parameter <em>A</em>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arr</td><td>A linear arrangement of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
    <tr><td class="paramname">A</td><td>Algorithm to use to compute the number of crossings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of crossings \(C\). </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The preconditions of this function depend on the choice of algorithm. See the preconditions of each algorithm in <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">lal::linarr::algorithms_C</a>. </dd></dl>

</div>
</div>
<a id="a986371a18404f18e4589c7b709c55315" name="a986371a18404f18e4589c7b709c55315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a986371a18404f18e4589c7b709c55315">&#9670;&#160;</a></span>num_crossings_list() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; uint64_t &gt; lal::linarr::num_crossings_list </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>G</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>arrs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the number of edge crossings in a linear arrangement. </p>
<p>Given a graph \(G\) and a list of linear arrangements \(L=\{\pi_i\}_{i=1}^k\) of its nodes, computes the number of edge crossings for each of the linear arrangements \(\pi_i\), i.e., computes \(\{C_{\pi_i}(G)\}_{i=1}^k\), using the algorithm specified by the parameter <em>A</em>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arrs</td><td>A list of \(k\) linear arrangements of the nodes \(\Pi = \{\pi_i\}_{i=1}^k\). </td></tr>
    <tr><td class="paramname">A</td><td>Algorithm to use to compute the number of crossings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list \(L\) where \(L_i = C_{\pi_i}(G)\). </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>None of the arrangements in <em>pis</em> can be empty. </dd>
<dd>
The preconditions of this function depend on the choice of algorithm. See the preconditions of each algorithm in <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">lal::linarr::algorithms_C</a>. </dd></dl>

</div>
</div>
<a id="a6282f5b1fb20e9f86a8fd6747d543262" name="a6282f5b1fb20e9f86a8fd6747d543262"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6282f5b1fb20e9f86a8fd6747d543262">&#9670;&#160;</a></span>num_crossings_list() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; uint64_t &gt; lal::linarr::num_crossings_list </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>G</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>arrs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">algorithms_C</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7a4fbf0df9152d076908cc0754dbb50a06">algorithms_C::ladder</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the number of edge crossings in a linear arrangement. </p>
<p>Given a graph \(G\) and a list of linear arrangements \(L=\{\pi_i\}_{i=1}^k\) of its nodes, computes the number of edge crossings for each of the linear arrangements \(\pi_i\), i.e., computes \(\{C_{\pi_i}(G)\}_{i=1}^k\), using the algorithm specified by the parameter <em>A</em>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arrs</td><td>A list of \(k\) linear arrangements of the nodes \(\Pi = \{\pi_i\}_{i=1}^k\). </td></tr>
    <tr><td class="paramname">A</td><td>Algorithm to use to compute the number of crossings. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list \(L\) where \(L_i = C_{\pi_i}(G)\). </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>None of the arrangements in <em>pis</em> can be empty. </dd>
<dd>
The preconditions of this function depend on the choice of algorithm. See the preconditions of each algorithm in <a class="el" href="#aa7dc22d99964e6a6bb1fe5dd096e64b7">lal::linarr::algorithms_C</a>. </dd></dl>

</div>
</div>
<a id="a563b246458a32226833073c5d248500e" name="a563b246458a32226833073c5d248500e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a563b246458a32226833073c5d248500e">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; lal::linarr::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linarr_1_1chunk.html">chunk</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Standard output operator for chunks. </p>
<p>Usable by <a class="el" href="classlal_1_1linarr_1_1chunk.html">lal::linarr::chunk</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>ostream C++ object. </td></tr>
    <tr><td class="paramname">c</td><td>Input chunk. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The output stream. </dd></dl>

</div>
</div>
<a id="ae44186b49349b0f49daaf8ec968ba34b" name="ae44186b49349b0f49daaf8ec968ba34b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae44186b49349b0f49daaf8ec968ba34b">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; lal::linarr::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linarr_1_1chunk__sequence.html">chunk_sequence</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>seq</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Standard output operator for chunk sequences. </p>
<p>Usable by <a class="el" href="classlal_1_1linarr_1_1chunk__sequence.html">lal::linarr::chunk_sequence</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>ostream C++ object. </td></tr>
    <tr><td class="paramname">seq</td><td>Input chunk sequence. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The output stream. </dd></dl>

</div>
</div>
<a id="a659d080affa5219805b9a40f6f0164e6" name="a659d080affa5219805b9a40f6f0164e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a659d080affa5219805b9a40f6f0164e6">&#9670;&#160;</a></span>predicted_num_crossings() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double lal::linarr::predicted_num_crossings </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>arr</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Approximates the number of crossings. </p>
<p>See <a class="el" href="#a5078b16561c6ebe15a88a9b6b5b574bc">lal::linarr::predicted_num_crossings_rational</a> for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arr</td><td>A linear arrangement of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Approximation of the number of crossings \(E_2[C_G\;|\;\delta]\). </dd></dl>

</div>
</div>
<a id="a9db950bbaa1d8623c561142f14f06920" name="a9db950bbaa1d8623c561142f14f06920"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9db950bbaa1d8623c561142f14f06920">&#9670;&#160;</a></span>predicted_num_crossings() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double lal::linarr::predicted_num_crossings </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>arr</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Approximates the number of crossings. </p>
<p>See <a class="el" href="#a5078b16561c6ebe15a88a9b6b5b574bc">lal::linarr::predicted_num_crossings_rational</a> for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arr</td><td>A linear arrangement of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Approximation of the number of crossings \(E_2[C_G\;|\;\delta]\). </dd></dl>

</div>
</div>
<a id="a24d733f3e2029e5cfe5497708a3baf64" name="a24d733f3e2029e5cfe5497708a3baf64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24d733f3e2029e5cfe5497708a3baf64">&#9670;&#160;</a></span>predicted_num_crossings_rational() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a> lal::linarr::predicted_num_crossings_rational </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>arr</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Predicts the number of crossings. </p>
<p>Given a linear arrangement, which determines the length of the edges, predict the number of crossings conditioned by the length of the edges in the linear arrangement. Implementation of <a class="el" href="citelist.html#CITEREF_Ferrer2014a">[22]</a>. If the arrangement is not specified, the identity arrangement is used. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arr</td><td>A linear arrangement of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Approximation of the number of crossings \(E_2[C_G\;|\;\delta]\). </dd></dl>

</div>
</div>
<a id="a5078b16561c6ebe15a88a9b6b5b574bc" name="a5078b16561c6ebe15a88a9b6b5b574bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5078b16561c6ebe15a88a9b6b5b574bc">&#9670;&#160;</a></span>predicted_num_crossings_rational() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlal_1_1numeric_1_1rational.html">numeric::rational</a> lal::linarr::predicted_num_crossings_rational </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>arr</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Predicts the number of crossings. </p>
<p>Given a linear arrangement, which determines the length of the edges, predict the number of crossings conditioned by the length of the edges in the linear arrangement. Implementation of <a class="el" href="citelist.html#CITEREF_Ferrer2014a">[22]</a>. If the arrangement is not specified, the identity arrangement is used. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">arr</td><td>A linear arrangement of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Approximation of the number of crossings \(E_2[C_G\;|\;\delta]\). </dd></dl>

</div>
</div>
<a id="ab70693683a8da54a2e4350c665067cf1" name="ab70693683a8da54a2e4350c665067cf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab70693683a8da54a2e4350c665067cf1">&#9670;&#160;</a></span>sum_edge_lengths() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lal::linarr::sum_edge_lengths </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1directed__graph.html">graphs::directed_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pi</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the sum of the length of the edges in a linear arrangement. </p>
<p>Given a graph \(G\) and a linear arrangement of its nodes \(\pi\), computes the sum of the length of the graph's edges in the arrangement. Formally, this function computes the value \(D_{\pi}(G)=\sum_{uv\in E(G)} |\pi(u) - \pi(v)|\).</p>
<p>If the arrangement is not specified, the identity arrangement is used. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">pi</td><td>Linear arrangement of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of edge lengths \(D\). </dd></dl>

</div>
</div>
<a id="ad7ded133434870e08c4473c12e7a03ce" name="ad7ded133434870e08c4473c12e7a03ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7ded133434870e08c4473c12e7a03ce">&#9670;&#160;</a></span>sum_edge_lengths() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lal::linarr::sum_edge_lengths </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1undirected__graph.html">graphs::undirected_graph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pi</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the sum of the length of the edges in a linear arrangement. </p>
<p>Given a graph \(G\) and a linear arrangement of its nodes \(\pi\), computes the sum of the length of the graph's edges in the arrangement. Formally, this function computes the value \(D_{\pi}(G)=\sum_{uv\in E(G)} |\pi(u) - \pi(v)|\).</p>
<p>If the arrangement is not specified, the identity arrangement is used. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Input graph. </td></tr>
    <tr><td class="paramname">pi</td><td>Linear arrangement of the nodes. When omitted, \(\pi_I\) is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of edge lengths \(D\). </dd></dl>

</div>
</div>
<a id="adcb046c518ebe8b9c7aa17f4141c0f80" name="adcb046c518ebe8b9c7aa17f4141c0f80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcb046c518ebe8b9c7aa17f4141c0f80">&#9670;&#160;</a></span>syntactic_dependency_tree_classify() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; bool, <a class="el" href="#a7f09036a41db5bf5009bff33658c988e">__syntactic_dependency_tree_size</a> &gt; lal::linarr::syntactic_dependency_tree_classify </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pi</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the type of syntactic dependency tree. </p>
<p>Given an undirected rooted tree and a linear arrangement of its nodes, computes the class of projective structure the tree belongs to.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input tree. </td></tr>
    <tr><td class="paramname">pi</td><td>Linear arrangement of the nodes. If \(\pi[u]=p\) then node <em>u</em> is placed in position <em>p</em> of the arrangement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The class of projective structure. If the class could not be determined the method sets the corresponding position for <a class="el" href="#a682101b23eb6c0db724df82e2aae18ddaad921d60486366258809553a3db49a4a">lal::linarr::syntactic_dependency_tree_type::unknown</a>. </dd></dl>

</div>
</div>
<a id="a7f4c5571263d6aaeddeaecc3d37f7e1c" name="a7f4c5571263d6aaeddeaecc3d37f7e1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f4c5571263d6aaeddeaecc3d37f7e1c">&#9670;&#160;</a></span>syntactic_dependency_tree_classify() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; bool, <a class="el" href="#a7f09036a41db5bf5009bff33658c988e">__syntactic_dependency_tree_size</a> &gt; lal::linarr::syntactic_dependency_tree_classify </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlal_1_1graphs_1_1rooted__tree.html">graphs::rooted_tree</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t</td>          <td class="paramname"><span class="paramname"><em>C</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pi</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the type of syntactic dependency tree. </p>
<p>Given an undirected rooted tree and a linear arrangement of its nodes, computes the class of projective structure the tree belongs to.</p>
<p>This function admits the precomputed number of edge crossings in the same linear arrangement passed as parameter to this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Input tree. </td></tr>
    <tr><td class="paramname">C</td><td>Number of crossings (see <a class="el" href="#a3806eb869914f45cf79c15e8aa7d2a51">lal::linarr::num_crossings</a>). </td></tr>
    <tr><td class="paramname">pi</td><td>Linear arrangement of the nodes. If \(\pi[u]=p\) then node <em>u</em> is placed in position <em>p</em> of the arrangement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The class of projective structure. If the class could not be determined the method sets the corresponding position for <a class="el" href="#a682101b23eb6c0db724df82e2aae18ddaad921d60486366258809553a3db49a4a">lal::linarr::syntactic_dependency_tree_type::unknown</a>. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
