<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LAL: Linear Arrangement Library: lal::linear_arrangement Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">LAL: Linear Arrangement Library<span id="projectnumber">&#160;24.10.00</span>
   </div>
   <div id="projectbrief">A library focused on algorithms on linear arrangements of graphs.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacelal.html">lal</a></li><li class="navelem"><a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="classlal_1_1linear__arrangement-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">lal::linear_arrangement Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Linear arrangement of vertices.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="linear__arrangement_8hpp_source.html">linear_arrangement.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab8268694da6790d0890d26a8e81dd097" id="r_ab8268694da6790d0890d26a8e81dd097"><td class="memItemLeft" align="right" valign="top"><a id="ab8268694da6790d0890d26a8e81dd097" name="ab8268694da6790d0890d26a8e81dd097"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>linear_arrangement</b> () noexcept=default</td></tr>
<tr class="memdesc:ab8268694da6790d0890d26a8e81dd097"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br /></td></tr>
<tr class="separator:ab8268694da6790d0890d26a8e81dd097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e54a433c254906e8168a309e1ed48eb" id="r_a4e54a433c254906e8168a309e1ed48eb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e54a433c254906e8168a309e1ed48eb">linear_arrangement</a> (std::size_t n) noexcept</td></tr>
<tr class="memdesc:a4e54a433c254906e8168a309e1ed48eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor with size.  <br /></td></tr>
<tr class="separator:a4e54a433c254906e8168a309e1ed48eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b97408d23b92dc1dad1ac89665d5f7e" id="r_a6b97408d23b92dc1dad1ac89665d5f7e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b97408d23b92dc1dad1ac89665d5f7e">linear_arrangement</a> (const std::vector&lt; <a class="el" href="namespacelal.html#a5c3f34575ec933a44ed7b6d81e8c75f6">position</a> &gt; &amp;dir_arr) noexcept</td></tr>
<tr class="memdesc:a6b97408d23b92dc1dad1ac89665d5f7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor with direct arrangement.  <br /></td></tr>
<tr class="separator:a6b97408d23b92dc1dad1ac89665d5f7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacf079cd11c85708419d45ec446408dc" id="r_aacf079cd11c85708419d45ec446408dc"><td class="memItemLeft" align="right" valign="top"><a id="aacf079cd11c85708419d45ec446408dc" name="aacf079cd11c85708419d45ec446408dc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>linear_arrangement</b> (const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;arr) noexcept</td></tr>
<tr class="memdesc:aacf079cd11c85708419d45ec446408dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. <br /></td></tr>
<tr class="separator:aacf079cd11c85708419d45ec446408dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37dfffff4001e940227a319f2fcfd9e2" id="r_a37dfffff4001e940227a319f2fcfd9e2"><td class="memItemLeft" align="right" valign="top"><a id="a37dfffff4001e940227a319f2fcfd9e2" name="a37dfffff4001e940227a319f2fcfd9e2"></a>
<a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;arr) noexcept</td></tr>
<tr class="memdesc:a37dfffff4001e940227a319f2fcfd9e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. <br /></td></tr>
<tr class="separator:a37dfffff4001e940227a319f2fcfd9e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76962fa982e918c764caf466eb707fa9" id="r_a76962fa982e918c764caf466eb707fa9"><td class="memItemLeft" align="right" valign="top"><a id="a76962fa982e918c764caf466eb707fa9" name="a76962fa982e918c764caf466eb707fa9"></a>
<a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const std::vector&lt; <a class="el" href="namespacelal.html#a5c3f34575ec933a44ed7b6d81e8c75f6">position</a> &gt; &amp;dir_arr) noexcept</td></tr>
<tr class="memdesc:a76962fa982e918c764caf466eb707fa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator. <br /></td></tr>
<tr class="separator:a76962fa982e918c764caf466eb707fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c6d41c90995b9cee9154c5d831ec372" id="r_a3c6d41c90995b9cee9154c5d831ec372"><td class="memItemLeft" align="right" valign="top"><a id="a3c6d41c90995b9cee9154c5d831ec372" name="a3c6d41c90995b9cee9154c5d831ec372"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>linear_arrangement</b> (<a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;&amp;arr) noexcept</td></tr>
<tr class="memdesc:a3c6d41c90995b9cee9154c5d831ec372"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor. <br /></td></tr>
<tr class="separator:a3c6d41c90995b9cee9154c5d831ec372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01211da9b38e7a336ac300b74c4aaf4a" id="r_a01211da9b38e7a336ac300b74c4aaf4a"><td class="memItemLeft" align="right" valign="top"><a id="a01211da9b38e7a336ac300b74c4aaf4a" name="a01211da9b38e7a336ac300b74c4aaf4a"></a>
<a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;&amp;arr) noexcept</td></tr>
<tr class="memdesc:a01211da9b38e7a336ac300b74c4aaf4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator. <br /></td></tr>
<tr class="separator:a01211da9b38e7a336ac300b74c4aaf4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa18b07a998f678866390510f6827cba7" id="r_aa18b07a998f678866390510f6827cba7"><td class="memItemLeft" align="right" valign="top"><a id="aa18b07a998f678866390510f6827cba7" name="aa18b07a998f678866390510f6827cba7"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~linear_arrangement</b> () noexcept=default</td></tr>
<tr class="memdesc:aa18b07a998f678866390510f6827cba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default destructor. <br /></td></tr>
<tr class="separator:aa18b07a998f678866390510f6827cba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5db3751d2df6ee98d3737c0ac10cef8" id="r_aa5db3751d2df6ee98d3737c0ac10cef8"><td class="memItemLeft" align="right" valign="top"><a id="aa5db3751d2df6ee98d3737c0ac10cef8" name="aa5db3751d2df6ee98d3737c0ac10cef8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> &amp;arr) const noexcept</td></tr>
<tr class="memdesc:aa5db3751d2df6ee98d3737c0ac10cef8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lexicographic comparison of two linear arrangements. <br /></td></tr>
<tr class="separator:aa5db3751d2df6ee98d3737c0ac10cef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7855d77b7dafaeb44db5a1012064ec76" id="r_a7855d77b7dafaeb44db5a1012064ec76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacelal.html#a5c3f34575ec933a44ed7b6d81e8c75f6">position</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7855d77b7dafaeb44db5a1012064ec76">operator[]</a> (const <a class="el" href="structlal_1_1node__t.html">node_t</a> &amp;u) const noexcept</td></tr>
<tr class="memdesc:a7855d77b7dafaeb44db5a1012064ec76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the position of node <em>u</em>.  <br /></td></tr>
<tr class="separator:a7855d77b7dafaeb44db5a1012064ec76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a614a3d71edb2a0d9fcb2fed65c2de195" id="r_a614a3d71edb2a0d9fcb2fed65c2de195"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a614a3d71edb2a0d9fcb2fed65c2de195">operator[]</a> (const <a class="el" href="structlal_1_1position__t.html">position_t</a> &amp;p) const noexcept</td></tr>
<tr class="memdesc:a614a3d71edb2a0d9fcb2fed65c2de195"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the node at position <em>p</em>.  <br /></td></tr>
<tr class="separator:a614a3d71edb2a0d9fcb2fed65c2de195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b5f92b26080bd5b85359c5f9c8d4ba1" id="r_a0b5f92b26080bd5b85359c5f9c8d4ba1"><td class="memItemLeft" align="right" valign="top"><a id="a0b5f92b26080bd5b85359c5f9c8d4ba1" name="a0b5f92b26080bd5b85359c5f9c8d4ba1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clear</b> () noexcept</td></tr>
<tr class="memdesc:a0b5f92b26080bd5b85359c5f9c8d4ba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the memory used by the linear arrangement. <br /></td></tr>
<tr class="separator:a0b5f92b26080bd5b85359c5f9c8d4ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0832bcbc5e5a31e87dc697655f43e831" id="r_a0832bcbc5e5a31e87dc697655f43e831"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacelal.html#a5c3f34575ec933a44ed7b6d81e8c75f6">position</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0832bcbc5e5a31e87dc697655f43e831">get_position_of</a> (const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> u) const noexcept</td></tr>
<tr class="memdesc:a0832bcbc5e5a31e87dc697655f43e831"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the position of node <em>u</em>.  <br /></td></tr>
<tr class="separator:a0832bcbc5e5a31e87dc697655f43e831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9028aa11557f4ba5b3b452306068157b" id="r_a9028aa11557f4ba5b3b452306068157b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9028aa11557f4ba5b3b452306068157b">get_node_at</a> (const <a class="el" href="namespacelal.html#a5c3f34575ec933a44ed7b6d81e8c75f6">position</a> p) const noexcept</td></tr>
<tr class="memdesc:a9028aa11557f4ba5b3b452306068157b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the node at position <em>p</em>.  <br /></td></tr>
<tr class="separator:a9028aa11557f4ba5b3b452306068157b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72589c4c79e03e27c5454bdc1b3244f1" id="r_a72589c4c79e03e27c5454bdc1b3244f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a72589c4c79e03e27c5454bdc1b3244f1">resize</a> (std::size_t n) noexcept</td></tr>
<tr class="memdesc:a72589c4c79e03e27c5454bdc1b3244f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the size of the arrangement.  <br /></td></tr>
<tr class="separator:a72589c4c79e03e27c5454bdc1b3244f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b63f94c0158363bcace37ce19fff7bb" id="r_a4b63f94c0158363bcace37ce19fff7bb"><td class="memTemplParams" colspan="2">template&lt;typename NODE , typename POSITION , std::enable_if_t&lt;(std::is_integral_v&lt; NODE &gt; or std::is_same_v&lt; NODE, <a class="el" href="structlal_1_1node__t.html">node_t</a> &gt;) and(std::is_integral_v&lt; POSITION &gt; or std::is_same_v&lt; POSITION, <a class="el" href="structlal_1_1position__t.html">position_t</a> &gt;), bool &gt;  = true&gt; </td></tr>
<tr class="memitem:a4b63f94c0158363bcace37ce19fff7bb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4b63f94c0158363bcace37ce19fff7bb">assign</a> (const NODE u, const POSITION p) noexcept</td></tr>
<tr class="memdesc:a4b63f94c0158363bcace37ce19fff7bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns a node <em>u</em> to position <em>p</em>.  <br /></td></tr>
<tr class="separator:a4b63f94c0158363bcace37ce19fff7bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04680e239a300b2bd3fe90ab9268fd0b" id="r_a04680e239a300b2bd3fe90ab9268fd0b"><td class="memTemplParams" colspan="2">template&lt;typename what , std::enable_if_t&lt; std::is_same_v&lt; what, <a class="el" href="structlal_1_1node__t.html">node_t</a> &gt; or std::is_same_v&lt; what, <a class="el" href="structlal_1_1position__t.html">position_t</a> &gt;, bool &gt;  = true&gt; </td></tr>
<tr class="memitem:a04680e239a300b2bd3fe90ab9268fd0b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a04680e239a300b2bd3fe90ab9268fd0b">swap</a> (const what u_t, const what v_t) noexcept</td></tr>
<tr class="memdesc:a04680e239a300b2bd3fe90ab9268fd0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the position of two vertices or of two positions.  <br /></td></tr>
<tr class="separator:a04680e239a300b2bd3fe90ab9268fd0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbd4032da7861ea0f1ef35078766539e" id="r_acbd4032da7861ea0f1ef35078766539e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acbd4032da7861ea0f1ef35078766539e">shift_left</a> () noexcept</td></tr>
<tr class="memdesc:acbd4032da7861ea0f1ef35078766539e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts the vertices one position to the left.  <br /></td></tr>
<tr class="separator:acbd4032da7861ea0f1ef35078766539e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86f6902375ceb6f7ec2bba5110096122" id="r_a86f6902375ceb6f7ec2bba5110096122"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a86f6902375ceb6f7ec2bba5110096122">shift_right</a> () noexcept</td></tr>
<tr class="memdesc:a86f6902375ceb6f7ec2bba5110096122"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifts the vertices one position to the right.  <br /></td></tr>
<tr class="separator:a86f6902375ceb6f7ec2bba5110096122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a167b56012211752eaeaf7661ed9a5400" id="r_a167b56012211752eaeaf7661ed9a5400"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a167b56012211752eaeaf7661ed9a5400">mirror</a> () noexcept</td></tr>
<tr class="memdesc:a167b56012211752eaeaf7661ed9a5400"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mirror the arrangement.  <br /></td></tr>
<tr class="separator:a167b56012211752eaeaf7661ed9a5400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a316251fb0cac4df10da4cad421c7686c" id="r_a316251fb0cac4df10da4cad421c7686c"><td class="memItemLeft" align="right" valign="top"><a id="a316251fb0cac4df10da4cad421c7686c" name="a316251fb0cac4df10da4cad421c7686c"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> () const noexcept</td></tr>
<tr class="memdesc:a316251fb0cac4df10da4cad421c7686c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of the arrangement (number of nodes in the arrangement). <br /></td></tr>
<tr class="separator:a316251fb0cac4df10da4cad421c7686c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0742993798dbd69b7d44e0cb0e08774" id="r_aa0742993798dbd69b7d44e0cb0e08774"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa0742993798dbd69b7d44e0cb0e08774">identity</a> () noexcept</td></tr>
<tr class="memdesc:aa0742993798dbd69b7d44e0cb0e08774"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes this arrangement an identity arrangement.  <br /></td></tr>
<tr class="separator:aa0742993798dbd69b7d44e0cb0e08774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad89763c3ca1f19a80e4a04dccadef951" id="r_ad89763c3ca1f19a80e4a04dccadef951"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad89763c3ca1f19a80e4a04dccadef951">update_direct</a> () noexcept</td></tr>
<tr class="memdesc:ad89763c3ca1f19a80e4a04dccadef951"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the direct arrangement using the inverse arrangement.  <br /></td></tr>
<tr class="separator:ad89763c3ca1f19a80e4a04dccadef951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71f927053906157a4bc62811bc51855a" id="r_a71f927053906157a4bc62811bc51855a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a71f927053906157a4bc62811bc51855a">update_inverse</a> () noexcept</td></tr>
<tr class="memdesc:a71f927053906157a4bc62811bc51855a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the inverse arrangement using the direct arrangement.  <br /></td></tr>
<tr class="separator:a71f927053906157a4bc62811bc51855a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad18222235abcde3f4ddc3a094499034f" id="r_ad18222235abcde3f4ddc3a094499034f"><td class="memItemLeft" align="right" valign="top"><a id="ad18222235abcde3f4ddc3a094499034f" name="ad18222235abcde3f4ddc3a094499034f"></a>
<a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>begin_direct</b> () noexcept</td></tr>
<tr class="memdesc:ad18222235abcde3f4ddc3a094499034f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to beginning of direct arrangement. <br /></td></tr>
<tr class="separator:ad18222235abcde3f4ddc3a094499034f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5de4276be4a21cb9a8d48030e5fd876a" id="r_a5de4276be4a21cb9a8d48030e5fd876a"><td class="memItemLeft" align="right" valign="top"><a id="a5de4276be4a21cb9a8d48030e5fd876a" name="a5de4276be4a21cb9a8d48030e5fd876a"></a>
const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>begin_direct</b> () const noexcept</td></tr>
<tr class="memdesc:a5de4276be4a21cb9a8d48030e5fd876a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to beginning of direct arrangement. <br /></td></tr>
<tr class="separator:a5de4276be4a21cb9a8d48030e5fd876a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add75fd2d5d12ef991762ff057cf4124a" id="r_add75fd2d5d12ef991762ff057cf4124a"><td class="memItemLeft" align="right" valign="top"><a id="add75fd2d5d12ef991762ff057cf4124a" name="add75fd2d5d12ef991762ff057cf4124a"></a>
<a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>end_direct</b> () noexcept</td></tr>
<tr class="memdesc:add75fd2d5d12ef991762ff057cf4124a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to end of direct arrangement. <br /></td></tr>
<tr class="separator:add75fd2d5d12ef991762ff057cf4124a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4377871ce216be0c8f7f8684281d1a4" id="r_ad4377871ce216be0c8f7f8684281d1a4"><td class="memItemLeft" align="right" valign="top"><a id="ad4377871ce216be0c8f7f8684281d1a4" name="ad4377871ce216be0c8f7f8684281d1a4"></a>
const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>end_direct</b> () const noexcept</td></tr>
<tr class="memdesc:ad4377871ce216be0c8f7f8684281d1a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to end of direct arrangement. <br /></td></tr>
<tr class="separator:ad4377871ce216be0c8f7f8684281d1a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadeec3a7ea3544da1f88724ba0b9099d" id="r_aadeec3a7ea3544da1f88724ba0b9099d"><td class="memItemLeft" align="right" valign="top"><a id="aadeec3a7ea3544da1f88724ba0b9099d" name="aadeec3a7ea3544da1f88724ba0b9099d"></a>
<a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>begin_inverse</b> () noexcept</td></tr>
<tr class="memdesc:aadeec3a7ea3544da1f88724ba0b9099d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to beginning of inverse arrangement. <br /></td></tr>
<tr class="separator:aadeec3a7ea3544da1f88724ba0b9099d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5918dff228ceda956b584c7a0936403" id="r_aa5918dff228ceda956b584c7a0936403"><td class="memItemLeft" align="right" valign="top"><a id="aa5918dff228ceda956b584c7a0936403" name="aa5918dff228ceda956b584c7a0936403"></a>
const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>begin_inverse</b> () const noexcept</td></tr>
<tr class="memdesc:aa5918dff228ceda956b584c7a0936403"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to beginning of inverse arrangement. <br /></td></tr>
<tr class="separator:aa5918dff228ceda956b584c7a0936403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c77d71e9383fe8b543fe52716e4c3b3" id="r_a8c77d71e9383fe8b543fe52716e4c3b3"><td class="memItemLeft" align="right" valign="top"><a id="a8c77d71e9383fe8b543fe52716e4c3b3" name="a8c77d71e9383fe8b543fe52716e4c3b3"></a>
<a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>end_inverse</b> () noexcept</td></tr>
<tr class="memdesc:a8c77d71e9383fe8b543fe52716e4c3b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to end of inverse arrangement. <br /></td></tr>
<tr class="separator:a8c77d71e9383fe8b543fe52716e4c3b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8c9ccd189458b5cdf7b27e04df92769" id="r_ac8c9ccd189458b5cdf7b27e04df92769"><td class="memItemLeft" align="right" valign="top"><a id="ac8c9ccd189458b5cdf7b27e04df92769" name="ac8c9ccd189458b5cdf7b27e04df92769"></a>
const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>end_inverse</b> () const noexcept</td></tr>
<tr class="memdesc:ac8c9ccd189458b5cdf7b27e04df92769"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to end of inverse arrangement. <br /></td></tr>
<tr class="separator:ac8c9ccd189458b5cdf7b27e04df92769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03c8ee6c537539711b3debfa4ac28ab6" id="r_a03c8ee6c537539711b3debfa4ac28ab6"><td class="memItemLeft" align="right" valign="top"><a id="a03c8ee6c537539711b3debfa4ac28ab6" name="a03c8ee6c537539711b3debfa4ac28ab6"></a>
std::vector&lt; <a class="el" href="namespacelal.html#a5c3f34575ec933a44ed7b6d81e8c75f6">position</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>direct_as_vector</b> () const noexcept</td></tr>
<tr class="memdesc:a03c8ee6c537539711b3debfa4ac28ab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a std::vector from the direct arrangement. <br /></td></tr>
<tr class="separator:a03c8ee6c537539711b3debfa4ac28ab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dceaee0d8d60263d37dbdbb4600823e" id="r_a2dceaee0d8d60263d37dbdbb4600823e"><td class="memItemLeft" align="right" valign="top"><a id="a2dceaee0d8d60263d37dbdbb4600823e" name="a2dceaee0d8d60263d37dbdbb4600823e"></a>
std::vector&lt; <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>inverse_as_vector</b> () const noexcept</td></tr>
<tr class="memdesc:a2dceaee0d8d60263d37dbdbb4600823e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a std::vector from the inverse arrangement. <br /></td></tr>
<tr class="separator:a2dceaee0d8d60263d37dbdbb4600823e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a8163a50d8c3ff85b18fb9b1562dfc295" id="r_a8163a50d8c3ff85b18fb9b1562dfc295"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8163a50d8c3ff85b18fb9b1562dfc295">from_direct</a> (const std::vector&lt; <a class="el" href="namespacelal.html#a5c3f34575ec933a44ed7b6d81e8c75f6">position</a> &gt; &amp;v) noexcept</td></tr>
<tr class="memdesc:a8163a50d8c3ff85b18fb9b1562dfc295"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a linear arrangement from a direct arrangement.  <br /></td></tr>
<tr class="separator:a8163a50d8c3ff85b18fb9b1562dfc295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b71d39591c937eb2df7680aee29200e" id="r_a7b71d39591c937eb2df7680aee29200e"><td class="memTemplParams" colspan="2">template&lt;typename It &gt; </td></tr>
<tr class="memitem:a7b71d39591c937eb2df7680aee29200e"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7b71d39591c937eb2df7680aee29200e">from_direct</a> (It begin, It end) noexcept</td></tr>
<tr class="memdesc:a7b71d39591c937eb2df7680aee29200e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a linear arrangement from a direct arrangement.  <br /></td></tr>
<tr class="separator:a7b71d39591c937eb2df7680aee29200e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e7046ac1c0bb1f2a1d694c2f014b751" id="r_a9e7046ac1c0bb1f2a1d694c2f014b751"><td class="memTemplParams" colspan="2">template&lt;typename It &gt; </td></tr>
<tr class="memitem:a9e7046ac1c0bb1f2a1d694c2f014b751"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9e7046ac1c0bb1f2a1d694c2f014b751">from_direct</a> (It begin, It end, std::size_t <a class="el" href="#a316251fb0cac4df10da4cad421c7686c">size</a>) noexcept</td></tr>
<tr class="memdesc:a9e7046ac1c0bb1f2a1d694c2f014b751"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a linear arrangement from a direct arrangement.  <br /></td></tr>
<tr class="separator:a9e7046ac1c0bb1f2a1d694c2f014b751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45774e32f79ca4af33f7320aa42056a1" id="r_a45774e32f79ca4af33f7320aa42056a1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45774e32f79ca4af33f7320aa42056a1">from_inverse</a> (const std::vector&lt; <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> &gt; &amp;v) noexcept</td></tr>
<tr class="memdesc:a45774e32f79ca4af33f7320aa42056a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a linear arrangement from an inverse arrangement.  <br /></td></tr>
<tr class="separator:a45774e32f79ca4af33f7320aa42056a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c731ee1b879836a58be9a5c48f581c6" id="r_a6c731ee1b879836a58be9a5c48f581c6"><td class="memTemplParams" colspan="2">template&lt;typename It &gt; </td></tr>
<tr class="memitem:a6c731ee1b879836a58be9a5c48f581c6"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6c731ee1b879836a58be9a5c48f581c6">from_inverse</a> (It begin, It end) noexcept</td></tr>
<tr class="memdesc:a6c731ee1b879836a58be9a5c48f581c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a linear arrangement from an inverse arrangement.  <br /></td></tr>
<tr class="separator:a6c731ee1b879836a58be9a5c48f581c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abed0b9f2151039e8849613355d4b2070" id="r_abed0b9f2151039e8849613355d4b2070"><td class="memTemplParams" colspan="2">template&lt;typename It &gt; </td></tr>
<tr class="memitem:abed0b9f2151039e8849613355d4b2070"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abed0b9f2151039e8849613355d4b2070">from_inverse</a> (It begin, It end, std::size_t <a class="el" href="#a316251fb0cac4df10da4cad421c7686c">size</a>) noexcept</td></tr>
<tr class="memdesc:abed0b9f2151039e8849613355d4b2070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a linear arrangement from an inverse arrangement.  <br /></td></tr>
<tr class="separator:abed0b9f2151039e8849613355d4b2070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51233a683bc9e3c06416f9c9aca173c2" id="r_a51233a683bc9e3c06416f9c9aca173c2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a51233a683bc9e3c06416f9c9aca173c2">identity</a> (std::size_t n) noexcept</td></tr>
<tr class="memdesc:a51233a683bc9e3c06416f9c9aca173c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an identity linear arrangement.  <br /></td></tr>
<tr class="separator:a51233a683bc9e3c06416f9c9aca173c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a6045e78d0ba648f14f61a52141646506" id="r_a6045e78d0ba648f14f61a52141646506"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlal_1_1detail_1_1array.html">detail::array</a>&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6045e78d0ba648f14f61a52141646506">m_memory</a></td></tr>
<tr class="separator:a6045e78d0ba648f14f61a52141646506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a042adc1171b430656e68eff05337eec9" id="r_a042adc1171b430656e68eff05337eec9"><td class="memItemLeft" align="right" valign="top"><a id="a042adc1171b430656e68eff05337eec9" name="a042adc1171b430656e68eff05337eec9"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>m_n</b> = 0</td></tr>
<tr class="memdesc:a042adc1171b430656e68eff05337eec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of the arrangement (number of nodes in the arrangement). <br /></td></tr>
<tr class="separator:a042adc1171b430656e68eff05337eec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad13a87dc8d3a35f6f890ad7b62fa4c55" id="r_ad13a87dc8d3a35f6f890ad7b62fa4c55"><td class="memItemLeft" align="right" valign="top"><a id="ad13a87dc8d3a35f6f890ad7b62fa4c55" name="ad13a87dc8d3a35f6f890ad7b62fa4c55"></a>
<a class="el" href="namespacelal.html#a5c3f34575ec933a44ed7b6d81e8c75f6">position</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>m_direct</b> = nullptr</td></tr>
<tr class="memdesc:ad13a87dc8d3a35f6f890ad7b62fa4c55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the direct arrangement values. <br /></td></tr>
<tr class="separator:ad13a87dc8d3a35f6f890ad7b62fa4c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a047c797aabc191b58a160261447b47b2" id="r_a047c797aabc191b58a160261447b47b2"><td class="memItemLeft" align="right" valign="top"><a id="a047c797aabc191b58a160261447b47b2" name="a047c797aabc191b58a160261447b47b2"></a>
<a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>m_inverse</b> = nullptr</td></tr>
<tr class="memdesc:a047c797aabc191b58a160261447b47b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the inverse arrangement values. <br /></td></tr>
<tr class="separator:a047c797aabc191b58a160261447b47b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:aced48a52ffde749da418353adc282a3d" id="r_aced48a52ffde749da418353adc282a3d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aced48a52ffde749da418353adc282a3d">set_pointers</a> () noexcept</td></tr>
<tr class="memdesc:aced48a52ffde749da418353adc282a3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <a class="el" href="#ad13a87dc8d3a35f6f890ad7b62fa4c55">m_direct</a> and <a class="el" href="#a047c797aabc191b58a160261447b47b2">m_inverse</a> appropriately.  <br /></td></tr>
<tr class="separator:aced48a52ffde749da418353adc282a3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d6ef9f2b441a559f418e4c1a03c51a4" id="r_a2d6ef9f2b441a559f418e4c1a03c51a4"><td class="memTemplParams" colspan="2">template&lt;bool from_direct_arr, typename It &gt; </td></tr>
<tr class="memitem:a2d6ef9f2b441a559f418e4c1a03c51a4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2d6ef9f2b441a559f418e4c1a03c51a4">from_data</a> (const It begin, const It end) noexcept</td></tr>
<tr class="memdesc:a2d6ef9f2b441a559f418e4c1a03c51a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes this arrangement from a direct or inverse arrangement.  <br /></td></tr>
<tr class="separator:a2d6ef9f2b441a559f418e4c1a03c51a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Linear arrangement of vertices. </p>
<p>A linear arrangement is a pair of two functions that relate vertices to a distinct position in a linear ordering.</p>
<p>This concept is further explained in page <a class="el" href="LAL_concepts.html#LAL_concepts__linear_arrangement">Linear Arrangement</a>.</p>
<p>Now, this class's usage is simple enough. Declare a linear arrangement with a given number of vertices </p><div class="fragment"><div class="line"><a class="code hl_class" href="classlal_1_1linear__arrangement.html">lal::linear_arrangement</a> arr(n);</div>
<div class="ttc" id="aclasslal_1_1linear__arrangement_html"><div class="ttname"><a href="classlal_1_1linear__arrangement.html">lal::linear_arrangement</a></div><div class="ttdoc">Linear arrangement of vertices.</div><div class="ttdef"><b>Definition</b> linear_arrangement.hpp:103</div></div>
</div><!-- fragment --><p> or initialize it </p><div class="fragment"><div class="line"><a class="code hl_class" href="classlal_1_1linear__arrangement.html">lal::linear_arrangement</a> arr;</div>
<div class="line">arr.<a class="code hl_function" href="#a72589c4c79e03e27c5454bdc1b3244f1">resize</a>(n);</div>
<div class="ttc" id="aclasslal_1_1linear__arrangement_html_a72589c4c79e03e27c5454bdc1b3244f1"><div class="ttname"><a href="#a72589c4c79e03e27c5454bdc1b3244f1">lal::linear_arrangement::resize</a></div><div class="ttdeci">void resize(std::size_t n) noexcept</div><div class="ttdoc">Changes the size of the arrangement.</div><div class="ttdef"><b>Definition</b> linear_arrangement.hpp:355</div></div>
</div><!-- fragment --><p> Assign a vertex to a given position using the method <a class="el" href="#a4b63f94c0158363bcace37ce19fff7bb">assign</a>. Retrieving a vertex's position can be done using either the method <a class="el" href="#a0832bcbc5e5a31e87dc697655f43e831">get_position_of</a> or using the <a class="el" href="#a7855d77b7dafaeb44db5a1012064ec76">operator[]</a> passing to it a <a class="el" href="structlal_1_1node__t.html">lal::node_t</a> object. Likewise, use the method <a class="el" href="#a9028aa11557f4ba5b3b452306068157b">get_node_at</a> or the <a class="el" href="#a7855d77b7dafaeb44db5a1012064ec76">operator[]</a> with a <a class="el" href="structlal_1_1position__t.html">lal::position_t</a> to retrieve the vertex at a given position. Therefore, the following loops are equivalent </p><div class="fragment"><div class="line"><a class="code hl_class" href="classlal_1_1linear__arrangement.html">lal::linear_arrangement</a>(n);</div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"><span class="keywordflow">for</span> (<a class="code hl_typedef" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">lal::node</a> u = 0; u &lt; n; ++u) {</div>
<div class="line">   <span class="keyword">const</span> <a class="code hl_typedef" href="namespacelal.html#a5c3f34575ec933a44ed7b6d81e8c75f6">lal::position</a> p = arr.<a class="code hl_function" href="#a0832bcbc5e5a31e87dc697655f43e831">get_position_of</a>(u);</div>
<div class="line">   <span class="comment">// ...</span></div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">for</span> (<a class="code hl_struct" href="structlal_1_1node__t.html">lal::node_t</a> u = 0; u &lt; n; ++u) {</div>
<div class="line">   <span class="keyword">const</span> <a class="code hl_typedef" href="namespacelal.html#a5c3f34575ec933a44ed7b6d81e8c75f6">lal::position</a> p = arr[u];</div>
<div class="line">}</div>
<div class="ttc" id="aclasslal_1_1linear__arrangement_html_a0832bcbc5e5a31e87dc697655f43e831"><div class="ttname"><a href="#a0832bcbc5e5a31e87dc697655f43e831">lal::linear_arrangement::get_position_of</a></div><div class="ttdeci">position get_position_of(const node u) const noexcept</div><div class="ttdoc">Returns the position of node u.</div><div class="ttdef"><b>Definition</b> linear_arrangement.hpp:335</div></div>
<div class="ttc" id="anamespacelal_html_a5c3f34575ec933a44ed7b6d81e8c75f6"><div class="ttname"><a href="namespacelal.html#a5c3f34575ec933a44ed7b6d81e8c75f6">lal::position</a></div><div class="ttdeci">uint64_t position</div><div class="ttdoc">Node's position type.</div><div class="ttdef"><b>Definition</b> basic_types.hpp:53</div></div>
<div class="ttc" id="anamespacelal_html_ae5688e9acca02d5865dfc724e480ce25"><div class="ttname"><a href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">lal::node</a></div><div class="ttdeci">uint64_t node</div><div class="ttdoc">Node type. See Node / Vertex page for further details.</div><div class="ttdef"><b>Definition</b> basic_types.hpp:51</div></div>
<div class="ttc" id="astructlal_1_1node__t_html"><div class="ttname"><a href="structlal_1_1node__t.html">lal::node_t</a></div><div class="ttdoc">Typesafe node type.</div><div class="ttdef"><b>Definition</b> basic_types.hpp:70</div></div>
</div><!-- fragment --><p> Types <a class="el" href="structlal_1_1node__t.html">lal::node_t</a> and <a class="el" href="structlal_1_1position__t.html">lal::position_t</a> are useful also in swapping vertices in the arrangement (see <a class="el" href="#a04680e239a300b2bd3fe90ab9268fd0b">swap</a>).</p>
<p>Linear arrangements can be transformed. For example, an arrangement can be</p><ul>
<li>shifted to the left (see <a class="el" href="#acbd4032da7861ea0f1ef35078766539e">lal::linear_arrangement::shift_left</a>),</li>
<li>shifted to the right (see <a class="el" href="#a86f6902375ceb6f7ec2bba5110096122">lal::linear_arrangement::shift_right</a>),</li>
<li>mirrored (see <a class="el" href="#a167b56012211752eaeaf7661ed9a5400">lal::linear_arrangement::mirror</a>).</li>
<li>in case the inverse arrangement was manipulated, the directed can be updated (see <a class="el" href="#ad89763c3ca1f19a80e4a04dccadef951">lal::linear_arrangement::update_direct</a>).</li>
<li>in case the direct arrangement was manipulated, the inverse can be updated (see <a class="el" href="#a71f927053906157a4bc62811bc51855a">lal::linear_arrangement::update_inverse</a>). </li>
</ul>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a4e54a433c254906e8168a309e1ed48eb" name="a4e54a433c254906e8168a309e1ed48eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e54a433c254906e8168a309e1ed48eb">&#9670;&#160;</a></span>linear_arrangement() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">lal::linear_arrangement::linear_arrangement </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor with size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of nodes in the arrangement. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6b97408d23b92dc1dad1ac89665d5f7e" name="a6b97408d23b92dc1dad1ac89665d5f7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b97408d23b92dc1dad1ac89665d5f7e">&#9670;&#160;</a></span>linear_arrangement() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">lal::linear_arrangement::linear_arrangement </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacelal.html#a5c3f34575ec933a44ed7b6d81e8c75f6">position</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>dir_arr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor with direct arrangement. </p>
<p>Constructs a linear arrangement assuming that the parameter is a direct arrangement, i.e., <em>dir_arr</em>[u]=p if the position of vertex <em>u</em> is <em>p</em>.</p>
<p>This helps the conversion from python's list to this object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dir_arr</td><td>Direct arrangement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="#a047c797aabc191b58a160261447b47b2">m_inverse</a> is updated. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4b63f94c0158363bcace37ce19fff7bb" name="a4b63f94c0158363bcace37ce19fff7bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b63f94c0158363bcace37ce19fff7bb">&#9670;&#160;</a></span>assign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NODE , typename POSITION , std::enable_if_t&lt;(std::is_integral_v&lt; NODE &gt; or std::is_same_v&lt; NODE, <a class="el" href="structlal_1_1node__t.html">node_t</a> &gt;) and(std::is_integral_v&lt; POSITION &gt; or std::is_same_v&lt; POSITION, <a class="el" href="structlal_1_1position__t.html">position_t</a> &gt;), bool &gt;  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::linear_arrangement::assign </td>
          <td>(</td>
          <td class="paramtype">const NODE</td>          <td class="paramname"><span class="paramname"><em>u</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const POSITION</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns a node <em>u</em> to position <em>p</em>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">NODE</td><td>A type that must be convertible to <a class="el" href="structlal_1_1node__t.html">node_t</a>. </td></tr>
    <tr><td class="paramname">POSITION</td><td>A type that must be convertible to <a class="el" href="structlal_1_1position__t.html">position_t</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>Node. </td></tr>
    <tr><td class="paramname">p</td><td>Position. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Values <em>u</em> and <em>p</em> must both be strictly less than the size of the arrangement (see <a class="el" href="#a042adc1171b430656e68eff05337eec9">m_n</a>). </dd></dl>

</div>
</div>
<a id="a2d6ef9f2b441a559f418e4c1a03c51a4" name="a2d6ef9f2b441a559f418e4c1a03c51a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d6ef9f2b441a559f418e4c1a03c51a4">&#9670;&#160;</a></span>from_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool from_direct_arr, typename It &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::linear_arrangement::from_data </td>
          <td>(</td>
          <td class="paramtype">const It</td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const It</td>          <td class="paramname"><span class="paramname"><em>end</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes this arrangement from a direct or inverse arrangement. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">from_direct_arr</td><td>If true, parameter <em>v</em> is interpreted as a direct arrangement; as an inverse arrangement if otherwise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>Pointer to beginning of data. </td></tr>
    <tr><td class="paramname">end</td><td>Pointer to ending of data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Pointers <a class="el" href="#ad13a87dc8d3a35f6f890ad7b62fa4c55">m_direct</a> and <a class="el" href="#a047c797aabc191b58a160261447b47b2">m_inverse</a> must have been set appropriately. </dd></dl>

</div>
</div>
<a id="a8163a50d8c3ff85b18fb9b1562dfc295" name="a8163a50d8c3ff85b18fb9b1562dfc295"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8163a50d8c3ff85b18fb9b1562dfc295">&#9670;&#160;</a></span>from_direct() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> lal::linear_arrangement::from_direct </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacelal.html#a5c3f34575ec933a44ed7b6d81e8c75f6">position</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a linear arrangement from a direct arrangement. </p>
<p>A direct arrangement gives the position of every node. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>A direct arrangement. This gives the position of every node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A linear arrangement object constructed from <em>v</em>. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="#a047c797aabc191b58a160261447b47b2">m_inverse</a> is updated. </dd></dl>

</div>
</div>
<a id="a7b71d39591c937eb2df7680aee29200e" name="a7b71d39591c937eb2df7680aee29200e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b71d39591c937eb2df7680aee29200e">&#9670;&#160;</a></span>from_direct() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename It &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> lal::linear_arrangement::from_direct </td>
          <td>(</td>
          <td class="paramtype">It</td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It</td>          <td class="paramname"><span class="paramname"><em>end</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a linear arrangement from a direct arrangement. </p>
<p>A direct arrangement gives the position of every node. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>A pointer to the beginning of the direct arrangement. </td></tr>
    <tr><td class="paramname">end</td><td>A pointer to the end of the direct arrangement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A linear arrangement object constructed from <em>v</em>. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="#a047c797aabc191b58a160261447b47b2">m_inverse</a> is updated. </dd></dl>

</div>
</div>
<a id="a9e7046ac1c0bb1f2a1d694c2f014b751" name="a9e7046ac1c0bb1f2a1d694c2f014b751"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e7046ac1c0bb1f2a1d694c2f014b751">&#9670;&#160;</a></span>from_direct() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename It &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> lal::linear_arrangement::from_direct </td>
          <td>(</td>
          <td class="paramtype">It</td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It</td>          <td class="paramname"><span class="paramname"><em>end</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a linear arrangement from a direct arrangement. </p>
<p>A direct arrangement gives the position of every node. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>A pointer to the beginning of the direct arrangement. </td></tr>
    <tr><td class="paramname">end</td><td>A pointer to the end of the direct arrangement. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the container pointer by <em>begin</em> and <em>end</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A linear arrangement object constructed from <em>v</em>. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="#a047c797aabc191b58a160261447b47b2">m_inverse</a> is updated. </dd></dl>

</div>
</div>
<a id="a45774e32f79ca4af33f7320aa42056a1" name="a45774e32f79ca4af33f7320aa42056a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45774e32f79ca4af33f7320aa42056a1">&#9670;&#160;</a></span>from_inverse() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> lal::linear_arrangement::from_inverse </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a linear arrangement from an inverse arrangement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>An inverse arrangement. This gives the node for every position. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A linear arrangement object constructed from <em>v</em>. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="#ad13a87dc8d3a35f6f890ad7b62fa4c55">m_direct</a> is updated. </dd></dl>

</div>
</div>
<a id="a6c731ee1b879836a58be9a5c48f581c6" name="a6c731ee1b879836a58be9a5c48f581c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c731ee1b879836a58be9a5c48f581c6">&#9670;&#160;</a></span>from_inverse() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename It &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> lal::linear_arrangement::from_inverse </td>
          <td>(</td>
          <td class="paramtype">It</td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It</td>          <td class="paramname"><span class="paramname"><em>end</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a linear arrangement from an inverse arrangement. </p>
<p>A direct arrangement gives the node for every position. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>A pointer to the beginning of the inverse arrangement. </td></tr>
    <tr><td class="paramname">end</td><td>A pointer to the end of the inverse arrangement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A linear arrangement object constructed from <em>v</em>. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="#ad13a87dc8d3a35f6f890ad7b62fa4c55">m_direct</a> is updated. </dd></dl>

</div>
</div>
<a id="abed0b9f2151039e8849613355d4b2070" name="abed0b9f2151039e8849613355d4b2070"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abed0b9f2151039e8849613355d4b2070">&#9670;&#160;</a></span>from_inverse() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename It &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> lal::linear_arrangement::from_inverse </td>
          <td>(</td>
          <td class="paramtype">It</td>          <td class="paramname"><span class="paramname"><em>begin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">It</td>          <td class="paramname"><span class="paramname"><em>end</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a linear arrangement from an inverse arrangement. </p>
<p>A direct arrangement gives the node for every position. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>A pointer to the beginning of the inverse arrangement. </td></tr>
    <tr><td class="paramname">end</td><td>A pointer to the end of the inverse arrangement. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the container pointer by <em>begin</em> and <em>end</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A linear arrangement object constructed from <em>v</em>. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="#ad13a87dc8d3a35f6f890ad7b62fa4c55">m_direct</a> is updated. </dd></dl>

</div>
</div>
<a id="a9028aa11557f4ba5b3b452306068157b" name="a9028aa11557f4ba5b3b452306068157b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9028aa11557f4ba5b3b452306068157b">&#9670;&#160;</a></span>get_node_at()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> lal::linear_arrangement::get_node_at </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#a5c3f34575ec933a44ed7b6d81e8c75f6">position</a></td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the node at position <em>p</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Position. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The node at position <em>p</em>. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The <em>p-th</em> index of <a class="el" href="#a047c797aabc191b58a160261447b47b2">m_inverse</a> is up to date. </dd>
<dd>
The value of <em>p</em> must be strictly less than the size of the arrangement (see <a class="el" href="#a042adc1171b430656e68eff05337eec9">m_n</a>). </dd></dl>

</div>
</div>
<a id="a0832bcbc5e5a31e87dc697655f43e831" name="a0832bcbc5e5a31e87dc697655f43e831"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0832bcbc5e5a31e87dc697655f43e831">&#9670;&#160;</a></span>get_position_of()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacelal.html#a5c3f34575ec933a44ed7b6d81e8c75f6">position</a> lal::linear_arrangement::get_position_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a></td>          <td class="paramname"><span class="paramname"><em>u</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the position of node <em>u</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>Node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The position of node <em>u</em>. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The <em>u-th</em> index of <a class="el" href="#ad13a87dc8d3a35f6f890ad7b62fa4c55">m_direct</a> is up to date. </dd>
<dd>
The value of <em>u</em> must be strictly less than the size of the arrangement (see <a class="el" href="#a042adc1171b430656e68eff05337eec9">m_n</a>). </dd></dl>

</div>
</div>
<a id="aa0742993798dbd69b7d44e0cb0e08774" name="aa0742993798dbd69b7d44e0cb0e08774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0742993798dbd69b7d44e0cb0e08774">&#9670;&#160;</a></span>identity() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::linear_arrangement::identity </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes this arrangement an identity arrangement. </p>
<p>This is the arrangement in which vertex 0 is assigned to position 0, vertex 1 is assigned to position 1, and so on. </p>

</div>
</div>
<a id="a51233a683bc9e3c06416f9c9aca173c2" name="a51233a683bc9e3c06416f9c9aca173c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51233a683bc9e3c06416f9c9aca173c2">&#9670;&#160;</a></span>identity() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classlal_1_1linear__arrangement.html">linear_arrangement</a> lal::linear_arrangement::identity </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an identity linear arrangement. </p>
<p>This is the arrangement in which vertex 0 is assigned to position 0, vertex 1 is assigned to position 1, and so on. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of vertices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a167b56012211752eaeaf7661ed9a5400" name="a167b56012211752eaeaf7661ed9a5400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a167b56012211752eaeaf7661ed9a5400">&#9670;&#160;</a></span>mirror()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::linear_arrangement::mirror </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mirror the arrangement. </p>
<p>Swaps the vertices so that the first is placed at the last position, the second at the second to last, ... More formally, swaps arr[1] with arr[n], arr[2] with arr[n-1], ... </p><dl class="section pre"><dt>Precondition</dt><dd>All nodes to have been assigned to a position. </dd></dl>

</div>
</div>
<a id="a7855d77b7dafaeb44db5a1012064ec76" name="a7855d77b7dafaeb44db5a1012064ec76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7855d77b7dafaeb44db5a1012064ec76">&#9670;&#160;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacelal.html#a5c3f34575ec933a44ed7b6d81e8c75f6">position</a> lal::linear_arrangement::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlal_1_1node__t.html">node_t</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>u</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the position of node <em>u</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>Node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The position of node <em>u</em>. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The <em>u-th</em> index of <a class="el" href="#ad13a87dc8d3a35f6f890ad7b62fa4c55">m_direct</a> is up to date. </dd>
<dd>
The value of <em>u</em> must be strictly less than the size of the arrangement (see <a class="el" href="#a042adc1171b430656e68eff05337eec9">m_n</a>). </dd></dl>

</div>
</div>
<a id="a614a3d71edb2a0d9fcb2fed65c2de195" name="a614a3d71edb2a0d9fcb2fed65c2de195"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a614a3d71edb2a0d9fcb2fed65c2de195">&#9670;&#160;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacelal.html#ae5688e9acca02d5865dfc724e480ce25">node</a> lal::linear_arrangement::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlal_1_1position__t.html">position_t</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the node at position <em>p</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Position. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The node at position <em>p</em>. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The <em>p-th</em> index of <a class="el" href="#a047c797aabc191b58a160261447b47b2">m_inverse</a> is up to date. </dd>
<dd>
The value of <em>p</em> must be strictly less than the size of the arrangement (see <a class="el" href="#a042adc1171b430656e68eff05337eec9">m_n</a>). </dd></dl>

</div>
</div>
<a id="a72589c4c79e03e27c5454bdc1b3244f1" name="a72589c4c79e03e27c5454bdc1b3244f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72589c4c79e03e27c5454bdc1b3244f1">&#9670;&#160;</a></span>resize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::linear_arrangement::resize </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes the size of the arrangement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>New size of the arrangement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>Sets the position of each node to \(n+1\), and the node at each position is also \(n+1\). </dd></dl>

</div>
</div>
<a id="aced48a52ffde749da418353adc282a3d" name="aced48a52ffde749da418353adc282a3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aced48a52ffde749da418353adc282a3d">&#9670;&#160;</a></span>set_pointers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::linear_arrangement::set_pointers </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets <a class="el" href="#ad13a87dc8d3a35f6f890ad7b62fa4c55">m_direct</a> and <a class="el" href="#a047c797aabc191b58a160261447b47b2">m_inverse</a> appropriately. </p>
<p>Sets the pointers <a class="el" href="#ad13a87dc8d3a35f6f890ad7b62fa4c55">m_direct</a> and <a class="el" href="#a047c797aabc191b58a160261447b47b2">m_inverse</a> to appropriate locations of <a class="el" href="#a6045e78d0ba648f14f61a52141646506">m_memory</a>. </p>

</div>
</div>
<a id="acbd4032da7861ea0f1ef35078766539e" name="acbd4032da7861ea0f1ef35078766539e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbd4032da7861ea0f1ef35078766539e">&#9670;&#160;</a></span>shift_left()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::linear_arrangement::shift_left </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shifts the vertices one position to the left. </p>
<dl class="section pre"><dt>Precondition</dt><dd>All nodes to have been assigned to a position. </dd></dl>

</div>
</div>
<a id="a86f6902375ceb6f7ec2bba5110096122" name="a86f6902375ceb6f7ec2bba5110096122"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86f6902375ceb6f7ec2bba5110096122">&#9670;&#160;</a></span>shift_right()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::linear_arrangement::shift_right </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shifts the vertices one position to the right. </p>
<dl class="section pre"><dt>Precondition</dt><dd>All nodes to have been assigned to a position. </dd></dl>

</div>
</div>
<a id="a04680e239a300b2bd3fe90ab9268fd0b" name="a04680e239a300b2bd3fe90ab9268fd0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04680e239a300b2bd3fe90ab9268fd0b">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename what , std::enable_if_t&lt; std::is_same_v&lt; what, <a class="el" href="structlal_1_1node__t.html">node_t</a> &gt; or std::is_same_v&lt; what, <a class="el" href="structlal_1_1position__t.html">position_t</a> &gt;, bool &gt;  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::linear_arrangement::swap </td>
          <td>(</td>
          <td class="paramtype">const what</td>          <td class="paramname"><span class="paramname"><em>u_t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const what</td>          <td class="paramname"><span class="paramname"><em>v_t</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the position of two vertices or of two positions. </p>
<p>Updates <a class="el" href="#ad13a87dc8d3a35f6f890ad7b62fa4c55">m_direct</a> and <a class="el" href="#a047c797aabc191b58a160261447b47b2">m_inverse</a> so that the vertices are effectively swapped.</p>
<p>The two parameters have to be of the same type: either <a class="el" href="structlal_1_1node__t.html">lal::node_t</a> or <a class="el" href="structlal_1_1position__t.html">lal::position_t</a>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">what</td><td>Swap either vertices or positions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u_t</td><td>Value indicating the first object. </td></tr>
    <tr><td class="paramname">v_t</td><td>Value indicating the second object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Values <em>u</em> and <em>p</em> must both be strictly less than the size of the arrangement (see <a class="el" href="#a042adc1171b430656e68eff05337eec9">m_n</a>). </dd></dl>

</div>
</div>
<a id="ad89763c3ca1f19a80e4a04dccadef951" name="ad89763c3ca1f19a80e4a04dccadef951"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad89763c3ca1f19a80e4a04dccadef951">&#9670;&#160;</a></span>update_direct()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::linear_arrangement::update_direct </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the direct arrangement using the inverse arrangement. </p>
<p>This function is only useful when there have been changes to the inverse arrangement not via the <a class="el" href="#a4b63f94c0158363bcace37ce19fff7bb">assign</a> function. </p>

</div>
</div>
<a id="a71f927053906157a4bc62811bc51855a" name="a71f927053906157a4bc62811bc51855a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71f927053906157a4bc62811bc51855a">&#9670;&#160;</a></span>update_inverse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void lal::linear_arrangement::update_inverse </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the inverse arrangement using the direct arrangement. </p>
<p>This function is only useful when there have been changes to the direct arrangement not via the <a class="el" href="#a4b63f94c0158363bcace37ce19fff7bb">assign</a> function. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a6045e78d0ba648f14f61a52141646506" name="a6045e78d0ba648f14f61a52141646506"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6045e78d0ba648f14f61a52141646506">&#9670;&#160;</a></span>m_memory</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlal_1_1detail_1_1array.html">detail::array</a>&lt;uint64_t&gt; lal::linear_arrangement::m_memory</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Memory of the linear arrangement. Holds twice as many elements as vertices there are in the arrangement (see <a class="el" href="#a042adc1171b430656e68eff05337eec9">m_n</a>). </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>lal/<a class="el" href="linear__arrangement_8hpp_source.html">linear_arrangement.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
